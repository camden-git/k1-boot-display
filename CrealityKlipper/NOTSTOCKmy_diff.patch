diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/chelper/__init__.py crealityShit/klippy/chelper/__init__.py
--- klipperStock/klippy/chelper/__init__.py	2024-01-14 23:01:59.513788890 -0600
+++ crealityShit/klippy/chelper/__init__.py	2024-01-14 23:02:21.738061295 -0600
@@ -266,13 +266,13 @@
         srcfiles = get_abs_files(srcdir, SOURCE_FILES)
         ofiles = get_abs_files(srcdir, OTHER_FILES)
         destlib = get_abs_files(srcdir, [DEST_LIB])[0]
-        if check_build_code(srcfiles+ofiles+[__file__], destlib):
-            if check_gcc_option(SSE_FLAGS):
-                cmd = "%s %s %s" % (GCC_CMD, SSE_FLAGS, COMPILE_ARGS)
-            else:
-                cmd = "%s %s" % (GCC_CMD, COMPILE_ARGS)
-            logging.info("Building C code module %s", DEST_LIB)
-            do_build_code(cmd % (destlib, ' '.join(srcfiles)))
+#        if check_build_code(srcfiles+ofiles+[__file__], destlib):
+#             if check_gcc_option(SSE_FLAGS):
+#                 cmd = "%s %s %s" % (GCC_CMD, SSE_FLAGS, COMPILE_ARGS)
+#             else:
+#                 cmd = "%s %s" % (GCC_CMD, COMPILE_ARGS)
+#             logging.info("Building C code module %s", DEST_LIB)
+#             do_build_code(cmd % (destlib, ' '.join(srcfiles)))
         FFI_main = cffi.FFI()
         for d in defs_all:
             FFI_main.cdef(d)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/chelper/Makefile crealityShit/klippy/chelper/Makefile
--- klipperStock/klippy/chelper/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ crealityShit/klippy/chelper/Makefile	2024-01-14 23:02:21.734061247 -0600
@@ -0,0 +1,23 @@
+CC = gcc
+CFLAGS := -Wall -g -O2 -flto -fwhole-program -fno-use-linker-plugin
+
+OBJECTS = pyhelper.o serialqueue.o stepcompress.o itersolve.o trapq.o \
+		  pollreactor.o msgblock.o trdispatch.o \
+		  kin_cartesian.o kin_corexy.o kin_corexz.o kin_delta.o \
+		  kin_deltesian.o kin_polar.o kin_rotary_delta.o kin_winch.o \
+		  kin_extruder.o kin_shaper.o
+
+DIST_LIB = c_helper.so
+
+all: $(DIST_LIB)
+
+clean:
+	@echo "Cleaning up directory."
+	rm -f *.a *.o  $(DIST_LIB) *~
+
+$(DIST_LIB):$(OBJECTS)
+	$(CC) -shared -fPIC -o $@ $(OBJECTS)
+
+%.o: %.c
+	$(CC) $(CFLAGS) -g -c -o $@ $<
+
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/chelper/serialqueue.c crealityShit/klippy/chelper/serialqueue.c
--- klipperStock/klippy/chelper/serialqueue.c	2024-01-14 23:01:59.509788840 -0600
+++ crealityShit/klippy/chelper/serialqueue.c	2024-01-14 23:02:21.738061295 -0600
@@ -603,6 +603,7 @@
 background_thread(void *data)
 {
     struct serialqueue *sq = data;
+    nice(-20);
     pollreactor_run(sq->pr);
 
     pthread_mutex_lock(&sq->lock);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/chelper/stepcompress.c crealityShit/klippy/chelper/stepcompress.c
--- klipperStock/klippy/chelper/stepcompress.c	2024-01-14 23:01:59.513788890 -0600
+++ crealityShit/klippy/chelper/stepcompress.c	2024-01-14 23:02:21.742061346 -0600
@@ -63,6 +63,7 @@
     int step_count, interval, add;
 };
 
+// uint32_t pre_interval;
 
 /****************************************************************
  * Step compression
@@ -209,10 +210,22 @@
 {
     if (!CHECK_LINES)
         return 0;
+
     if (!move.count || (!move.interval && !move.add && move.count > 1)
         || move.interval >= 0x80000000) {
         errorf("stepcompress o=%d i=%d c=%d a=%d: Invalid sequence"
                , sc->oid, move.interval, move.count, move.add);
+        errorf("stepcompress queue[%p]=%u queue_end[%p]=%u queue_pos[%p]=%u queue_next[%p]=%u last_step_clock=%llu max_error=%u : lxc check_line"
+               , sc->queue, *(sc->queue), sc->queue_end, *(sc->queue_end), sc->queue_pos, *(sc->queue_pos),
+               sc->queue_next, *(sc->queue_next), sc->last_step_clock, sc->max_error);
+        uint16_t i;
+        uint32_t intervals = move.interval, ps = 0;
+        for (i=0; i<move.count; i++) {
+            ps += intervals;
+            struct points points = minmax_point(sc, sc->queue_pos + i);
+            errorf("stepcompress queue_pos+i=%u ps=%u minp=%u maxp=%u : lxc Invalid sequence 2"
+               , *(sc->queue_pos + i), ps, points.minp, points.maxp);
+        }
         return ERROR_RET;
     }
     uint32_t interval = move.interval, p = 0;
@@ -359,6 +372,7 @@
     list_add_tail(&qm->node, &sc->msg_queue);
     sc->last_step_clock = last_clock;
 
+    // pre_interval = move->interval;
     // Create and store move in history tracking
     struct history_steps *hs = malloc(sizeof(*hs));
     hs->first_clock = first_clock;
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/clocksync.py crealityShit/klippy/clocksync.py
--- klipperStock/klippy/clocksync.py	2024-01-14 23:01:59.493788645 -0600
+++ crealityShit/klippy/clocksync.py	2024-01-14 23:02:21.706060905 -0600
@@ -32,9 +32,12 @@
         self.mcu_freq = serial.msgparser.get_constant_float('CLOCK_FREQ')
         # Load initial clock and frequency
         params = serial.send_with_response('get_uptime', 'uptime')
+        self.time_avg = params['#sent_time']
+        if not self.time_avg:
+            params = serial.send_with_response('get_uptime', 'uptime')
+            self.time_avg = params['#sent_time']
         self.last_clock = (params['high'] << 32) | params['clock']
         self.clock_avg = self.last_clock
-        self.time_avg = params['#sent_time']
         self.clock_est = (self.time_avg, self.clock_avg, self.mcu_freq)
         self.prediction_variance = (.001 * self.mcu_freq)**2
         # Enable periodic get_clock timer
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/configfile.py crealityShit/klippy/configfile.py
--- klipperStock/klippy/configfile.py	2024-01-14 23:01:59.505788792 -0600
+++ crealityShit/klippy/configfile.py	2024-01-14 23:02:21.730061199 -0600
@@ -29,29 +29,36 @@
                     acc_id = (self.section.lower(), option.lower())
                     self.access_tracking[acc_id] = default
                 return default
-            raise error("Option '%s' in section '%s' must be specified"
-                        % (option, self.section))
+            raise error(
+                """{"code":"key335", "msg":"Option '%s' in section '%s' must be specified", "values":["%s", "%s"]}"""
+                % (option, self.section, option, self.section))
         try:
             v = parser(self.section, option)
         except self.error as e:
             raise
         except:
-            raise error("Unable to parse option '%s' in section '%s'"
-                        % (option, self.section))
+            raise error(
+                """{"code": "key282", "msg": "Unable to parse option '%s' in section '%s'", "values":["%s", "%s"]}"""
+                % (option, self.section, option, self.section))
         if note_valid:
             self.access_tracking[(self.section.lower(), option.lower())] = v
         if minval is not None and v < minval:
-            raise error("Option '%s' in section '%s' must have minimum of %s"
-                        % (option, self.section, minval))
+            if option == "z_offset" and self.section == "bltouch":
+                raise error("""{"code":"key281", "msg":"Error on 'z_offset': 'touch' must have minimum of %s", "values":["%s"]}""" % (
+                    minval, minval
+                ))
+            else:
+                raise error("""{"code":"key252", "msg":"Error on '%s': %s must have minimum of %s", "values":["%s","%s","%s"]}"""
+                            % (option, self.section, minval, option, self.section, minval))
         if maxval is not None and v > maxval:
-            raise error("Option '%s' in section '%s' must have maximum of %s"
-                        % (option, self.section, maxval))
+            raise error("""{"code":"key253", "msg":"Error on '%s': %s must have maximumof %s", "values":["%s","%s","%s"]}"""
+                        % (option, self.section, maxval, option, self.section, maxval))
         if above is not None and v <= above:
-            raise error("Option '%s' in section '%s' must be above %s"
-                        % (option, self.section, above))
+            raise error("""{"code":"key254", "msg":"Error on '%s': %s must be above %s", "values":["%s","%s","%s"]}"""
+                        % (option, self.section, above, option, self.section, above))
         if below is not None and v >= below:
-            raise self.error("Option '%s' in section '%s' must be below %s"
-                             % (option, self.section, below))
+            raise self.error("""{"code":"key255", "msg":"Error on '%s': %s must be below %s", "values":["%s","%s","%s"]}"""
+                             % (option, self.section, below, option, self.section, below))
         return v
     def get(self, option, default=sentinel, note_valid=True):
         return self._get_wrapper(self.fileconfig.get, option, default,
@@ -147,6 +154,8 @@
         gcode = self.printer.lookup_object('gcode')
         gcode.register_command("SAVE_CONFIG", self.cmd_SAVE_CONFIG,
                                desc=self.cmd_SAVE_CONFIG_help)
+        gcode.register_command("CXSAVE_CONFIG", self.cmd_CXSAVE_CONFIG,
+                               desc=self.cmd_CXSAVE_CONFIG_help)
     def get_printer(self):
         return self.printer
     def _read_config_file(self, filename):
@@ -292,13 +301,11 @@
         for section_name in fileconfig.sections():
             section = section_name.lower()
             if section not in valid_sections and section not in objects:
-                raise error("Section '%s' is not a valid config section"
-                            % (section,))
+                raise error("""{"code":"key341", "msg":"Section '%s' is not a valid config section", "values":["%s"]}""" % (section, section))
             for option in fileconfig.options(section_name):
                 option = option.lower()
                 if (section, option) not in access_tracking:
-                    raise error("Option '%s' is not valid in section '%s'"
-                                % (option, section))
+                    raise error("""{"code":"key342", "msg":"Option '%s' is not valid in section '%s'", "values":["%s", "%s"]}""" % (option, section, option, section))
         # Setup get_status()
         self._build_status(config)
     def log_config(self, config):
@@ -417,3 +424,52 @@
             raise gcode.error(msg)
         # Request a restart
         gcode.request_restart('restart')
+
+    cmd_CXSAVE_CONFIG_help = "Overwrite config file by cx "
+    def cmd_CXSAVE_CONFIG(self, gcmd):
+        if not self.autosave.fileconfig.sections():
+            return
+        gcode = self.printer.lookup_object('gcode')
+        # Create string containing autosave data
+        autosave_data = self._build_config_string(self.autosave)
+        lines = [('#*# ' + l).strip()
+                 for l in autosave_data.split('\n')]
+        lines.insert(0, "\n" + AUTOSAVE_HEADER.rstrip())
+        lines.append("")
+        autosave_data = '\n'.join(lines)
+        # Read in and validate current config file
+        cfgname = self.printer.get_start_args()['config_file']
+        try:
+            data = self._read_config_file(cfgname)
+            regular_data, old_autosave_data = self._find_autosave_data(data)
+            config = self._build_config_wrapper(regular_data, cfgname)
+        except error as e:
+            msg = "Unable to parse existing config on SAVE_CONFIG"
+            logging.exception(msg)
+            raise gcode.error(msg)
+        regular_data = self._strip_duplicates(regular_data, self.autosave)
+        self._disallow_include_conflicts(regular_data, cfgname, gcode)
+        data = regular_data.rstrip() + autosave_data
+        # Determine filenames
+        datestr = time.strftime("-%Y%m%d_%H%M%S")
+        backup_name = cfgname + datestr
+        temp_name = cfgname + "_autosave"
+        if cfgname.endswith(".cfg"):
+            backup_name = cfgname[:-4] + datestr + ".cfg"
+            temp_name = cfgname[:-4] + "_autosave.cfg"
+        # Create new config file with temporary name and swap with main config
+        logging.info("SAVE_CONFIG to '%s' (backup in '%s')",
+                     cfgname, backup_name)
+        try:
+            f = open(temp_name, 'w')
+            f.write(data)
+            f.close()
+            os.rename(cfgname, backup_name)
+            os.rename(temp_name, cfgname)
+        except:
+            msg = "Unable to write config file during SAVE_CONFIG"
+            logging.exception(msg)
+            raise gcode.error(msg)
+
+        # Request a restart
+        # gcode.request_restart('restart')
\ No newline at end of file
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/ad5206.py crealityShit/klippy/extras/ad5206.py
--- klipperStock/klippy/extras/ad5206.py	2024-01-14 23:01:59.477788447 -0600
+++ crealityShit/klippy/extras/ad5206.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,22 +0,0 @@
-# AD5206 digipot code
-#
-# Copyright (C) 2017,2018  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-from . import bus
-
-class ad5206:
-    def __init__(self, config):
-        self.spi = bus.MCU_SPI_from_config(
-            config, 0, pin_option="enable_pin", default_speed=25000000)
-        scale = config.getfloat('scale', 1., above=0.)
-        for i in range(6):
-            val = config.getfloat('channel_%d' % (i+1,), None,
-                                  minval=0., maxval=scale)
-            if val is not None:
-                self.set_register(i, int(val * 256. / scale + .5))
-    def set_register(self, reg, value):
-        self.spi.spi_send([reg, value])
-
-def load_config_prefix(config):
-    return ad5206(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/adc_scaled.py crealityShit/klippy/extras/adc_scaled.py
--- klipperStock/klippy/extras/adc_scaled.py	2024-01-14 23:01:59.449788103 -0600
+++ crealityShit/klippy/extras/adc_scaled.py	2024-01-14 23:02:21.646060169 -0600
@@ -45,7 +45,7 @@
         self.inv_smooth_time = 1. / smooth_time
         self.mcu = self.mcu_vref.get_mcu()
         if self.mcu is not self.mcu_vssa.get_mcu():
-            raise config.error("vref and vssa must be on same mcu")
+            raise config.error("""{"code":"key188", "msg": "vref and vssa must be on same mcu", "values": []}""")
         # Register setup_pin
         ppins = self.printer.lookup_object('pins')
         ppins.register_chip(self.name, self)
@@ -61,7 +61,7 @@
         return mcu_adc
     def setup_pin(self, pin_type, pin_params):
         if pin_type != 'adc':
-            raise self.printer.config_error("adc_scaled only supports adc pins")
+            raise self.printer.config_error("""{"code":"key189", "msg": "adc_scaled only supports adc pins", "values": []}""")
         return MCU_scaled_adc(self, pin_params)
     def calc_smooth(self, read_time, read_value, last):
         last_time, last_value = last
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/adc_temperature.py crealityShit/klippy/extras/adc_temperature.py
--- klipperStock/klippy/extras/adc_temperature.py	2024-01-14 23:01:59.445788055 -0600
+++ crealityShit/klippy/extras/adc_temperature.py	2024-01-14 23:02:21.634060022 -0600
@@ -54,7 +54,7 @@
                 last_value = value
                 continue
             if key <= last_key:
-                raise ValueError("duplicate value")
+                raise ValueError("""{"code":"key26", "msg":"duplicate value", "values": []}""")
             gain = (value - last_value) / (key - last_key)
             offset = last_value - last_key * gain
             if self.slopes and self.slopes[-1] == (gain, offset):
@@ -64,7 +64,7 @@
             self.keys.append(key)
             self.slopes.append((gain, offset))
         if not self.keys:
-            raise ValueError("need at least two samples")
+            raise ValueError("""{"code":"key27", "msg":"need at least two samples", "values": []}""")
         self.keys.append(9999999999999.)
         self.slopes.append(self.slopes[-1])
     def interpolate(self, key):
@@ -102,8 +102,8 @@
         try:
             li = LinearInterpolate(samples)
         except ValueError as e:
-            raise config.error("adc_temperature %s in heater %s" % (
-                str(e), config.get_name()))
+            raise config.error("""{"code":"key28", "msg":"adc_temperature %s in heater %s", "values": ["%s", "%s"]}""" % (
+                str(e), config.get_name(), str(e), config.get_name()))
         self.calc_temp = li.interpolate
         self.calc_adc = li.reverse_interpolate
 
@@ -134,8 +134,8 @@
         try:
             self.li = LinearInterpolate([(r, t) for t, r in samples])
         except ValueError as e:
-            raise config.error("adc_temperature %s in heater %s" % (
-                str(e), config.get_name()))
+            raise config.error("""{"code":"key28", "msg":"adc_temperature %s in heater %s", "values": ["%s", "%s"]}""" % (
+                str(e), config.get_name(), str(e), config.get_name()))
     def calc_temp(self, adc):
         # Calculate temperature from adc
         adc = max(.00001, min(.99999, adc))
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/adxl345.py crealityShit/klippy/extras/adxl345.py
--- klipperStock/klippy/extras/adxl345.py	2024-01-14 23:01:59.457788201 -0600
+++ crealityShit/klippy/extras/adxl345.py	2024-01-14 23:02:21.654060268 -0600
@@ -5,6 +5,8 @@
 # This file may be distributed under the terms of the GNU GPLv3 license.
 import logging, time, collections, threading, multiprocessing, os
 from . import bus, motion_report
+import struct
+from multiprocessing import shared_memory
 
 # ADXL345 registers
 REG_DEVID = 0x00
@@ -83,6 +85,71 @@
                 count += 1
         del samples[count:]
         return self.samples
+
+    def copy_double_to_buffer(self, buffer, offset, val):
+        bytes = struct.pack("d", val)
+
+        # little store
+        try:
+            buffer[offset:offset+8] = bytearray(bytes)
+            del bytes
+        except:
+            gcode = self.printer.lookup_object('gcode')
+            gcode.respond_info("val: %f, bytes: %s, offset: %d" % (val, bytes.hex(), offset))
+
+    def copy_int_to_buffer(self, buffer, offset, val):
+        # little store
+        try:
+            buffer[offset] = val & 0xFF
+            buffer[offset + 1] = (val >> 8) & 0xFF
+            buffer[offset + 2] = (val >> 16) & 0xFF
+            buffer[offset + 3] = (val >> 24) & 0xFF
+        except:
+            gcode = self.printer.lookup_object('gcode')
+            gcode.respond_info("val: %f, offset: %d" % (val, offset))
+
+    def get_samples_to_shared_mem(self):
+        gcode = self.printer.lookup_object('gcode')
+        raw_samples = self._get_raw_samples()
+        if not raw_samples:
+            return self.samples
+        total = sum([len(m['params']['data']) for m in raw_samples])
+        count = 0
+
+        # shm size = (double bytes) * (count of member: samp_time, x, y and z) * total
+        shm_size = 8 * 4 * total
+        shm = shared_memory.SharedMemory(name="psm_samples", create=True, size=shm_size)
+
+        buffer = shm.buf
+        self.copy_int_to_buffer(buffer, 0, count)
+        count += 4
+
+        reactor = self.printer.get_reactor()
+        for msg in raw_samples:
+            for samp_time, x, y, z in msg['params']['data']:
+                if samp_time < self.request_start_time:
+                    continue
+                if samp_time > self.request_end_time:
+                    break
+
+                # 30000 * sizeof(samp_time, x, y, z) + sizeof(count)
+                # switch process
+                if count % 960000 == 4:
+                    reactor.pause(reactor.monotonic() + .1)
+
+                self.copy_double_to_buffer(buffer, count, samp_time)
+                count += 8
+                self.copy_double_to_buffer(buffer, count, x)
+                count += 8
+                self.copy_double_to_buffer(buffer, count, y)
+                count += 8
+                self.copy_double_to_buffer(buffer, count, z)
+                count += 8
+
+        self.copy_int_to_buffer(buffer, 0, count)
+        shm.close()
+        gcode.respond_info("shm_size: %d, double bytes count: %d" % (shm_size, count))
+
     def write_to_file(self, filename):
         def write_impl():
             try:
@@ -114,6 +181,22 @@
         if len(name_parts) == 1:
             if self.name == "adxl345" or not config.has_section("adxl345"):
                 self.register_commands(None)
+        webhooks = self.printer.lookup_object('webhooks')
+        webhooks.register_endpoint("getAdxl345Status",
+                                   self.get_adxl345_status)
+    def get_adxl345_status(self, web_request):
+        adxl345_is_exist = True
+        try:
+            aclient = self.chip.start_internal_client()
+            self.printer.lookup_object('toolhead').dwell(1.)
+            aclient.finish_measurements()
+            values = aclient.get_samples()
+        except Exception as err:
+            logging.error(err)
+            values = ""
+        if not values:
+            adxl345_is_exist = False
+        web_request.send({"adxl345_is_exist": adxl345_is_exist})
     def register_commands(self, name):
         # Register commands
         gcode = self.printer.lookup_object('gcode')
@@ -139,7 +222,7 @@
         # End measurements
         name = gcmd.get("NAME", time.strftime("%Y%m%d_%H%M%S"))
         if not name.replace('-', '').replace('_', '').isalnum():
-            raise gcmd.error("Invalid NAME parameter")
+            raise gcmd.error("""{"code":"key64", "msg":"Invalid adxl345 NAME parameter", "values": []}""")
         bg_client = self.bg_client
         self.bg_client = None
         bg_client.finish_measurements()
@@ -158,7 +241,7 @@
         aclient.finish_measurements()
         values = aclient.get_samples()
         if not values:
-            raise gcmd.error("No accelerometer measurements found")
+            raise gcmd.error("""{"code":"key232", "msg":"No adxl345 measurements found", "values": []}""")
         _, accel_x, accel_y, accel_z = values[-1]
         gcmd.respond_info("accelerometer values (x, y, z): %.6f, %.6f, %.6f"
                           % (accel_x, accel_y, accel_z))
@@ -236,11 +319,11 @@
               '-x': (0, -SCALE_XY), '-y': (1, -SCALE_XY), '-z': (2, -SCALE_Z)}
         axes_map = config.getlist('axes_map', ('x','y','z'), count=3)
         if any([a not in am for a in axes_map]):
-            raise config.error("Invalid adxl345 axes_map parameter")
+            raise config.error('{"code": "key9", "msg": "Invalid adxl345 axes_map parameter"}')
         self.axes_map = [am[a.strip()] for a in axes_map]
         self.data_rate = config.getint('rate', 3200)
         if self.data_rate not in QUERY_RATES:
-            raise config.error("Invalid rate parameter: %d" % (self.data_rate,))
+            raise config.error("""{"code":"key245", "msg":"Invalid rate parameter: %d", "values": [%d]}""" % (self.data_rate,self.data_rate,))
         # Measurement storage (accessed from background thread)
         self.lock = threading.Lock()
         self.raw_samples = []
@@ -288,10 +371,8 @@
         stored_val = self.read_reg(reg)
         if stored_val != val:
             raise self.printer.command_error(
-                    "Failed to set ADXL345 register [0x%x] to 0x%x: got 0x%x. "
-                    "This is generally indicative of connection problems "
-                    "(e.g. faulty wiring) or a faulty adxl345 chip." % (
-                        reg, val, stored_val))
+                    """{"code":"key65", "msg":"Failed to set ADXL345 register [0x%x] to 0x%x: got 0x%x. \nThis is generally indicative of connection problems\n(e.g. faulty wiring)\nor a faulty adxl345 chip.", "values": ["%x","%x","%x"]}""" % (
+                        reg, val, stored_val, reg, val, stored_val))
     # Measurement collection
     def is_measuring(self):
         return self.query_rate > 0
@@ -341,7 +422,7 @@
             if fifo <= 32:
                 break
         else:
-            raise self.printer.command_error("Unable to query adxl345 fifo")
+            raise self.printer.command_error("""{"code":"key118", "msg":"Unable to query adxl345 fifo", "values": []}""")
         mcu_clock = self.mcu.clock32_to_clock64(params['clock'])
         sequence = (self.last_sequence & ~0xffff) | params['next_sequence']
         if sequence < self.last_sequence:
@@ -374,10 +455,8 @@
         dev_id = self.read_reg(REG_DEVID)
         if dev_id != ADXL345_DEV_ID:
             raise self.printer.command_error(
-                "Invalid adxl345 id (got %x vs %x).\n"
-                "This is generally indicative of connection problems\n"
-                "(e.g. faulty wiring) or a faulty adxl345 chip."
-                % (dev_id, ADXL345_DEV_ID))
+                """{"code":"key119", "msg": "Invalid adxl345 id (got %x vs %x).This is generally indicative of connection problems(e.g. faulty wiring) or a faulty adxl345 chip.", "values": ["%x", "%x"]}"""
+                % (dev_id, ADXL345_DEV_ID, dev_id, ADXL345_DEV_ID))
         # Setup chip in requested query rate
         self.set_reg(REG_POWER_CTL, 0x00)
         self.set_reg(REG_DATA_FORMAT, 0x0B)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/angle.py crealityShit/klippy/extras/angle.py
--- klipperStock/klippy/extras/angle.py	2024-01-14 23:01:59.453788154 -0600
+++ crealityShit/klippy/extras/angle.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,578 +0,0 @@
-# Support for reading SPI magnetic angle sensors
-#
-# Copyright (C) 2021,2022  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging, math, threading
-from . import bus, motion_report
-
-MIN_MSG_TIME = 0.100
-TCODE_ERROR = 0xff
-
-TRINAMIC_DRIVERS = ["tmc2130", "tmc2208", "tmc2209", "tmc2660", "tmc5160"]
-
-CALIBRATION_BITS = 6 # 64 entries
-ANGLE_BITS = 16 # angles range from 0..65535
-
-class AngleCalibration:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.name = config.get_name()
-        self.stepper_name = config.get('stepper', None)
-        if self.stepper_name is None:
-            # No calibration
-            return
-        try:
-            import numpy
-        except:
-            raise config.error("Angle calibration requires numpy module")
-        sconfig = config.getsection(self.stepper_name)
-        sconfig.getint('microsteps', note_valid=False)
-        self.tmc_module = self.mcu_stepper = None
-        # Current calibration data
-        self.mcu_pos_offset = None
-        self.angle_phase_offset = 0.
-        self.calibration_reversed = False
-        self.calibration = []
-        cal = config.get('calibrate', None)
-        if cal is not None:
-            data = [d.strip() for d in cal.split(',')]
-            angles = [float(d) for d in data if d]
-            self.load_calibration(angles)
-        # Register commands
-        self.printer.register_event_handler("stepper:sync_mcu_position",
-                                            self.handle_sync_mcu_pos)
-        self.printer.register_event_handler("klippy:connect", self.connect)
-        cname = self.name.split()[-1]
-        gcode = self.printer.lookup_object('gcode')
-        gcode.register_mux_command("ANGLE_CALIBRATE", "CHIP",
-                                   cname, self.cmd_ANGLE_CALIBRATE,
-                                   desc=self.cmd_ANGLE_CALIBRATE_help)
-    def handle_sync_mcu_pos(self, mcu_stepper):
-        if mcu_stepper.get_name() == self.stepper_name:
-            self.mcu_pos_offset = None
-    def calc_mcu_pos_offset(self, sample):
-        # Lookup phase information
-        mcu_phase_offset, phases = self.tmc_module.get_phase_offset()
-        if mcu_phase_offset is None:
-            return
-        # Find mcu position at time of sample
-        angle_time, angle_pos = sample
-        mcu_pos = self.mcu_stepper.get_past_mcu_position(angle_time)
-        # Convert angle_pos to mcu_pos units
-        microsteps, full_steps = self.get_microsteps()
-        angle_to_mcu_pos = full_steps * microsteps / float(1<<ANGLE_BITS)
-        angle_mpos = angle_pos * angle_to_mcu_pos
-        # Calculate adjustment for stepper phases
-        phase_diff = ((angle_mpos + self.angle_phase_offset * angle_to_mcu_pos)
-                      - (mcu_pos + mcu_phase_offset)) % phases
-        if phase_diff > phases//2:
-            phase_diff -= phases
-        # Store final offset
-        self.mcu_pos_offset = mcu_pos - (angle_mpos - phase_diff)
-    def apply_calibration(self, samples):
-        calibration = self.calibration
-        if not calibration:
-            return None
-        calibration_reversed = self.calibration_reversed
-        interp_bits = ANGLE_BITS - CALIBRATION_BITS
-        interp_mask = (1 << interp_bits) - 1
-        interp_round = 1 << (interp_bits - 1)
-        for i, (samp_time, angle) in enumerate(samples):
-            bucket = (angle & 0xffff) >> interp_bits
-            cal1 = calibration[bucket]
-            cal2 = calibration[bucket + 1]
-            adj = (angle & interp_mask) * (cal2 - cal1)
-            adj = cal1 + ((adj + interp_round) >> interp_bits)
-            angle_diff = (angle - adj) & 0xffff
-            angle_diff -= (angle_diff & 0x8000) << 1
-            new_angle = angle - angle_diff
-            if calibration_reversed:
-                new_angle = -new_angle
-            samples[i] = (samp_time, new_angle)
-        if self.mcu_pos_offset is None:
-            self.calc_mcu_pos_offset(samples[0])
-            if self.mcu_pos_offset is None:
-                return None
-        return self.mcu_stepper.mcu_to_commanded_position(self.mcu_pos_offset)
-    def load_calibration(self, angles):
-        # Calculate linear intepolation calibration buckets by solving
-        # linear equations
-        angle_max = 1 << ANGLE_BITS
-        calibration_count = 1 << CALIBRATION_BITS
-        bucket_size = angle_max // calibration_count
-        full_steps = len(angles)
-        nominal_step = float(angle_max) / full_steps
-        self.angle_phase_offset = (angles.index(min(angles)) & 3) * nominal_step
-        self.calibration_reversed = angles[-2] > angles[-1]
-        if self.calibration_reversed:
-            angles = list(reversed(angles))
-        first_step = angles.index(min(angles))
-        angles = angles[first_step:] + angles[:first_step]
-        import numpy
-        eqs = numpy.zeros((full_steps, calibration_count))
-        ans = numpy.zeros((full_steps,))
-        for step, angle in enumerate(angles):
-            int_angle = int(angle + .5) % angle_max
-            bucket = int(int_angle / bucket_size)
-            bucket_start = bucket * bucket_size
-            ang_diff = angle - bucket_start
-            ang_diff_per = ang_diff / bucket_size
-            eq = eqs[step]
-            eq[bucket] = 1. - ang_diff_per
-            eq[(bucket + 1) % calibration_count] = ang_diff_per
-            ans[step] = float(step * nominal_step)
-            if bucket + 1 >= calibration_count:
-                ans[step] -= ang_diff_per * angle_max
-        sol = numpy.linalg.lstsq(eqs, ans, rcond=None)[0]
-        isol = [int(s + .5) for s in sol]
-        self.calibration = isol + [isol[0] + angle_max]
-    def lookup_tmc(self):
-        for driver in TRINAMIC_DRIVERS:
-            driver_name = "%s %s" % (driver, self.stepper_name)
-            module = self.printer.lookup_object(driver_name, None)
-            if module is not None:
-                return module
-        raise self.printer.command_error("Unable to find TMC driver for %s"
-                                         % (self.stepper_name,))
-    def connect(self):
-        self.tmc_module = self.lookup_tmc()
-        fmove = self.printer.lookup_object('force_move')
-        self.mcu_stepper = fmove.lookup_stepper(self.stepper_name)
-    def get_microsteps(self):
-        configfile = self.printer.lookup_object('configfile')
-        sconfig = configfile.get_status(None)['settings']
-        stconfig = sconfig.get(self.stepper_name, {})
-        microsteps = stconfig['microsteps']
-        full_steps = stconfig['full_steps_per_rotation']
-        return microsteps, full_steps
-    def get_stepper_phase(self):
-        mcu_phase_offset, phases = self.tmc_module.get_phase_offset()
-        if mcu_phase_offset is None:
-            raise self.printer.command_error("Driver phase not known for %s"
-                                             % (self.stepper_name,))
-        mcu_pos = self.mcu_stepper.get_mcu_position()
-        return (mcu_pos + mcu_phase_offset) % phases
-    def do_calibration_moves(self):
-        move = self.printer.lookup_object('force_move').manual_move
-        # Start data collection
-        angle_sensor = self.printer.lookup_object(self.name)
-        cconn = angle_sensor.start_internal_client()
-        # Move stepper several turns (to allow internal sensor calibration)
-        microsteps, full_steps = self.get_microsteps()
-        mcu_stepper = self.mcu_stepper
-        step_dist = mcu_stepper.get_step_dist()
-        full_step_dist = step_dist * microsteps
-        rotation_dist = full_steps * full_step_dist
-        align_dist = step_dist * self.get_stepper_phase()
-        move_time = 0.010
-        move_speed = full_step_dist / move_time
-        move(mcu_stepper, -(rotation_dist+align_dist), move_speed)
-        move(mcu_stepper, 2. * rotation_dist, move_speed)
-        move(mcu_stepper, -2. * rotation_dist, move_speed)
-        move(mcu_stepper, .5 * rotation_dist - full_step_dist, move_speed)
-        # Move to each full step position
-        toolhead = self.printer.lookup_object('toolhead')
-        times = []
-        samp_dist = full_step_dist
-        for i in range(2 * full_steps):
-            move(mcu_stepper, samp_dist, move_speed)
-            start_query_time = toolhead.get_last_move_time() + 0.050
-            end_query_time = start_query_time + 0.050
-            times.append((start_query_time, end_query_time))
-            toolhead.dwell(0.150)
-            if i == full_steps-1:
-                # Reverse direction and test each full step again
-                move(mcu_stepper, .5 * rotation_dist, move_speed)
-                move(mcu_stepper, -.5 * rotation_dist + samp_dist, move_speed)
-                samp_dist = -samp_dist
-        move(mcu_stepper, .5*rotation_dist + align_dist, move_speed)
-        toolhead.wait_moves()
-        # Finish data collection
-        cconn.finalize()
-        msgs = cconn.get_messages()
-        # Correlate query responses
-        cal = {}
-        step = 0
-        for msg in msgs:
-            for query_time, pos in msg['params']['data']:
-                # Add to step tracking
-                while step < len(times) and query_time > times[step][1]:
-                    step += 1
-                if step < len(times) and query_time >= times[step][0]:
-                    cal.setdefault(step, []).append(pos)
-        if len(cal) != len(times):
-            raise self.printer.command_error(
-                "Failed calibration - incomplete sensor data")
-        fcal = { i: cal[i] for i in range(full_steps) }
-        rcal = { full_steps-i-1: cal[i+full_steps] for i in range(full_steps) }
-        return fcal, rcal
-    def calc_angles(self, meas):
-        total_count = total_variance = 0
-        angles = {}
-        for step, data in meas.items():
-            count = len(data)
-            angle_avg = float(sum(data)) / count
-            angles[step] = angle_avg
-            total_count += count
-            total_variance += sum([(d - angle_avg)**2 for d in data])
-        return angles, math.sqrt(total_variance / total_count), total_count
-    cmd_ANGLE_CALIBRATE_help = "Calibrate angle sensor to stepper motor"
-    def cmd_ANGLE_CALIBRATE(self, gcmd):
-        # Perform calibration movement and capture
-        old_calibration = self.calibration
-        self.calibration = []
-        try:
-            fcal, rcal = self.do_calibration_moves()
-        finally:
-            self.calibration = old_calibration
-        # Calculate each step position average and variance
-        microsteps, full_steps = self.get_microsteps()
-        fangles, fstd, ftotal = self.calc_angles(fcal)
-        rangles, rstd, rtotal = self.calc_angles(rcal)
-        if (len({a: i for i, a in fangles.items()}) != len(fangles)
-            or len({a: i for i, a in rangles.items()}) != len(rangles)):
-            raise self.printer.command_error(
-                "Failed calibration - sensor not updating for each step")
-        merged = { i: fcal[i] + rcal[i] for i in range(full_steps) }
-        angles, std, total = self.calc_angles(merged)
-        gcmd.respond_info("angle: stddev=%.3f (%.3f forward / %.3f reverse)"
-                          " in %d queries" % (std, fstd, rstd, total))
-        # Order data with lowest/highest magnet position first
-        anglist = [angles[i] % 0xffff for i in range(full_steps)]
-        if angles[0] > angles[1]:
-            first_ang = max(anglist)
-        else:
-            first_ang = min(anglist)
-        first_phase = anglist.index(first_ang) & ~3
-        anglist = anglist[first_phase:] + anglist[:first_phase]
-        # Save results
-        cal_contents = []
-        for i, angle in enumerate(anglist):
-            if not i % 8:
-                cal_contents.append('\n')
-            cal_contents.append("%.1f" % (angle,))
-            cal_contents.append(',')
-        cal_contents.pop()
-        configfile = self.printer.lookup_object('configfile')
-        configfile.remove_section(self.name)
-        configfile.set(self.name, 'calibrate', ''.join(cal_contents))
-
-class HelperA1333:
-    SPI_MODE = 3
-    SPI_SPEED = 10000000
-    def __init__(self, config, spi, oid):
-        self.spi = spi
-        self.is_tcode_absolute = False
-        self.last_temperature = None
-    def get_static_delay(self):
-        return .000001
-    def start(self):
-        # Setup for angle query
-        self.spi.spi_transfer([0x32, 0x00])
-
-class HelperAS5047D:
-    SPI_MODE = 1
-    SPI_SPEED = int(1. / .000000350)
-    def __init__(self, config, spi, oid):
-        self.spi = spi
-        self.is_tcode_absolute = False
-        self.last_temperature = None
-    def get_static_delay(self):
-        return .000100
-    def start(self):
-        # Clear any errors from device
-        self.spi.spi_transfer([0xff, 0xfc]) # Read DIAAGC
-        self.spi.spi_transfer([0x40, 0x01]) # Read ERRFL
-        self.spi.spi_transfer([0xc0, 0x00]) # Read NOP
-
-class HelperTLE5012B:
-    SPI_MODE = 1
-    SPI_SPEED = 4000000
-    def __init__(self, config, spi, oid):
-        self.printer = config.get_printer()
-        self.spi = spi
-        self.oid = oid
-        self.is_tcode_absolute = True
-        self.last_temperature = None
-        self.mcu = spi.get_mcu()
-        self.mcu.register_config_callback(self._build_config)
-        self.spi_angle_transfer_cmd = None
-        self.last_chip_mcu_clock = self.last_chip_clock = 0
-        self.chip_freq = 0.
-        name = config.get_name().split()[-1]
-        gcode = self.printer.lookup_object("gcode")
-        gcode.register_mux_command("ANGLE_DEBUG_READ", "CHIP", name,
-                                   self.cmd_ANGLE_DEBUG_READ,
-                                   desc=self.cmd_ANGLE_DEBUG_READ_help)
-        gcode.register_mux_command("ANGLE_DEBUG_WRITE", "CHIP", name,
-                                   self.cmd_ANGLE_DEBUG_WRITE,
-                                   desc=self.cmd_ANGLE_DEBUG_WRITE_help)
-    def _build_config(self):
-        cmdqueue = self.spi.get_command_queue()
-        self.spi_angle_transfer_cmd = self.mcu.lookup_query_command(
-            "spi_angle_transfer oid=%c data=%*s",
-            "spi_angle_transfer_response oid=%c clock=%u response=%*s",
-            oid=self.oid, cq=cmdqueue)
-    def get_tcode_params(self):
-        return self.last_chip_mcu_clock, self.last_chip_clock, self.chip_freq
-    def _calc_crc(self, data):
-        crc = 0xff
-        for d in data:
-            crc ^= d
-            for i in range(8):
-                if crc & 0x80:
-                    crc = (crc << 1) ^ 0x1d
-                else:
-                    crc <<= 1
-        return (~crc) & 0xff
-    def _send_spi(self, msg):
-        for retry in range(5):
-            if msg[0] & 0x04:
-                params = self.spi_angle_transfer_cmd.send([self.oid, msg])
-            else:
-                params = self.spi.spi_transfer(msg)
-            resp = bytearray(params['response'])
-            crc = self._calc_crc(bytearray(msg[:2]) + resp[2:-2])
-            if crc == resp[-1]:
-                return params
-        raise self.printer.command_error("Unable to query tle5012b chip")
-    def _read_reg(self, reg):
-        cw = 0x8000 | ((reg & 0x3f) << 4) | 0x01
-        if reg >= 0x05 and reg <= 0x11:
-            cw |= 0x5000
-        msg = [cw >> 8, cw & 0xff, 0, 0, 0, 0]
-        params = self._send_spi(msg)
-        resp = bytearray(params['response'])
-        return (resp[2] << 8) | resp[3]
-    def _write_reg(self, reg, val):
-        cw = ((reg & 0x3f) << 4) | 0x01
-        if reg >= 0x05 and reg <= 0x11:
-            cw |= 0x5000
-        msg = [cw >> 8, cw & 0xff, (val >> 8) & 0xff, val & 0xff, 0, 0]
-        for retry in range(5):
-            self._send_spi(msg)
-            rval = self._read_reg(reg)
-            if rval == val:
-                return
-        raise self.printer.command_error("Unable to write to tle5012b chip")
-    def _mask_reg(self, reg, off, on):
-        rval = self._read_reg(reg)
-        self._write_reg(reg, (rval & ~off) | on)
-    def _query_clock(self):
-        # Read frame counter (and normalize to a 16bit counter)
-        msg = [0x84, 0x42, 0, 0, 0, 0, 0, 0] # Read with latch, AREV and FSYNC
-        params = self._send_spi(msg)
-        resp = bytearray(params['response'])
-        mcu_clock = self.mcu.clock32_to_clock64(params['clock'])
-        chip_clock = ((resp[2] & 0x7e) << 9) | ((resp[4] & 0x3e) << 4)
-        # Calculate temperature
-        temper = resp[5] - ((resp[4] & 0x01) << 8)
-        self.last_temperature = (temper + 152) / 2.776
-        return mcu_clock, chip_clock
-    def update_clock(self):
-        mcu_clock, chip_clock = self._query_clock()
-        mdiff = mcu_clock - self.last_chip_mcu_clock
-        chip_mclock = self.last_chip_clock + int(mdiff * self.chip_freq + .5)
-        cdiff = (chip_mclock - chip_clock) & 0xffff
-        cdiff -= (cdiff & 0x8000) << 1
-        new_chip_clock = chip_mclock - cdiff
-        self.chip_freq = float(new_chip_clock - self.last_chip_clock) / mdiff
-        self.last_chip_clock = new_chip_clock
-        self.last_chip_mcu_clock = mcu_clock
-    def start(self):
-        # Clear any errors from device
-        self._read_reg(0x00) # Read STAT
-        # Initialize chip (so different chip variants work the same way)
-        self._mask_reg(0x06, 0xc003, 0x4000) # MOD1: 42.7us, IIF disable
-        self._mask_reg(0x08, 0x0007, 0x0001) # MOD2: Predict off, autocal=1
-        self._mask_reg(0x0e, 0x0003, 0x0000) # MOD4: IIF mode
-        # Setup starting clock values
-        mcu_clock, chip_clock = self._query_clock()
-        self.last_chip_clock = chip_clock
-        self.last_chip_mcu_clock = mcu_clock
-        self.chip_freq = float(1<<5) / self.mcu.seconds_to_clock(1. / 750000.)
-        self.update_clock()
-    cmd_ANGLE_DEBUG_READ_help = "Query low-level angle sensor register"
-    def cmd_ANGLE_DEBUG_READ(self, gcmd):
-        reg = gcmd.get("REG", minval=0, maxval=0x30, parser=lambda x: int(x, 0))
-        val = self._read_reg(reg)
-        gcmd.respond_info("ANGLE REG[0x%02x] = 0x%04x" % (reg, val))
-    cmd_ANGLE_DEBUG_WRITE_help = "Set low-level angle sensor register"
-    def cmd_ANGLE_DEBUG_WRITE(self, gcmd):
-        reg = gcmd.get("REG", minval=0, maxval=0x30, parser=lambda x: int(x, 0))
-        val = gcmd.get("VAL", minval=0, maxval=0xffff,
-                       parser=lambda x: int(x, 0))
-        self._write_reg(reg, val)
-
-SAMPLE_PERIOD = 0.000400
-
-class Angle:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.sample_period = config.getfloat('sample_period', SAMPLE_PERIOD,
-                                             above=0.)
-        self.calibration = AngleCalibration(config)
-        # Measurement conversion
-        self.start_clock = self.time_shift = self.sample_ticks = 0
-        self.last_sequence = self.last_angle = 0
-        # Measurement storage (accessed from background thread)
-        self.lock = threading.Lock()
-        self.raw_samples = []
-        # Sensor type
-        sensors = { "a1333": HelperA1333, "as5047d": HelperAS5047D,
-                    "tle5012b": HelperTLE5012B }
-        sensor_type = config.getchoice('sensor_type', {s: s for s in sensors})
-        sensor_class = sensors[sensor_type]
-        self.spi = bus.MCU_SPI_from_config(config, sensor_class.SPI_MODE,
-                                           default_speed=sensor_class.SPI_SPEED)
-        self.mcu = mcu = self.spi.get_mcu()
-        self.oid = oid = mcu.create_oid()
-        self.sensor_helper = sensor_class(config, self.spi, oid)
-        # Setup mcu sensor_spi_angle bulk query code
-        self.query_spi_angle_cmd = self.query_spi_angle_end_cmd = None
-        mcu.add_config_cmd(
-            "config_spi_angle oid=%d spi_oid=%d spi_angle_type=%s"
-            % (oid, self.spi.get_oid(), sensor_type))
-        mcu.add_config_cmd(
-            "query_spi_angle oid=%d clock=0 rest_ticks=0 time_shift=0"
-            % (oid,), on_restart=True)
-        mcu.register_config_callback(self._build_config)
-        mcu.register_response(self._handle_spi_angle_data,
-                              "spi_angle_data", oid)
-        # API server endpoints
-        self.api_dump = motion_report.APIDumpHelper(
-            self.printer, self._api_update, self._api_startstop, 0.100)
-        self.name = config.get_name().split()[1]
-        wh = self.printer.lookup_object('webhooks')
-        wh.register_mux_endpoint("angle/dump_angle", "sensor", self.name,
-                                 self._handle_dump_angle)
-    def _build_config(self):
-        freq = self.mcu.seconds_to_clock(1.)
-        while float(TCODE_ERROR << self.time_shift) / freq < 0.002:
-            self.time_shift += 1
-        cmdqueue = self.spi.get_command_queue()
-        self.query_spi_angle_cmd = self.mcu.lookup_command(
-            "query_spi_angle oid=%c clock=%u rest_ticks=%u time_shift=%c",
-            cq=cmdqueue)
-        self.query_spi_angle_end_cmd = self.mcu.lookup_query_command(
-            "query_spi_angle oid=%c clock=%u rest_ticks=%u time_shift=%c",
-            "spi_angle_end oid=%c sequence=%hu", oid=self.oid, cq=cmdqueue)
-    def get_status(self, eventtime=None):
-        return {'temperature': self.sensor_helper.last_temperature}
-    # Measurement collection
-    def is_measuring(self):
-        return self.start_clock != 0
-    def _handle_spi_angle_data(self, params):
-        with self.lock:
-            self.raw_samples.append(params)
-    def _extract_samples(self, raw_samples):
-        # Load variables to optimize inner loop below
-        sample_ticks = self.sample_ticks
-        start_clock = self.start_clock
-        clock_to_print_time = self.mcu.clock_to_print_time
-        last_sequence = self.last_sequence
-        last_angle = self.last_angle
-        time_shift = 0
-        static_delay = 0.
-        last_chip_mcu_clock = last_chip_clock = chip_freq = inv_chip_freq = 0.
-        is_tcode_absolute = self.sensor_helper.is_tcode_absolute
-        if is_tcode_absolute:
-            tparams = self.sensor_helper.get_tcode_params()
-            last_chip_mcu_clock, last_chip_clock, chip_freq = tparams
-            inv_chip_freq = 1. / chip_freq
-        else:
-            time_shift = self.time_shift
-            static_delay = self.sensor_helper.get_static_delay()
-        # Process every message in raw_samples
-        count = error_count = 0
-        samples = [None] * (len(raw_samples) * 16)
-        for params in raw_samples:
-            seq = (last_sequence & ~0xffff) | params['sequence']
-            if seq < last_sequence:
-                seq += 0x10000
-            last_sequence = seq
-            d = bytearray(params['data'])
-            msg_mclock = start_clock + seq*16*sample_ticks
-            for i in range(len(d) // 3):
-                tcode = d[i*3]
-                if tcode == TCODE_ERROR:
-                    error_count += 1
-                    continue
-                raw_angle = d[i*3 + 1] | (d[i*3 + 2] << 8)
-                angle_diff = (last_angle - raw_angle) & 0xffff
-                angle_diff -= (angle_diff & 0x8000) << 1
-                last_angle -= angle_diff
-                mclock = msg_mclock + i*sample_ticks
-                if is_tcode_absolute:
-                    # tcode is tle5012b frame counter
-                    mdiff = mclock - last_chip_mcu_clock
-                    chip_mclock = last_chip_clock + int(mdiff * chip_freq + .5)
-                    cdiff = ((tcode << 10) - chip_mclock) & 0xffff
-                    cdiff -= (cdiff & 0x8000) << 1
-                    sclock = mclock + (cdiff - 0x800) * inv_chip_freq
-                else:
-                    # tcode is mcu clock offset shifted by time_shift
-                    sclock = mclock + (tcode<<time_shift)
-                ptime = round(clock_to_print_time(sclock) - static_delay, 6)
-                samples[count] = (ptime, last_angle)
-                count += 1
-        self.last_sequence = last_sequence
-        self.last_angle = last_angle
-        del samples[count:]
-        return samples, error_count
-    # API interface
-    def _api_update(self, eventtime):
-        if self.sensor_helper.is_tcode_absolute:
-            self.sensor_helper.update_clock()
-        with self.lock:
-            raw_samples = self.raw_samples
-            self.raw_samples = []
-        if not raw_samples:
-            return {}
-        samples, error_count = self._extract_samples(raw_samples)
-        if not samples:
-            return {}
-        offset = self.calibration.apply_calibration(samples)
-        return {'data': samples, 'errors': error_count,
-                'position_offset': offset}
-    def _start_measurements(self):
-        if self.is_measuring():
-            return
-        logging.info("Starting angle '%s' measurements", self.name)
-        self.sensor_helper.start()
-        # Start bulk reading
-        with self.lock:
-            self.raw_samples = []
-        self.last_sequence = 0
-        systime = self.printer.get_reactor().monotonic()
-        print_time = self.mcu.estimated_print_time(systime) + MIN_MSG_TIME
-        self.start_clock = reqclock = self.mcu.print_time_to_clock(print_time)
-        rest_ticks = self.mcu.seconds_to_clock(self.sample_period)
-        self.sample_ticks = rest_ticks
-        self.query_spi_angle_cmd.send([self.oid, reqclock, rest_ticks,
-                                       self.time_shift], reqclock=reqclock)
-    def _finish_measurements(self):
-        if not self.is_measuring():
-            return
-        # Halt bulk reading
-        params = self.query_spi_angle_end_cmd.send([self.oid, 0, 0, 0])
-        self.start_clock = 0
-        with self.lock:
-            self.raw_samples = []
-        self.sensor_helper.last_temperature = None
-        logging.info("Stopped angle '%s' measurements", self.name)
-    def _api_startstop(self, is_start):
-        if is_start:
-            self._start_measurements()
-        else:
-            self._finish_measurements()
-    def _handle_dump_angle(self, web_request):
-        self.api_dump.add_client(web_request)
-        hdr = ('time', 'angle')
-        web_request.send({'header': hdr})
-    def start_internal_client(self):
-        return self.api_dump.add_internal_client()
-
-def load_config_prefix(config):
-    return Angle(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/bed_mesh.py crealityShit/klippy/extras/bed_mesh.py
--- klipperStock/klippy/extras/bed_mesh.py	2024-01-14 23:01:59.457788201 -0600
+++ crealityShit/klippy/extras/bed_mesh.py	2024-01-14 23:02:21.658060316 -0600
@@ -93,6 +93,7 @@
         self.last_position = [0., 0., 0., 0.]
         self.bmc = BedMeshCalibrate(config, self)
         self.z_mesh = None
+        self.z_mesh_bak = None
         self.toolhead = None
         self.horizontal_move_z = config.getfloat('horizontal_move_z', 5.)
         self.fade_start = config.getfloat('fade_start', 1.)
@@ -121,6 +122,12 @@
         self.gcode.register_command(
             'BED_MESH_OFFSET', self.cmd_BED_MESH_OFFSET,
             desc=self.cmd_BED_MESH_OFFSET_help)
+        self.gcode.register_command(
+            'BED_MESH_SAVE', self.cmd_BED_MESH_SAVE,
+            desc=self.cmd_BED_MESH_SAVE_help)
+        self.gcode.register_command(
+            'BED_MESH_RESTORE', self.cmd_BED_MESH_RESTORE,
+            desc=self.cmd_BED_MESH_RESTORE_help)
         # Register transform
         gcode_move = self.printer.load_object(config, 'gcode_move')
         gcode_move.set_move_transform(self)
@@ -167,7 +174,7 @@
         self.update_status()
     def get_z_factor(self, z_pos):
         if z_pos >= self.fade_end:
-            return 0.
+            return 0.0
         elif z_pos >= self.fade_start:
             return (self.fade_end - z_pos) / self.fade_dist
         else:
@@ -277,6 +284,13 @@
             gcode_move.reset_last_position()
         else:
             gcmd.respond_info("No mesh loaded to offset")
+    cmd_BED_MESH_SAVE_help = "Save the Mesh to bak"
+    def cmd_BED_MESH_SAVE(self, gcmd):
+        if self.z_mesh is not None:
+            self.z_mesh_bak = self.z_mesh
+    cmd_BED_MESH_RESTORE_help = "Restore the bak Mesh to Mesh"
+    def cmd_BED_MESH_RESTORE(self, gcmd):
+        self.set_mesh(self.z_mesh_bak)
 
 
 class BedMeshCalibrate:
@@ -316,7 +330,7 @@
         x_dist = math.floor(x_dist * 100) / 100
         y_dist = math.floor(y_dist * 100) / 100
         if x_dist < 1. or y_dist < 1.:
-            raise error("bed_mesh: min/max points too close together")
+            raise error("""{"code":"key43", "msg":"bed_mesh: min/max points too close together", "values": []}""")
 
         if self.radius is not None:
             # round bed, min/max needs to be recalculated
@@ -716,7 +730,7 @@
                         "Probed table length: %d Probed Table:\n%s") %
                     (len(probed_matrix), str(probed_matrix)))
 
-        z_mesh = ZMesh(params)
+        z_mesh = ZMesh(params,self.printer)
         try:
             z_mesh.build_mesh(probed_matrix)
         except BedMeshError as e:
@@ -809,7 +823,9 @@
 
 
 class ZMesh:
-    def __init__(self, params):
+    def __init__(self, params,printer):
+        self.printer = printer
+        self.isenable = True
         self.probed_matrix = self.mesh_matrix = None
         self.mesh_params = params
         self.avg_z = 0.
@@ -847,6 +863,15 @@
                            (self.mesh_x_count - 1)
         self.mesh_y_dist = (self.mesh_y_max - self.mesh_y_min) / \
                            (self.mesh_y_count - 1)
+        self.gcode = self.printer.lookup_object('gcode')
+        if "BED_MESH_SET_DISABLE" not in self.gcode.ready_gcode_handlers:
+            self.gcode.register_command(
+                'BED_MESH_SET_DISABLE', self.cmd_BED_MESH_SET_DISABLE,
+                desc=self.cmd_BED_MESH_SET_DISABLE_helper)
+        if "BED_MESH_SET_ENABLE" not in self.gcode.ready_gcode_handlers:
+            self.gcode.register_command(
+                'BED_MESH_SET_ENABLE', self.cmd_BED_MESH_SET_ENABLE,
+                desc=self.cmd_BED_MESH_SET_ENABLE_helper)
     def get_mesh_matrix(self):
         if self.mesh_matrix is not None:
             return [[round(z, 6) for z in line]
@@ -908,7 +933,15 @@
         return self.mesh_x_min + self.mesh_x_dist * index
     def get_y_coordinate(self, index):
         return self.mesh_y_min + self.mesh_y_dist * index
+
+    def cmd_BED_MESH_SET_DISABLE(self, gcmd):
+        self.isenable = False
+    cmd_BED_MESH_SET_DISABLE_helper = " set  MESH disable"
+    def cmd_BED_MESH_SET_ENABLE(self, gcmd):
+        self.isenable = True
+    cmd_BED_MESH_SET_ENABLE_helper = "set  MESH enable "
     def calc_z(self, x, y):
+        if self.isenable:
         if self.mesh_matrix is not None:
             tbl = self.mesh_matrix
             tx, xidx = self._get_linear_index(x + self.mesh_offsets[0], 0)
@@ -917,6 +950,7 @@
             z1 = lerp(tx, tbl[yidx+1][xidx], tbl[yidx+1][xidx+1])
             return lerp(ty, z0, z1)
         else:
+                pass
             # No mesh table generated, no z-adjustment
             return 0.
     def get_z_range(self):
@@ -1194,18 +1228,21 @@
             % (prof_name))
     def load_profile(self, prof_name):
         profile = self.profiles.get(prof_name, None)
-        if profile is None:
-            raise self.gcode.error(
-                "bed_mesh: Unknown profile [%s]" % prof_name)
+        if profile is not None:
         probed_matrix = profile['points']
         mesh_params = profile['mesh_params']
-        z_mesh = ZMesh(mesh_params)
+            z_mesh = ZMesh(mesh_params,self.printer)
         try:
             z_mesh.build_mesh(probed_matrix)
         except BedMeshError as e:
             raise self.gcode.error(str(e))
         self.current_profile = prof_name
         self.bedmesh.set_mesh(z_mesh)
+        else:
+            self.gcode.respond_info("bed_mesh: Unknown profile [%s]" % (prof_name,))
+            # raise self.gcode.error(
+            #     "bed_mesh: Unknown profile [%s]" % prof_name)
+
     def remove_profile(self, prof_name):
         if prof_name in self.profiles:
             configfile = self.printer.lookup_object('configfile')
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/bed_screws.py crealityShit/klippy/extras/bed_screws.py
--- klipperStock/klippy/extras/bed_screws.py	2024-01-14 23:01:59.481788498 -0600
+++ crealityShit/klippy/extras/bed_screws.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,118 +0,0 @@
-# Helper script to adjust bed screws
-#
-# Copyright (C) 2019-2021  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-class BedScrews:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.reset()
-        self.number_of_screws = 0
-        # Read config
-        screws = []
-        fine_adjust = []
-        for i in range(99):
-            prefix = "screw%d" % (i + 1,)
-            if config.get(prefix, None) is None:
-                break
-            screw_coord = config.getfloatlist(prefix, count=2)
-            screw_name = "screw at %.3f,%.3f" % screw_coord
-            screw_name = config.get(prefix + "_name", screw_name)
-            screws.append((screw_coord, screw_name))
-            pfa = prefix + "_fine_adjust"
-            if config.get(pfa, None) is not None:
-                fine_coord = config.getfloatlist(pfa, count=2)
-                fine_adjust.append((fine_coord, screw_name))
-        if len(screws) < 3:
-            raise config.error("bed_screws: Must have at least three screws")
-        self.number_of_screws = len(screws)
-        self.states = {'adjust': screws, 'fine': fine_adjust}
-        self.speed = config.getfloat('speed', 50., above=0.)
-        self.lift_speed = config.getfloat('probe_speed', 5., above=0.)
-        self.horizontal_move_z = config.getfloat('horizontal_move_z', 5.)
-        self.probe_z = config.getfloat('probe_height', 0.)
-        # Register command
-        self.gcode = self.printer.lookup_object('gcode')
-        self.gcode.register_command("BED_SCREWS_ADJUST",
-                                    self.cmd_BED_SCREWS_ADJUST,
-                                    desc=self.cmd_BED_SCREWS_ADJUST_help)
-    def reset(self):
-        self.state = None
-        self.current_screw = 0
-        self.accepted_screws = 0
-    def move(self, coord, speed):
-        self.printer.lookup_object('toolhead').manual_move(coord, speed)
-    def move_to_screw(self, state, screw):
-        # Move up, over, and then down
-        self.move((None, None, self.horizontal_move_z), self.lift_speed)
-        coord, name = self.states[state][screw]
-        self.move((coord[0], coord[1], self.horizontal_move_z), self.speed)
-        self.move((coord[0], coord[1], self.probe_z), self.lift_speed)
-        # Update state
-        self.state = state
-        self.current_screw = screw
-        # Register commands
-        self.gcode.respond_info(
-            "Adjust %s. Then run ACCEPT, ADJUSTED, or ABORT\n"
-            "Use ADJUSTED if a significant screw adjustment is made" % (name,))
-        self.gcode.register_command('ACCEPT', self.cmd_ACCEPT,
-                                    desc=self.cmd_ACCEPT_help)
-        self.gcode.register_command('ADJUSTED', self.cmd_ADJUSTED,
-                                    desc=self.cmd_ADJUSTED_help)
-        self.gcode.register_command('ABORT', self.cmd_ABORT,
-                                    desc=self.cmd_ABORT_help)
-    def unregister_commands(self):
-        self.gcode.register_command('ACCEPT', None)
-        self.gcode.register_command('ADJUSTED', None)
-        self.gcode.register_command('ABORT', None)
-    def get_status(self, eventtime):
-        return {
-            'is_active': self.state is not None,
-            'state': self.state,
-            'current_screw': self.current_screw,
-            'accepted_screws': self.accepted_screws
-        }
-    cmd_BED_SCREWS_ADJUST_help = "Tool to help adjust bed leveling screws"
-    def cmd_BED_SCREWS_ADJUST(self, gcmd):
-        if self.state is not None:
-            raise gcmd.error("Already in bed_screws helper; use ABORT to exit")
-        # reset accepted screws
-        self.accepted_screws = 0
-        self.move((None, None, self.horizontal_move_z), self.speed)
-        self.move_to_screw('adjust', 0)
-    cmd_ACCEPT_help = "Accept bed screw position"
-    def cmd_ACCEPT(self, gcmd):
-        self.unregister_commands()
-        self.accepted_screws = self.accepted_screws + 1
-        if self.current_screw + 1 < len(self.states[self.state]) \
-                and self.accepted_screws < self.number_of_screws:
-            # Continue with next screw
-            self.move_to_screw(self.state, self.current_screw + 1)
-            return
-        if self.accepted_screws < self.number_of_screws:
-            # Retry coarse adjustments
-            self.move_to_screw('adjust', 0)
-            return
-        if self.state == 'adjust' and self.states['fine']:
-            # Reset accepted screws for fine adjustment
-            self.accepted_screws = 0
-            # Perform fine screw adjustments
-            self.move_to_screw('fine', 0)
-            return
-        # Done
-        self.reset()
-        self.move((None, None, self.horizontal_move_z), self.lift_speed)
-        gcmd.respond_info("Bed screws tool completed successfully")
-    cmd_ADJUSTED_help = "Accept bed screw position after notable adjustment"
-    def cmd_ADJUSTED(self, gcmd):
-        self.unregister_commands()
-        self.accepted_screws = -1
-        self.cmd_ACCEPT(gcmd)
-    cmd_ABORT_help = "Abort bed screws tool"
-    def cmd_ABORT(self, gcmd):
-        self.unregister_commands()
-        self.reset()
-
-def load_config(config):
-    return BedScrews(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/bed_tilt.py crealityShit/klippy/extras/bed_tilt.py
--- klipperStock/klippy/extras/bed_tilt.py	2024-01-14 23:01:59.453788154 -0600
+++ crealityShit/klippy/extras/bed_tilt.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,99 +0,0 @@
-# Bed tilt compensation
-#
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-import mathutil
-from . import probe
-
-class BedTilt:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.printer.register_event_handler("klippy:connect",
-                                            self.handle_connect)
-        self.x_adjust = config.getfloat('x_adjust', 0.)
-        self.y_adjust = config.getfloat('y_adjust', 0.)
-        self.z_adjust = config.getfloat('z_adjust', 0.)
-        if config.get('points', None) is not None:
-            BedTiltCalibrate(config, self)
-        self.toolhead = None
-        # Register move transform with g-code class
-        gcode_move = self.printer.load_object(config, 'gcode_move')
-        gcode_move.set_move_transform(self)
-    def handle_connect(self):
-        self.toolhead = self.printer.lookup_object('toolhead')
-    def get_position(self):
-        x, y, z, e = self.toolhead.get_position()
-        return [x, y, z - x*self.x_adjust - y*self.y_adjust - self.z_adjust, e]
-    def move(self, newpos, speed):
-        x, y, z, e = newpos
-        self.toolhead.move([x, y, z + x*self.x_adjust + y*self.y_adjust
-                            + self.z_adjust, e], speed)
-    def update_adjust(self, x_adjust, y_adjust, z_adjust):
-        self.x_adjust = x_adjust
-        self.y_adjust = y_adjust
-        self.z_adjust = z_adjust
-        gcode_move = self.printer.lookup_object('gcode_move')
-        gcode_move.reset_last_position()
-        configfile = self.printer.lookup_object('configfile')
-        configfile.set('bed_tilt', 'x_adjust', "%.6f" % (x_adjust,))
-        configfile.set('bed_tilt', 'y_adjust', "%.6f" % (y_adjust,))
-        configfile.set('bed_tilt', 'z_adjust', "%.6f" % (z_adjust,))
-
-# Helper script to calibrate the bed tilt
-class BedTiltCalibrate:
-    def __init__(self, config, bedtilt):
-        self.printer = config.get_printer()
-        self.bedtilt = bedtilt
-        self.probe_helper = probe.ProbePointsHelper(config, self.probe_finalize)
-        self.probe_helper.minimum_points(3)
-        # Register BED_TILT_CALIBRATE command
-        self.gcode = self.printer.lookup_object('gcode')
-        self.gcode.register_command(
-            'BED_TILT_CALIBRATE', self.cmd_BED_TILT_CALIBRATE,
-            desc=self.cmd_BED_TILT_CALIBRATE_help)
-    cmd_BED_TILT_CALIBRATE_help = "Bed tilt calibration script"
-    def cmd_BED_TILT_CALIBRATE(self, gcmd):
-        self.probe_helper.start_probe(gcmd)
-    def probe_finalize(self, offsets, positions):
-        # Setup for coordinate descent analysis
-        z_offset = offsets[2]
-        logging.info("Calculating bed_tilt with: %s", positions)
-        params = { 'x_adjust': self.bedtilt.x_adjust,
-                   'y_adjust': self.bedtilt.y_adjust,
-                   'z_adjust': z_offset }
-        logging.info("Initial bed_tilt parameters: %s", params)
-        # Perform coordinate descent
-        def adjusted_height(pos, params):
-            x, y, z = pos
-            return (z - x*params['x_adjust'] - y*params['y_adjust']
-                    - params['z_adjust'])
-        def errorfunc(params):
-            total_error = 0.
-            for pos in positions:
-                total_error += adjusted_height(pos, params)**2
-            return total_error
-        new_params = mathutil.coordinate_descent(
-            params.keys(), params, errorfunc)
-        # Update current bed_tilt calculations
-        x_adjust = new_params['x_adjust']
-        y_adjust = new_params['y_adjust']
-        z_adjust = (new_params['z_adjust'] - z_offset
-                    - x_adjust * offsets[0] - y_adjust * offsets[1])
-        self.bedtilt.update_adjust(x_adjust, y_adjust, z_adjust)
-        # Log and report results
-        logging.info("Calculated bed_tilt parameters: %s", new_params)
-        for pos in positions:
-            logging.info("orig: %s new: %s", adjusted_height(pos, params),
-                         adjusted_height(pos, new_params))
-        msg = "x_adjust: %.6f y_adjust: %.6f z_adjust: %.6f" % (
-            x_adjust, y_adjust, z_adjust)
-        self.printer.set_rollover_info("bed_tilt", "bed_tilt: %s" % (msg,))
-        self.gcode.respond_info(
-            "%s\nThe above parameters have been applied to the current\n"
-            "session. The SAVE_CONFIG command will update the printer\n"
-            "config file and restart the printer." % (msg,))
-
-def load_config(config):
-    return BedTilt(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/bl24c16f.py crealityShit/klippy/extras/bl24c16f.py
--- klipperStock/klippy/extras/bl24c16f.py	1969-12-31 18:00:00.000000000 -0600
+++ crealityShit/klippy/extras/bl24c16f.py	2024-01-14 23:02:21.650060220 -0600
@@ -0,0 +1,301 @@
+# Support for i2c based temperature sensors
+#
+# Copyright (C) 2020  Eric Callahan <arksine.code@gmail.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import logging
+import struct
+from . import bus
+
+BL24C16F_CHIP_ADDR_0 = 0x50
+BL24C16F_CHIP_ADDR_1 = 0x51
+BL24C16F_CHIP_ADDR_2 = 0x52
+BL24C16F_CHIP_ADDR_3 = 0x53
+BL24C16F_CHIP_ADDR_4 = 0x54
+BL24C16F_CHIP_ADDR_5 = 0x55
+BL24C16F_CHIP_ADDR_6 = 0x56
+BL24C16F_CHIP_ADDR_7 = 0x57
+
+class EEPROMCommandHelper:
+    def __init__(self, config, chip):
+        self.printer = config.get_printer()
+        self.chip = chip
+        name_parts = config.get_name().split()
+        self.base_name = name_parts[0]
+        self.name = name_parts[-1]
+        self.register_commands(self.name)
+        if len(name_parts) == 1:
+            if self.name == "bl24c16f" or not config.has_section("bl24c16f"):
+                self.register_commands(None)
+
+    def register_commands(self, name):
+        gcode = self.printer.lookup_object('gcode')
+        gcode.register_mux_command("EEPROM_DEBUG_READ", "CHIP", name,
+                                   self.cmd_EEPROM_DEBUG_READ,
+                                   desc=self.cmd_EEPROM_DEBUG_READ_help)
+        gcode.register_mux_command("EEPROM_DEBUG_WRITE_BYTE", "CHIP", name,
+                                   self.cmd_EEPROM_DEBUG_WRITE_BYTE,
+                                   desc=self.cmd_EEPROM_DEBUG_WRITE_BYTE_help)
+        gcode.register_mux_command("EEPROM_DEBUG_WRITE_INT", "CHIP", name,
+                                   self.cmd_EEPROM_DEBUG_WRITE_INT,
+                                   desc=self.cmd_EEPROM_DEBUG_WRITE_INT_help)
+        gcode.register_mux_command("EEPROM_DEBUG_WRITE_FLOAT", "CHIP", name,
+                                   self.cmd_EEPROM_DEBUG_WRITE_FLOAT,
+                                   desc=self.cmd_EEPROM_DEBUG_WRITE_FLOAT_help)
+        
+        gcode.register_mux_command("EEPROM_READ", "CHIP", name,
+                                   self.cmd_EEPROM_READ,
+                                   desc=self.cmd_EEPROM_READ_help)
+        gcode.register_mux_command("EEPROM_WRITE_BYTE", "CHIP", name,
+                                   self.cmd_EEPROM_WRITE_BYTE,
+                                   desc=self.cmd_EEPROM_WRITE_BYTE_help)
+        gcode.register_mux_command("EEPROM_WRITE_INT", "CHIP", name,
+                                   self.cmd_EEPROM_WRITE_INT,
+                                   desc=self.cmd_EEPROM_WRITE_INT_help)
+        gcode.register_mux_command("EEPROM_WRITE_FLOAT", "CHIP", name,
+                                   self.cmd_EEPROM_WRITE_FLOAT,
+                                   desc=self.cmd_EEPROM_WRITE_FLOAT_help)
+        
+        gcode.register_mux_command("EEPROM_IS_FIRST_USED", "CHIP", name,
+                                   self.cmd_EEPROM_IS_FIRST_USED)
+        gcode.register_mux_command("EEPROM_POS", "CHIP", name,
+                                   self.cmd_EEPROM_POS)
+        gcode.register_mux_command("EEPROM_PRINTER_INFO", "CHIP", name,
+                                   self.cmd_EEPROM_PRINTER_INFO)
+
+    def cmd_EEPROM_IS_FIRST_USED(self, gcmd):
+        val = self.chip.read_reg(1, 1)
+        state = False if int.from_bytes(val, 'little') != 255 else True
+        gcmd.respond_info("EEPROM_IS_USED val:%s state:%s" % (int.from_bytes(val, 'little'), state))
+        if int.from_bytes(val, 'little') != 255:
+            return False
+        else:
+            return True
+    
+    def cmd_EEPROM_POS(self, gcmd):
+        pos = self.chip.read_reg(0, 1)
+        gcmd.respond_info("EEPROM_POS int_pos:%s, pos:%s" % (int.from_bytes(pos, 'little'), pos))
+        
+    def cmd_EEPROM_PRINTER_INFO(self, gcmd):
+        pos = int.from_bytes(self.chip.read_reg(0, 1), 'little')
+        file_position = self.chip.read_reg(pos*8, 4)
+        base_position_e = self.chip.read_reg(pos*8+4, 4)
+        ret =  {"file_position": int.from_bytes(file_position, 'little'), "base_position_e": struct.unpack('f', base_position_e)[0]}
+        gcmd.respond_info("EEPROM_PRINTER_INFO ret:%s" % str(ret))
+
+    def cmd_EEPROM_DEBUG_READ(self, gcmd):
+        addr = gcmd.get("ADDR", minval=0, maxval=2047, parser=lambda x: int(x, 0))
+        size = gcmd.get("SIZE", minval=0, maxval=56, parser=lambda x: int(x, 0))
+        vals = self.chip.read_reg(addr, size)
+        gcmd.respond_info("EEPROM_DEBUG_READ size: 0x%x" % size)
+        reg_vals = 'read vals: '
+        for i in range(size):
+            if i % 16 == 0:
+                reg_vals += '\n'
+            reg_vals += '0x%x ' % vals[i]
+
+        gcmd.respond_info(reg_vals)
+
+    cmd_EEPROM_DEBUG_READ_help = "Read data bytes from eeprom"
+
+    def cmd_EEPROM_DEBUG_WRITE_BYTE(self, gcmd):
+        addr = gcmd.get("ADDR", minval=0, maxval=2047, parser=lambda x: int(x, 0))
+        val = gcmd.get("VAL", minval=0, maxval=255, parser=lambda x: int(x, 0))
+        gcmd.respond_info("EEPROM_DEBUG_WRITE_BYTE : ADDR[0x%x] = 0x%x" % (addr, val))
+        self.chip.write_reg(addr, val)
+
+    cmd_EEPROM_DEBUG_WRITE_BYTE_help = "Write byte data to eeprom"
+
+    def cmd_EEPROM_DEBUG_WRITE_INT(self, gcmd):
+        pos = self.chip.read_reg(0, 1)
+        gcmd.respond_info("EEPROM_POS int_pos:%s" % int.from_bytes(pos, 'little'))
+        addr = gcmd.get("ADDR", minval=0, maxval=2047, parser=lambda x: int(x, 0))
+        val = gcmd.get("VAL", minval=0, maxval=4294967296, parser=lambda x: int(x, 0))
+        gcmd.respond_info("EEPROM_DEBUG_WRITE_INT : val = %d" % val)
+        vals = [val & 0xFF]
+        vals += [   (val >> 8) & 0xFF,
+                    (val >> 16) & 0xFF,
+                    (val >> 24) & 0xFF,
+                ]
+        gcmd.respond_info("EEPROM_DEBUG_WRITE_INT : ADDR[0x%x] = 0x%02x 0x%02x 0x%02x 0x%02x"
+                % (addr, vals[0], vals[1], vals[2], vals[3]))
+        self.chip.write_reg(addr, vals)
+
+    cmd_EEPROM_DEBUG_WRITE_INT_help = "Write int (4 byte) data to eeprom"
+
+    def cmd_EEPROM_DEBUG_WRITE_FLOAT(self, gcmd):
+        addr = gcmd.get("ADDR", minval=0, maxval=2047, parser=lambda x: int(x, 0))
+        val = gcmd.get_float("VAL", 0.)
+        gcmd.respond_info("EEPROM_DEBUG_WRITE_FLOAT : val = %f" % val)
+        bs = struct.pack("f", val)
+        data = int.from_bytes(bs, byteorder="little")
+
+        vals = [data & 0xFF]
+        vals += [   (data >> 8) & 0xFF, 
+                    (data >> 16) & 0xFF,
+                    (data >> 24) & 0xFF
+                ]
+        gcmd.respond_info("EEPROM_DEBUG_WRITE_FLOAT : ADDR[0x%x] = 0x%02x 0x%02x 0x%02x 0x%02x"
+                        % (addr, vals[0], vals[1], vals[2], vals[3]))
+        self.chip.write_reg(addr, vals)
+
+    cmd_EEPROM_DEBUG_WRITE_FLOAT_help = "Write float (4 byte) data to eeprom"
+    
+    def cmd_EEPROM_READ(self, gcmd):
+        addr = gcmd.get("ADDR", minval=0, maxval=2047, parser=lambda x: int(x, 0))
+        size = gcmd.get("SIZE", minval=0, maxval=56, parser=lambda x: int(x, 0))
+        vals = self.chip.read_reg(addr, size)
+        # gcmd.respond_info("EEPROM_READ size: 0x%x" % size)
+        reg_vals = 'read vals: '
+        for i in range(size):
+            if i % 16 == 0:
+                reg_vals += '\n'
+            reg_vals += '0x%x ' % vals[i]
+        # gcmd.respond_info(reg_vals)
+    cmd_EEPROM_READ_help = "Read data bytes from eeprom"
+
+    def cmd_EEPROM_WRITE_BYTE(self, gcmd):
+        addr = gcmd.get("ADDR", minval=0, maxval=2047, parser=lambda x: int(x, 0))
+        val = gcmd.get("VAL", minval=0, maxval=255, parser=lambda x: int(x, 0))
+        # gcmd.respond_info("EEPROM_WRITE_BYTE : ADDR[0x%x] = 0x%x" % (addr, val))
+        self.chip.write_reg(addr, val)
+    cmd_EEPROM_WRITE_BYTE_help = "Write byte data to eeprom"
+
+    def cmd_EEPROM_WRITE_INT(self, gcmd):
+        # pos = self.chip.read_reg(0, 1)
+        # gcmd.respond_info("EEPROM_POS int_pos:%s" % int.from_bytes(pos, 'little'))
+        addr = gcmd.get("ADDR", minval=0, maxval=2047, parser=lambda x: int(x, 0))
+        val = gcmd.get("VAL", minval=0, maxval=4294967296, parser=lambda x: int(x, 0))
+        # gcmd.respond_info("EEPROM_WRITE_INT : val = %d" % val)
+        vals = [val & 0xFF]
+        vals += [   (val >> 8) & 0xFF,
+                    (val >> 16) & 0xFF,
+                    (val >> 24) & 0xFF,
+                ]
+        # gcmd.respond_info("EEPROM_WRITE_INT : ADDR[0x%x] = 0x%02x 0x%02x 0x%02x 0x%02x"
+                # % (addr, vals[0], vals[1], vals[2], vals[3]))
+        self.chip.write_reg(addr, vals)
+    cmd_EEPROM_WRITE_INT_help = "Write int (4 byte) data to eeprom"
+
+    def cmd_EEPROM_WRITE_FLOAT(self, gcmd):
+        addr = gcmd.get("ADDR", minval=0, maxval=2047, parser=lambda x: int(x, 0))
+        val = gcmd.get_float("VAL", 0.)
+        # gcmd.respond_info("EEPROM_WRITE_FLOAT : val = %f" % val)
+        bs = struct.pack("f", val)
+        data = int.from_bytes(bs, byteorder="little")
+
+        vals = [data & 0xFF]
+        vals += [   (data >> 8) & 0xFF, 
+                    (data >> 16) & 0xFF,
+                    (data >> 24) & 0xFF
+                ]
+        # gcmd.respond_info("EEPROM_WRITE_FLOAT : ADDR[0x%x] = 0x%02x 0x%02x 0x%02x 0x%02x"
+                        # % (addr, vals[0], vals[1], vals[2], vals[3]))
+        self.chip.write_reg(addr, vals)
+    cmd_EEPROM_WRITE_FLOAT_help = "Write float (4 byte) data to eeprom"  
+
+class BL24C16F:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        EEPROMCommandHelper(config, self)
+        self.name = config.get_name().split()[-1]
+        self.reactor = self.printer.get_reactor()
+        self.i2c0 = bus.MCU_I2C_from_config(
+            config, default_addr=BL24C16F_CHIP_ADDR_0, default_speed=400000)
+        self.i2c1 = bus.MCU_I2C_from_config(
+            config, default_addr=BL24C16F_CHIP_ADDR_1, default_speed=400000)
+        self.i2c2 = bus.MCU_I2C_from_config(
+            config, default_addr=BL24C16F_CHIP_ADDR_2, default_speed=400000)
+        self.i2c3 = bus.MCU_I2C_from_config(
+            config, default_addr=BL24C16F_CHIP_ADDR_3, default_speed=400000)
+        self.i2c4 = bus.MCU_I2C_from_config(
+            config, default_addr=BL24C16F_CHIP_ADDR_4, default_speed=400000)
+        self.i2c5 = bus.MCU_I2C_from_config(
+            config, default_addr=BL24C16F_CHIP_ADDR_5, default_speed=400000)
+        self.i2c6 = bus.MCU_I2C_from_config(
+            config, default_addr=BL24C16F_CHIP_ADDR_6, default_speed=400000)
+        self.i2c7 = bus.MCU_I2C_from_config(
+            config, default_addr=BL24C16F_CHIP_ADDR_7, default_speed=400000)
+        self.mcu = self.i2c0.get_mcu()
+        self.printer.add_object("bl24c16f " + self.name, self)
+        self.printer.register_event_handler("klippy:connect",
+                                            self.handle_connect)
+
+    def handle_connect(self):
+        self._init_bl24c16f()
+
+    def _init_bl24c16f(self):
+        logging.info("bl24c16f init...")
+
+    def read_reg(self, addr, read_len):
+        index = addr // 256
+        offset = addr % 256
+        reg = [offset]
+
+        if index == 0 :
+            params = self.i2c0.i2c_read(reg, read_len)
+        elif index == 1 :
+            params = self.i2c1.i2c_read(reg, read_len)
+        elif index == 2 :
+            params = self.i2c2.i2c_read(reg, read_len)
+        elif index == 3 :
+            params = self.i2c3.i2c_read(reg, read_len)
+        elif index == 4 :
+            params = self.i2c4.i2c_read(reg, read_len)
+        elif index == 5 :
+            params = self.i2c5.i2c_read(reg, read_len)
+        elif index == 6 :
+            params = self.i2c6.i2c_read(reg, read_len)
+        elif index == 7 :
+            params = self.i2c7.i2c_read(reg, read_len)
+
+        return bytearray(params['response'])
+
+    def write_reg(self, addr, data):
+        if type(data) is not list:
+            data = [data]
+
+        index = addr // 256
+        offset = addr % 256
+        data.insert(0, offset)
+        if index == 0 :
+            self.i2c0.i2c_write(data)
+        if index == 1 :
+            self.i2c1.i2c_write(data)
+        if index == 2 :
+            self.i2c2.i2c_write(data)
+        if index == 3 :
+            self.i2c3.i2c_write(data)
+        if index == 4 :
+            self.i2c4.i2c_write(data)
+        if index == 5 :
+            self.i2c5.i2c_write(data)
+        if index == 6 :
+            self.i2c6.i2c_write(data)
+        if index == 7 :
+            self.i2c7.i2c_write(data)
+
+    def setEepromDisable(self):
+        self.write_reg(1, 255)
+
+    def checkEepromFirstEnable(self):
+        val = self.read_reg(1, 1)
+        if int.from_bytes(val, 'little') != 255:
+            return False
+        else:
+            return True
+        
+    def eepromReadHeader(self):
+        pos = self.read_reg(0, 1)
+        return int.from_bytes(pos, 'little')
+    
+    def eepromReadBody(self, pos):
+        file_position = self.read_reg(pos*8, 4)
+        base_position_e = self.read_reg(pos*8+4, 4)
+        return {"file_position": int.from_bytes(file_position, 'little'), "base_position_e": struct.unpack('f', base_position_e)[0]}
+
+def load_config(config):
+    return BL24C16F(config)
+
+def load_config_prefix(config):
+    return BL24C16F(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/bltouch.py crealityShit/klippy/extras/bltouch.py
--- klipperStock/klippy/extras/bltouch.py	2024-01-14 23:01:59.453788154 -0600
+++ crealityShit/klippy/extras/bltouch.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,276 +0,0 @@
-# BLTouch support
-#
-# Copyright (C) 2018-2021  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-from . import probe
-
-SIGNAL_PERIOD = 0.020
-MIN_CMD_TIME = 5 * SIGNAL_PERIOD
-
-TEST_TIME = 5 * 60.
-RETRY_RESET_TIME = 1.
-ENDSTOP_REST_TIME = .001
-ENDSTOP_SAMPLE_TIME = .000015
-ENDSTOP_SAMPLE_COUNT = 4
-
-Commands = {
-    'pin_down': 0.000650, 'touch_mode': 0.001165,
-    'pin_up': 0.001475, 'self_test': 0.001780, 'reset': 0.002190,
-    'set_5V_output_mode' : 0.001988, 'set_OD_output_mode' : 0.002091,
-    'output_mode_store' : 0.001884,
-}
-
-# BLTouch "endstop" wrapper
-class BLTouchEndstopWrapper:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.printer.register_event_handler("klippy:connect",
-                                            self.handle_connect)
-        self.printer.register_event_handler('klippy:mcu_identify',
-                                            self.handle_mcu_identify)
-        self.position_endstop = config.getfloat('z_offset', minval=0.)
-        self.stow_on_each_sample = config.getboolean('stow_on_each_sample',
-                                                     True)
-        self.probe_touch_mode = config.getboolean('probe_with_touch_mode',
-                                                  False)
-        # Create a pwm object to handle the control pin
-        ppins = self.printer.lookup_object('pins')
-        self.mcu_pwm = ppins.setup_pin('pwm', config.get('control_pin'))
-        self.mcu_pwm.setup_max_duration(0.)
-        self.mcu_pwm.setup_cycle_time(SIGNAL_PERIOD)
-        # Command timing
-        self.next_cmd_time = self.action_end_time = 0.
-        self.finish_home_complete = self.wait_trigger_complete = None
-        # Create an "endstop" object to handle the sensor pin
-        pin = config.get('sensor_pin')
-        pin_params = ppins.lookup_pin(pin, can_invert=True, can_pullup=True)
-        mcu = pin_params['chip']
-        self.mcu_endstop = mcu.setup_pin('endstop', pin_params)
-        # output mode
-        omodes = {'5V': '5V', 'OD': 'OD', None: None}
-        self.output_mode = config.getchoice('set_output_mode', omodes, None)
-        # Setup for sensor test
-        self.next_test_time = 0.
-        self.pin_up_not_triggered = config.getboolean(
-            'pin_up_reports_not_triggered', True)
-        self.pin_up_touch_triggered = config.getboolean(
-            'pin_up_touch_mode_reports_triggered', True)
-        # Calculate pin move time
-        self.pin_move_time = config.getfloat('pin_move_time', 0.680, above=0.)
-        # Wrappers
-        self.get_mcu = self.mcu_endstop.get_mcu
-        self.add_stepper = self.mcu_endstop.add_stepper
-        self.get_steppers = self.mcu_endstop.get_steppers
-        self.home_wait = self.mcu_endstop.home_wait
-        self.query_endstop = self.mcu_endstop.query_endstop
-        # Register BLTOUCH_DEBUG command
-        self.gcode = self.printer.lookup_object('gcode')
-        self.gcode.register_command("BLTOUCH_DEBUG", self.cmd_BLTOUCH_DEBUG,
-                                    desc=self.cmd_BLTOUCH_DEBUG_help)
-        self.gcode.register_command("BLTOUCH_STORE", self.cmd_BLTOUCH_STORE,
-                                    desc=self.cmd_BLTOUCH_STORE_help)
-        # multi probes state
-        self.multi = 'OFF'
-    def handle_mcu_identify(self):
-        kin = self.printer.lookup_object('toolhead').get_kinematics()
-        for stepper in kin.get_steppers():
-            if stepper.is_active_axis('z'):
-                self.add_stepper(stepper)
-    def handle_connect(self):
-        self.sync_mcu_print_time()
-        self.next_cmd_time += 0.200
-        self.set_output_mode(self.output_mode)
-        try:
-            self.raise_probe()
-            self.verify_raise_probe()
-        except self.printer.command_error as e:
-            logging.warning("BLTouch raise probe error: %s", str(e))
-    def sync_mcu_print_time(self):
-        curtime = self.printer.get_reactor().monotonic()
-        est_time = self.mcu_pwm.get_mcu().estimated_print_time(curtime)
-        self.next_cmd_time = max(self.next_cmd_time, est_time + MIN_CMD_TIME)
-    def sync_print_time(self):
-        toolhead = self.printer.lookup_object('toolhead')
-        print_time = toolhead.get_last_move_time()
-        if self.next_cmd_time > print_time:
-            toolhead.dwell(self.next_cmd_time - print_time)
-        else:
-            self.next_cmd_time = print_time
-    def send_cmd(self, cmd, duration=MIN_CMD_TIME):
-        # Translate duration to ticks to avoid any secondary mcu clock skew
-        mcu = self.mcu_pwm.get_mcu()
-        cmd_clock = mcu.print_time_to_clock(self.next_cmd_time)
-        pulse = int((duration - MIN_CMD_TIME) / SIGNAL_PERIOD) * SIGNAL_PERIOD
-        cmd_clock += mcu.seconds_to_clock(max(MIN_CMD_TIME, pulse))
-        end_time = mcu.clock_to_print_time(cmd_clock)
-        # Schedule command followed by PWM disable
-        self.mcu_pwm.set_pwm(self.next_cmd_time, Commands[cmd] / SIGNAL_PERIOD)
-        self.mcu_pwm.set_pwm(end_time, 0.)
-        # Update time tracking
-        self.action_end_time = self.next_cmd_time + duration
-        self.next_cmd_time = max(self.action_end_time, end_time + MIN_CMD_TIME)
-    def verify_state(self, triggered):
-        # Perform endstop check to verify bltouch reports desired state
-        self.mcu_endstop.home_start(self.action_end_time, ENDSTOP_SAMPLE_TIME,
-                                    ENDSTOP_SAMPLE_COUNT, ENDSTOP_REST_TIME,
-                                    triggered=triggered)
-        trigger_time = self.mcu_endstop.home_wait(self.action_end_time + 0.100)
-        return trigger_time > 0.
-    def raise_probe(self):
-        self.sync_mcu_print_time()
-        if not self.pin_up_not_triggered:
-            self.send_cmd('reset')
-        self.send_cmd('pin_up', duration=self.pin_move_time)
-    def verify_raise_probe(self):
-        if not self.pin_up_not_triggered:
-            # No way to verify raise attempt
-            return
-        for retry in range(3):
-            success = self.verify_state(False)
-            if success:
-                # The "probe raised" test completed successfully
-                break
-            if retry >= 2:
-                raise self.printer.command_error(
-                    "BLTouch failed to raise probe")
-            msg = "Failed to verify BLTouch probe is raised; retrying."
-            self.gcode.respond_info(msg)
-            self.sync_mcu_print_time()
-            self.send_cmd('reset', duration=RETRY_RESET_TIME)
-            self.send_cmd('pin_up', duration=self.pin_move_time)
-    def lower_probe(self):
-        self.test_sensor()
-        self.sync_print_time()
-        self.send_cmd('pin_down', duration=self.pin_move_time)
-        if self.probe_touch_mode:
-            self.send_cmd('touch_mode')
-    def test_sensor(self):
-        if not self.pin_up_touch_triggered:
-            # Nothing to test
-            return
-        toolhead = self.printer.lookup_object('toolhead')
-        print_time = toolhead.get_last_move_time()
-        if print_time < self.next_test_time:
-            self.next_test_time = print_time + TEST_TIME
-            return
-        # Raise the bltouch probe and test if probe is raised
-        self.sync_print_time()
-        for retry in range(3):
-            self.send_cmd('pin_up', duration=self.pin_move_time)
-            self.send_cmd('touch_mode')
-            success = self.verify_state(True)
-            self.sync_print_time()
-            if success:
-                # The "bltouch connection" test completed successfully
-                self.next_test_time = print_time + TEST_TIME
-                return
-            msg = "BLTouch failed to verify sensor state"
-            if retry >= 2:
-                raise self.printer.command_error(msg)
-            self.gcode.respond_info(msg + '; retrying.')
-            self.send_cmd('reset', duration=RETRY_RESET_TIME)
-    def multi_probe_begin(self):
-        if self.stow_on_each_sample:
-            return
-        self.multi = 'FIRST'
-    def multi_probe_end(self):
-        if self.stow_on_each_sample:
-            return
-        self.sync_print_time()
-        self.raise_probe()
-        self.verify_raise_probe()
-        self.sync_print_time()
-        self.multi = 'OFF'
-    def probe_prepare(self, hmove):
-        if self.multi == 'OFF' or self.multi == 'FIRST':
-            self.lower_probe()
-            if self.multi == 'FIRST':
-                self.multi = 'ON'
-        self.sync_print_time()
-    def home_start(self, print_time, sample_time, sample_count, rest_time,
-                   triggered=True):
-        rest_time = min(rest_time, ENDSTOP_REST_TIME)
-        self.finish_home_complete = self.mcu_endstop.home_start(
-            print_time, sample_time, sample_count, rest_time, triggered)
-        # Schedule wait_for_trigger callback
-        r = self.printer.get_reactor()
-        self.wait_trigger_complete = r.register_callback(self.wait_for_trigger)
-        return self.finish_home_complete
-    def wait_for_trigger(self, eventtime):
-        self.finish_home_complete.wait()
-        if self.multi == 'OFF':
-            self.raise_probe()
-    def probe_finish(self, hmove):
-        self.wait_trigger_complete.wait()
-        if self.multi == 'OFF':
-            self.verify_raise_probe()
-        self.sync_print_time()
-        if hmove.check_no_movement() is not None:
-            raise self.printer.command_error("BLTouch failed to deploy")
-    def get_position_endstop(self):
-        return self.position_endstop
-    def set_output_mode(self, mode):
-        # If this is inadvertently/purposely issued for a
-        # BLTOUCH pre V3.0 and clones:
-        #   No reaction at all.
-        # BLTOUCH V3.0 and V3.1:
-        #   This will set the mode.
-        if mode is None:
-            return
-        logging.info("BLTouch set output mode: %s", mode)
-        self.sync_mcu_print_time()
-        if mode == '5V':
-            self.send_cmd('set_5V_output_mode')
-        if mode == 'OD':
-            self.send_cmd('set_OD_output_mode')
-    def store_output_mode(self, mode):
-        # If this command is inadvertently/purposely issued for a
-        # BLTOUCH pre V3.0 and clones:
-        #   No reaction at all to this sequence apart from a pin-down/pin-up
-        # BLTOUCH V3.0:
-        #   This will set the mode (twice) and sadly, a pin-up is needed at
-        #   the end, because of the pin-down
-        # BLTOUCH V3.1:
-        #   This will set the mode and store it in the eeprom.
-        #   The pin-up is not needed but does not hurt
-        logging.info("BLTouch store output mode: %s", mode)
-        self.sync_print_time()
-        self.send_cmd('pin_down')
-        if mode == '5V':
-            self.send_cmd('set_5V_output_mode')
-        else:
-            self.send_cmd('set_OD_output_mode')
-        self.send_cmd('output_mode_store')
-        if mode == '5V':
-            self.send_cmd('set_5V_output_mode')
-        else:
-            self.send_cmd('set_OD_output_mode')
-        self.send_cmd('pin_up')
-    cmd_BLTOUCH_DEBUG_help = "Send a command to the bltouch for debugging"
-    def cmd_BLTOUCH_DEBUG(self, gcmd):
-        cmd = gcmd.get('COMMAND', None)
-        if cmd is None or cmd not in Commands:
-            gcmd.respond_info("BLTouch commands: %s" % (
-                ", ".join(sorted([c for c in Commands if c is not None]))))
-            return
-        gcmd.respond_info("Sending BLTOUCH_DEBUG COMMAND=%s" % (cmd,))
-        self.sync_print_time()
-        self.send_cmd(cmd, duration=self.pin_move_time)
-        self.sync_print_time()
-    cmd_BLTOUCH_STORE_help = "Store an output mode in the BLTouch EEPROM"
-    def cmd_BLTOUCH_STORE(self, gcmd):
-        cmd = gcmd.get('MODE', None)
-        if cmd is None or cmd not in ['5V', 'OD']:
-            gcmd.respond_info("BLTouch output modes: 5V, OD")
-            return
-        gcmd.respond_info("Storing BLTouch output mode: %s" % (cmd,))
-        self.sync_print_time()
-        self.store_output_mode(cmd)
-        self.sync_print_time()
-
-def load_config(config):
-    blt = BLTouchEndstopWrapper(config)
-    config.get_printer().add_object('probe', probe.PrinterProbe(config, blt))
-    return blt
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/bme280.py crealityShit/klippy/extras/bme280.py
--- klipperStock/klippy/extras/bme280.py	2024-01-14 23:01:59.441788007 -0600
+++ crealityShit/klippy/extras/bme280.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,480 +0,0 @@
-# Support for i2c based temperature sensors
-#
-# Copyright (C) 2020  Eric Callahan <arksine.code@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-from . import bus
-
-REPORT_TIME = .8
-BME280_CHIP_ADDR = 0x76
-BME280_REGS = {
-    'RESET': 0xE0, 'CTRL_HUM': 0xF2,
-    'STATUS': 0xF3, 'CTRL_MEAS': 0xF4, 'CONFIG': 0xF5,
-    'PRESSURE_MSB': 0xF7, 'PRESSURE_LSB': 0xF8, 'PRESSURE_XLSB': 0xF9,
-    'TEMP_MSB': 0xFA, 'TEMP_LSB': 0xFB, 'TEMP_XLSB': 0xFC,
-    'HUM_MSB': 0xFD, 'HUM_LSB': 0xFE, 'CAL_1': 0x88, 'CAL_2': 0xE1
-}
-
-BME680_REGS = {
-    'RESET': 0xE0, 'CTRL_HUM': 0x72, 'CTRL_GAS_1': 0x71, 'CTRL_GAS_0': 0x70,
-    'GAS_WAIT_0': 0x64, 'RES_HEAT_0': 0x5A, 'IDAC_HEAT_0': 0x50,
-    'STATUS': 0x73, 'EAS_STATUS_0': 0x1D, 'CTRL_MEAS': 0x74, 'CONFIG': 0x75,
-    'GAS_R_LSB': 0x2B, 'GAS_R_MSB': 0x2A,
-    'PRESSURE_MSB': 0x1F, 'PRESSURE_LSB': 0x20, 'PRESSURE_XLSB': 0x21,
-    'TEMP_MSB': 0x22, 'TEMP_LSB': 0x23, 'TEMP_XLSB': 0x24,
-    'HUM_MSB': 0x25, 'HUM_LSB': 0x26, 'CAL_1': 0x88, 'CAL_2': 0xE1,
-    'RES_HEAT_VAL': 0x00, 'RES_HEAT_RANGE': 0x02, 'RANGE_SWITCHING_ERROR': 0x04
-}
-
-BME680_GAS_CONSTANTS = {
-    0: (1., 8000000.),
-    1: (1., 4000000.),
-    2: (1., 2000000.),
-    3: (1., 1000000.),
-    4: (1., 499500.4995),
-    5: (0.99, 248262.1648),
-    6: (1., 125000.),
-    7: (0.992, 63004.03226),
-    8: (1., 31281.28128),
-    9: (1., 15625.),
-    10: (0.998, 7812.5),
-    11: (0.995, 3906.25),
-    12: (1., 1953.125),
-    13: (0.99, 976.5625),
-    14: (1., 488.28125),
-    15: (1., 244.140625)
-}
-
-STATUS_MEASURING = 1 << 3
-STATUS_IM_UPDATE = 1
-MODE = 1
-RUN_GAS = 1 << 4
-NB_CONV_0 = 0
-EAS_NEW_DATA = 1 << 7
-GAS_DONE = 1 << 6
-MEASURE_DONE = 1 << 5
-RESET_CHIP_VALUE = 0xB6
-
-BME_CHIPS = {
-    0x58: 'BMP280', 0x60: 'BME280', 0x61: 'BME680'
-}
-BME_CHIP_ID_REG = 0xD0
-
-
-def get_twos_complement(val, bit_size):
-    if val & (1 << (bit_size - 1)):
-        val -= (1 << bit_size)
-    return val
-
-
-def get_unsigned_short(bits):
-    return bits[1] << 8 | bits[0]
-
-
-def get_signed_short(bits):
-    val = get_unsigned_short(bits)
-    return get_twos_complement(val, 16)
-
-
-def get_signed_byte(bits):
-    return get_twos_complement(bits, 8)
-
-
-class BME280:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.name = config.get_name().split()[-1]
-        self.reactor = self.printer.get_reactor()
-        self.i2c = bus.MCU_I2C_from_config(
-            config, default_addr=BME280_CHIP_ADDR, default_speed=100000)
-        self.mcu = self.i2c.get_mcu()
-        self.iir_filter = config.getint('bme280_iir_filter', 1)
-        self.os_temp = config.getint('bme280_oversample_temp', 2)
-        self.os_hum = config.getint('bme280_oversample_hum', 2)
-        self.os_pres = config.getint('bme280_oversample_pressure', 2)
-        self.gas_heat_temp = config.getint('bme280_gas_target_temp', 320)
-        self.gas_heat_duration = config.getint('bme280_gas_heat_duration', 150)
-        logging.info("BMxx80: Oversampling: Temp %dx Humid %dx Pressure %dx" % (
-            pow(2, self.os_temp - 1), pow(2, self.os_hum - 1),
-            pow(2, self.os_pres - 1)))
-        logging.info("BMxx80: IIR: %dx" % (pow(2, self.iir_filter) - 1))
-
-        self.temp = self.pressure = self.humidity = self.gas = self.t_fine = 0.
-        self.min_temp = self.max_temp = self.range_switching_error = 0.
-        self.max_sample_time = None
-        self.dig = self.sample_timer = None
-        self.chip_type = 'BMP280'
-        self.chip_registers = BME280_REGS
-        self.printer.add_object("bme280 " + self.name, self)
-        if self.printer.get_start_args().get('debugoutput') is not None:
-            return
-        self.printer.register_event_handler("klippy:connect",
-                                            self.handle_connect)
-
-    def handle_connect(self):
-        self._init_bmxx80()
-        self.reactor.update_timer(self.sample_timer, self.reactor.NOW)
-
-    def setup_minmax(self, min_temp, max_temp):
-        self.min_temp = min_temp
-        self.max_temp = max_temp
-
-    def setup_callback(self, cb):
-        self._callback = cb
-
-    def get_report_time_delta(self):
-        return REPORT_TIME
-
-    def _init_bmxx80(self):
-        def read_calibration_data_bmp280(calib_data_1):
-            dig = {}
-            dig['T1'] = get_unsigned_short(calib_data_1[0:2])
-            dig['T2'] = get_signed_short(calib_data_1[2:4])
-            dig['T3'] = get_signed_short(calib_data_1[4:6])
-
-            dig['P1'] = get_unsigned_short(calib_data_1[6:8])
-            dig['P2'] = get_signed_short(calib_data_1[8:10])
-            dig['P3'] = get_signed_short(calib_data_1[10:12])
-            dig['P4'] = get_signed_short(calib_data_1[12:14])
-            dig['P5'] = get_signed_short(calib_data_1[14:16])
-            dig['P6'] = get_signed_short(calib_data_1[16:18])
-            dig['P7'] = get_signed_short(calib_data_1[18:20])
-            dig['P8'] = get_signed_short(calib_data_1[20:22])
-            dig['P9'] = get_signed_short(calib_data_1[22:24])
-            return dig
-
-        def read_calibration_data_bme280(calib_data_1, calib_data_2):
-            dig = read_calibration_data_bmp280(calib_data_1)
-            dig['H1'] = calib_data_1[25] & 0xFF
-            dig['H2'] = get_signed_short(calib_data_2[0:2])
-            dig['H3'] = calib_data_2[2] & 0xFF
-            dig['H4'] = get_twos_complement(
-                (calib_data_2[3] << 4) | (calib_data_2[4] & 0x0F), 12)
-            dig['H5'] = get_twos_complement(
-                (calib_data_2[5] << 4) | ((calib_data_2[4] & 0xF0) >> 4), 12)
-            dig['H6'] = get_twos_complement(calib_data_2[6], 8)
-            return dig
-
-        def read_calibration_data_bme680(calib_data_1, calib_data_2):
-            dig = {}
-            dig['T1'] = get_unsigned_short(calib_data_2[8:10])
-            dig['T2'] = get_signed_short(calib_data_1[2:4])
-            dig['T3'] = get_signed_byte(calib_data_1[4])
-
-            dig['P1'] = get_unsigned_short(calib_data_1[6:8])
-            dig['P2'] = get_signed_short(calib_data_1[8:10])
-            dig['P3'] = calib_data_1[10]
-            dig['P4'] = get_signed_short(calib_data_1[12:14])
-            dig['P5'] = get_signed_short(calib_data_1[14:16])
-            dig['P6'] = get_signed_byte(calib_data_1[17])
-            dig['P7'] = get_signed_byte(calib_data_1[16])
-            dig['P8'] = get_signed_short(calib_data_1[20:22])
-            dig['P9'] = get_signed_short(calib_data_1[22:24])
-            dig['P10'] = calib_data_1[24]
-
-            dig['H1'] = get_twos_complement(
-                (calib_data_2[2] << 4) | (calib_data_2[1] & 0x0F), 12)
-            dig['H2'] = get_twos_complement(
-                (calib_data_2[0] << 4) | ((calib_data_2[1] & 0xF0) >> 4), 12)
-            dig['H3'] = get_signed_byte(calib_data_2[3])
-            dig['H4'] = get_signed_byte(calib_data_2[4])
-            dig['H5'] = get_signed_byte(calib_data_2[5])
-            dig['H6'] = calib_data_2[6]
-            dig['H7'] = get_signed_byte(calib_data_2[7])
-
-            dig['G1'] = get_signed_byte(calib_data_2[12])
-            dig['G2'] = get_signed_short(calib_data_2[10:12])
-            dig['G3'] = get_signed_byte(calib_data_2[13])
-            return dig
-
-        chip_id = self.read_id()
-        if chip_id not in BME_CHIPS.keys():
-            logging.info("bme280: Unknown Chip ID received %#x" % chip_id)
-        else:
-            self.chip_type = BME_CHIPS[chip_id]
-            logging.info("bme280: Found Chip %s at %#x" % (
-                self.chip_type, self.i2c.i2c_address))
-
-        # Reset chip
-        self.write_register('RESET', [RESET_CHIP_VALUE])
-        self.reactor.pause(self.reactor.monotonic() + .5)
-
-        # Make sure non-volatile memory has been copied to registers
-        status = self.read_register('STATUS', 1)[0]
-        while status & STATUS_IM_UPDATE:
-            self.reactor.pause(self.reactor.monotonic() + .01)
-            status = self.read_register('STATUS', 1)[0]
-
-        if self.chip_type == 'BME680':
-            self.max_sample_time = 0.5
-            self.sample_timer = self.reactor.register_timer(self._sample_bme680)
-            self.chip_registers = BME680_REGS
-        else:
-            self.max_sample_time = \
-                (1.25 + (2.3 * self.os_temp) + ((2.3 * self.os_pres) + .575)
-                 + ((2.3 * self.os_hum) + .575)) / 1000
-            self.sample_timer = self.reactor.register_timer(self._sample_bme280)
-            self.chip_registers = BME280_REGS
-
-        if self.chip_type in ('BME680', 'BME280'):
-            self.write_register('CONFIG', (self.iir_filter & 0x07) << 2)
-
-        # Read out and calculate the trimming parameters
-        cal_1 = self.read_register('CAL_1', 26)
-        cal_2 = self.read_register('CAL_2', 16)
-        if self.chip_type == 'BME280':
-            self.dig = read_calibration_data_bme280(cal_1, cal_2)
-        elif self.chip_type == 'BMP280':
-            self.dig = read_calibration_data_bmp280(cal_1)
-        elif self.chip_type == 'BME680':
-            self.dig = read_calibration_data_bme680(cal_1, cal_2)
-
-    def _sample_bme280(self, eventtime):
-        # Enter forced mode
-        if self.chip_type == 'BME280':
-            self.write_register('CTRL_HUM', self.os_hum)
-        meas = self.os_temp << 5 | self.os_pres << 2 | MODE
-        self.write_register('CTRL_MEAS', meas)
-
-        try:
-            # wait until results are ready
-            status = self.read_register('STATUS', 1)[0]
-            while status & STATUS_MEASURING:
-                self.reactor.pause(
-                    self.reactor.monotonic() + self.max_sample_time)
-                status = self.read_register('STATUS', 1)[0]
-
-            if self.chip_type == 'BME280':
-                data = self.read_register('PRESSURE_MSB', 8)
-            elif self.chip_type == 'BMP280':
-                data = self.read_register('PRESSURE_MSB', 6)
-            else:
-                return self.reactor.NEVER
-        except Exception:
-            logging.exception("BME280: Error reading data")
-            self.temp = self.pressure = self.humidity = .0
-            return self.reactor.NEVER
-
-        temp_raw = (data[3] << 12) | (data[4] << 4) | (data[5] >> 4)
-        self.temp = self._compensate_temp(temp_raw)
-        pressure_raw = (data[0] << 12) | (data[1] << 4) | (data[2] >> 4)
-        self.pressure = self._compensate_pressure_bme280(pressure_raw) / 100.
-        if self.chip_type == 'BME280':
-            humid_raw = (data[6] << 8) | data[7]
-            self.humidity = self._compensate_humidity_bme280(humid_raw)
-        if self.temp < self.min_temp or self.temp > self.max_temp:
-            self.printer.invoke_shutdown(
-                "BME280 temperature %0.1f outside range of %0.1f:%.01f"
-                % (self.temp, self.min_temp, self.max_temp))
-        measured_time = self.reactor.monotonic()
-        self._callback(self.mcu.estimated_print_time(measured_time), self.temp)
-        return measured_time + REPORT_TIME
-
-    def _sample_bme680(self, eventtime):
-        self.write_register('CTRL_HUM', self.os_hum & 0x07)
-        meas = self.os_temp << 5 | self.os_pres << 2
-        self.write_register('CTRL_MEAS', [meas])
-
-        gas_wait_0 = self._calculate_gas_heater_duration(self.gas_heat_duration)
-        self.write_register('GAS_WAIT_0', [gas_wait_0])
-        res_heat_0 = self._calculate_gas_heater_resistance(self.gas_heat_temp)
-        self.write_register('RES_HEAT_0', [res_heat_0])
-        gas_config = RUN_GAS | NB_CONV_0
-        self.write_register('CTRL_GAS_1', [gas_config])
-
-        def data_ready(stat):
-            new_data = (stat & EAS_NEW_DATA)
-            gas_done = not (stat & GAS_DONE)
-            meas_done = not (stat & MEASURE_DONE)
-            return new_data and gas_done and meas_done
-
-        # Enter forced mode
-        meas = meas | MODE
-        self.write_register('CTRL_MEAS', meas)
-        try:
-            # wait until results are ready
-            status = self.read_register('EAS_STATUS_0', 1)[0]
-            while not data_ready(status):
-                self.reactor.pause(
-                    self.reactor.monotonic() + self.max_sample_time)
-                status = self.read_register('EAS_STATUS_0', 1)[0]
-
-            data = self.read_register('PRESSURE_MSB', 8)
-            gas_data = self.read_register('GAS_R_MSB', 2)
-        except Exception:
-            logging.exception("BME680: Error reading data")
-            self.temp = self.pressure = self.humidity = self.gas = .0
-            return self.reactor.NEVER
-
-        temp_raw = (data[3] << 12) | (data[4] << 4) | (data[5] >> 4)
-        if temp_raw != 0x80000:
-            self.temp = self._compensate_temp(temp_raw)
-        pressure_raw = (data[0] << 12) | (data[1] << 4) | (data[2] >> 4)
-        if pressure_raw != 0x80000:
-            self.pressure = self._compensate_pressure_bme680(
-                pressure_raw) / 100.
-        humid_raw = (data[6] << 8) | data[7]
-        self.humidity = self._compensate_humidity_bme680(humid_raw)
-
-        gas_valid = ((gas_data[1] & 0x20) == 0x20)
-        if gas_valid:
-            gas_heater_stable = ((gas_data[1] & 0x10) == 0x10)
-            if not gas_heater_stable:
-                logging.warning("BME680: Gas heater didn't reach target")
-            gas_raw = (gas_data[0] << 2) | ((gas_data[1] & 0xC0) >> 6)
-            gas_range = (gas_data[1] & 0x0F)
-            self.gas = self._compensate_gas(gas_raw, gas_range)
-
-        if self.temp < self.min_temp or self.temp > self.max_temp:
-            self.printer.invoke_shutdown(
-                "BME680 temperature %0.1f outside range of %0.1f:%.01f"
-                % (self.temp, self.min_temp, self.max_temp))
-        measured_time = self.reactor.monotonic()
-        self._callback(self.mcu.estimated_print_time(measured_time), self.temp)
-        return measured_time + REPORT_TIME * 4
-
-    def _compensate_temp(self, raw_temp):
-        dig = self.dig
-        var1 = ((raw_temp / 16384. - (dig['T1'] / 1024.)) * dig['T2'])
-        var2 = (
-                ((raw_temp / 131072.) - (dig['T1'] / 8192.)) *
-                ((raw_temp / 131072.) - (dig['T1'] / 8192.)) * dig['T3'])
-        self.t_fine = var1 + var2
-        return self.t_fine / 5120.0
-
-    def _compensate_pressure_bme280(self, raw_pressure):
-        dig = self.dig
-        t_fine = self.t_fine
-        var1 = t_fine / 2. - 64000.
-        var2 = var1 * var1 * dig['P6'] / 32768.
-        var2 = var2 + var1 * dig['P5'] * 2.
-        var2 = var2 / 4. + (dig['P4'] * 65536.)
-        var1 = (dig['P3'] * var1 * var1 / 524288. + dig['P2'] * var1) / 524288.
-        var1 = (1. + var1 / 32768.) * dig['P1']
-        if var1 == 0:
-            return 0.
-        else:
-            pressure = 1048576.0 - raw_pressure
-            pressure = ((pressure - var2 / 4096.) * 6250.) / var1
-            var1 = dig['P9'] * pressure * pressure / 2147483648.
-            var2 = pressure * dig['P8'] / 32768.
-            return pressure + (var1 + var2 + dig['P7']) / 16.
-
-    def _compensate_pressure_bme680(self, raw_pressure):
-        dig = self.dig
-        t_fine = self.t_fine
-        var1 = t_fine / 2. - 64000.
-        var2 = var1 * var1 * dig['P6'] / 131072.
-        var2 = var2 + var1 * dig['P5'] * 2.
-        var2 = var2 / 4. + (dig['P4'] * 65536.)
-        var1 = (dig['P3'] * var1 * var1 / 16384. + dig['P2'] * var1) / 524288.
-        var1 = (1. + var1 / 32768.) * dig['P1']
-        if var1 == 0:
-            return 0.
-        else:
-            pressure = 1048576.0 - raw_pressure
-            pressure = ((pressure - var2 / 4096.) * 6250.) / var1
-            var1 = dig['P9'] * pressure * pressure / 2147483648.
-            var2 = pressure * dig['P8'] / 32768.
-            var3 = (pressure / 256.) * (pressure / 256.) * (pressure / 256.) * (
-                    dig['P10'] / 131072.)
-            return pressure + (var1 + var2 + var3 + (dig['P7'] * 128.)) / 16.
-
-    def _compensate_humidity_bme280(self, raw_humidity):
-        dig = self.dig
-        t_fine = self.t_fine
-        humidity = t_fine - 76800.
-        h1 = (
-                raw_humidity - (
-                dig['H4'] * 64. + dig['H5'] / 16384. * humidity))
-        h2 = (dig['H2'] / 65536. * (1. + dig['H6'] / 67108864. * humidity *
-                                    (1. + dig['H3'] / 67108864. * humidity)))
-        humidity = h1 * h2
-        humidity = humidity * (1. - dig['H1'] * humidity / 524288.)
-        return min(100., max(0., humidity))
-
-    def _compensate_humidity_bme680(self, raw_humidity):
-        dig = self.dig
-        temp_comp = self.temp
-
-        var1 = raw_humidity - (
-                (dig['H1'] * 16.) + ((dig['H3'] / 2.) * temp_comp))
-        var2 = var1 * ((dig['H2'] / 262144.) *
-                       (1. + ((dig['H4'] / 16384.) * temp_comp) +
-                        ((dig['H5'] / 1048576.) * temp_comp * temp_comp)))
-        var3 = dig['H6'] / 16384.
-        var4 = dig['H7'] / 2097152.
-        humidity = var2 + ((var3 + (var4 * temp_comp)) * var2 * var2)
-        return min(100., max(0., humidity))
-
-    def _compensate_gas(self, gas_raw, gas_range):
-        gas_switching_error = self.read_register('RANGE_SWITCHING_ERROR', 1)[0]
-        var1 = (1340. + 5. * gas_switching_error) * \
-               BME680_GAS_CONSTANTS[gas_range][0]
-        gas = var1 * BME680_GAS_CONSTANTS[gas_range][1] / (
-                gas_raw - 512. + var1)
-        return gas
-
-    def _calculate_gas_heater_resistance(self, target_temp):
-        amb_temp = self.temp
-        heater_data = self.read_register('RES_HEAT_VAL', 3)
-        res_heat_val = get_signed_byte(heater_data[0])
-        res_heat_range = (heater_data[2] & 0x30) >> 4
-        dig = self.dig
-        var1 = (dig['G1'] / 16.) + 49.
-        var2 = ((dig['G2'] / 32768.) * 0.0005) + 0.00235
-        var3 = dig['G3'] / 1024.
-        var4 = var1 * (1. + (var2 * target_temp))
-        var5 = var4 + (var3 * amb_temp)
-        res_heat = (3.4 * ((var5 * (4. / (4. + res_heat_range))
-                            * (1. / (1. + (res_heat_val * 0.002)))) - 25))
-        return int(res_heat)
-
-    def _calculate_gas_heater_duration(self, duration_ms):
-        if duration_ms >= 4032:
-            duration_reg = 0xff
-        else:
-            factor = 0
-            while duration_ms > 0x3F:
-                duration_ms //= 4
-                factor += 1
-            duration_reg = duration_ms + (factor * 64)
-
-        return duration_reg
-
-    def read_id(self):
-        # read chip id register
-        regs = [BME_CHIP_ID_REG]
-        params = self.i2c.i2c_read(regs, 1)
-        return bytearray(params['response'])[0]
-
-    def read_register(self, reg_name, read_len):
-        # read a single register
-        regs = [self.chip_registers[reg_name]]
-        params = self.i2c.i2c_read(regs, read_len)
-        return bytearray(params['response'])
-
-    def write_register(self, reg_name, data):
-        if type(data) is not list:
-            data = [data]
-        reg = self.chip_registers[reg_name]
-        data.insert(0, reg)
-        self.i2c.i2c_write(data)
-
-    def get_status(self, eventtime):
-        data = {
-            'temperature': round(self.temp, 2),
-            'pressure': self.pressure
-        }
-        if self.chip_type in ('BME280', 'BME680'):
-            data['humidity'] = self.humidity
-        if self.chip_type == 'BME680':
-            data['gas'] = self.gas
-        return data
-
-
-def load_config(config):
-    # Register sensor
-    pheaters = config.get_printer().load_object(config, "heaters")
-    pheaters.add_sensor_factory("BME280", BME280)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/bus.py crealityShit/klippy/extras/bus.py
--- klipperStock/klippy/extras/bus.py	2024-01-14 23:01:59.469788348 -0600
+++ crealityShit/klippy/extras/bus.py	2024-01-14 23:02:21.670060464 -0600
@@ -19,10 +19,10 @@
     if bus is None:
         rev_enums = {v: k for k, v in enums.items()}
         if 0 not in rev_enums:
-            raise ppins.error("Must specify %s on mcu '%s'" % (param, mcu_name))
+            raise ppins.error("""{"code": "key310", "msg": "Must specify %s on mcu '%s'", "values":["%s", "%s"]}""" % (param, mcu_name, param, mcu_name))
         bus = rev_enums[0]
     if bus not in enums:
-        raise ppins.error("Unknown %s '%s'" % (param, bus))
+        raise ppins.error("""{"code": "key311", "msg": "Unknown %s '%s'", "values":["%s", "%s"]}""" % (param, bus, param, bus))
     # Check for reserved bus pins
     constants = mcu.get_constants()
     reserve_pins = constants.get('BUS_PINS_%s' % (bus,), None)
@@ -125,8 +125,8 @@
                          for name in sw_pin_names]
         for pin_params in sw_pin_params:
             if pin_params['chip'] != mcu:
-                raise ppins.error("%s: spi pins must be on same mcu" % (
-                    config.get_name(),))
+                raise ppins.error("""{"code":"key231", "msg":"%s spi pins must be on same mcu", "values": ["%s"]}""" % (
+                    config.get_name(), config.get_name()))
         sw_pins = tuple([pin_params['pin'] for pin_params in sw_pin_params])
         bus = None
     else:
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/canbus_ids.py crealityShit/klippy/extras/canbus_ids.py
--- klipperStock/klippy/extras/canbus_ids.py	2024-01-14 23:01:59.493788645 -0600
+++ crealityShit/klippy/extras/canbus_ids.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,26 +0,0 @@
-# Support for tracking canbus node ids
-#
-# Copyright (C) 2021  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-NODEID_FIRST = 4
-
-class PrinterCANBus:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.ids = {}
-    def add_uuid(self, config, canbus_uuid, canbus_iface):
-        if canbus_uuid in self.ids:
-            raise config.error("Duplicate canbus_uuid")
-        new_id = len(self.ids) + NODEID_FIRST
-        self.ids[canbus_uuid] = new_id
-        return new_id
-    def get_nodeid(self, canbus_uuid):
-        if canbus_uuid not in self.ids:
-            raise self.printer.config_error("Unknown canbus_uuid %s"
-                                            % (canbus_uuid,))
-        return self.ids[canbus_uuid]
-
-def load_config(config):
-    return PrinterCANBus(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/controller_fan.py crealityShit/klippy/extras/controller_fan.py
--- klipperStock/klippy/extras/controller_fan.py	2024-01-14 23:01:59.445788055 -0600
+++ crealityShit/klippy/extras/controller_fan.py	2024-01-14 23:02:21.638060073 -0600
@@ -37,9 +37,8 @@
             return
         if not all(x in all_steppers for x in self.stepper_names):
             raise self.printer.config_error(
-                "One or more of these steppers are unknown: "
-                 "%s (valid steppers are: %s)"
-                % (self.stepper_names, ", ".join(all_steppers)))
+                """{"code":"key66", "msg":"One or more of these steppers are unknown: %s (valid steppers are: %s)", "values": ["%s", "%s"]}"""
+                % (self.stepper_names, ", ".join(all_steppers), self.stepper_names, ", ".join(all_steppers)))
     def handle_ready(self):
         reactor = self.printer.get_reactor()
         reactor.register_timer(self.callback, reactor.monotonic()+PIN_MIN_TIME)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/custom_macro.py crealityShit/klippy/extras/custom_macro.py
--- klipperStock/klippy/extras/custom_macro.py	1969-12-31 18:00:00.000000000 -0600
+++ crealityShit/klippy/extras/custom_macro.py	2024-01-14 23:02:21.686060659 -0600
@@ -0,0 +1,121 @@
+# Support for 1-wire based temperature sensors
+#
+# Copyright (C) 2020 Alan Lord <alanslists@gmail.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import time
+
+class CUSTOM_MACRO:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.gcode = self.printer.lookup_object('gcode')
+        self.pheaters = None
+        self.heater_hot = None
+        self.extruder_temp=None
+        self.bed_temp=None
+        self.prtouch = None
+        self.gcode.register_command("CX_PRINT_LEVELING_CALIBRATION", self.cmd_CX_PRINT_LEVELING_CALIBRATION, desc=self.cmd_CX_PRINT_LEVELING_CALIBRATION_help)
+        self.gcode.register_command("CX_CLEAN_CALIBRATION_FLAGS", self.cmd_CX_CLEAN_CALIBRATION_FLAGS, desc=self.cmd_CX_CLEAN_CALIBRATION_FLAGS_help)
+        self.gcode.register_command("CX_PRINT_DRAW_ONE_LINE", self.cmd_CX_PRINT_DRAW_ONE_LINE, desc=self.cmd_CX_PRINT_DRAW_ONE_LINE_help)
+        self.gcode.register_command("CX_ROUGH_G28", self.cmd_CX_ROUGH_G28, desc=self.cmd_CX_ROUGH_G28_help)
+        self.gcode.register_command("CX_NOZZLE_CLEAR", self.cmd_CX_NOZZLE_CLEAR, desc=self.cmd_CX_NOZZLE_CLEAR_help)
+        self.default_extruder_temp = config.getfloat("default_extruder_temp", default=240.0)
+        self.default_bed_temp = config.getfloat("default_bed_temp", default=50.0)
+        self.g28_ext_temp = config.getfloat("g28_ext_temp", default=140.0)
+        self.nozzle_clear = config.getboolean('nozzle_clear', True)
+        self.calibration = config.getint('calibration', default=0)
+        self.leveling_calibration = 0
+        pass
+
+
+    def get_status(self, eventtime):
+        return {
+            'leveling_calibration': self.leveling_calibration,
+            'default_extruder_temp': self.default_extruder_temp,
+            'default_bed_temp': self.default_bed_temp,
+            'g28_ext_temp': self.g28_ext_temp
+        }
+
+    cmd_CX_PRINT_LEVELING_CALIBRATION_help = "Start Print function,three parameter:EXTRUDER_TEMP(180-300),BED_TEMP(0-100),CALIBRATION(0 or 1)"
+    def cmd_CX_PRINT_LEVELING_CALIBRATION(self, gcmd):
+        self.gcode.run_script_from_command('CHECK_BED_MESH AUTO_G29=1')
+        pass
+
+    cmd_CX_CLEAN_CALIBRATION_FLAGS_help = "Clean calibration flags"
+    def cmd_CX_CLEAN_CALIBRATION_FLAGS(self, gcmd):
+        self.leveling_calibration = 0
+        pass
+
+    cmd_CX_PRINT_DRAW_ONE_LINE_help = "Draw one line before printing"
+    def cmd_CX_PRINT_DRAW_ONE_LINE(self, gcmd):
+        self.gcode.run_script_from_command('M83')
+        self.gcode.run_script_from_command('G1 X10 Y10 Z2 F6000')
+        self.gcode.run_script_from_command('G1 Z0.1 F600')
+        self.pheaters = self.printer.lookup_object('heaters')
+        self.heater_hot = self.printer.lookup_object('extruder').heater
+        self.gcode.respond_info("can_break_flag = %d" % (self.pheaters.can_break_flag))
+        self.gcode.run_script_from_command('M104 S%d' % (self.extruder_temp))
+        self.gcode.run_script_from_command('M140 S%d' % (self.bed_temp))
+        self.pheaters.set_temperature(self.heater_hot, self.extruder_temp, True)
+        self.gcode.respond_info("can_break_flag = %d" % (self.pheaters.can_break_flag))
+        while self.pheaters.can_break_flag == 1:
+            time.sleep(1)
+        self.gcode.respond_info("can_break_flag = %d" % (self.pheaters.can_break_flag))
+        if self.pheaters.can_break_flag == 3:
+            self.pheaters.can_break_flag = 0
+            self.gcode.respond_info("can_break_flag is 3")
+            self.gcode.run_script_from_command('G21')
+            self.gcode.run_script_from_command('G1 F2400 E-0.5')
+            self.gcode.run_script_from_command('SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY=5')
+            self.gcode.run_script_from_command('M204 S12000')
+            self.gcode.run_script_from_command('G21')
+            self.gcode.run_script_from_command('SET_VELOCITY_LIMIT ACCEL_TO_DECEL=6000')
+            # self.gcode.run_script_from_command('SET_PRESSURE_ADVANCE ADVANCE=0.04')
+            # self.gcode.run_script_from_command('SET_PRESSURE_ADVANCE SMOOTH_TIME=0.04')
+            self.gcode.run_script_from_command('M220 S100')
+            self.gcode.run_script_from_command('M221 S100')
+            self.gcode.run_script_from_command('G1 Z2.0 F1200')
+            self.gcode.run_script_from_command('G1 X0.1 Y20 Z0.3 F6000.0')
+            self.gcode.run_script_from_command('G1 X0.1 Y180.0 Z0.3 F3000.0 E10.0')
+            self.gcode.run_script_from_command('G1 X0.4 Y180.0 Z0.3 F3000.0')
+            self.gcode.run_script_from_command('G1 X0.4 Y20.0 Z0.3 F3000.0 E10.0')
+            self.gcode.run_script_from_command('G1 Y10.0 F3000.0')
+            self.gcode.run_script_from_command('G1 Z2.0 F600.0')
+            self.gcode.run_script_from_command('G1 Z0.3 F600.0')
+            self.gcode.run_script_from_command('G1 Z2.0 F600.0')
+            # self.gcode.run_script_from_command('G1 X0.4 Y10.0 Z0.3 F6000.0')
+            self.gcode.run_script_from_command('M82')
+            self.gcode.run_script_from_command('G92 E0')
+            # self.gcode.run_script_from_command('G1 Z2.0 F600')
+            self.gcode.run_script_from_command('G1 F12000')
+            self.gcode.run_script_from_command('G21')
+        pass
+
+    cmd_CX_ROUGH_G28_help = "rough G28"
+    def cmd_CX_ROUGH_G28(self, gcmd):
+        self.extruder_temp = gcmd.get_float('EXTRUDER_TEMP', default=self.default_extruder_temp, minval=180.0, maxval=320.0)
+        self.g28_ext_temp = self.extruder_temp - 70
+        if self.g28_ext_temp > 180.0:
+            self.g28_ext_temp = 180.0
+        try:
+            self.prtouch = self.printer.lookup_object('prtouch_v2')
+        except:
+            self.prtouch = self.printer.lookup_object('prtouch')
+            gcmd.respond_info("self.prtouch = prtouch")
+        self.prtouch.change_hot_min_temp(self.g28_ext_temp)
+        self.bed_temp = gcmd.get_float('BED_TEMP', default=self.default_bed_temp, minval=0.0, maxval=130.0)
+        self.leveling_calibration = gcmd.get_int('LEVELING_CALIBRATION', default=1, minval=0, maxval=1)
+        self.gcode.run_script_from_command('M104 S%d' % (self.g28_ext_temp))
+        self.gcode.run_script_from_command('M140 S%d' % (self.bed_temp))
+        self.gcode.run_script_from_command('M204 S500')
+        self.gcode.run_script_from_command('G28')
+        # self.gcode.run_script_from_command('NOZZLE_CLEAR HOT_MIN_TEMP=%d HOT_MAX_TEMP=%d BED_MAX_TEMP=%d' % (self.g28_ext_temp, self.extruder_temp - 20, self.bed_temp))
+        pass
+
+    cmd_CX_NOZZLE_CLEAR_help = "nozzle clear with temperature"
+    def cmd_CX_NOZZLE_CLEAR(self, gcmd):
+        self.gcode.run_script_from_command('NOZZLE_CLEAR HOT_MIN_TEMP=%d HOT_MAX_TEMP=%d BED_MAX_TEMP=%d' % (self.g28_ext_temp, self.extruder_temp - 20, self.bed_temp))
+        pass
+
+def load_config(config):
+    return CUSTOM_MACRO(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/dac084S085.py crealityShit/klippy/extras/dac084S085.py
--- klipperStock/klippy/extras/dac084S085.py	2024-01-14 23:01:59.469788348 -0600
+++ crealityShit/klippy/extras/dac084S085.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,25 +0,0 @@
-# SPI DAC DAC084S085 implementation
-#
-# Copyright (C) 2021  Lorenzo Franco <lorenzo.franco@lorenzing.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-from . import bus
-
-class dac084S085:
-    def __init__(self, config):
-        self.spi = bus.MCU_SPI_from_config(
-            config, 1, pin_option="enable_pin", default_speed=10000000)
-        scale = config.getfloat('scale', 1., above=0.)
-        for chan, name in enumerate("ABCD"):
-            val = config.getfloat('channel_%s' % (name,), None,
-                                   minval=0., maxval=scale)
-            if val is not None:
-                self.set_register(chan, int(val * 255. / scale))
-    def set_register(self, chan, value):
-        b1 = (chan << 6) | (1 << 4) | ((value >> 4) & 0x0f)
-        b2 = (value << 4) & 0xf0
-        self.spi.spi_send([b1, b2])
-
-def load_config_prefix(config):
-    return dac084S085(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/dirzctl.py crealityShit/klippy/extras/dirzctl.py
--- klipperStock/klippy/extras/dirzctl.py	1969-12-31 18:00:00.000000000 -0600
+++ crealityShit/klippy/extras/dirzctl.py	2024-01-14 23:02:21.706060905 -0600
@@ -0,0 +1,111 @@
+# Support for button detection and callbacks
+#
+# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import mcu
+import time
+
+class DirZCtl:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.toolhead = None
+        self.mcu = mcu.get_printer_mcu(self.printer, config.get('use_mcu'))
+        self.oid = self.mcu.create_oid()
+        self.steppers = []
+        self.mcu.register_config_callback(self._build_config)
+        self.mcu.register_response(self._handle_debug_dirzctl, "debug_dirzctl", self.oid)
+        self.mcu.register_response(self._handle_result_dirzctl, "result_dirzctl", self.oid)
+        self.printer.register_event_handler('klippy:mcu_identify', self._handle_mcu_identify)
+        self.printer.register_event_handler("klippy:shutdown", self._handle_shutdown)
+        self.printer.register_event_handler("klippy:disconnect", self._handle_disconnect)
+        self.gcode = self.printer.lookup_object("gcode")
+        self.gcode.register_command('DIRZCTL', self.cmd_DIRZCTL, desc=self.cmd_DIRZCTL_help)
+        self.all_params = []
+        self.hx711s = None
+        self.mcu_freq = 72000000
+        self.step_base = config.getfloat('step_base', default=2, minval=1, maxval=6)
+        self.last_send_heart = 0.
+        self.is_shutdown = True
+        self.is_timeout = True
+        pass
+
+    def _handle_mcu_identify(self):
+        self.hx711s = self.printer.lookup_object('hx711s')
+        self.steppers = []
+        self.toolhead = self.printer.lookup_object('toolhead')
+        for stepper in self.toolhead.get_kinematics().get_steppers():
+            if stepper.is_active_axis('z'):
+                self.steppers.append(stepper)
+        self.mcu_freq = self.mcu.get_constant_float('CLOCK_FREQ')   
+
+        # self.send_heart_beat_cmd = self.mcu.lookup_query_command(
+        # "heart_beat_dirzctl oid=%c",
+        # "heart_beat_dirzctl_result oid=%c",
+        # oid=self.oid, cq=None)
+
+        self.is_shutdown = False
+        self.is_timeout = False
+        pass
+
+    def _build_config(self):
+        self.mcu.add_config_cmd("config_dirzctl oid=%d z_count=%d" % (self.oid, len(self.steppers)))
+        for i in range(len(self.steppers)):
+            dir_pin, step_pin, ivt_dir, ivt_step = self.steppers[i].get_pin_info()
+            self.mcu.add_config_cmd("add_dirzctl oid=%d index=%d dir_pin=%s step_pin=%s dir_invert=%d step_invert=%d" % (self.oid, i, dir_pin, step_pin, ivt_dir, ivt_step))
+
+        # self.run_cmd = self.mcu.lookup_command("run_dirzctl oid=%c direct=%c step_us=%u step_cnt=%u is_ck_con=%c", cq=None)
+        self.run_cmd = self.mcu.lookup_command("run_dirzctl oid=%c direct=%c step_us=%u step_cnt=%u", cq=None)
+        pass
+
+    def _handle_shutdown(self):
+        self.is_shutdown = True
+        pass
+    
+    def _handle_disconnect(self):
+        self.is_timeout = True
+        pass
+
+    def _handle_debug_dirzctl(self, params):
+        self.printer.lookup_object('prtouch').pnt_msg(str(params))
+        pass
+
+    def _handle_result_dirzctl(self, params):
+        self.all_params.append(params)
+        # self.printer.lookup_object('prtouch').pnt_msg(str(params))
+        pass
+
+    def get_params(self):
+        return self.all_params, (self.all_params[0]['tick'] if len(self.all_params) > 0 else 0)
+
+    def check_and_run(self, direct, step_us, step_cnt, wait_finish=True, is_ck_con=False):
+        if self.is_shutdown or self.is_timeout:
+            pass
+        if step_cnt != 0:
+            self.all_params = []
+        # self.run_cmd.send([self.oid, direct, step_us, step_cnt, 1 if is_ck_con else 0])
+        self.run_cmd.send([self.oid, direct, step_us, step_cnt])
+        t_start = time.time()
+        while not (self.is_shutdown or self.is_timeout) and wait_finish and ((time.time() - t_start) < (1.5 * 1000 * 1000 * step_us * step_cnt)) and len(self.all_params) != 2:
+            self.hx711s.delay_s(0.05)
+        pass
+
+    def send_heart_beat(self):
+        #if time.time() - self.last_send_heart > 0.1:
+        #    self.send_heart_beat_cmd.send([self.oid])
+        #    self.last_send_heart = time.time()
+        pass
+
+    cmd_DIRZCTL_help = "Test DIRZCTL."
+    # DIRZCTL DIRECT=1 STEP_US=1500 STEP_CNT=100
+    def cmd_DIRZCTL(self, gcmd):
+        index = gcmd.get_int('INDEX', len(self.steppers), minval=0, maxval=len(self.steppers))
+        direct = gcmd.get_int('DIRECT', 1, minval=0, maxval=1)
+        step_us = gcmd.get_int('STEP_US', 1500, minval=4, maxval=100000)
+        step_cnt = gcmd.get_int('STEP_CNT', 256, minval=0, maxval=10000)
+        self.check_and_run(direct, step_us, step_cnt, False, False)
+        pass
+
+
+def load_config(config):
+    return DirZCtl(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/display/display.cfg crealityShit/klippy/extras/display/display.cfg
--- klipperStock/klippy/extras/display/display.cfg	2024-01-14 23:01:59.465788301 -0600
+++ crealityShit/klippy/extras/display/display.cfg	1969-12-31 18:00:00.000000000 -0600
@@ -1,461 +0,0 @@
-# This file defines the default layout of the printer's lcd display.
-
-# It is not necessary to edit this file to change the display.
-# Instead, one may override any of the sections defined here by
-# defining a section with the same name in the main printer.cfg config
-# file.
-
-
-######################################################################
-# Helper macros for showing common screen values
-######################################################################
-
-[display_template _heater_temperature]
-param_heater_name: "extruder"
-text:
-  {% if param_heater_name in printer %}
-    {% set heater = printer[param_heater_name] %}
-    # Show glyph
-    {% if param_heater_name == "heater_bed" %}
-      {% if heater.target %}
-        {% set frame = (printer.toolhead.estimated_print_time|int % 2) + 1 %}
-        ~bed_heat{frame}~
-      {% else %}
-        ~bed~
-      {% endif %}
-    {% else %}
-      ~extruder~
-    {% endif %}
-    # Show temperature
-    { "%3.0f" % (heater.temperature,) }
-    # Optionally show target
-    {% if heater.target and (heater.temperature - heater.target)|abs > 2 %}
-      ~right_arrow~
-      { "%0.0f" % (heater.target,) }
-    {% endif %}
-    ~degrees~
-  {% endif %}
-
-[display_template _fan_speed]
-text:
-  {% if 'fan' in printer %}
-    {% set speed = printer.fan.speed %}
-    {% if speed %}
-      {% set frame = (printer.toolhead.estimated_print_time|int % 2) + 1 %}
-      ~fan{frame}~
-    {% else %}
-      ~fan1~
-    {% endif %}
-    { "{:>4.0%}".format(speed) }
-  {% endif %}
-
-[display_template _printing_time]
-text:
-  {% set ptime = printer.idle_timeout.printing_time %}
-  { "%02d:%02d" % (ptime // (60 * 60), (ptime // 60) % 60) }
-
-[display_template _print_status]
-text:
-  {% if printer.display_status.message %}
-    { printer.display_status.message }
-  {% elif printer.idle_timeout.printing_time %}
-    {% set pos = printer.toolhead.position %}
-    { "X%-4.0fY%-4.0fZ%-5.2f" % (pos.x, pos.y, pos.z) }
-  {% else %}
-    Ready
-  {% endif %}
-
-
-######################################################################
-# Default 16x4 display
-######################################################################
-
-[display_data _default_16x4 extruder]
-position: 0, 0
-text:
-  {% set active_extruder = printer.toolhead.extruder %}
-  { render("_heater_temperature", param_heater_name=active_extruder) }
-
-[display_data _default_16x4 fan]
-position: 0, 10
-text: { render("_fan_speed") }
-
-[display_data _default_16x4 heater_bed]
-position: 1, 0
-text: { render("_heater_temperature", param_heater_name="heater_bed") }
-
-[display_data _default_16x4 speed_factor]
-position: 1, 10
-text:
-  ~feedrate~
-  { "{:>4.0%}".format(printer.gcode_move.speed_factor) }
-
-[display_data _default_16x4 print_progress]
-position: 2, 0
-text: { "{:^10.0%}".format(printer.display_status.progress) }
-[display_data _default_16x4 progress_bar]
-position: 2, 1 # Draw graphical progress bar after text is written
-text: { draw_progress_bar(2, 0, 10, printer.display_status.progress) }
-
-[display_data _default_16x4 printing_time]
-position: 2, 10
-text: { "%6s" % (render("_printing_time").strip(),) }
-
-[display_data _default_16x4 print_status]
-position: 3, 0
-text: { render("_print_status") }
-
-
-######################################################################
-# Alternative 16x4 layout for multi-extruders
-######################################################################
-
-[display_data _multiextruder_16x4 extruder]
-position: 0, 0
-text: { render("_heater_temperature", param_heater_name="extruder") }
-
-[display_data _multiextruder_16x4 fan]
-position: 0, 10
-text: { render("_fan_speed") }
-
-[display_data _multiextruder_16x4 extruder1]
-position: 1, 0
-text: { render("_heater_temperature", param_heater_name="extruder1") }
-
-[display_data _multiextruder_16x4 print_progress]
-position: 1, 10
-text: { "{:^6.0%}".format(printer.display_status.progress) }
-[display_data _multiextruder_16x4 progress_bar]
-position: 1, 11 # Draw graphical progress bar after text is written
-text: { draw_progress_bar(1, 10, 6, printer.display_status.progress) }
-
-[display_data _multiextruder_16x4 heater_bed]
-position: 2, 0
-text: { render("_heater_temperature", param_heater_name="heater_bed") }
-
-[display_data _multiextruder_16x4 printing_time]
-position: 2, 10
-text: { "%6s" % (render("_printing_time").strip(),) }
-
-[display_data _multiextruder_16x4 print_status]
-position: 3, 0
-text: { render("_print_status") }
-
-
-######################################################################
-# Default 20x4 display
-######################################################################
-
-[display_data _default_20x4 extruder]
-position: 0, 0
-text: { render("_heater_temperature", param_heater_name="extruder") }
-
-[display_data _default_20x4 heater_bed]
-position: 0, 10
-text: { render("_heater_temperature", param_heater_name="heater_bed") }
-
-[display_data _default_20x4 extruder1]
-position: 1, 0
-text: { render("_heater_temperature", param_heater_name="extruder1") }
-
-[display_data _default_20x4 fan]
-position: 1, 10
-text:
-  {% if 'fan' in printer %}
-    { "Fan {:^4.0%}".format(printer.fan.speed) }
-  {% endif %}
-
-[display_data _default_20x4 speed_factor]
-position: 2, 0
-text:
-  ~feedrate~
-  { "{:^4.0%}".format(printer.gcode_move.speed_factor) }
-
-[display_data _default_20x4 print_progress]
-position: 2, 8
-text:
-  {% if 'virtual_sdcard' in printer and printer.virtual_sdcard.progress %}
-    ~sd~
-  {% else %}
-    ~usb~
-  {% endif %}
-  { "{:^4.0%}".format(printer.display_status.progress) }
-
-[display_data _default_20x4 printing_time]
-position: 2, 14
-text:
-  ~clock~
-  { render("_printing_time") }
-
-[display_data _default_20x4 print_status]
-position: 3, 0
-text: { render("_print_status") }
-
-
-######################################################################
-# Default 16x4 glyphs
-######################################################################
-
-[display_glyph extruder]
-data:
-  ................
-  ................
-  ..************..
-  .....******.....
-  ..************..
-  .....******.....
-  ..************..
-  ................
-  ....********....
-  ....******.*....
-  ....********....
-  ................
-  ......****......
-  .......**.......
-  ................
-  ................
-
-[display_glyph bed]
-data:
-  ................
-  ................
-  ................
-  ................
-  ................
-  ................
-  ................
-  ................
-  ................
-  ................
-  ................
-  ...*********....
-  ..*.........*...
-  .*************..
-  ................
-  ................
-
-[display_glyph bed_heat1]
-data:
-  ................
-  ................
-  ..*....*....*...
-  .*....*....*....
-  ..*....*....*...
-  ...*....*....*..
-  ..*....*....*...
-  .*....*....*....
-  ..*....*....*...
-  ................
-  ................
-  ...*********....
-  ..*.........*...
-  .*************..
-  ................
-  ................
-
-[display_glyph bed_heat2]
-data:
-  ................
-  ................
-  ..*....*....*...
-  ...*....*....*..
-  ..*....*....*...
-  .*....*....*....
-  ..*....*....*...
-  ...*....*....*..
-  ..*....*....*...
-  ................
-  ................
-  ...*********....
-  ..*.........*...
-  .*************..
-  ................
-  ................
-
-[display_glyph fan1]
-data:
-  ................
-  ................
-  ....***.........
-  ...****....**...
-  ...****...****..
-  ....***..*****..
-  .....*....****..
-  .......**.......
-  .......**.......
-  ..****....*.....
-  ..*****..***....
-  ..****...****...
-  ...**....****...
-  .........***....
-  ................
-  ................
-
-[display_glyph fan2]
-data:
-  ................
-  ................
-  .......****.....
-  .......****.....
-  .......***......
-  ..**...**.......
-  ..***...........
-  ..****.**.****..
-  ..****.**.****..
-  ...........***..
-  .......**...**..
-  ......***.......
-  .....****.......
-  .....****.......
-  ................
-  ................
-
-[display_glyph feedrate]
-data:
-  ................
-  ................
-  ***.***.***.**..
-  *...*...*...*.*.
-  **..**..**..*.*.
-  *...*...*...*.*.
-  *...***.***.**..
-  ................
-  **...*..***.***.
-  *.*.*.*..*..*...
-  **..***..*..**..
-  *.*.*.*..*..*...
-  *.*.*.*..*..***.
-  ................
-  ................
-  ................
-
-# In addition to the above glyphs, 16x4 displays also have the
-# following hard-coded single character glyphs: right_arrow, degrees.
-
-
-######################################################################
-# Default 20x4 glyphs
-######################################################################
-
-[display_glyph extruder]
-hd44780_slot: 0
-hd44780_data:
-  ..*..
-  .*.*.
-  .*.*.
-  .*.*.
-  .*.*.
-  *...*
-  *...*
-  .***.
-
-[display_glyph bed]
-hd44780_slot: 1
-hd44780_data:
-  .....
-  *****
-  *.*.*
-  *...*
-  *.*.*
-  *****
-  .....
-  .....
-
-[display_glyph bed_heat1]
-hd44780_slot: 1
-hd44780_data:
-  .*..*
-  *..*.
-  .*..*
-  *..*.
-  .....
-  *****
-  .....
-  .....
-
-[display_glyph bed_heat2]
-hd44780_slot: 1
-hd44780_data:
-  *..*.
-  .*..*
-  *..*.
-  .*..*
-  .....
-  *****
-  .....
-  .....
-
-[display_glyph fan]
-hd44780_slot: 2
-hd44780_data:
-  .....
-  *..**
-  **.*.
-  ..*..
-  .*.**
-  **..*
-  .....
-  .....
-
-[display_glyph feedrate]
-hd44780_slot: 3
-hd44780_data:
-  ***..
-  *....
-  **...
-  *.***
-  ..*.*
-  ..**.
-  ..*.*
-  .....
-
-[display_glyph clock]
-hd44780_slot: 4
-hd44780_data:
-  .....
-  .***.
-  *..**
-  *.*.*
-  *...*
-  .***.
-  .....
-  .....
-
-[display_glyph degrees]
-hd44780_slot: 5
-hd44780_data:
-  .**..
-  *..*.
-  *..*.
-  .**..
-  .....
-  .....
-  .....
-  .....
-
-[display_glyph usb]
-hd44780_slot: 6
-hd44780_data:
-  .***.
-  .***.
-  .***.
-  *****
-  *****
-  *****
-  ..*..
-  ..*..
-
-[display_glyph sd]
-hd44780_slot: 6
-hd44780_data:
-  .....
-  ..***
-  .****
-  *****
-  *****
-  *****
-  *****
-  .....
-
-# In addition to the above glyphs, 20x4 displays also have the
-# following hard-coded glyphs: right_arrow.
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/display/display.py crealityShit/klippy/extras/display/display.py
--- klipperStock/klippy/extras/display/display.py	2024-01-14 23:01:59.461788252 -0600
+++ crealityShit/klippy/extras/display/display.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,271 +0,0 @@
-# Basic LCD display support
-#
-# Copyright (C) 2018-2022  Kevin O'Connor <kevin@koconnor.net>
-# Copyright (C) 2018  Aleph Objects, Inc <marcio@alephobjects.com>
-# Copyright (C) 2018  Eric Callahan <arksine.code@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging, os, ast
-from . import hd44780, hd44780_spi, st7920, uc1701, menu
-
-# Normal time between each screen redraw
-REDRAW_TIME = 0.500
-# Minimum time between screen redraws
-REDRAW_MIN_TIME = 0.100
-
-LCD_chips = {
-    'st7920': st7920.ST7920, 'emulated_st7920': st7920.EmulatedST7920,
-    'hd44780': hd44780.HD44780, 'uc1701': uc1701.UC1701,
-    'ssd1306': uc1701.SSD1306, 'sh1106': uc1701.SH1106,
-    'hd44780_spi': hd44780_spi.hd44780_spi
-}
-
-# Storage of [display_template my_template] config sections
-class DisplayTemplate:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        name_parts = config.get_name().split()
-        if len(name_parts) != 2:
-            raise config.error("Section name '%s' is not valid"
-                               % (config.get_name(),))
-        self.name = name_parts[1]
-        self.params = {}
-        for option in config.get_prefix_options('param_'):
-            try:
-                self.params[option] = ast.literal_eval(config.get(option))
-            except ValueError as e:
-                raise config.error(
-                    "Option '%s' in section '%s' is not a valid literal" % (
-                        option, config.get_name()))
-        gcode_macro = self.printer.load_object(config, 'gcode_macro')
-        self.template = gcode_macro.load_template(config, 'text')
-    def get_params(self):
-        return self.params
-    def render(self, context, **kwargs):
-        params = dict(self.params)
-        params.update(**kwargs)
-        if len(params) != len(self.params):
-            raise self.printer.command_error(
-                "Invalid parameter to display_template %s" % (self.name,))
-        context = dict(context)
-        context.update(params)
-        return self.template.render(context)
-
-# Store [display_data my_group my_item] sections (one instance per group name)
-class DisplayGroup:
-    def __init__(self, config, name, data_configs):
-        # Load and parse the position of display_data items
-        items = []
-        for c in data_configs:
-            pos = c.get('position')
-            try:
-                row, col = [int(v.strip()) for v in pos.split(',')]
-            except:
-                raise config.error("Unable to parse 'position' in section '%s'"
-                                   % (c.get_name(),))
-            items.append((row, col, c.get_name()))
-        # Load all templates and store sorted by display position
-        configs_by_name = {c.get_name(): c for c in data_configs}
-        printer = config.get_printer()
-        gcode_macro = printer.load_object(config, 'gcode_macro')
-        self.data_items = []
-        for row, col, name in sorted(items):
-            c = configs_by_name[name]
-            if c.get('text'):
-                template = gcode_macro.load_template(c, 'text')
-                self.data_items.append((row, col, template))
-    def show(self, display, templates, eventtime):
-        context = self.data_items[0][2].create_template_context(eventtime)
-        context['draw_progress_bar'] = display.draw_progress_bar
-        def render(name, **kwargs):
-            return templates[name].render(context, **kwargs)
-        context['render'] = render
-        for row, col, template in self.data_items:
-            text = template.render(context)
-            display.draw_text(row, col, text.replace('\n', ''), eventtime)
-        context.clear() # Remove circular references for better gc
-
-# Global cache of DisplayTemplate, DisplayGroup, and glyphs
-class PrinterDisplayTemplate:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.display_templates = {}
-        self.display_data_groups = {}
-        self.display_glyphs = {}
-        self.load_config(config)
-    def get_display_templates(self):
-        return self.display_templates
-    def get_display_data_groups(self):
-        return self.display_data_groups
-    def get_display_glyphs(self):
-        return self.display_glyphs
-    def _parse_glyph(self, config, glyph_name, data, width, height):
-        glyph_data = []
-        for line in data.split('\n'):
-            line = line.strip().replace('.', '0').replace('*', '1')
-            if not line:
-                continue
-            if len(line) != width or line.replace('0', '').replace('1', ''):
-                raise config.error("Invalid glyph line in %s" % (glyph_name,))
-            glyph_data.append(int(line, 2))
-        if len(glyph_data) != height:
-            raise config.error("Glyph %s incorrect lines" % (glyph_name,))
-        return glyph_data
-    def load_config(self, config):
-        # Load default display config file
-        pconfig = self.printer.lookup_object('configfile')
-        filename = os.path.join(os.path.dirname(__file__), 'display.cfg')
-        try:
-            dconfig = pconfig.read_config(filename)
-        except Exception:
-            raise self.printer.config_error("Cannot load config '%s'"
-                                            % (filename,))
-        # Load display_template sections
-        dt_main = config.get_prefix_sections('display_template ')
-        dt_main_names = { c.get_name(): 1 for c in dt_main }
-        dt_def = [c for c in dconfig.get_prefix_sections('display_template ')
-                  if c.get_name() not in dt_main_names]
-        for c in dt_main + dt_def:
-            dt = DisplayTemplate(c)
-            self.display_templates[dt.name] = dt
-        # Load display_data sections
-        dd_main = config.get_prefix_sections('display_data ')
-        dd_main_names = { c.get_name(): 1 for c in dd_main }
-        dd_def = [c for c in dconfig.get_prefix_sections('display_data ')
-                  if c.get_name() not in dd_main_names]
-        groups = {}
-        for c in dd_main + dd_def:
-            name_parts = c.get_name().split()
-            if len(name_parts) != 3:
-                raise config.error("Section name '%s' is not valid"
-                                   % (c.get_name(),))
-            groups.setdefault(name_parts[1], []).append(c)
-        for group_name, data_configs in groups.items():
-            dg = DisplayGroup(config, group_name, data_configs)
-            self.display_data_groups[group_name] = dg
-        # Load display glyphs
-        dg_prefix = 'display_glyph '
-        self.display_glyphs = icons = {}
-        dg_main = config.get_prefix_sections(dg_prefix)
-        dg_main_names = {c.get_name(): 1 for c in dg_main}
-        dg_def = [c for c in dconfig.get_prefix_sections(dg_prefix)
-                  if c.get_name() not in dg_main_names]
-        for dg in dg_main + dg_def:
-            glyph_name = dg.get_name()[len(dg_prefix):]
-            data = dg.get('data', None)
-            if data is not None:
-                idata = self._parse_glyph(config, glyph_name, data, 16, 16)
-                icon1 = [(bits >> 8) & 0xff for bits in idata]
-                icon2 = [bits & 0xff for bits in idata]
-                icons.setdefault(glyph_name, {})['icon16x16'] = (icon1, icon2)
-            data = dg.get('hd44780_data', None)
-            if data is not None:
-                slot = dg.getint('hd44780_slot', minval=0, maxval=7)
-                idata = self._parse_glyph(config, glyph_name, data, 5, 8)
-                icons.setdefault(glyph_name, {})['icon5x8'] = (slot, idata)
-
-def lookup_display_templates(config):
-    printer = config.get_printer()
-    dt = printer.lookup_object("display_template", None)
-    if dt is None:
-        dt = PrinterDisplayTemplate(config)
-        printer.add_object("display_template", dt)
-    return dt
-
-class PrinterLCD:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.reactor = self.printer.get_reactor()
-        # Load low-level lcd handler
-        self.lcd_chip = config.getchoice('lcd_type', LCD_chips)(config)
-        # Load menu and display_status
-        self.menu = None
-        name = config.get_name()
-        if name == 'display':
-            # only load menu for primary display
-            self.menu = menu.MenuManager(config, self)
-        self.printer.load_object(config, "display_status")
-        # Configurable display
-        templates = lookup_display_templates(config)
-        self.display_templates = templates.get_display_templates()
-        self.display_data_groups = templates.get_display_data_groups()
-        self.lcd_chip.set_glyphs(templates.get_display_glyphs())
-        dgroup = "_default_16x4"
-        if self.lcd_chip.get_dimensions()[0] == 20:
-            dgroup = "_default_20x4"
-        dgroup = config.get('display_group', dgroup)
-        self.show_data_group = self.display_data_groups.get(dgroup)
-        if self.show_data_group is None:
-            raise config.error("Unknown display_data group '%s'" % (dgroup,))
-        # Screen updating
-        self.printer.register_event_handler("klippy:ready", self.handle_ready)
-        self.screen_update_timer = self.reactor.register_timer(
-            self.screen_update_event)
-        self.redraw_request_pending = False
-        self.redraw_time = 0.
-        # Register g-code commands
-        gcode = self.printer.lookup_object("gcode")
-        gcode.register_mux_command('SET_DISPLAY_GROUP', 'DISPLAY', name,
-                                   self.cmd_SET_DISPLAY_GROUP,
-                                   desc=self.cmd_SET_DISPLAY_GROUP_help)
-        if name == 'display':
-            gcode.register_mux_command('SET_DISPLAY_GROUP', 'DISPLAY', None,
-                                       self.cmd_SET_DISPLAY_GROUP)
-    def get_dimensions(self):
-        return self.lcd_chip.get_dimensions()
-    def handle_ready(self):
-        self.lcd_chip.init()
-        # Start screen update timer
-        self.reactor.update_timer(self.screen_update_timer, self.reactor.NOW)
-    # Screen updating
-    def screen_update_event(self, eventtime):
-        if self.redraw_request_pending:
-            self.redraw_request_pending = False
-            self.redraw_time = eventtime + REDRAW_MIN_TIME
-        self.lcd_chip.clear()
-        # update menu component
-        if self.menu is not None:
-            ret = self.menu.screen_update_event(eventtime)
-            if ret:
-                self.lcd_chip.flush()
-                return eventtime + REDRAW_TIME
-        # Update normal display
-        try:
-            self.show_data_group.show(self, self.display_templates, eventtime)
-        except:
-            logging.exception("Error during display screen update")
-        self.lcd_chip.flush()
-        return eventtime + REDRAW_TIME
-    def request_redraw(self):
-        if self.redraw_request_pending:
-            return
-        self.redraw_request_pending = True
-        self.reactor.update_timer(self.screen_update_timer, self.redraw_time)
-    def draw_text(self, row, col, mixed_text, eventtime):
-        pos = col
-        for i, text in enumerate(mixed_text.split('~')):
-            if i & 1 == 0:
-                # write text
-                self.lcd_chip.write_text(pos, row, text.encode())
-                pos += len(text)
-            else:
-                # write glyph
-                pos += self.lcd_chip.write_glyph(pos, row, text)
-        return pos
-    def draw_progress_bar(self, row, col, width, value):
-        pixels = -1 << int(width * 8 * (1. - value) + .5)
-        pixels |= (1 << (width * 8 - 1)) | 1
-        for i in range(width):
-            data = [0xff] + [(pixels >> (i * 8)) & 0xff] * 14 + [0xff]
-            self.lcd_chip.write_graphics(col + width - 1 - i, row, data)
-        return ""
-    cmd_SET_DISPLAY_GROUP_help = "Set the active display group"
-    def cmd_SET_DISPLAY_GROUP(self, gcmd):
-        group = gcmd.get('GROUP')
-        new_dg = self.display_data_groups.get(group)
-        if new_dg is None:
-            raise gcmd.error("Unknown display_data group '%s'" % (group,))
-        self.show_data_group = new_dg
-
-def load_config(config):
-    return PrinterLCD(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/display/font8x14.py crealityShit/klippy/extras/display/font8x14.py
--- klipperStock/klippy/extras/display/font8x14.py	2024-01-14 23:01:59.461788252 -0600
+++ crealityShit/klippy/extras/display/font8x14.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,276 +0,0 @@
-# Fonts for connected displays
-#
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-# Copyright (C) 2018  Eric Callahan  <arksine.code@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-
-######################################################################
-# Font - VGA 8x14, Row Major, MSB, 2 bytes padding
-#
-# Font comes from fntcol16.zip package found at:
-# ftp://ftp.simtel.net/pub/simtelnet/msdos/screen/fntcol16.zip
-# (c) Joseph Gil
-#
-# Indivdual fonts are public domain
-######################################################################
-
-VGA_FONT = [
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7e\x81\xa5\x81\x81\xbd\x99\x81\x7e\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7e\xff\xdb\xff\xff\xc3\xe7\xff\x7e\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x6c\xfe\xfe\xfe\xfe\x7c\x38\x10\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x10\x38\x7c\xfe\x7c\x38\x10\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x3c\x3c\xe7\xe7\xe7\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x3c\x7e\xff\xff\x7e\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x18\x3c\x3c\x18\x00\x00\x00\x00\x00\x00',
-    b'\x00\xff\xff\xff\xff\xff\xe7\xc3\xc3\xe7\xff\xff\xff\xff\xff\x00',
-    b'\x00\x00\x00\x00\x00\x3c\x66\x42\x42\x66\x3c\x00\x00\x00\x00\x00',
-    b'\x00\xff\xff\xff\xff\xc3\x99\xbd\xbd\x99\xc3\xff\xff\xff\xff\x00',
-    b'\x00\x00\x00\x1e\x0e\x1a\x32\x78\xcc\xcc\xcc\x78\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3c\x66\x66\x66\x3c\x18\x7e\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3f\x33\x3f\x30\x30\x30\x70\xf0\xe0\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7f\x63\x7f\x63\x63\x63\x67\xe7\xe6\xc0\x00\x00\x00',
-    b'\x00\x00\x00\x18\x18\xdb\x3c\xe7\x3c\xdb\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x80\xc0\xe0\xf8\xfe\xf8\xe0\xc0\x80\x00\x00\x00\x00',
-    b'\x00\x00\x00\x02\x06\x0e\x3e\xfe\x3e\x0e\x06\x02\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x3c\x7e\x18\x18\x18\x7e\x3c\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x66\x66\x66\x66\x66\x66\x00\x66\x66\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7f\xdb\xdb\xdb\x7b\x1b\x1b\x1b\x1b\x00\x00\x00\x00',
-    b'\x00\x00\x7c\xc6\x60\x38\x6c\xc6\xc6\x6c\x38\x0c\xc6\x7c\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfe\xfe\xfe\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x3c\x7e\x18\x18\x18\x7e\x3c\x18\x7e\x00\x00\x00',
-    b'\x00\x00\x00\x18\x3c\x7e\x18\x18\x18\x18\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x18\x18\x18\x18\x18\x7e\x3c\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x18\x0c\xfe\x0c\x18\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x30\x60\xfe\x60\x30\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xc0\xc0\xc0\xfe\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x28\x6c\xfe\x6c\x28\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x10\x38\x38\x7c\x7c\xfe\xfe\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\xfe\xfe\x7c\x7c\x38\x38\x10\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x3c\x3c\x3c\x18\x18\x00\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x66\x66\x66\x24\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x6c\x6c\xfe\x6c\x6c\x6c\xfe\x6c\x6c\x00\x00\x00\x00',
-    b'\x00\x18\x18\x7c\xc6\xc2\xc0\x7c\x06\x86\xc6\x7c\x18\x18\x00\x00',
-    b'\x00\x00\x00\x00\x00\xc2\xc6\x0c\x18\x30\x66\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x38\x6c\x6c\x38\x76\xdc\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x30\x30\x30\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x0c\x18\x30\x30\x30\x30\x30\x18\x0c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x30\x18\x0c\x0c\x0c\x0c\x0c\x18\x30\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x66\x3c\xff\x3c\x66\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x18\x18\x7e\x18\x18\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x18\x18\x30\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\xfe\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x02\x06\x0c\x18\x30\x60\xc0\x80\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\xce\xde\xf6\xe6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x38\x78\x18\x18\x18\x18\x18\x7e\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\x06\x0c\x18\x30\x60\xc6\xfe\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\x06\x06\x3c\x06\x06\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x0c\x1c\x3c\x6c\xcc\xfe\x0c\x0c\x1e\x00\x00\x00\x00',
-    b'\x00\x00\x00\xfe\xc0\xc0\xc0\xfc\x06\x06\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x38\x60\xc0\xc0\xfc\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xfe\xc6\x06\x0c\x18\x30\x30\x30\x30\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\xc6\xc6\x7c\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\xc6\xc6\x7e\x06\x06\x0c\x78\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x18\x18\x00\x00\x00\x18\x18\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x18\x18\x00\x00\x00\x18\x18\x30\x00\x00\x00\x00',
-    b'\x00\x00\x00\x06\x0c\x18\x30\x60\x30\x18\x0c\x06\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x7e\x00\x00\x7e\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x60\x30\x18\x0c\x06\x0c\x18\x30\x60\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\xc6\x0c\x18\x18\x00\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\xc6\xde\xde\xde\xdc\xc0\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x10\x38\x6c\xc6\xc6\xfe\xc6\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\xfc\x66\x66\x66\x7c\x66\x66\x66\xfc\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3c\x66\xc2\xc0\xc0\xc0\xc2\x66\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xf8\x6c\x66\x66\x66\x66\x66\x6c\xf8\x00\x00\x00\x00',
-    b'\x00\x00\x00\xfe\x66\x62\x68\x78\x68\x62\x66\xfe\x00\x00\x00\x00',
-    b'\x00\x00\x00\xfe\x66\x62\x68\x78\x68\x60\x60\xf0\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3c\x66\xc2\xc0\xc0\xde\xc6\x66\x3a\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xc6\xc6\xc6\xfe\xc6\xc6\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3c\x18\x18\x18\x18\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x1e\x0c\x0c\x0c\x0c\x0c\xcc\xcc\x78\x00\x00\x00\x00',
-    b'\x00\x00\x00\xe6\x66\x6c\x6c\x78\x6c\x6c\x66\xe6\x00\x00\x00\x00',
-    b'\x00\x00\x00\xf0\x60\x60\x60\x60\x60\x62\x66\xfe\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xee\xfe\xfe\xd6\xc6\xc6\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xe6\xf6\xfe\xde\xce\xc6\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x38\x6c\xc6\xc6\xc6\xc6\xc6\x6c\x38\x00\x00\x00\x00',
-    b'\x00\x00\x00\xfc\x66\x66\x66\x7c\x60\x60\x60\xf0\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\xc6\xc6\xc6\xd6\xde\x7c\x0c\x0e\x00\x00\x00',
-    b'\x00\x00\x00\xfc\x66\x66\x66\x7c\x6c\x66\x66\xe6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\xc6\x60\x38\x0c\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7e\x7e\x5a\x18\x18\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xc6\xc6\xc6\xc6\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xc6\xc6\xc6\xc6\xc6\x6c\x38\x10\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xc6\xc6\xc6\xd6\xd6\xfe\x7c\x6c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xc6\x6c\x38\x38\x38\x6c\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x66\x66\x66\x66\x3c\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xfe\xc6\x8c\x18\x30\x60\xc2\xc6\xfe\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3c\x30\x30\x30\x30\x30\x30\x30\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x80\xc0\xe0\x70\x38\x1c\x0e\x06\x02\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x3c\x00\x00\x00\x00',
-    b'\x00\x10\x38\x6c\xc6\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00',
-    b'\x00\x30\x30\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x78\x0c\x7c\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x00\xe0\x60\x60\x78\x6c\x66\x66\x66\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x7c\xc6\xc0\xc0\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x1c\x0c\x0c\x3c\x6c\xcc\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x7c\xc6\xfe\xc0\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x38\x6c\x64\x60\xf0\x60\x60\x60\xf0\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x76\xcc\xcc\xcc\x7c\x0c\xcc\x78\x00\x00',
-    b'\x00\x00\x00\xe0\x60\x60\x6c\x76\x66\x66\x66\xe6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x18\x00\x38\x18\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x06\x06\x00\x0e\x06\x06\x06\x06\x66\x66\x3c\x00\x00',
-    b'\x00\x00\x00\xe0\x60\x60\x66\x6c\x78\x6c\x66\xe6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x38\x18\x18\x18\x18\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xec\xfe\xd6\xd6\xd6\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xdc\x66\x66\x66\x66\x66\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x7c\xc6\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xdc\x66\x66\x66\x7c\x60\x60\xf0\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x76\xcc\xcc\xcc\x7c\x0c\x0c\x1e\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xdc\x76\x66\x60\x60\xf0\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x7c\xc6\x70\x1c\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x10\x30\x30\xfc\x30\x30\x30\x36\x1c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xcc\xcc\xcc\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x66\x66\x66\x66\x3c\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xc6\xc6\xd6\xd6\xfe\x6c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xc6\x6c\x38\x38\x6c\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xc6\xc6\xc6\xc6\x7e\x06\x0c\xf8\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xfe\xcc\x18\x30\x66\xfe\x00\x00\x00\x00',
-    b'\x00\x00\x00\x0e\x18\x18\x18\x70\x18\x18\x18\x0e\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x18\x18\x18\x00\x18\x18\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x70\x18\x18\x18\x0e\x18\x18\x18\x70\x00\x00\x00\x00',
-    b'\x00\x00\x00\x76\xdc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x10\x38\x6c\xc6\xc6\xfe\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3c\x66\xc2\xc0\xc0\xc2\x66\x3c\x0c\x06\x7c\x00\x00',
-    b'\x00\x00\x00\xcc\xcc\x00\xcc\xcc\xcc\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x0c\x18\x30\x00\x7c\xc6\xfe\xc0\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x10\x38\x6c\x00\x78\x0c\x7c\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x00\xcc\xcc\x00\x78\x0c\x7c\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x60\x30\x18\x00\x78\x0c\x7c\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x38\x6c\x38\x00\x78\x0c\x7c\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x3c\x66\x60\x66\x3c\x0c\x06\x3c\x00\x00\x00',
-    b'\x00\x00\x10\x38\x6c\x00\x7c\xc6\xfe\xc0\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xcc\xcc\x00\x7c\xc6\xfe\xc0\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x60\x30\x18\x00\x7c\xc6\xfe\xc0\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x66\x66\x00\x38\x18\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x18\x3c\x66\x00\x38\x18\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x60\x30\x18\x00\x38\x18\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\xc6\xc6\x10\x38\x6c\xc6\xc6\xfe\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x38\x6c\x38\x00\x38\x6c\xc6\xc6\xfe\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x18\x30\x60\x00\xfe\x66\x60\x7c\x60\x66\xfe\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\xcc\x76\x36\x7e\xd8\xd8\x6e\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3e\x6c\xcc\xcc\xfe\xcc\xcc\xcc\xce\x00\x00\x00\x00',
-    b'\x00\x00\x10\x38\x6c\x00\x7c\xc6\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xc6\x00\x7c\xc6\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x60\x30\x18\x00\x7c\xc6\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x30\x78\xcc\x00\xcc\xcc\xcc\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x60\x30\x18\x00\xcc\xcc\xcc\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xc6\x00\xc6\xc6\xc6\xc6\x7e\x06\x0c\x78\x00\x00',
-    b'\x00\x00\xc6\xc6\x38\x6c\xc6\xc6\xc6\xc6\x6c\x38\x00\x00\x00\x00',
-    b'\x00\x00\xc6\xc6\x00\xc6\xc6\xc6\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x18\x18\x3c\x66\x60\x60\x66\x3c\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x38\x6c\x64\x60\xf0\x60\x60\x60\xe6\xfc\x00\x00\x00\x00',
-    b'\x00\x00\x00\x66\x66\x3c\x18\x7e\x18\x7e\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\xf8\xcc\xcc\xf8\xc4\xcc\xde\xcc\xcc\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x0e\x1b\x18\x18\x18\x7e\x18\x18\x18\x18\xd8\x70\x00\x00',
-    b'\x00\x00\x18\x30\x60\x00\x78\x0c\x7c\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x0c\x18\x30\x00\x38\x18\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x18\x30\x60\x00\x7c\xc6\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x18\x30\x60\x00\xcc\xcc\xcc\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x00\x76\xdc\x00\xdc\x66\x66\x66\x66\x66\x00\x00\x00\x00',
-    b'\x00\x76\xdc\x00\xc6\xe6\xf6\xfe\xde\xce\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x3c\x6c\x6c\x3e\x00\x7e\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x38\x6c\x6c\x38\x00\x7c\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x30\x30\x00\x30\x30\x60\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\xfe\xc0\xc0\xc0\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\xfe\x06\x06\x06\x00\x00\x00\x00\x00',
-    b'\x00\x00\xc0\xc0\xc6\xcc\xd8\x30\x60\xdc\x86\x0c\x18\x3e\x00\x00',
-    b'\x00\x00\xc0\xc0\xc6\xcc\xd8\x30\x66\xce\x9e\x3e\x06\x06\x00\x00',
-    b'\x00\x00\x00\x18\x18\x00\x18\x18\x3c\x3c\x3c\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x36\x6c\xd8\x6c\x36\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\xd8\x6c\x36\x6c\xd8\x00\x00\x00\x00\x00\x00',
-    b'\x00\x11\x44\x11\x44\x11\x44\x11\x44\x11\x44\x11\x44\x11\x44\x00',
-    b'\x00\x55\xaa\x55\xaa\x55\xaa\x55\xaa\x55\xaa\x55\xaa\x55\xaa\x00',
-    b'\x00\xdd\x77\xdd\x77\xdd\x77\xdd\x77\xdd\x77\xdd\x77\xdd\x77\x00',
-    b'\x00\x18\x18\x18\x18\x18\x18\x18\x18\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x18\x18\x18\x18\x18\x18\x18\xf8\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x18\x18\x18\x18\x18\xf8\x18\xf8\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x36\x36\x36\x36\x36\x36\x36\xf6\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\xfe\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x00\x00\x00\x00\x00\xf8\x18\xf8\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x36\x36\x36\x36\x36\xf6\x06\xf6\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x36\x36\x36\x36\x36\x36\x36\x36\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x00\x00\x00\x00\x00\xfe\x06\xf6\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x36\x36\x36\x36\x36\xf6\x06\xfe\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x36\x36\x36\x36\x36\x36\x36\xfe\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x18\x18\x18\x18\x18\xf8\x18\xf8\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\xf8\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x18\x18\x18\x18\x18\x18\x18\x1f\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x18\x18\x18\x18\x18\x18\x18\xff\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\xff\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x18\x18\x18\x18\x18\x18\x18\x1f\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x18\x18\x18\x18\x18\x18\x18\xff\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x18\x18\x18\x18\x18\x1f\x18\x1f\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x36\x36\x36\x36\x36\x36\x36\x37\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x36\x36\x36\x36\x36\x37\x30\x3f\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x3f\x30\x37\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x36\x36\x36\x36\x36\xf7\x00\xff\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xff\x00\xf7\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x36\x36\x36\x36\x36\x37\x30\x37\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x00\x00\x00\x00\x00\xff\x00\xff\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x36\x36\x36\x36\x36\xf7\x00\xf7\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x18\x18\x18\x18\x18\xff\x00\xff\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x36\x36\x36\x36\x36\x36\x36\xff\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xff\x00\xff\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\xff\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x36\x36\x36\x36\x36\x36\x36\x3f\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x18\x18\x18\x18\x18\x1f\x18\x1f\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x1f\x18\x1f\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x3f\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x36\x36\x36\x36\x36\x36\x36\xff\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x18\x18\x18\x18\x18\xff\x18\xff\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x18\x18\x18\x18\x18\x18\x18\xf8\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x1f\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\x00',
-    b'\x00\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\x00',
-    b'\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x00',
-    b'\x00\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x76\xdc\xd8\xd8\xdc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x7c\xc6\xfc\xc6\xc6\xfc\xc0\xc0\x40\x00\x00',
-    b'\x00\x00\x00\xfe\xc6\xc6\xc0\xc0\xc0\xc0\xc0\xc0\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\xfe\x6c\x6c\x6c\x6c\x6c\x6c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xfe\xc6\x60\x30\x18\x30\x60\xc6\xfe\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x7e\xd8\xd8\xd8\xd8\x70\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x66\x66\x66\x66\x7c\x60\x60\xc0\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x76\xdc\x18\x18\x18\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7e\x18\x3c\x66\x66\x66\x3c\x18\x7e\x00\x00\x00\x00',
-    b'\x00\x00\x00\x38\x6c\xc6\xc6\xfe\xc6\xc6\x6c\x38\x00\x00\x00\x00',
-    b'\x00\x00\x00\x38\x6c\xc6\xc6\xc6\x6c\x6c\x6c\xee\x00\x00\x00\x00',
-    b'\x00\x00\x00\x1e\x30\x18\x0c\x3e\x66\x66\x66\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x7e\xdb\xdb\x7e\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x03\x06\x7e\xdb\xdb\xf3\x7e\x60\xc0\x00\x00\x00\x00',
-    b'\x00\x00\x00\x1c\x30\x60\x60\x7c\x60\x60\x30\x1c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x7c\xc6\xc6\xc6\xc6\xc6\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\xfe\x00\x00\xfe\x00\x00\xfe\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x18\x18\x7e\x18\x18\x00\x00\xff\x00\x00\x00\x00',
-    b'\x00\x00\x00\x30\x18\x0c\x06\x0c\x18\x30\x00\x7e\x00\x00\x00\x00',
-    b'\x00\x00\x00\x0c\x18\x30\x60\x30\x18\x0c\x00\x7e\x00\x00\x00\x00',
-    b'\x00\x00\x00\x0e\x1b\x1b\x18\x18\x18\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x18\x18\x18\x18\x18\x18\x18\x18\xd8\xd8\x70\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x18\x18\x00\x7e\x00\x18\x18\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x76\xdc\x00\x76\xdc\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x38\x6c\x6c\x38\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x18\x18\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x18\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x0f\x0c\x0c\x0c\x0c\x0c\xec\x6c\x3c\x1c\x00\x00\x00\x00',
-    b'\x00\x00\xd8\x6c\x6c\x6c\x6c\x6c\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x70\xd8\x30\x60\xc8\xf8\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x7c\x7c\x7c\x7c\x7c\x7c\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
-]
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/display/hd44780.py crealityShit/klippy/extras/display/hd44780.py
--- klipperStock/klippy/extras/display/hd44780.py	2024-01-14 23:01:59.465788301 -0600
+++ crealityShit/klippy/extras/display/hd44780.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,134 +0,0 @@
-# Support for HD44780 (20x4 text) LCD displays
-#
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-# Copyright (C) 2018  Eric Callahan <arksine.code@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-
-BACKGROUND_PRIORITY_CLOCK = 0x7fffffff00000000
-LINE_LENGTH_DEFAULT=20
-LINE_LENGTH_OPTIONS={16:16, 20:20}
-
-TextGlyphs = { 'right_arrow': b'\x7e' }
-
-HD44780_DELAY = .000040
-
-class HD44780:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        # pin config
-        ppins = self.printer.lookup_object('pins')
-        pins = [ppins.lookup_pin(config.get(name + '_pin'))
-                for name in ['rs', 'e', 'd4', 'd5', 'd6', 'd7']]
-        self.hd44780_protocol_init = config.getboolean('hd44780_protocol_init',
-                                                       True)
-        self.line_length = config.getchoice('line_length', LINE_LENGTH_OPTIONS,
-                                            LINE_LENGTH_DEFAULT)
-        mcu = None
-        for pin_params in pins:
-            if mcu is not None and pin_params['chip'] != mcu:
-                raise ppins.error("hd44780 all pins must be on same mcu")
-            mcu = pin_params['chip']
-        self.pins = [pin_params['pin'] for pin_params in pins]
-        self.mcu = mcu
-        self.oid = self.mcu.create_oid()
-        self.mcu.register_config_callback(self.build_config)
-        self.send_data_cmd = self.send_cmds_cmd = None
-        self.icons = {}
-        # framebuffers
-        self.text_framebuffers = [bytearray(b' '*2*self.line_length),
-                                  bytearray(b' '*2*self.line_length)]
-        self.glyph_framebuffer = bytearray(64)
-        self.all_framebuffers = [
-            # Text framebuffers
-            (self.text_framebuffers[0], bytearray(b'~'*2*self.line_length),
-             0x80),
-            (self.text_framebuffers[1], bytearray(b'~'*2*self.line_length),
-             0xc0),
-            # Glyph framebuffer
-            (self.glyph_framebuffer, bytearray(b'~'*64), 0x40) ]
-    def build_config(self):
-        self.mcu.add_config_cmd(
-            "config_hd44780 oid=%d rs_pin=%s e_pin=%s"
-            " d4_pin=%s d5_pin=%s d6_pin=%s d7_pin=%s delay_ticks=%d" % (
-                self.oid, self.pins[0], self.pins[1],
-                self.pins[2], self.pins[3], self.pins[4], self.pins[5],
-                self.mcu.seconds_to_clock(HD44780_DELAY)))
-        cmd_queue = self.mcu.alloc_command_queue()
-        self.send_cmds_cmd = self.mcu.lookup_command(
-            "hd44780_send_cmds oid=%c cmds=%*s", cq=cmd_queue)
-        self.send_data_cmd = self.mcu.lookup_command(
-            "hd44780_send_data oid=%c data=%*s", cq=cmd_queue)
-    def send(self, cmds, is_data=False):
-        cmd_type = self.send_cmds_cmd
-        if is_data:
-            cmd_type = self.send_data_cmd
-        cmd_type.send([self.oid, cmds], reqclock=BACKGROUND_PRIORITY_CLOCK)
-        #logging.debug("hd44780 %d %s", is_data, repr(cmds))
-    def flush(self):
-        # Find all differences in the framebuffers and send them to the chip
-        for new_data, old_data, fb_id in self.all_framebuffers:
-            if new_data == old_data:
-                continue
-            # Find the position of all changed bytes in this framebuffer
-            diffs = [[i, 1] for i, (n, o) in enumerate(zip(new_data, old_data))
-                     if n != o]
-            # Batch together changes that are close to each other
-            for i in range(len(diffs)-2, -1, -1):
-                pos, count = diffs[i]
-                nextpos, nextcount = diffs[i+1]
-                if pos + 4 >= nextpos and nextcount < 16:
-                    diffs[i][1] = nextcount + (nextpos - pos)
-                    del diffs[i+1]
-            # Transmit changes
-            for pos, count in diffs:
-                chip_pos = pos
-                self.send([fb_id + chip_pos])
-                self.send(new_data[pos:pos+count], is_data=True)
-            old_data[:] = new_data
-    def init(self):
-        curtime = self.printer.get_reactor().monotonic()
-        print_time = self.mcu.estimated_print_time(curtime)
-        # Program 4bit / 2-line mode and then issue 0x02 "Home" command
-        if self.hd44780_protocol_init:
-            init = [[0x33], [0x33], [0x32], [0x28, 0x28, 0x02]]
-        else:
-            init = [[0x02]]
-        # Reset (set positive direction ; enable display and hide cursor)
-        init.append([0x06, 0x0c])
-        for i, cmds in enumerate(init):
-            minclock = self.mcu.print_time_to_clock(print_time + i * .100)
-            self.send_cmds_cmd.send([self.oid, cmds], minclock=minclock)
-        self.flush()
-    def write_text(self, x, y, data):
-        if x + len(data) > self.line_length:
-            data = data[:self.line_length - min(x, self.line_length)]
-        pos = x + ((y & 0x02) >> 1) * self.line_length
-        self.text_framebuffers[y & 1][pos:pos+len(data)] = data
-    def set_glyphs(self, glyphs):
-        for glyph_name, glyph_data in glyphs.items():
-            data = glyph_data.get('icon5x8')
-            if data is not None:
-                self.icons[glyph_name] = data
-    def write_glyph(self, x, y, glyph_name):
-        data = self.icons.get(glyph_name)
-        if data is not None:
-            slot, bits = data
-            self.write_text(x, y, [slot])
-            self.glyph_framebuffer[slot * 8:(slot + 1) * 8] = bits
-            return 1
-        char = TextGlyphs.get(glyph_name)
-        if char is not None:
-            # Draw character
-            self.write_text(x, y, char)
-            return 1
-        return 0
-    def write_graphics(self, x, y, data):
-        pass
-    def clear(self):
-        spaces = b' ' * 2*self.line_length
-        self.text_framebuffers[0][:] = spaces
-        self.text_framebuffers[1][:] = spaces
-    def get_dimensions(self):
-        return (self.line_length, 4)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/display/hd44780_spi.py crealityShit/klippy/extras/display/hd44780_spi.py
--- klipperStock/klippy/extras/display/hd44780_spi.py	2024-01-14 23:01:59.461788252 -0600
+++ crealityShit/klippy/extras/display/hd44780_spi.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,125 +0,0 @@
-# Support for HD44780 (20x4 text) LCD displays
-#
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-# Copyright (C) 2018  Eric Callahan <arksine.code@gmail.com>
-# Copyright (C) 2021  Marc-Andre Denis <marcadenis@msn.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-from .. import bus
-
-LINE_LENGTH_DEFAULT=20
-LINE_LENGTH_OPTIONS={16:16, 20:20}
-
-TextGlyphs = { 'right_arrow': b'\x7e' }
-
-
-
-class hd44780_spi:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.hd44780_protocol_init = config.getboolean('hd44780_protocol_init',
-                                                       True)
-        # spi config
-        self.spi = bus.MCU_SPI_from_config(
-            config, 0x00, pin_option="latch_pin")
-        self.mcu = self.spi.get_mcu()
-        #self.spi.spi_send([0x01,0xa0])
-        self.data_mask = (1<<1)
-        self.command_mask = 0
-        self.enable_mask = (1<<3)
-
-        self.icons = {}
-        self.line_length = config.getchoice('line_length', LINE_LENGTH_OPTIONS,
-                                            LINE_LENGTH_DEFAULT)
-
-        # framebuffers
-        self.text_framebuffers = [bytearray(b' '*2*self.line_length),
-                                  bytearray(b' '*2*self.line_length)]
-        self.glyph_framebuffer = bytearray(64)
-        self.all_framebuffers = [
-            # Text framebuffers
-            (self.text_framebuffers[0], bytearray(b'~'*2*self.line_length),
-             0x80),
-            (self.text_framebuffers[1], bytearray(b'~'*2*self.line_length),
-             0xc0),
-            # Glyph framebuffer
-            (self.glyph_framebuffer, bytearray(b'~'*64), 0x40) ]
-    def send_4_bits(self, cmd, is_data, minclock):
-        if is_data:
-            mask = self.data_mask
-        else:
-            mask = self.command_mask
-        self.spi.spi_send([(cmd & 0xF0) | mask], minclock)
-        self.spi.spi_send([(cmd & 0xF0) | mask | self.enable_mask], minclock)
-        self.spi.spi_send([(cmd & 0xF0) | mask], minclock)
-    def send(self, cmds, is_data=False, minclock=0):
-        for data in cmds:
-            self.send_4_bits(data,is_data,minclock)
-            self.send_4_bits(data<<4,is_data,minclock)
-    def flush(self):
-        # Find all differences in the framebuffers and send them to the chip
-        for new_data, old_data, fb_id in self.all_framebuffers:
-            if new_data == old_data:
-                continue
-            # Find the position of all changed bytes in this framebuffer
-            diffs = [[i, 1] for i, (n, o) in enumerate(zip(new_data, old_data))
-                     if n != o]
-            # Batch together changes that are close to each other
-            for i in range(len(diffs)-2, -1, -1):
-                pos, count = diffs[i]
-                nextpos, nextcount = diffs[i+1]
-                if pos + 4 >= nextpos and nextcount < 16:
-                    diffs[i][1] = nextcount + (nextpos - pos)
-                    del diffs[i+1]
-            # Transmit changes
-            for pos, count in diffs:
-                chip_pos = pos
-                self.send([fb_id + chip_pos])
-                self.send(new_data[pos:pos+count], is_data=True)
-            old_data[:] = new_data
-    def init(self):
-        curtime = self.printer.get_reactor().monotonic()
-        print_time = self.mcu.estimated_print_time(curtime)
-        # Program 4bit / 2-line mode and then issue 0x02 "Home" command
-        if self.hd44780_protocol_init:
-            init = [[0x33], [0x33], [0x32], [0x28, 0x28, 0x02]]
-        else:
-            init = [[0x02]]
-        # Reset (set positive direction ; enable display and hide cursor)
-        init.append([0x06, 0x0c])
-        for i, cmds in enumerate(init):
-            minclock = self.mcu.print_time_to_clock(print_time + i * .100)
-            self.send(cmds, minclock=minclock)
-        self.flush()
-    def write_text(self, x, y, data):
-        if x + len(data) > self.line_length:
-            data = data[:self.line_length - min(x, self.line_length)]
-        pos = x + ((y & 0x02) >> 1) * self.line_length
-        self.text_framebuffers[y & 1][pos:pos+len(data)] = data
-    def set_glyphs(self, glyphs):
-        for glyph_name, glyph_data in glyphs.items():
-            data = glyph_data.get('icon5x8')
-            if data is not None:
-                self.icons[glyph_name] = data
-    def write_glyph(self, x, y, glyph_name):
-        data = self.icons.get(glyph_name)
-        if data is not None:
-            slot, bits = data
-            self.write_text(x, y, [slot])
-            self.glyph_framebuffer[slot * 8:(slot + 1) * 8] = bits
-            return 1
-        char = TextGlyphs.get(glyph_name)
-        if char is not None:
-            # Draw character
-            self.write_text(x, y, char)
-            return 1
-        return 0
-    def write_graphics(self, x, y, data):
-        pass
-    def clear(self):
-        spaces = b' ' * 2*self.line_length
-        self.text_framebuffers[0][:] = spaces
-        self.text_framebuffers[1][:] = spaces
-    def get_dimensions(self):
-        return (self.line_length, 4)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/display/__init__.py crealityShit/klippy/extras/display/__init__.py
--- klipperStock/klippy/extras/display/__init__.py	2024-01-14 23:01:59.461788252 -0600
+++ crealityShit/klippy/extras/display/__init__.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,21 +0,0 @@
-# Package definition for the extras/display directory
-#
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-from . import display
-
-def load_config(config):
-    return display.load_config(config)
-
-def load_config_prefix(config):
-    if not config.has_section('display'):
-        raise config.error(
-            "A primary [display] section must be defined in printer.cfg "
-            "to use auxilary displays")
-    name = config.get_name().split()[-1]
-    if name == "display":
-        raise config.error(
-            "Section name [display display] is not valid. "
-            "Please choose a different postfix.")
-    return display.load_config(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/display/menu.cfg crealityShit/klippy/extras/display/menu.cfg
--- klipperStock/klippy/extras/display/menu.cfg	2024-01-14 23:01:59.461788252 -0600
+++ crealityShit/klippy/extras/display/menu.cfg	1969-12-31 18:00:00.000000000 -0600
@@ -1,782 +0,0 @@
-# This file defines the default layout of the printer's menu.
-
-# It is not necessary to edit this file to change the menu. Instead,
-# one may override any of the sections defined here by defining a
-# section with the same name in the main printer.cfg config file.
-
-### DEFAULT MENU ###
-# Main
-#   + Tune
-#       + Speed: 000%
-#       + Flow: 000%
-#       + Offset Z:00.00
-#   + OctoPrint
-#       + Pause printing
-#       + Resume printing
-#       + Abort printing
-#   + SD Card
-#       + Start printing
-#       + Resume printing
-#       + Pause printing
-#       + Cancel printing
-#       + ... (files)
-#   + Control
-#       + Home All
-#       + Home Z
-#       + Home X/Y
-#       + Z Tilt
-#       + Quad Gantry Lvl
-#       + Bed Mesh
-#       + Steppers off
-#       + Fan: OFF
-#       + Fan speed: 000%
-#       + Lights: OFF
-#       + Lights: 000%
-#       + Move 10mm
-#           + Move X:000.0
-#           + Move Y:000.0
-#           + Move Z:000.0
-#           + Move E:+000.0
-#       + Move 1mm
-#           + Move X:000.0
-#           + Move Y:000.0
-#           + Move Z:000.0
-#           + Move E:+000.0
-#       + Move 0.1mm
-#           + Move X:000.0
-#           + Move Y:000.0
-#           + Move Z:000.0
-#           + Move E:+000.0
-#   + Temperature
-#       + Ex0:000 (0000)
-#       + Ex1:000 (0000)
-#       + Bed:000 (0000)
-#       + Preheat PLA
-#           + Preheat all
-#           + Preheat hotend
-#           + Preheat hotbed
-#       + Preheat ABS
-#           + Preheat all
-#           + Preheat hotend
-#           + Preheat hotbed
-#       + Cooldown
-#           + Cooldown all
-#           + Cooldown hotend
-#           + Cooldown hotbed
-#   + Filament
-#       + Ex0:000 (0000)
-#       + Load Fil. fast
-#       + Load Fil. slow
-#       + Unload Fil.fast
-#       + Unload Fil.slow
-#       + Feed: 000.0
-#   + Setup
-#       + Save config
-#       + Restart
-#           + Restart host
-#           + Restart FW
-#       + PID tuning
-#           + Tune Hotend PID
-#           + Tune Hotbed PID
-#       + Calibration
-#           + Delta cal. auto
-#           + Delta cal. man
-#               + Start probing
-#               + Move Z: 000.00
-#               + Test Z: ++
-#               + Accept
-#               + Abort
-#           + Bed probe
-#       + Dump parameters
-
-### menu main ###
-[menu __main]
-type: list
-name: Main
-
-### menu tune ###
-[menu __main __tune]
-type: list
-enable: {printer.idle_timeout.state == "Printing"}
-name: Tune
-
-[menu __main __tune __speed]
-type: input
-name: Speed: {'%3d' % (menu.input*100)}%
-input: {printer.gcode_move.speed_factor}
-input_min: 0.01
-input_max: 5
-input_step: 0.01
-realtime: True
-gcode:
-    M220 S{'%d' % (menu.input*100)}
-
-[menu __main __tune __flow]
-type: input
-name: Flow: {'%3d' % (menu.input*100)}%
-input: {printer.gcode_move.extrude_factor}
-input_min: 0.01
-input_max: 2
-input_step: 0.01
-realtime: True
-gcode:
-    M221 S{'%d' % (menu.input*100)}
-
-[menu __main __tune __offsetz]
-type: input
-name: Offset Z:{'%05.3f' % menu.input}
-input: {printer.gcode_move.homing_origin.z}
-input_min: -5
-input_max: 5
-input_step: 0.005
-realtime: True
-gcode:
-    SET_GCODE_OFFSET Z={'%.3f' % menu.input} MOVE=1
-
-
-### menu octoprint ###
-[menu __main __octoprint]
-type: list
-name: OctoPrint
-
-[menu __main __octoprint __pause]
-type: command
-enable: {printer.idle_timeout.state == "Printing"}
-name: Pause printing
-gcode:
-    {action_respond_info('action:pause')}
-
-[menu __main __octoprint __resume]
-type: command
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Resume printing
-gcode:
-    {action_respond_info('action:resume')}
-
-[menu __main __octoprint __abort]
-type: command
-enable: {printer.idle_timeout.state == "Printing"}
-name: Abort printing
-gcode:
-    {action_respond_info('action:cancel')}
-
-### menu virtual sdcard ###
-[menu __main __sdcard]
-type: vsdlist
-enable: {('virtual_sdcard' in printer)}
-name: SD Card
-
-[menu __main __sdcard __start]
-type: command
-enable: {('virtual_sdcard' in printer) and printer.virtual_sdcard.file_path and not printer.virtual_sdcard.is_active}
-name: Start printing
-gcode: M24
-
-[menu __main __sdcard __resume]
-type: command
-enable: {('virtual_sdcard' in printer) and printer.print_stats.state == "paused"}
-name: Resume printing
-gcode:
-    {% if "pause_resume" in printer %}
-        RESUME
-    {% else %}
-        M24
-    {% endif %}
-
-[menu __main __sdcard __pause]
-type: command
-enable: {('virtual_sdcard' in printer) and printer.print_stats.state == "printing"}
-name: Pause printing
-gcode:
-    {% if "pause_resume" in printer %}
-        PAUSE
-    {% else %}
-        M25
-    {% endif %}
-
-[menu __main __sdcard __cancel]
-type: command
-enable: {('virtual_sdcard' in printer) and (printer.print_stats.state == "printing" or printer.print_stats.state == "paused")}
-name: Cancel printing
-gcode:
-    {% if 'pause_resume' in printer %}
-        CANCEL_PRINT
-    {% else %}
-        M25
-        M27
-        M26 S0
-        TURN_OFF_HEATERS
-        {% if printer.toolhead.position.z <= printer.toolhead.axis_maximum.z - 5 %}
-            G91
-            G0 Z5 F1000
-            G90
-        {% endif %}
-    {% endif %}
-
-### menu control ###
-[menu __main __control]
-type: list
-name: Control
-
-[menu __main __control __home]
-type: command
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Home All
-gcode: G28
-
-[menu __main __control __homez]
-type: command
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Home Z
-gcode: G28 Z
-
-[menu __main __control __homexy]
-type: command
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Home X/Y
-gcode: G28 X Y
-
-[menu __main __control __z_tilt]
-type: command
-enable: {not printer.idle_timeout.state == "Printing" and ('z_tilt' in printer)}
-name: Z Tilt
-gcode: Z_TILT_ADJUST
-
-[menu __main __control __quad_gantry_level]
-type: command
-enable: {not printer.idle_timeout.state == "Printing" and ('quad_gantry_level' in printer)}
-name: Quad Gantry Lvl
-gcode: QUAD_GANTRY_LEVEL
-
-[menu __main __control __bed_mesh]
-type: command
-enable: {not printer.idle_timeout.state == "Printing" and ('bed_mesh' in printer)}
-name: Bed Mesh
-gcode: BED_MESH_CALIBRATE
-
-[menu __main __control __disable]
-type: command
-name: Steppers off
-gcode:
-    M84
-    M18
-
-[menu __main __control __fanonoff]
-type: input
-enable: {'fan' in printer}
-name: Fan: {'ON ' if menu.input else 'OFF'}
-input: {printer.fan.speed}
-input_min: 0
-input_max: 1
-input_step: 1
-gcode:
-    M106 S{255 if menu.input else 0}
-
-[menu __main __control __fanspeed]
-type: input
-enable: {'fan' in printer}
-name: Fan speed: {'%3d' % (menu.input*100)}%
-input: {printer.fan.speed}
-input_min: 0
-input_max: 1
-input_step: 0.01
-gcode:
-    M106 S{'%d' % (menu.input*255)}
-
-[menu __main __control __caselightonoff]
-type: input
-enable: {'output_pin caselight' in printer}
-name: Lights: {'ON ' if menu.input else 'OFF'}
-input: {printer['output_pin caselight'].value}
-input_min: 0
-input_max: 1
-input_step: 1
-gcode:
-    SET_PIN PIN=caselight VALUE={1 if menu.input else 0}
-
-[menu __main __control __caselightpwm]
-type: input
-enable: {'output_pin caselight' in printer}
-name: Lights: {'%3d' % (menu.input*100)}%
-input: {printer['output_pin caselight'].value}
-input_min: 0.0
-input_max: 1.0
-input_step: 0.01
-gcode:
-    SET_PIN PIN=caselight VALUE={menu.input}
-
-### menu move 10mm ###
-[menu __main __control __move_10mm]
-type: list
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move 10mm
-
-[menu __main __control __move_10mm __axis_x]
-type: input
-name: Move X:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.x}
-input_min: {printer.toolhead.axis_minimum.x}
-input_max: {printer.toolhead.axis_maximum.x}
-input_step: 10.0
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 X{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_10mm __axis_y]
-type: input
-name: Move Y:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.y}
-input_min: {printer.toolhead.axis_minimum.y}
-input_max: {printer.toolhead.axis_maximum.y}
-input_step: 10.0
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 Y{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_10mm __axis_z]
-type: input
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move Z:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.z}
-input_min: 0
-input_max: {printer.toolhead.axis_maximum.z}
-input_step: 10.0
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 Z{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_10mm __axis_e]
-type: input
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move E:{'%+06.1f' % menu.input}
-input: 0
-input_min: -{printer.configfile.config.extruder.max_extrude_only_distance|default(50)}
-input_max: {printer.configfile.config.extruder.max_extrude_only_distance|default(50)}
-input_step: 10.0
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    M83
-    G1 E{menu.input} F240
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-### menu move 1mm ###
-[menu __main __control __move_1mm]
-type: list
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move 1mm
-
-[menu __main __control __move_1mm __axis_x]
-type: input
-name: Move X:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.x}
-input_min: {printer.toolhead.axis_minimum.x}
-input_max: {printer.toolhead.axis_maximum.x}
-input_step: 1.0
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 X{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_1mm __axis_y]
-type: input
-name: Move Y:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.y}
-input_min: {printer.toolhead.axis_minimum.y}
-input_max: {printer.toolhead.axis_maximum.y}
-input_step: 1.0
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 Y{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_1mm __axis_z]
-type: input
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move Z:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.z}
-input_min: 0
-input_max: {printer.toolhead.axis_maximum.z}
-input_step: 1.0
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 Z{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_1mm __axis_e]
-type: input
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move E:{'%+06.1f' % menu.input}
-input: 0
-input_min: -{printer.configfile.config.extruder.max_extrude_only_distance|default(50)}
-input_max: {printer.configfile.config.extruder.max_extrude_only_distance|default(50)}
-input_step: 1.0
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    M83
-    G1 E{menu.input} F240
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-### menu move 0.1mm ###
-[menu __main __control __move_01mm]
-type: list
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move 0.1mm
-
-[menu __main __control __move_01mm __axis_x]
-type: input
-name: Move X:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.x}
-input_min: {printer.toolhead.axis_minimum.x}
-input_max: {printer.toolhead.axis_maximum.x}
-input_step: 0.1
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 X{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_01mm __axis_y]
-type: input
-name: Move Y:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.y}
-input_min: {printer.toolhead.axis_minimum.y}
-input_max: {printer.toolhead.axis_maximum.y}
-input_step: 0.1
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 Y{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_01mm __axis_z]
-type: input
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move Z:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.z}
-input_min: 0
-input_max: {printer.toolhead.axis_maximum.z}
-input_step: 0.1
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 Z{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_01mm __axis_e]
-type: input
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move E:{'%+06.1f' % menu.input}
-input: 0
-input_min: -{printer.configfile.config.extruder.max_extrude_only_distance|default(50)}
-input_max: {printer.configfile.config.extruder.max_extrude_only_distance|default(50)}
-input_step: 0.1
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    M83
-    G1 E{menu.input} F240
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-### menu temperature ###
-[menu __main __temp]
-type: list
-name: Temperature
-
-[menu __main __temp __hotend0_target]
-type: input
-enable: {('extruder' in printer) and ('extruder' in printer.heaters.available_heaters)}
-name: {"Ex0:%3.0f (%4.0f)" % (menu.input, printer.extruder.temperature)}
-input: {printer.extruder.target}
-input_min: 0
-input_max: {printer.configfile.config.extruder.max_temp}
-input_step: 1
-gcode: M104 T0 S{'%.0f' % menu.input}
-
-[menu __main __temp __hotend1_target]
-type: input
-enable: {('extruder1' in printer) and ('extruder1' in printer.heaters.available_heaters)}
-name: {"Ex1:%3.0f (%4.0f)" % (menu.input, printer.extruder1.temperature)}
-input: {printer.extruder1.target}
-input_min: 0
-input_max: {printer.configfile.config.extruder1.max_temp}
-input_step: 1
-gcode: M104 T1 S{'%.0f' % menu.input}
-
-[menu __main __temp __hotbed_target]
-type: input
-enable: {'heater_bed' in printer}
-name: {"Bed:%3.0f (%4.0f)" % (menu.input, printer.heater_bed.temperature)}
-input: {printer.heater_bed.target}
-input_min: 0
-input_max: {printer.configfile.config.heater_bed.max_temp}
-input_step: 1
-gcode: M140 S{'%.0f' % menu.input}
-
-[menu __main __temp __preheat_pla]
-type: list
-name: Preheat PLA
-
-[menu __main __temp __preheat_pla __all]
-type: command
-enable: {('extruder' in printer) and ('heater_bed' in printer)}
-name: Preheat all
-gcode:
-    M140 S60
-    M104 S200
-
-[menu __main __temp __preheat_pla __hotend]
-type: command
-enable: {'extruder' in printer}
-name: Preheat hotend
-gcode: M104 S200
-
-[menu __main __temp __preheat_pla __hotbed]
-type: command
-enable: {'heater_bed' in printer}
-name: Preheat hotbed
-gcode: M140 S60
-
-[menu __main __temp __preheat_abs]
-type: list
-name: Preheat ABS
-
-[menu __main __temp __preheat_abs __all]
-type: command
-enable: {('extruder' in printer) and ('heater_bed' in printer)}
-name: Preheat all
-gcode:
-    M140 S110
-    M104 S245
-
-[menu __main __temp __preheat_abs __hotend]
-type: command
-enable: {'extruder' in printer}
-name: Preheat hotend
-gcode: M104 S245
-
-[menu __main __temp __preheat_abs __hotbed]
-type: command
-enable: {'heater_bed' in printer}
-name: Preheat hotbed
-gcode: M140 S110
-
-[menu __main __temp __cooldown]
-type: list
-name: Cooldown
-
-[menu __main __temp __cooldown __all]
-type: command
-enable: {('extruder' in printer) and ('heater_bed' in printer)}
-name: Cooldown all
-gcode:
-    M104 S0
-    M140 S0
-
-[menu __main __temp __cooldown __hotend]
-type: command
-enable: {'extruder' in printer}
-name: Cooldown hotend
-gcode: M104 S0
-
-[menu __main __temp __cooldown __hotbed]
-type: command
-enable: {'heater_bed' in printer}
-name: Cooldown hotbed
-gcode: M140 S0
-
-### menu filament ###
-
-[menu __main __filament]
-type: list
-name: Filament
-
-[menu __main __filament __hotend0_target]
-type: input
-enable: {'extruder' in printer}
-name: {"Ex0:%3.0f (%4.0f)" % (menu.input, printer.extruder.temperature)}
-input: {printer.extruder.target}
-input_min: 0
-input_max: {printer.configfile.config.extruder.max_temp}
-input_step: 1
-gcode: M104 T0 S{'%.0f' % menu.input}
-
-[menu __main __filament __loadf]
-type: command
-name: Load Fil. fast
-gcode:
-    SAVE_GCODE_STATE NAME=__filament__load
-    M83
-    G1 E50 F960
-    RESTORE_GCODE_STATE NAME=__filament__load
-
-[menu __main __filament __loads]
-type: command
-name: Load Fil. slow
-gcode:
-    SAVE_GCODE_STATE NAME=__filament__load
-    M83
-    G1 E50 F240
-    RESTORE_GCODE_STATE NAME=__filament__load
-
-[menu __main __filament __unloadf]
-type: command
-name: Unload Fil.fast
-gcode:
-    SAVE_GCODE_STATE NAME=__filament__load
-    M83
-    G1 E-50 F960
-    RESTORE_GCODE_STATE NAME=__filament__load
-
-[menu __main __filament __unloads]
-type: command
-name: Unload Fil.slow
-gcode:
-    SAVE_GCODE_STATE NAME=__filament__load
-    M83
-    G1 E-50 F240
-    RESTORE_GCODE_STATE NAME=__filament__load
-
-[menu __main __filament __feed]
-type: input
-name: Feed: {'%.1f' % menu.input}
-input: 5
-input_step: 0.1
-gcode:
-    SAVE_GCODE_STATE NAME=__filament__load
-    M83
-    G1 E{'%.1f' % menu.input} F60
-    RESTORE_GCODE_STATE NAME=__filament__load
-
-### menu setup ###
-[menu __main __setup]
-type: list
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Setup
-
-[menu __main __setup __save_config]
-type: command
-name: Save config
-gcode: SAVE_CONFIG
-
-[menu __main __setup __restart]
-type: list
-name: Restart
-
-[menu __main __setup __restart __host_restart]
-type: command
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Restart host
-gcode: RESTART
-
-[menu __main __setup __restart __firmware_restart]
-type: command
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Restart FW
-gcode: FIRMWARE_RESTART
-
-[menu __main __setup __tuning]
-type: list
-name: PID tuning
-
-[menu __main __setup __tuning __hotend_pid_tuning]
-type: command
-enable: {(not printer.idle_timeout.state == "Printing") and ('extruder' in printer)}
-name: Tune Hotend PID
-gcode: PID_CALIBRATE HEATER=extruder TARGET=210 WRITE_FILE=1
-
-[menu __main __setup __tuning __hotbed_pid_tuning]
-type: command
-enable: {(not printer.idle_timeout.state == "Printing") and ('heater_bed' in printer)}
-name: Tune Hotbed PID
-gcode: PID_CALIBRATE HEATER=heater_bed TARGET=60 WRITE_FILE=1
-
-[menu __main __setup __calib]
-type: list
-name: Calibration
-
-[menu __main __setup __calib __delta_calib_auto]
-type: command
-enable: {(not printer.idle_timeout.state == "Printing") and ('delta_calibrate' in printer)}
-name: Delta cal. auto
-gcode:
-    G28
-    DELTA_CALIBRATE
-
-[menu __main __setup __calib __delta_calib_man]
-type: list
-enable: {(not printer.idle_timeout.state == "Printing") and ('delta_calibrate' in printer)}
-name: Delta cal. man
-
-[menu __main __setup __calib __bedprobe]
-type: command
-enable: {(not printer.idle_timeout.state == "Printing") and ('probe' in printer)}
-name: Bed probe
-gcode: PROBE
-
-[menu __main __setup __calib __delta_calib_man __start]
-type: command
-name: Start probing
-gcode:
-    G28
-    DELTA_CALIBRATE METHOD=manual
-
-[menu __main __setup __calib __delta_calib_man __move_z]
-type: input
-name: Move Z: {'%03.2f' % menu.input}
-input: {printer.gcode_move.gcode_position.z}
-input_step: 1
-realtime: True
-gcode:
-    {%- if menu.event == 'change' -%}
-        G1 Z{'%.2f' % menu.input}
-    {%- elif menu.event == 'long_click' -%}
-        G1 Z{'%.2f' % menu.input}
-        SAVE_GCODE_STATE NAME=__move__axis
-        G91
-        G1 Z2
-        G1 Z-2
-        RESTORE_GCODE_STATE NAME=__move__axis
-    {%- endif -%}
-
-[menu __main __setup __calib __delta_calib_man __test_z]
-type: input
-name: Test Z: {['++','+','+.01','+.05','+.1','+.5','-.5','-.1','-.05','-.01','-','--'][menu.input|int]}
-input: 6
-input_min: 0
-input_max: 11
-input_step: 1
-gcode:
-    {%- if menu.event == 'long_click' -%}
-        TESTZ Z={['++','+','+.01','+.05','+.1','+.5','-.5','-.1','-.05','-.01','-','--'][menu.input|int]}
-    {%- endif -%}
-
-[menu __main __setup __calib __delta_calib_man __accept]
-type: command
-name: Accept
-gcode: ACCEPT
-
-[menu __main __setup __calib __delta_calib_man __abort]
-type: command
-name: Abort
-gcode: ABORT
-
-[menu __main __setup __dump]
-type: command
-name: Dump parameters
-gcode:
-   {% for name1 in printer %}
-      {% for name2 in printer[name1] %}
-         { action_respond_info("printer['%s'].%s = %s"
-                               % (name1, name2, printer[name1][name2])) }
-      {% else %}
-         { action_respond_info("printer['%s'] = %s" % (name1, printer[name1])) }
-      {% endfor %}
-   {% endfor %}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/display/menu_keys.py crealityShit/klippy/extras/display/menu_keys.py
--- klipperStock/klippy/extras/display/menu_keys.py	2024-01-14 23:01:59.461788252 -0600
+++ crealityShit/klippy/extras/display/menu_keys.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,108 +0,0 @@
-# -*- coding: utf-8 -*-
-# Support for menu button press tracking
-#
-# Copyright (C) 2018  Janar Sööt <janar.soot@gmail.com>
-# Copyright (C) 2020  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-LONG_PRESS_DURATION = 0.800
-TIMER_DELAY = .200
-
-class MenuKeys:
-    def __init__(self, config, callback):
-        self.printer = config.get_printer()
-        self.reactor = self.printer.get_reactor()
-        self.callback = callback
-        buttons = self.printer.load_object(config, "buttons")
-        # Register rotary encoder
-        encoder_pins = config.get('encoder_pins', None)
-        encoder_steps_per_detent = config.getchoice('encoder_steps_per_detent',
-                                                    {2: 2, 4: 4}, 4)
-        if encoder_pins is not None:
-            try:
-                pin1, pin2 = encoder_pins.split(',')
-            except:
-                raise config.error("Unable to parse encoder_pins")
-            buttons.register_rotary_encoder(pin1.strip(), pin2.strip(),
-                                            self.encoder_cw_callback,
-                                            self.encoder_ccw_callback,
-                                            encoder_steps_per_detent)
-        self.encoder_fast_rate = config.getfloat('encoder_fast_rate',
-                                                 .030, above=0.)
-        self.last_encoder_cw_eventtime = 0
-        self.last_encoder_ccw_eventtime = 0
-        # Register click button
-        self.is_short_click = False
-        self.click_timer = self.reactor.register_timer(self.long_click_event)
-        self.register_button(config, 'click_pin', self.click_callback, False)
-        # Register other buttons
-        self.register_button(config, 'back_pin', self.back_callback)
-        self.register_button(config, 'up_pin', self.up_callback)
-        self.register_button(config, 'down_pin', self.down_callback)
-        self.register_button(config, 'kill_pin', self.kill_callback)
-
-    def register_button(self, config, name, callback, push_only=True):
-        pin = config.get(name, None)
-        if pin is None:
-            return
-        buttons = self.printer.lookup_object("buttons")
-        if config.get('analog_range_' + name, None) is None:
-            if push_only:
-                buttons.register_button_push(pin, callback)
-            else:
-                buttons.register_buttons([pin], callback)
-            return
-        amin, amax = config.getfloatlist('analog_range_' + name, count=2)
-        pullup = config.getfloat('analog_pullup_resistor', 4700., above=0.)
-        if push_only:
-            buttons.register_adc_button_push(pin, amin, amax, pullup, callback)
-        else:
-            buttons.register_adc_button(pin, amin, amax, pullup, callback)
-
-    # Rotary encoder callbacks
-    def encoder_cw_callback(self, eventtime):
-        fast_rate = ((eventtime - self.last_encoder_cw_eventtime)
-                     <= self.encoder_fast_rate)
-        self.last_encoder_cw_eventtime = eventtime
-        if fast_rate:
-            self.callback('fast_up', eventtime)
-        else:
-            self.callback('up', eventtime)
-
-    def encoder_ccw_callback(self, eventtime):
-        fast_rate = ((eventtime - self.last_encoder_ccw_eventtime)
-                     <= self.encoder_fast_rate)
-        self.last_encoder_ccw_eventtime = eventtime
-        if fast_rate:
-            self.callback('fast_down', eventtime)
-        else:
-            self.callback('down', eventtime)
-
-    # Click handling
-    def long_click_event(self, eventtime):
-        self.is_short_click = False
-        self.callback('long_click', eventtime)
-        return self.reactor.NEVER
-
-    def click_callback(self, eventtime, state):
-        if state:
-            self.is_short_click = True
-            self.reactor.update_timer(self.click_timer,
-                                      eventtime + LONG_PRESS_DURATION)
-        elif self.is_short_click:
-            self.reactor.update_timer(self.click_timer, self.reactor.NEVER)
-            self.callback('click', eventtime)
-
-    # Other button callbacks
-    def back_callback(self, eventtime):
-        self.callback('back', eventtime)
-
-    def up_callback(self, eventtime):
-        self.callback('up', eventtime)
-
-    def down_callback(self, eventtime):
-        self.callback('down', eventtime)
-
-    def kill_callback(self, eventtime):
-        self.printer.invoke_shutdown("Shutdown due to kill button!")
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/display/menu.py crealityShit/klippy/extras/display/menu.py
--- klipperStock/klippy/extras/display/menu.py	2024-01-14 23:01:59.461788252 -0600
+++ crealityShit/klippy/extras/display/menu.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,1067 +0,0 @@
-# -*- coding: utf-8 -*-
-# Basic LCD menu support
-#
-# Copyright (C) 2020  Janar Sööt <janar.soot@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import os, logging, ast, re
-from string import Template
-from . import menu_keys
-
-
-class sentinel:
-    pass
-
-
-class error(Exception):
-    pass
-
-
-# Scriptable menu element abstract baseclass
-class MenuElement(object):
-    def __init__(self, manager, config, **kwargs):
-        if type(self) is MenuElement:
-            raise error(
-                'Abstract MenuElement cannot be instantiated directly')
-        self._manager = manager
-        self._cursor = '>'
-        # set class defaults and attributes from arguments
-        self._index = kwargs.get('index', None)
-        self._enable = kwargs.get('enable', True)
-        self._name = kwargs.get('name', None)
-        self._enable_tpl = self._name_tpl = None
-        if config is not None:
-            # overwrite class attributes from config
-            self._index = config.getint('index', self._index)
-            self._name_tpl = manager.gcode_macro.load_template(
-                config, 'name', self._name)
-            try:
-                self._enable = config.getboolean('enable', self._enable)
-            except config.error:
-                self._enable_tpl = manager.gcode_macro.load_template(
-                    config, 'enable')
-            # item namespace - used in relative paths
-            self._ns = str(" ".join(config.get_name().split(' ')[1:])).strip()
-        else:
-            # ns - item namespace key, used in item relative paths
-            # $__id - generated id text variable
-            __id = '__menu_' + hex(id(self)).lstrip("0x").rstrip("L")
-            self._ns = Template(
-                'menu ' + kwargs.get('ns', __id)).safe_substitute(__id=__id)
-        self._last_heartbeat = None
-        self.__scroll_pos = None
-        self.__scroll_request_pending = False
-        self.__scroll_next = 0
-        # menu scripts
-        self._scripts = {}
-        # init
-        self.init()
-
-    # override
-    def init(self):
-        pass
-
-    def _render_name(self):
-        if self._name_tpl is not None:
-            context = self.get_context()
-            return self.manager.asflat(self._name_tpl.render(context))
-        return self.manager.asflat(self._name)
-
-    def _load_script(self, config, name, option=None):
-        """Load script template from config or callback from dict"""
-        if name in self._scripts:
-            logging.info(
-                "Declaration of '%s' hides "
-                "previous script declaration" % (name,))
-        option = option or name
-        if isinstance(config, dict):
-            self._scripts[name] = config.get(option, None)
-        else:
-            self._scripts[name] = self.manager.gcode_macro.load_template(
-                config, option, '')
-
-    # override
-    def is_editing(self):
-        return False
-
-    # override
-    def is_scrollable(self):
-        return True
-
-    # override
-    def is_enabled(self):
-        context = self.get_context()
-        return self.eval_enable(context)
-
-    # override
-    def start_editing(self):
-        pass
-
-    # override
-    def stop_editing(self):
-        pass
-
-    # override
-    def get_context(self, cxt=None):
-        # get default menu context
-        context = self.manager.get_context(cxt)
-        context['menu'].update({
-            'ns': self.get_ns()
-        })
-        return context
-
-    def eval_enable(self, context):
-        if self._enable_tpl is not None:
-            return bool(ast.literal_eval(self._enable_tpl.render(context)))
-        return bool(self._enable)
-
-    # Called when a item is selected
-    def select(self):
-        self.__reset_scroller()
-
-    def heartbeat(self, eventtime):
-        self._last_heartbeat = eventtime
-        if eventtime >= self.__scroll_next:
-            self.__scroll_next = eventtime + 0.5
-            if not self.is_editing():
-                self.__update_scroller()
-
-    def __update_scroller(self):
-        if self.__scroll_pos is None and self.__scroll_request_pending is True:
-            self.__scroll_pos = 0
-        elif self.__scroll_request_pending is True:
-            self.__scroll_pos += 1
-            self.__scroll_request_pending = False
-        elif self.__scroll_request_pending is False:
-            pass  # hold scroll position
-        elif self.__scroll_request_pending is None:
-            self.__reset_scroller()
-
-    def __reset_scroller(self):
-        self.__scroll_pos = None
-        self.__scroll_request_pending = False
-
-    def need_scroller(self, value):
-        """
-        Allows to control the scroller
-        Parameters:
-            value (bool, None): True  - inc. scroll pos. on next update
-                                False - hold scroll pos.
-                                None  - reset the scroller
-        """
-        self.__scroll_request_pending = value
-
-    def __slice_name(self, name, index):
-        chunks = []
-        for i, text in enumerate(re.split(r'(\~.*?\~)', name)):
-            if i & 1 == 0:  # text
-                chunks += text
-            else:  # glyph placeholder
-                chunks.append(text)
-        return "".join(chunks[index:])
-
-    def render_name(self, selected=False):
-        name = str(self._render_name())
-        if selected and self.__scroll_pos is not None:
-            name = self.__slice_name(name, self.__scroll_pos)
-        else:
-            self.__reset_scroller()
-        return name
-
-    def get_ns(self, name='.'):
-        name = str(name).strip()
-        if name.startswith('..'):
-            name = ' '.join(
-                [(' '.join(str(self._ns).split(' ')[:-1])), name[2:]])
-        elif name.startswith('.'):
-            name = ' '.join([str(self._ns), name[1:]])
-        return name.strip()
-
-    def send_event(self, event, *args):
-        return self.manager.send_event(
-            "%s:%s" % (self.get_ns(), str(event)), *args)
-
-    def get_script(self, name):
-        if name in self._scripts:
-            return self._scripts[name]
-        return None
-
-    def _run_script(self, name, context):
-        _render = getattr(self._scripts[name], 'render', None)
-        # check template
-        if _render is not None and callable(_render):
-            return _render(context)
-        # check callback
-        elif callable(self._scripts[name]):
-            return self._scripts[name](self, context)
-        # check static string
-        elif isinstance(self._scripts[name], str):
-            return self._scripts[name]
-
-    def run_script(self, name, **kwargs):
-        event = kwargs.get('event', None)
-        context = kwargs.get('context', None)
-        render_only = kwargs.get('render_only', False)
-        result = ""
-        # init context
-        if name in self._scripts:
-            context = self.get_context(context)
-            context['menu'].update({
-                'event': event or name
-            })
-            result = self._run_script(name, context)
-        if not render_only:
-            # run result as gcode
-            self.manager.queue_gcode(result)
-            # default behaviour
-            _handle = getattr(self, "handle_script_" + name, None)
-            if callable(_handle):
-                _handle()
-        return result
-
-    @property
-    def cursor(self):
-        return str(self._cursor)[:1]
-
-    @property
-    def manager(self):
-        return self._manager
-
-    @property
-    def index(self):
-        return self._index
-
-
-class MenuContainer(MenuElement):
-    """Menu container abstract class"""
-    def __init__(self, manager, config, **kwargs):
-        if type(self) is MenuContainer:
-            raise error(
-                'Abstract MenuContainer cannot be instantiated directly')
-        super(MenuContainer, self).__init__(manager, config, **kwargs)
-        self._populate_cb = kwargs.get('populate', None)
-        self._cursor = '>'
-        self.__selected = None
-        self._allitems = []
-        self._names = []
-        self._items = []
-
-    def init(self):
-        super(MenuContainer, self).init()
-        # recursive guard
-        self._parents = []
-
-    # overload
-    def _names_aslist(self):
-        return []
-
-    # overload
-    def is_accepted(self, item):
-        return isinstance(item, MenuElement)
-
-    def is_editing(self):
-        return any([item.is_editing() for item in self._items])
-
-    def stop_editing(self):
-        for item in self._items:
-            if item.is_editing():
-                item.stop_editing()
-
-    def lookup_item(self, item):
-        if isinstance(item, str):
-            name = item.strip()
-            ns = self.get_ns(name)
-            return (self.manager.lookup_menuitem(ns), name)
-        elif isinstance(item, MenuElement):
-            return (item, item.get_ns())
-        return (None, item)
-
-    # overload
-    def _lookup_item(self, item):
-        return self.lookup_item(item)
-
-    def _index_of(self, item):
-        try:
-            index = None
-            if isinstance(item, str):
-                s = item.strip()
-                index = self._names.index(s)
-            elif isinstance(item, MenuElement):
-                index = self._items.index(item)
-            return index
-        except ValueError:
-            return None
-
-    def index_of(self, item, look_inside=False):
-        index = self._index_of(item)
-        if index is None and look_inside is True:
-            for con in self:
-                if isinstance(con, MenuContainer) and con._index_of(item):
-                    index = self._index_of(con)
-        return index
-
-    def add_parents(self, parents):
-        if isinstance(parents, list):
-            self._parents.extend(parents)
-        else:
-            self._parents.append(parents)
-
-    def assert_recursive_relation(self, parents=None):
-        assert self not in (parents or self._parents), \
-            "Recursive relation of '%s' container" % (self.get_ns(),)
-
-    def insert_item(self, s, index=None):
-        self._insert_item(s, index)
-
-    def _insert_item(self, s, index=None):
-        item, name = self._lookup_item(s)
-        if item is not None:
-            if not self.is_accepted(item):
-                raise error("Menu item '%s'is not accepted!" % str(type(item)))
-            if isinstance(item, (MenuElement)):
-                item.init()
-            if isinstance(item, (MenuContainer)):
-                item.add_parents(self._parents)
-                item.add_parents(self)
-                item.assert_recursive_relation()
-            if index is None:
-                self._allitems.append((item, name))
-            else:
-                self._allitems.insert(index, (item, name))
-
-    # overload
-    def _populate(self):
-        pass
-
-    def populate(self):
-        self._allitems = []  # empty list
-        for name in self._names_aslist():
-            self._insert_item(name)
-        # populate successor items
-        self._populate()
-        # run populate callback
-        if self._populate_cb is not None and callable(self._populate_cb):
-            self._populate_cb(self)
-        # send populate event
-        self.send_event('populate', self)
-
-    def update_items(self):
-        _a = [(item, name) for item, name in self._allitems
-              if item.is_enabled()]
-        self._items, self._names = zip(*_a) or ([], [])
-
-    # select methods
-    def init_selection(self):
-        self.select_at(0)
-
-    def select_at(self, index):
-        self.__selected = index
-        # select element
-        item = self.selected_item()
-        if isinstance(item, MenuElement):
-            item.select()
-        return item
-
-    def select_item(self, needle):
-        if isinstance(needle, MenuElement):
-            if self.selected_item() is not needle:
-                index = self.index_of(needle)
-                if index is not None:
-                    self.select_at(index)
-        else:
-            logging.error("Cannot select non menuitem")
-        return self.selected
-
-    def selected_item(self):
-        if isinstance(self.selected, int) and 0 <= self.selected < len(self):
-            return self[self.selected]
-        else:
-            return None
-
-    def select_next(self):
-        if not isinstance(self.selected, int):
-            index = 0 if len(self) else None
-        elif 0 <= self.selected < len(self) - 1:
-            index = self.selected + 1
-        else:
-            index = self.selected
-        return self.select_at(index)
-
-    def select_prev(self):
-        if not isinstance(self.selected, int):
-            index = 0 if len(self) else None
-        elif 0 < self.selected < len(self):
-            index = self.selected - 1
-        else:
-            index = self.selected
-        return self.select_at(index)
-
-    # override
-    def draw_container(self, nrows, eventtime):
-        pass
-
-    def __iter__(self):
-        return iter(self._items)
-
-    def __len__(self):
-        return len(self._items)
-
-    def __getitem__(self, key):
-        return self._items[key]
-
-    @property
-    def selected(self):
-        return self.__selected
-
-
-class MenuDisabled(MenuElement):
-    def __init__(self, manager, config, **kwargs):
-        super(MenuDisabled, self).__init__(manager, config, name='')
-
-    def is_enabled(self):
-        return False
-
-
-class MenuCommand(MenuElement):
-    def __init__(self, manager, config, **kwargs):
-        super(MenuCommand, self).__init__(manager, config, **kwargs)
-        self._load_script(config or kwargs, 'gcode')
-
-
-class MenuInput(MenuCommand):
-    def __init__(self, manager, config, **kwargs):
-        super(MenuInput, self).__init__(manager, config, **kwargs)
-        # set class defaults and attributes from arguments
-        self._input = kwargs.get('input', None)
-        self._input_min = kwargs.get('input_min', -999999.0)
-        self._input_max = kwargs.get('input_max', 999999.0)
-        self._input_step = kwargs.get('input_step', 1.0)
-        self._realtime = kwargs.get('realtime', False)
-        self._input_tpl = self._input_min_tpl = self._input_max_tpl = None
-        if config is not None:
-            # overwrite class attributes from config
-            self._realtime = config.getboolean('realtime', self._realtime)
-            self._input_tpl = manager.gcode_macro.load_template(
-                config, 'input')
-            self._input_min_tpl = manager.gcode_macro.load_template(
-                config, 'input_min', str(self._input_min))
-            self._input_max_tpl = manager.gcode_macro.load_template(
-                config, 'input_max', str(self._input_max))
-            self._input_step = config.getfloat(
-                'input_step', self._input_step, above=0.)
-
-    def init(self):
-        super(MenuInput, self).init()
-        self._is_dirty = False
-        self.__last_change = None
-        self._input_value = None
-
-    def is_scrollable(self):
-        return False
-
-    def is_editing(self):
-        return self._input_value is not None
-
-    def stop_editing(self):
-        if not self.is_editing():
-            return
-        self._reset_value()
-
-    def start_editing(self):
-        if self.is_editing():
-            return
-        self._init_value()
-
-    def heartbeat(self, eventtime):
-        super(MenuInput, self).heartbeat(eventtime)
-        if (self._is_dirty is True
-                and self.__last_change is not None
-                and self._input_value is not None
-                and (eventtime - self.__last_change) > 0.250):
-            if self._realtime is True:
-                self.run_script('gcode', event='change')
-                self.run_script('change')
-            self._is_dirty = False
-
-    def get_context(self, cxt=None):
-        context = super(MenuInput, self).get_context(cxt)
-        value = (self._eval_value(context) if self._input_value is None
-                 else self._input_value)
-        context['menu'].update({
-            'input': value
-        })
-        return context
-
-    def is_enabled(self):
-        context = super(MenuInput, self).get_context()
-        return self.eval_enable(context)
-
-    def _eval_min(self, context):
-        try:
-            if self._input_min_tpl is not None:
-                return float(ast.literal_eval(
-                    self._input_min_tpl.render(context)))
-            return float(self._input_min)
-        except ValueError:
-            logging.exception("Input min value evaluation error")
-
-    def _eval_max(self, context):
-        try:
-            if self._input_max_tpl is not None:
-                return float(ast.literal_eval(
-                    self._input_max_tpl.render(context)))
-            return float(self._input_max)
-        except ValueError:
-            logging.exception("Input max value evaluation error")
-
-    def _eval_value(self, context):
-        try:
-            if self._input_tpl is not None:
-                return float(ast.literal_eval(
-                    self._input_tpl.render(context)))
-            return float(self._input)
-        except ValueError:
-            logging.exception("Input value evaluation error")
-
-    def _value_changed(self):
-        self.__last_change = self._last_heartbeat
-        self._is_dirty = True
-
-    def _init_value(self):
-        context = super(MenuInput, self).get_context()
-        self._input_value = None
-        self._input_min = self._eval_min(context)
-        self._input_max = self._eval_max(context)
-        self._input_value = min(self._input_max, max(
-            self._input_min, self._eval_value(context)))
-        self._value_changed()
-
-    def _reset_value(self):
-        self._input_value = None
-
-    def _get_input_step(self, fast_rate=False):
-        return ((10.0 * self._input_step) if fast_rate and (
-                (self._input_max - self._input_min) / self._input_step > 100.0)
-                else self._input_step)
-
-    def inc_value(self, fast_rate=False):
-        last_value = self._input_value
-        if self._input_value is None:
-            return
-
-        input_step = self._get_input_step(fast_rate)
-        self._input_value += abs(input_step)
-        self._input_value = min(self._input_max, max(
-            self._input_min, self._input_value))
-
-        if last_value != self._input_value:
-            self._value_changed()
-
-    def dec_value(self, fast_rate=False):
-        last_value = self._input_value
-        if self._input_value is None:
-            return
-
-        input_step = self._get_input_step(fast_rate)
-        self._input_value -= abs(input_step)
-        self._input_value = min(self._input_max, max(
-            self._input_min, self._input_value))
-
-        if last_value != self._input_value:
-            self._value_changed()
-
-    # default behaviour on click
-    def handle_script_click(self):
-        if not self.is_editing():
-            self.start_editing()
-        elif self.is_editing():
-            self.stop_editing()
-
-
-class MenuList(MenuContainer):
-    def __init__(self, manager, config, **kwargs):
-        super(MenuList, self).__init__(manager, config, **kwargs)
-        self._viewport_top = 0
-
-        def _cb(el, context):
-            el.manager.back()
-        # create back item
-        self._itemBack = self.manager.menuitem_from(
-            'command', name='..', gcode=_cb)
-
-    def _names_aslist(self):
-        return self.manager.lookup_children(self.get_ns())
-
-    def _populate(self):
-        super(MenuList, self)._populate()
-        self._viewport_top = 0
-        #  add back as first item
-        self.insert_item(self._itemBack, 0)
-
-    def draw_container(self, nrows, eventtime):
-        display = self.manager.display
-        selected_row = self.selected
-        # adjust viewport
-        if selected_row is not None:
-            if selected_row >= (self._viewport_top + nrows):
-                self._viewport_top = (selected_row - nrows) + 1
-            if selected_row < self._viewport_top:
-                self._viewport_top = selected_row
-        else:
-            self._viewport_top = 0
-        # clamps viewport
-        self._viewport_top = max(0, min(self._viewport_top, len(self) - nrows))
-        try:
-            y = 0
-            for row in range(self._viewport_top, self._viewport_top + nrows):
-                text = ""
-                prefix = ""
-                suffix = ""
-                if row < len(self):
-                    current = self[row]
-                    selected = (row == selected_row)
-                    if selected:
-                        current.heartbeat(eventtime)
-                    text = current.render_name(selected)
-                    # add prefix (selection indicator)
-                    if selected and not current.is_editing():
-                        prefix = current.cursor
-                    elif selected and current.is_editing():
-                        prefix = '*'
-                    else:
-                        prefix = ' '
-                    # add suffix (folder indicator)
-                    if isinstance(current, MenuList):
-                        suffix += '>'
-                # draw to display
-                plen = len(prefix)
-                slen = len(suffix)
-                width = self.manager.cols - plen - slen
-                # draw item prefix (cursor)
-                ppos = display.draw_text(y, 0, prefix, eventtime)
-                # draw item name
-                tpos = display.draw_text(y, ppos, text.ljust(width), eventtime)
-                # check scroller
-                if (selected and tpos > self.manager.cols
-                        and current.is_scrollable()):
-                    # scroll next
-                    current.need_scroller(True)
-                else:
-                    # reset scroller
-                    current.need_scroller(None)
-                # draw item suffix
-                if suffix:
-                    display.draw_text(
-                        y, self.manager.cols - slen, suffix, eventtime)
-                # next display row
-                y += 1
-        except Exception:
-            logging.exception('List drawing error')
-
-
-class MenuVSDList(MenuList):
-    def __init__(self, manager, config, **kwargs):
-        super(MenuVSDList, self).__init__(manager, config, **kwargs)
-
-    def _populate(self):
-        super(MenuVSDList, self)._populate()
-        sdcard = self.manager.printer.lookup_object('virtual_sdcard', None)
-        if sdcard is not None:
-            files = sdcard.get_file_list()
-            for fname, fsize in files:
-                self.insert_item(self.manager.menuitem_from(
-                    'command', name=repr(fname), gcode='M23 /%s' % str(fname)))
-
-
-menu_items = {
-    'disabled': MenuDisabled,
-    'command': MenuCommand,
-    'input': MenuInput,
-    'list': MenuList,
-    'vsdlist': MenuVSDList
-}
-
-
-TIMER_DELAY = 1.0
-
-
-class MenuManager:
-    def __init__(self, config, display):
-        self.running = False
-        self.menuitems = {}
-        self.menustack = []
-        self.children = {}
-        self.display = display
-        self.printer = config.get_printer()
-        self.pconfig = self.printer.lookup_object('configfile')
-        self.gcode = self.printer.lookup_object('gcode')
-        self.gcode_queue = []
-        self.context = {}
-        self.root = None
-        self._root = config.get('menu_root', '__main')
-        self.cols, self.rows = self.display.get_dimensions()
-        self.timeout = config.getint('menu_timeout', 0)
-        self.timer = 0
-        # reverse container navigation
-        self._reverse_navigation = config.getboolean(
-            'menu_reverse_navigation', False)
-        # load printer objects
-        self.gcode_macro = self.printer.load_object(config, 'gcode_macro')
-        # register itself for printer callbacks
-        self.printer.add_object('menu', self)
-        self.printer.register_event_handler("klippy:ready", self.handle_ready)
-        # register for key events
-        menu_keys.MenuKeys(config, self.key_event)
-        # Load local config file in same directory as current module
-        self.load_config(os.path.dirname(__file__), 'menu.cfg')
-        # Load items from main config
-        self.load_menuitems(config)
-        # Load menu root
-        self.root = self.lookup_menuitem(self._root)
-        # send init event
-        self.send_event('init', self)
-
-    def handle_ready(self):
-        # start timer
-        reactor = self.printer.get_reactor()
-        reactor.register_timer(self.timer_event, reactor.NOW)
-
-    def timer_event(self, eventtime):
-        self.timeout_check(eventtime)
-        return eventtime + TIMER_DELAY
-
-    def timeout_check(self, eventtime):
-        if (self.is_running() and self.timeout > 0
-                and isinstance(self.root, MenuContainer)):
-            if self.timer >= self.timeout:
-                self.exit()
-            else:
-                self.timer += 1
-        else:
-            self.timer = 0
-
-    def send_event(self, event, *args):
-        return self.printer.send_event("menu:" + str(event), *args)
-
-    def is_running(self):
-        return self.running
-
-    def begin(self, eventtime):
-        self.menustack = []
-        self.timer = 0
-        if isinstance(self.root, MenuContainer):
-            # send begin event
-            self.send_event('begin', self)
-            self.update_context(eventtime)
-            if isinstance(self.root, MenuContainer):
-                self.root.init_selection()
-            self.stack_push(self.root)
-            self.running = True
-            return
-        elif self.root is not None:
-            logging.error("Invalid root, menu stopped!")
-        self.running = False
-
-    def get_status(self, eventtime):
-        return {
-            'timeout': self.timeout,
-            'running': self.running,
-            'rows': self.rows,
-            'cols': self.cols
-        }
-
-    def _action_back(self, force=False, update=True):
-        self.back(force, update)
-        return ""
-
-    def _action_exit(self, force=False):
-        self.exit(force)
-        return ""
-
-    def get_context(self, cxt=None):
-        context = dict(self.context)
-        if isinstance(cxt, dict):
-            context.update(cxt)
-        return context
-
-    def update_context(self, eventtime):
-        # menu default jinja2 context
-        self.context = self.gcode_macro.create_template_context(eventtime)
-        self.context['menu'] = {
-            'eventtime': eventtime,
-            'back': self._action_back,
-            'exit': self._action_exit
-        }
-
-    def stack_push(self, container):
-        if not isinstance(container, MenuContainer):
-            raise error("Wrong type, expected MenuContainer")
-        container.populate()
-        top = self.stack_peek()
-        if top is not None:
-            if isinstance(top, MenuList):
-                top.run_script('leave')
-        if isinstance(container, MenuList):
-            container.run_script('enter')
-        if not container.is_editing():
-            container.update_items()
-            container.init_selection()
-        self.menustack.append(container)
-
-    def stack_pop(self, update=True):
-        container = None
-        if self.stack_size() > 0:
-            container = self.menustack.pop()
-            if not isinstance(container, MenuContainer):
-                raise error("Wrong type, expected MenuContainer")
-            top = self.stack_peek()
-            if top is not None:
-                if not isinstance(container, MenuContainer):
-                    raise error("Wrong type, expected MenuContainer")
-                if not top.is_editing() and update is True:
-                    top.update_items()
-                    top.init_selection()
-                if isinstance(container, MenuList):
-                    container.run_script('leave')
-                if isinstance(top, MenuList):
-                    top.run_script('enter')
-            else:
-                if isinstance(container, MenuList):
-                    container.run_script('leave')
-        return container
-
-    def stack_size(self):
-        return len(self.menustack)
-
-    def stack_peek(self, lvl=0):
-        container = None
-        if self.stack_size() > lvl:
-            container = self.menustack[self.stack_size() - lvl - 1]
-        return container
-
-    def screen_update_event(self, eventtime):
-        # screen update
-        if not self.is_running():
-            return False
-        # draw menu
-        self.update_context(eventtime)
-        container = self.stack_peek()
-        if self.running and isinstance(container, MenuContainer):
-            container.heartbeat(eventtime)
-            container.draw_container(self.rows, eventtime)
-        return True
-
-    def up(self, fast_rate=False):
-        container = self.stack_peek()
-        if self.running and isinstance(container, MenuContainer):
-            self.timer = 0
-            current = container.selected_item()
-            if isinstance(current, MenuInput) and current.is_editing():
-                current.dec_value(fast_rate)
-            else:
-                if self._reverse_navigation is True:
-                    container.select_next()  # reverse
-                else:
-                    container.select_prev()  # normal
-
-    def down(self, fast_rate=False):
-        container = self.stack_peek()
-        if self.running and isinstance(container, MenuContainer):
-            self.timer = 0
-            current = container.selected_item()
-            if isinstance(current, MenuInput) and current.is_editing():
-                current.inc_value(fast_rate)
-            else:
-                if self._reverse_navigation is True:
-                    container.select_prev()  # reverse
-                else:
-                    container.select_next()  # normal
-
-    def back(self, force=False, update=True):
-        container = self.stack_peek()
-        if self.running and isinstance(container, MenuContainer):
-            self.timer = 0
-            current = container.selected_item()
-            if isinstance(current, MenuInput) and current.is_editing():
-                if force is True:
-                    current.stop_editing()
-                else:
-                    return
-            parent = self.stack_peek(1)
-            if isinstance(parent, MenuContainer):
-                self.stack_pop(update)
-                index = parent.index_of(container, True)
-                if index is not None:
-                    parent.select_at(index)
-                elif parent.selected_item() is None:
-                    parent.init_selection()
-
-            else:
-                self.stack_pop()
-                self.running = False
-
-    def exit(self, force=False):
-        container = self.stack_peek()
-        if self.running and isinstance(container, MenuContainer):
-            self.timer = 0
-            current = container.selected_item()
-            if (not force and isinstance(current, MenuInput)
-                    and current.is_editing()):
-                return
-            if isinstance(container, MenuList):
-                container.run_script('leave')
-            self.send_event('exit', self)
-            self.running = False
-
-    def push_container(self, menu):
-        container = self.stack_peek()
-        if self.running and isinstance(container, MenuContainer):
-            if (isinstance(menu, MenuContainer)
-                    and not container.is_editing()
-                    and menu is not container):
-                self.stack_push(menu)
-                return True
-        return False
-
-    def press(self, event='click'):
-        container = self.stack_peek()
-        if self.running and isinstance(container, MenuContainer):
-            self.timer = 0
-            current = container.selected_item()
-            if isinstance(current, MenuContainer):
-                self.stack_push(current)
-            elif isinstance(current, MenuInput):
-                if current.is_editing():
-                    current.run_script('gcode', event=event)
-                current.run_script(event)
-            elif isinstance(current, MenuCommand):
-                current.run_script('gcode', event=event)
-                current.run_script(event)
-            else:
-                # current is None, no selection. passthru to container
-                container.run_script(event)
-
-    def queue_gcode(self, script):
-        if not script:
-            return
-        if not self.gcode_queue:
-            reactor = self.printer.get_reactor()
-            reactor.register_callback(self.dispatch_gcode)
-        self.gcode_queue.append(script)
-
-    def dispatch_gcode(self, eventtime):
-        while self.gcode_queue:
-            script = self.gcode_queue[0]
-            try:
-                self.gcode.run_script(script)
-            except Exception:
-                logging.exception("Script running error")
-            self.gcode_queue.pop(0)
-
-    def menuitem_from(self, type, **kwargs):
-        if type not in menu_items:
-            raise error("Choice '%s' for option '%s'"
-                        " is not a valid choice" % (type, menu_items))
-        return menu_items[type](self, None, **kwargs)
-
-    def add_menuitem(self, name, item):
-        existing_item = False
-        if name in self.menuitems:
-            existing_item = True
-            logging.info(
-                "Declaration of '%s' hides "
-                "previous menuitem declaration" % (name,))
-        self.menuitems[name] = item
-        if isinstance(item, MenuElement):
-            parent = item.get_ns('..')
-            if parent and not existing_item:
-                if item.index is not None:
-                    self.children.setdefault(parent, []).insert(
-                        item.index, item.get_ns())
-                else:
-                    self.children.setdefault(parent, []).append(
-                        item.get_ns())
-
-    def lookup_menuitem(self, name, default=sentinel):
-        if name is None:
-            return None
-        if name in self.menuitems:
-            return self.menuitems[name]
-        if default is sentinel:
-            raise self.printer.config_error(
-                "Unknown menuitem '%s'" % (name,))
-        return default
-
-    def lookup_children(self, ns):
-        if ns in self.children:
-            return list(self.children[ns])
-        return list()
-
-    def load_config(self, *args):
-        cfg = None
-        filename = os.path.join(*args)
-        try:
-            cfg = self.pconfig.read_config(filename)
-        except Exception:
-            raise self.printer.config_error(
-                "Cannot load config '%s'" % (filename,))
-        if cfg:
-            self.load_menuitems(cfg)
-        return cfg
-
-    def load_menuitems(self, config):
-        for cfg in config.get_prefix_sections('menu '):
-            type = cfg.get('type')
-            if type not in menu_items:
-                raise error("Choice '%s' for option '%s'"
-                            " is not a valid choice" % (type, menu_items))
-            item = menu_items[type](self, cfg)
-            self.add_menuitem(item.get_ns(), item)
-
-    def _click_callback(self, eventtime, event):
-        if self.is_running():
-            self.press(event)
-        else:
-            # lets start and populate the menu items
-            self.begin(eventtime)
-
-    def key_event(self, key, eventtime):
-        if key == 'click':
-            self._click_callback(eventtime, key)
-        elif key == 'long_click':
-            self._click_callback(eventtime, key)
-        elif key == 'up':
-            self.up(False)
-        elif key == 'fast_up':
-            self.up(True)
-        elif key == 'down':
-            self.down(False)
-        elif key == 'fast_down':
-            self.down(True)
-        elif key == 'back':
-            self.back()
-        self.display.request_redraw()
-
-    # Collection of manager class helper methods
-
-    @classmethod
-    def stripliterals(cls, s):
-        """Literals are beginning or ending by the double or single quotes"""
-        s = str(s)
-        if (s.startswith('"') and s.endswith('"')) or \
-                (s.startswith("'") and s.endswith("'")):
-            s = s[1:-1]
-        return s
-
-    @classmethod
-    def aslatin(cls, s):
-        if isinstance(s, str):
-            return s
-        elif isinstance(s, unicode):
-            return unicode(s).encode('latin-1', 'ignore')
-        else:
-            return str(s)
-
-    @classmethod
-    def asflat(cls, s):
-        return cls.stripliterals(''.join(cls.aslatin(s).splitlines()))
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/display/st7920.py crealityShit/klippy/extras/display/st7920.py
--- klipperStock/klippy/extras/display/st7920.py	2024-01-14 23:01:59.461788252 -0600
+++ crealityShit/klippy/extras/display/st7920.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,257 +0,0 @@
-# Support for ST7920 (128x64 graphics) LCD displays
-#
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-from .. import bus
-from . import font8x14
-
-BACKGROUND_PRIORITY_CLOCK = 0x7fffffff00000000
-
-# Spec says 72us, but faster is possible in practice
-ST7920_CMD_DELAY  = .000020
-ST7920_SYNC_DELAY = .000045
-
-TextGlyphs = { 'right_arrow': b'\x1a' }
-CharGlyphs = { 'degrees': bytearray(font8x14.VGA_FONT[0xf8]) }
-
-class DisplayBase:
-    def __init__(self):
-        # framebuffers
-        self.text_framebuffer = bytearray(b' '*64)
-        self.glyph_framebuffer = bytearray(128)
-        self.graphics_framebuffers = [bytearray(32) for i in range(32)]
-        self.all_framebuffers = [
-            # Text framebuffer
-            (self.text_framebuffer, bytearray(b'~'*64), 0x80),
-            # Glyph framebuffer
-            (self.glyph_framebuffer, bytearray(b'~'*128), 0x40),
-            # Graphics framebuffers
-            ] + [(self.graphics_framebuffers[i], bytearray(b'~'*32), i)
-                 for i in range(32)]
-        self.cached_glyphs = {}
-        self.icons = {}
-    def flush(self):
-        # Find all differences in the framebuffers and send them to the chip
-        for new_data, old_data, fb_id in self.all_framebuffers:
-            if new_data == old_data:
-                continue
-            # Find the position of all changed bytes in this framebuffer
-            diffs = [[i, 1] for i, (n, o) in enumerate(zip(new_data, old_data))
-                     if n != o]
-            # Batch together changes that are close to each other
-            for i in range(len(diffs)-2, -1, -1):
-                pos, count = diffs[i]
-                nextpos, nextcount = diffs[i+1]
-                if pos + 5 >= nextpos and nextcount < 16:
-                    diffs[i][1] = nextcount + (nextpos - pos)
-                    del diffs[i+1]
-            # Transmit changes
-            for pos, count in diffs:
-                count += pos & 0x01
-                count += count & 0x01
-                pos = pos & ~0x01
-                chip_pos = pos >> 1
-                if fb_id < 0x40:
-                    # Graphics framebuffer update
-                    self.send([0x80 + fb_id, 0x80 + chip_pos], is_extended=True)
-                else:
-                    self.send([fb_id + chip_pos])
-                self.send(new_data[pos:pos+count], is_data=True)
-            old_data[:] = new_data
-    def init(self):
-        cmds = [0x24, # Enter extended mode
-                0x40, # Clear vertical scroll address
-                0x02, # Enable CGRAM access
-                0x26, # Enable graphics
-                0x22, # Leave extended mode
-                0x02, # Home the display
-                0x06, # Set positive update direction
-                0x0c] # Enable display and hide cursor
-        self.send(cmds)
-        self.flush()
-    def cache_glyph(self, glyph_name, base_glyph_name, glyph_id):
-        icon = self.icons.get(glyph_name)
-        base_icon = self.icons.get(base_glyph_name)
-        if icon is None or base_icon is None:
-            return
-        all_bits = zip(icon[0], icon[1], base_icon[0], base_icon[1])
-        for i, (ic1, ic2, b1, b2) in enumerate(all_bits):
-            x1, x2 = ic1 ^ b1, ic2 ^ b2
-            pos = glyph_id*32 + i*2
-            self.glyph_framebuffer[pos:pos+2] = [x1, x2]
-            self.all_framebuffers[1][1][pos:pos+2] = [x1 ^ 1, x2 ^ 1]
-        self.cached_glyphs[glyph_name] = (base_glyph_name, (0, glyph_id*2))
-    def set_glyphs(self, glyphs):
-        for glyph_name, glyph_data in glyphs.items():
-            icon = glyph_data.get('icon16x16')
-            if icon is not None:
-                self.icons[glyph_name] = icon
-        # Setup animated glyphs
-        self.cache_glyph('fan2', 'fan1', 0)
-        self.cache_glyph('bed_heat2', 'bed_heat1', 1)
-    def write_text(self, x, y, data):
-        if x + len(data) > 16:
-            data = data[:16 - min(x, 16)]
-        pos = [0, 32, 16, 48][y] + x
-        self.text_framebuffer[pos:pos+len(data)] = data
-    def write_graphics(self, x, y, data):
-        if x >= 16 or y >= 4 or len(data) != 16:
-            return
-        gfx_fb = y * 16
-        if gfx_fb >= 32:
-            gfx_fb -= 32
-            x += 16
-        for i, bits in enumerate(data):
-            self.graphics_framebuffers[gfx_fb + i][x] = bits
-    def write_glyph(self, x, y, glyph_name):
-        glyph_id = self.cached_glyphs.get(glyph_name)
-        if glyph_id is not None and x & 1 == 0:
-            # Render cached icon using character generator
-            glyph_name = glyph_id[0]
-            self.write_text(x, y, glyph_id[1])
-        icon = self.icons.get(glyph_name)
-        if icon is not None:
-            # Draw icon in graphics mode
-            self.write_graphics(x, y, icon[0])
-            self.write_graphics(x + 1, y, icon[1])
-            return 2
-        char = TextGlyphs.get(glyph_name)
-        if char is not None:
-            # Draw character
-            self.write_text(x, y, char)
-            return 1
-        font = CharGlyphs.get(glyph_name)
-        if font is not None:
-            # Draw single width character
-            self.write_graphics(x, y, font)
-            return 1
-        return 0
-    def clear(self):
-        self.text_framebuffer[:] = b' '*64
-        zeros = bytearray(32)
-        for gfb in self.graphics_framebuffers:
-            gfb[:] = zeros
-    def get_dimensions(self):
-        return (16, 4)
-
-# Display driver for stock ST7920 displays
-class ST7920(DisplayBase):
-    def __init__(self, config):
-        printer = config.get_printer()
-        # pin config
-        ppins = printer.lookup_object('pins')
-        pins = [ppins.lookup_pin(config.get(name + '_pin'))
-                for name in ['cs', 'sclk', 'sid']]
-        mcu = None
-        for pin_params in pins:
-            if mcu is not None and pin_params['chip'] != mcu:
-                raise ppins.error("st7920 all pins must be on same mcu")
-            mcu = pin_params['chip']
-        self.pins = [pin_params['pin'] for pin_params in pins]
-        # prepare send functions
-        self.mcu = mcu
-        self.oid = self.mcu.create_oid()
-        self.mcu.register_config_callback(self.build_config)
-        self.send_data_cmd = self.send_cmds_cmd = None
-        self.is_extended = False
-        # init display base
-        DisplayBase.__init__(self)
-    def build_config(self):
-        # configure send functions
-        self.mcu.add_config_cmd(
-            "config_st7920 oid=%u cs_pin=%s sclk_pin=%s sid_pin=%s"
-            " sync_delay_ticks=%d cmd_delay_ticks=%d" % (
-                self.oid, self.pins[0], self.pins[1], self.pins[2],
-                self.mcu.seconds_to_clock(ST7920_SYNC_DELAY),
-                self.mcu.seconds_to_clock(ST7920_CMD_DELAY)))
-        cmd_queue = self.mcu.alloc_command_queue()
-        self.send_cmds_cmd = self.mcu.lookup_command(
-            "st7920_send_cmds oid=%c cmds=%*s", cq=cmd_queue)
-        self.send_data_cmd = self.mcu.lookup_command(
-            "st7920_send_data oid=%c data=%*s", cq=cmd_queue)
-    def send(self, cmds, is_data=False, is_extended=False):
-        cmd_type = self.send_cmds_cmd
-        if is_data:
-            cmd_type = self.send_data_cmd
-        elif self.is_extended != is_extended:
-            add_cmd = 0x22
-            if is_extended:
-                add_cmd = 0x26
-            cmds = [add_cmd] + cmds
-            self.is_extended = is_extended
-        cmd_type.send([self.oid, cmds], reqclock=BACKGROUND_PRIORITY_CLOCK)
-        #logging.debug("st7920 %d %s", is_data, repr(cmds))
-
-# Helper code for toggling the en pin on startup
-class EnableHelper:
-    def __init__(self, pin_desc, spi):
-        self.en_pin = bus.MCU_bus_digital_out(spi.get_mcu(), pin_desc,
-                                              spi.get_command_queue())
-    def init(self):
-        mcu = self.en_pin.get_mcu()
-        curtime = mcu.get_printer().get_reactor().monotonic()
-        print_time = mcu.estimated_print_time(curtime)
-        # Toggle enable pin
-        minclock = mcu.print_time_to_clock(print_time + .100)
-        self.en_pin.update_digital_out(0, minclock=minclock)
-        minclock = mcu.print_time_to_clock(print_time + .200)
-        self.en_pin.update_digital_out(1, minclock=minclock)
-        # Force a delay to any subsequent commands on the command queue
-        minclock = mcu.print_time_to_clock(print_time + .300)
-        self.en_pin.update_digital_out(1, minclock=minclock)
-
-# Display driver for displays that emulate the ST7920 in software.
-# These displays rely on the CS pin to be toggled in order to initialize the
-# SPI correctly. This display driver uses a software SPI with an unused pin
-# as the MISO pin.
-class EmulatedST7920(DisplayBase):
-    def __init__(self, config):
-        # create software spi
-        ppins = config.get_printer().lookup_object('pins')
-        sw_pin_names = ['spi_software_%s_pin' % (name,)
-                        for name in ['miso', 'mosi', 'sclk']]
-        sw_pin_params = [ppins.lookup_pin(config.get(name), share_type=name)
-                         for name in sw_pin_names]
-        mcu = None
-        for pin_params in sw_pin_params:
-            if mcu is not None and pin_params['chip'] != mcu:
-                raise ppins.error("%s: spi pins must be on same mcu" % (
-                    config.get_name(),))
-            mcu = pin_params['chip']
-        sw_pins = tuple([pin_params['pin'] for pin_params in sw_pin_params])
-        speed = config.getint('spi_speed', 1000000, minval=100000)
-        self.spi = bus.MCU_SPI(mcu, None, None, 0, speed, sw_pins)
-        # create enable helper
-        self.en_helper = EnableHelper(config.get("en_pin"), self.spi)
-        self.en_set = False
-        # init display base
-        self.is_extended = False
-        DisplayBase.__init__(self)
-    def send(self, cmds, is_data=False, is_extended=False):
-        # setup sync byte and check for exten mode switch
-        sync_byte = 0xfa
-        if not is_data:
-            sync_byte = 0xf8
-            if self.is_extended != is_extended:
-                add_cmd = 0x22
-                if is_extended:
-                    add_cmd = 0x26
-                cmds = [add_cmd] + cmds
-                self.is_extended = is_extended
-        # copy data to ST7920 data format
-        spi_data = [0] * (2 * len(cmds) + 1)
-        spi_data[0] = sync_byte
-        i = 1
-        for b in cmds:
-            spi_data[i] = b & 0xF0
-            spi_data[i + 1] = (b & 0x0F) << 4
-            i = i + 2
-        # check if enable pin has been set
-        if not self.en_set:
-            self.en_helper.init()
-            self.en_set = True
-        # send data
-        self.spi.spi_send(spi_data, reqclock=BACKGROUND_PRIORITY_CLOCK)
-        #logging.debug("st7920 %s", repr(spi_data))
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/display/uc1701.py crealityShit/klippy/extras/display/uc1701.py
--- klipperStock/klippy/extras/display/uc1701.py	2024-01-14 23:01:59.461788252 -0600
+++ crealityShit/klippy/extras/display/uc1701.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,240 +0,0 @@
-# Support for UC1701 (and similar) 128x64 graphics LCD displays
-#
-# Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-# Copyright (C) 2018  Eric Callahan  <arksine.code@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-from .. import bus
-from . import font8x14
-
-BACKGROUND_PRIORITY_CLOCK = 0x7fffffff00000000
-
-TextGlyphs = { 'right_arrow': b'\x1a', 'degrees': b'\xf8' }
-
-class DisplayBase:
-    def __init__(self, io, columns=128, x_offset=0):
-        self.send = io.send
-        # framebuffers
-        self.columns = columns
-        self.x_offset = x_offset
-        self.vram = [bytearray(self.columns) for i in range(8)]
-        self.all_framebuffers = [(self.vram[i], bytearray(b'~'*self.columns), i)
-                                 for i in range(8)]
-        # Cache fonts and icons in display byte order
-        self.font = [self._swizzle_bits(bytearray(c))
-                     for c in font8x14.VGA_FONT]
-        self.icons = {}
-    def flush(self):
-        # Find all differences in the framebuffers and send them to the chip
-        for new_data, old_data, page in self.all_framebuffers:
-            if new_data == old_data:
-                continue
-            # Find the position of all changed bytes in this framebuffer
-            diffs = [[i, 1] for i, (n, o) in enumerate(zip(new_data, old_data))
-                     if n != o]
-            # Batch together changes that are close to each other
-            for i in range(len(diffs)-2, -1, -1):
-                pos, count = diffs[i]
-                nextpos, nextcount = diffs[i+1]
-                if pos + 5 >= nextpos and nextcount < 16:
-                    diffs[i][1] = nextcount + (nextpos - pos)
-                    del diffs[i+1]
-            # Transmit changes
-            for col_pos, count in diffs:
-                # Set Position registers
-                ra = 0xb0 | (page & 0x0F)
-                ca_msb = 0x10 | ((col_pos >> 4) & 0x0F)
-                ca_lsb = col_pos & 0x0F
-                self.send([ra, ca_msb, ca_lsb])
-                # Send Data
-                self.send(new_data[col_pos:col_pos+count], is_data=True)
-            old_data[:] = new_data
-    def _swizzle_bits(self, data):
-        # Convert from "rows of pixels" format to "columns of pixels"
-        top = bot = 0
-        for row in range(8):
-            spaced = (data[row] * 0x8040201008040201) & 0x8080808080808080
-            top |= spaced >> (7 - row)
-            spaced = (data[row + 8] * 0x8040201008040201) & 0x8080808080808080
-            bot |= spaced >> (7 - row)
-        bits_top = [(top >> s) & 0xff for s in range(0, 64, 8)]
-        bits_bot = [(bot >> s) & 0xff for s in range(0, 64, 8)]
-        return (bytearray(bits_top), bytearray(bits_bot))
-    def set_glyphs(self, glyphs):
-        for glyph_name, glyph_data in glyphs.items():
-            icon = glyph_data.get('icon16x16')
-            if icon is not None:
-                top1, bot1 = self._swizzle_bits(icon[0])
-                top2, bot2 = self._swizzle_bits(icon[1])
-                self.icons[glyph_name] = (top1 + top2, bot1 + bot2)
-    def write_text(self, x, y, data):
-        if x + len(data) > 16:
-            data = data[:16 - min(x, 16)]
-        pix_x = x * 8
-        pix_x += self.x_offset
-        page_top = self.vram[y * 2]
-        page_bot = self.vram[y * 2 + 1]
-        for c in bytearray(data):
-            bits_top, bits_bot = self.font[c]
-            page_top[pix_x:pix_x+8] = bits_top
-            page_bot[pix_x:pix_x+8] = bits_bot
-            pix_x += 8
-    def write_graphics(self, x, y, data):
-        if x >= 16 or y >= 4 or len(data) != 16:
-            return
-        bits_top, bits_bot = self._swizzle_bits(data)
-        pix_x = x * 8
-        pix_x += self.x_offset
-        page_top = self.vram[y * 2]
-        page_bot = self.vram[y * 2 + 1]
-        for i in range(8):
-            page_top[pix_x + i] ^= bits_top[i]
-            page_bot[pix_x + i] ^= bits_bot[i]
-    def write_glyph(self, x, y, glyph_name):
-        icon = self.icons.get(glyph_name)
-        if icon is not None and x < 15:
-            # Draw icon in graphics mode
-            pix_x = x * 8
-            pix_x += self.x_offset
-            page_idx = y * 2
-            self.vram[page_idx][pix_x:pix_x+16] = icon[0]
-            self.vram[page_idx + 1][pix_x:pix_x+16] = icon[1]
-            return 2
-        char = TextGlyphs.get(glyph_name)
-        if char is not None:
-            # Draw character
-            self.write_text(x, y, char)
-            return 1
-        return 0
-    def clear(self):
-        zeros = bytearray(self.columns)
-        for page in self.vram:
-            page[:] = zeros
-    def get_dimensions(self):
-        return (16, 4)
-
-# IO wrapper for "4 wire" spi bus (spi bus with an extra data/control line)
-class SPI4wire:
-    def __init__(self, config, data_pin_name):
-        self.spi = bus.MCU_SPI_from_config(config, 0, default_speed=10000000)
-        dc_pin = config.get(data_pin_name)
-        self.mcu_dc = bus.MCU_bus_digital_out(self.spi.get_mcu(), dc_pin,
-                                              self.spi.get_command_queue())
-    def send(self, cmds, is_data=False):
-        self.mcu_dc.update_digital_out(is_data,
-                                       reqclock=BACKGROUND_PRIORITY_CLOCK)
-        self.spi.spi_send(cmds, reqclock=BACKGROUND_PRIORITY_CLOCK)
-
-# IO wrapper for i2c bus
-class I2C:
-    def __init__(self, config, default_addr):
-        self.i2c = bus.MCU_I2C_from_config(config, default_addr=default_addr,
-                                           default_speed=400000)
-    def send(self, cmds, is_data=False):
-        if is_data:
-            hdr = 0x40
-        else:
-            hdr = 0x00
-        cmds = bytearray(cmds)
-        cmds.insert(0, hdr)
-        self.i2c.i2c_write(cmds, reqclock=BACKGROUND_PRIORITY_CLOCK)
-
-# Helper code for toggling a reset pin on startup
-class ResetHelper:
-    def __init__(self, pin_desc, io_bus):
-        self.mcu_reset = None
-        if pin_desc is None:
-            return
-        self.mcu_reset = bus.MCU_bus_digital_out(io_bus.get_mcu(), pin_desc,
-                                                 io_bus.get_command_queue())
-    def init(self):
-        if self.mcu_reset is None:
-            return
-        mcu = self.mcu_reset.get_mcu()
-        curtime = mcu.get_printer().get_reactor().monotonic()
-        print_time = mcu.estimated_print_time(curtime)
-        # Toggle reset
-        minclock = mcu.print_time_to_clock(print_time + .100)
-        self.mcu_reset.update_digital_out(0, minclock=minclock)
-        minclock = mcu.print_time_to_clock(print_time + .200)
-        self.mcu_reset.update_digital_out(1, minclock=minclock)
-        # Force a delay to any subsequent commands on the command queue
-        minclock = mcu.print_time_to_clock(print_time + .300)
-        self.mcu_reset.update_digital_out(1, minclock=minclock)
-
-# The UC1701 is a "4-wire" SPI display device
-class UC1701(DisplayBase):
-    def __init__(self, config):
-        io = SPI4wire(config, "a0_pin")
-        DisplayBase.__init__(self, io)
-        self.contrast = config.getint('contrast', 40, minval=0, maxval=63)
-        self.reset = ResetHelper(config.get("rst_pin", None), io.spi)
-    def init(self):
-        self.reset.init()
-        init_cmds = [0xE2, # System reset
-                     0x40, # Set display to start at line 0
-                     0xA0, # Set SEG direction
-                     0xC8, # Set COM Direction
-                     0xA2, # Set Bias = 1/9
-                     0x2C, # Boost ON
-                     0x2E, # Voltage regulator on
-                     0x2F, # Voltage follower on
-                     0xF8, # Set booster ratio
-                     0x00, # Booster ratio value (4x)
-                     0x23, # Set resistor ratio (3)
-                     0x81, # Set Electronic Volume
-                     self.contrast, # Electronic Volume value
-                     0xAC, # Set static indicator off
-                     0x00, # NOP
-                     0xA6, # Disable Inverse
-                     0xAF] # Set display enable
-        self.send(init_cmds)
-        self.send([0xA5]) # display all
-        self.send([0xA4]) # normal display
-        self.flush()
-
-# The SSD1306 supports both i2c and "4-wire" spi
-class SSD1306(DisplayBase):
-    def __init__(self, config, columns=128, x_offset=0):
-        cs_pin = config.get("cs_pin", None)
-        if cs_pin is None:
-            io = I2C(config, 60)
-            io_bus = io.i2c
-        else:
-            io = SPI4wire(config, "dc_pin")
-            io_bus = io.spi
-        self.reset = ResetHelper(config.get("reset_pin", None), io_bus)
-        DisplayBase.__init__(self, io, columns, x_offset)
-        self.contrast = config.getint('contrast', 239, minval=0, maxval=255)
-        self.vcomh = config.getint('vcomh', 0, minval=0, maxval=63)
-        self.invert = config.getboolean('invert', False)
-    def init(self):
-        self.reset.init()
-        init_cmds = [
-            0xAE,       # Display off
-            0xD5, 0x80, # Set oscillator frequency
-            0xA8, 0x3f, # Set multiplex ratio
-            0xD3, 0x00, # Set display offset
-            0x40,       # Set display start line
-            0x8D, 0x14, # Charge pump setting
-            0x20, 0x02, # Set Memory addressing mode
-            0xA1,       # Set Segment re-map
-            0xC8,       # Set COM output scan direction
-            0xDA, 0x12, # Set COM pins hardware configuration
-            0x81, self.contrast, # Set contrast control
-            0xD9, 0xA1, # Set pre-charge period
-            0xDB, self.vcomh, # Set VCOMH deselect level
-            0x2E,       # Deactivate scroll
-            0xA4,       # Output ram to display
-            0xA7 if self.invert else 0xA6, # Set normal/invert
-            0xAF,       # Display on
-        ]
-        self.send(init_cmds)
-        self.flush()
-
-# the SH1106 is SSD1306 compatible with up to 132 columns
-class SH1106(SSD1306):
-    def __init__(self, config):
-        x_offset = config.getint('x_offset', 0, minval=0, maxval=3)
-        SSD1306.__init__(self, config, 132, x_offset=x_offset)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/ds18b20.py crealityShit/klippy/extras/ds18b20.py
--- klipperStock/klippy/extras/ds18b20.py	2024-01-14 23:01:59.441788007 -0600
+++ crealityShit/klippy/extras/ds18b20.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,80 +0,0 @@
-# Support for 1-wire based temperature sensors
-#
-# Copyright (C) 2020 Alan Lord <alanslists@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-import mcu
-
-DS18_REPORT_TIME = 3.0
-# Temperature can be sampled at any time but conversion time is ~750ms, so
-# setting the time too low will not make the reports come faster.
-DS18_MIN_REPORT_TIME = 1.0
-DS18_MAX_CONSECUTIVE_ERRORS = 4
-
-class DS18B20:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.name = config.get_name().split()[-1]
-        self.sensor_id = bytearray(config.get("serial_no").encode())
-        self.temp = self.min_temp = self.max_temp = 0.0
-        self._report_clock = 0
-        self.report_time = config.getfloat(
-            'ds18_report_time',
-            DS18_REPORT_TIME,
-            minval=DS18_MIN_REPORT_TIME
-        )
-        self._mcu = mcu.get_printer_mcu(self.printer, config.get('sensor_mcu'))
-        self.oid = self._mcu.create_oid()
-        self._mcu.register_response(self._handle_ds18b20_response,
-            "ds18b20_result", self.oid)
-        self._mcu.register_config_callback(self._build_config)
-
-    def _build_config(self):
-        sid = "".join(["%02x" % (x,) for x in self.sensor_id])
-        self._mcu.add_config_cmd(
-            "config_ds18b20 oid=%d serial=%s max_error_count=%d"
-            % (self.oid, sid, DS18_MAX_CONSECUTIVE_ERRORS))
-
-        clock = self._mcu.get_query_slot(self.oid)
-        self._report_clock = self._mcu.seconds_to_clock(self.report_time)
-        self._mcu.add_config_cmd("query_ds18b20 oid=%d clock=%u rest_ticks=%u"
-            " min_value=%d max_value=%d" % (
-                self.oid, clock, self._report_clock,
-                self.min_temp * 1000, self.max_temp * 1000), is_init=True)
-
-    def _handle_ds18b20_response(self, params):
-        temp = params['value'] / 1000.0
-
-        if params["fault"]:
-            logging.info("ds18b20 reports fault %d (temp=%0.1f)",
-                         params["fault"], temp)
-            return
-
-        next_clock      = self._mcu.clock32_to_clock64(params['next_clock'])
-        last_read_clock = next_clock - self._report_clock
-        last_read_time  = self._mcu.clock_to_print_time(last_read_clock)
-        self._callback(last_read_time, temp)
-
-    def setup_minmax(self, min_temp, max_temp):
-        self.min_temp = min_temp
-        self.max_temp = max_temp
-
-    def fault(self, msg):
-        self.printer.invoke_async_shutdown(msg)
-
-    def get_report_time_delta(self):
-        return self.report_time
-
-    def setup_callback(self, cb):
-        self._callback = cb
-
-    def get_status(self, eventtime):
-        return {
-            'temperature': round(self.temp, 2),
-        }
-
-def load_config(config):
-    # Register sensor
-    pheaters = config.get_printer().load_object(config, "heaters")
-    pheaters.add_sensor_factory("DS18B20", DS18B20)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/endstop_phase.py crealityShit/klippy/extras/endstop_phase.py
--- klipperStock/klippy/extras/endstop_phase.py	2024-01-14 23:01:59.473788399 -0600
+++ crealityShit/klippy/extras/endstop_phase.py	2024-01-14 23:02:21.670060464 -0600
@@ -70,8 +70,9 @@
         if trigger_phase is not None:
             p, ps = config.getintlist('trigger_phase', sep='/', count=2)
             if p >= ps:
-                raise config.error("Invalid trigger_phase '%s'"
-                                   % (trigger_phase,))
+                raise config.error(
+                                    """{"code":"key157", "msg": "Invalid trigger_phase '%s'", "values": ["%s"]}""" % (trigger_phase, trigger_phase)
+                                   )
             self.endstop_phase = self.phase_calc.convert_phase(p, ps)
         self.endstop_align_zero = config.getboolean('endstop_align_zero', False)
         self.endstop_accuracy = config.getfloat('endstop_accuracy', None,
@@ -86,8 +87,11 @@
             self.endstop_phase_accuracy = int(
                 math.ceil(self.endstop_accuracy / self.step_dist))
         if self.endstop_phase_accuracy >= self.phases // 2:
-            raise config.error("Endstop for %s is not accurate enough for"
-                               " stepper phase adjustment" % (self.name,))
+            raise config.error(
+                               """{"code":"key158", "msg": "Endstop for %s is not accurate enough for stepper phase adjustment", "values": ["%s"]}""" % (
+                                   self.name, self.name
+                               )
+                               )
         if self.printer.get_start_args().get('debugoutput') is not None:
             self.endstop_phase_accuracy = self.phases
     def align_endstop(self, rail):
@@ -112,8 +116,10 @@
             delta -= self.phases
         elif delta > self.endstop_phase_accuracy:
             raise self.printer.command_error(
-                "Endstop %s incorrect phase (got %d vs %d)" % (
-                    self.name, phase, self.endstop_phase))
+                """{"code":"key161", "msg": "Endstop %s incorrect phase (got %d vs %d)", "values": ["%s", %d, %d]}""" % (
+                    self.name, phase, self.endstop_phase, self.name, phase, self.endstop_phase
+                )
+            )
         return delta * self.step_dist
     def handle_home_rails_end(self, homing_state, rails):
         for rail in rails:
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/fan_feedback.py crealityShit/klippy/extras/fan_feedback.py
--- klipperStock/klippy/extras/fan_feedback.py	1969-12-31 18:00:00.000000000 -0600
+++ crealityShit/klippy/extras/fan_feedback.py	2024-01-14 23:02:21.690060709 -0600
@@ -0,0 +1,116 @@
+import logging
+
+
+class FanFeedback:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+
+        self.print_delay_time = config.getfloat('print_delay_time', 5.)
+        self.current_delay_time = config.getfloat('current_delay_time', 2.)
+
+        ppins = self.printer.lookup_object('pins')
+
+        self.params = []
+        fan_num = 0
+        for i in range(0, 5):
+            sensor_pin = config.get("fan%d_pin" % i, None)
+            # logging.info("fan feedback sensor_pin: %s" % sensor_pin)
+            if not sensor_pin:
+                continue
+            pin_params = ppins.lookup_pin(sensor_pin, can_invert=False, can_pullup=True)
+            mcu = pin_params['chip']
+            oid = mcu.create_oid()
+            config_cmd = "config_fancheck oid=%d fan_num=%d fan0_pin=%s pull_up0=%s" \
+                         " fan1_pin=%s pull_up1=%s fan2_pin=%s pull_up2=%s fan3_pin=%s" \
+                         " pull_up3=%s fan4_pin=%s pull_up4=%s" % (
+                oid, 5,
+                pin_params['pin'], pin_params["pullup"],
+                pin_params['pin'], pin_params["pullup"],
+                pin_params['pin'], pin_params["pullup"],
+                pin_params['pin'], pin_params["pullup"],
+                pin_params['pin'], pin_params["pullup"]
+            )
+            if fan_num == 0:
+                mcu.register_response(self._handle_result_fan_check0, "fan_status", oid)
+            elif fan_num == 1:
+                mcu.register_response(self._handle_result_fan_check1, "fan_status", oid)
+            fan_num += 1
+            param = i, config_cmd, pin_params, mcu, oid
+            # logging.info("%s" % (config_cmd))
+            mcu.add_config_cmd(config_cmd)
+            self.params.append(param)
+        self.which_fan = 2**fan_num - 1
+        self.fan_num = fan_num
+
+        self.gcode = config.get_printer().lookup_object('gcode')
+        self.gcode.register_command("QUERY_FAN_CHECK", self.cmd_QUERY_FAN_CHECK, desc=self.cmd_QUERY_FAN_CHECK_help)
+        self.print_stats = self.printer.load_object(config, 'print_stats')
+        self.printer.register_event_handler("klippy:ready", self.handle_ready)
+        self.cx_fan_status = {}
+        webhooks = self.printer.lookup_object('webhooks')
+        webhooks.register_endpoint("get_cx_fan_status",
+                                   self._get_cx_fan_status)
+
+    def handle_ready(self):
+        reactor = self.printer.get_reactor()
+        reactor.register_timer(
+            self.cx_fan_status_update_event, reactor.monotonic()+1.)
+
+    def delay_s(self, delay_s):
+        toolhead = self.printer.lookup_object("toolhead")
+        reactor = self.printer.get_reactor()
+        eventtime = reactor.monotonic()
+        if not self.printer.is_shutdown():
+            toolhead.get_last_move_time()
+            eventtime = reactor.pause(eventtime + delay_s)
+            pass
+
+    def _get_cx_fan_status(self):
+        return self.cx_fan_status
+
+    def cx_fan_status_update_event(self, eventtime):
+        if self.print_stats.get_status(eventtime).get("state") != "printing":
+            next_time = eventtime + self.current_delay_time
+        else:
+            next_time = eventtime + self.print_delay_time
+        for i in self.params:
+            cmd = "query_fancheck oid=%c which_fan=%c"
+            oid = i[4]
+            mcu = i[3]
+            query_cmd = mcu.lookup_command(cmd, cq=None)
+            # log_cmd = "query_fancheck oid=%s which_fan=%s" % (oid, 31)
+            # logging.info("%s" % log_cmd)
+            query_cmd.send([oid, self.which_fan])
+        return next_time
+
+    cmd_QUERY_FAN_CHECK_help = "Check CXSW Special Fan Status"
+    def cmd_QUERY_FAN_CHECK(self, gcmd):
+        self.gcode.respond_info("%s" % self.cx_fan_status)
+
+    def _handle_result_fan_check0(self, params):
+        # logging.info("_handle_result_fan_check0: %s" % params)
+        # self.cx_fan_status["fan0_speed"] = params.get("fan0_speed", 0)
+        self.cx_fan_status = {
+            "fan0_speed": params.get("fan0_speed", 0),
+            "fan1_speed": self.cx_fan_status.get("fan1_speed", 0),
+            "fan2_speed": self.cx_fan_status.get("fan2_speed", 0),
+            "fan3_speed": self.cx_fan_status.get("fan3_speed", 0),
+            "fan4_speed": self.cx_fan_status.get("fan4_speed", 0),
+        }
+
+    def _handle_result_fan_check1(self, params):
+        # logging.info("_handle_result_fan_check1: %s" % params)
+        # self.cx_fan_status["fan1_speed"] = params.get("fan1_speed", 0)
+        self.cx_fan_status = {
+            "fan0_speed": self.cx_fan_status.get("fan0_speed", 0),
+            "fan1_speed": params.get("fan1_speed", 0),
+            "fan2_speed": self.cx_fan_status.get("fan2_speed", 0),
+            "fan3_speed": self.cx_fan_status.get("fan3_speed", 0),
+            "fan4_speed": self.cx_fan_status.get("fan4_speed", 0),
+        }
+
+    def get_status(self, eventtime):
+        return self.cx_fan_status
+
+def load_config(config):
+    return FanFeedback(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/filament_switch_sensor.py crealityShit/klippy/extras/filament_switch_sensor.py
--- klipperStock/klippy/extras/filament_switch_sensor.py	2024-01-14 23:01:59.485788546 -0600
+++ crealityShit/klippy/extras/filament_switch_sensor.py	2024-01-14 23:02:21.694060758 -0600
@@ -71,7 +71,9 @@
             return
         # Determine "printing" status
         idle_timeout = self.printer.lookup_object("idle_timeout")
-        is_printing = idle_timeout.get_status(eventtime)["state"] == "Printing"
+        print_stats = self.printer.lookup_object('print_stats')
+        is_printing = print_stats.state == "printing"
+        # is_printing = idle_timeout.get_status(eventtime)["state"] == "Printing"
         # Perform filament action associated with status change (if any)
         if is_filament_present:
             if not is_printing and self.insert_gcode is not None:
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/filter.py crealityShit/klippy/extras/filter.py
--- klipperStock/klippy/extras/filter.py	1969-12-31 18:00:00.000000000 -0600
+++ crealityShit/klippy/extras/filter.py	2024-01-14 23:02:21.662060367 -0600
@@ -0,0 +1,125 @@
+# Support for 1-wire based temperature sensors
+#
+# Copyright (C) 2020 Alan Lord <alanslists@gmail.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+from logging import Filter
+from os import remove
+from time import time
+import mcu
+import math
+
+
+class RCTFilter:
+    def __init__(self):
+        pass
+
+    def ftr_val(self, vals):
+        out_vals = []
+        if len(vals) < 3:
+            return vals
+        for i in range(len(vals) - 2):   
+            tmp = [math.fabs(vals[i]), math.fabs(vals[i + 1]), math.fabs(vals[i + 2])]
+            index = tmp.index(min(tmp))
+            out_vals.append(vals[index + i])
+        out_vals.append(vals[-2])
+        out_vals.append(vals[-1])
+        return out_vals
+
+
+class RCHFilter:
+    def __init__(self, cut_frq_hz, acq_frq_hz):
+        self.cut_frq_hz = cut_frq_hz
+        self.acq_frq_hz = acq_frq_hz
+        pass
+
+    def ftr_val(self, vals):
+        out_vals = [0]
+        rc = 1. / 2. / math.pi / self.cut_frq_hz
+        coff = rc / (rc + 1. / self.acq_frq_hz)
+        for i in range(1, len(vals)):
+            out_vals.append((vals[i] - vals[i - 1] + out_vals[-1]) * coff)
+        return out_vals
+
+
+class RCLFilter:
+    def __init__(self, k1_new):
+        self.k1_new = k1_new
+        pass
+
+    def ftr_val(self, vals):
+        out_vals = [vals[0]]
+        for i in range(1, len(vals)):
+            out_vals.append(out_vals[-1] * (1 - self.k1_new) + vals[i] * self.k1_new)
+        return out_vals
+
+
+class Filter:
+    def __init__(self, config):
+        self.hft_hz = config.getfloat('hft_hz', default=5, minval=0.1, maxval=10.)
+        self.lft_k1 = config.getfloat('lft_k1', default=0.8, minval=0., maxval=1.)
+        self.lft_k1_oft = config.getfloat('lft_k1_oft', default=0.8, minval=0., maxval=1.)
+        self.lft_k1_cal = config.getfloat('lft_k1_cal', default=0.8, minval=0., maxval=1.)
+        pass
+    
+    def get_tft(self):
+        return RCTFilter()
+
+    def get_lft(self, k1):
+        return RCLFilter(k1)
+
+    def get_hft(self, cut_hz, acq_hz):
+        return RCHFilter(cut_frq_hz=cut_hz, acq_frq_hz=acq_hz)
+
+    def cal_offset_by_vals(self, s_count, new_valss, lft_k1, cut_len):
+        out_vals = []
+        tmp_vals = [[], [], [], []]
+        tft = RCTFilter()
+        lft = RCLFilter(lft_k1)
+        for i in range(s_count):
+            tmp_vals[i] = tft.ftr_val(new_valss[i])
+            tmp_vals[i] = lft.ftr_val(tmp_vals[i])
+        for i in range(len(tmp_vals[0])):
+            sums = 0
+            for j in range(s_count):
+                if i < len(tmp_vals[j]):
+                    sums += math.fabs(tmp_vals[j][i])
+            out_vals.append(sums)
+        if len(out_vals) > cut_len:
+            del out_vals[0:(len(out_vals) - cut_len)]
+        for i in range(s_count):
+            if len(tmp_vals[i]) > cut_len:
+                del tmp_vals[i][0:(len(tmp_vals[i]) - cut_len)]
+            for j in range(len(tmp_vals[i])):
+                tmp_vals[i][j] = abs(tmp_vals[i][j])
+        return out_vals, tmp_vals
+
+
+    def cal_filter_by_vals(self, s_count, now_valss, hft_hz, lft_k1, cut_len):
+        out_vals = []
+        tmp_vals = [[], [], [], []]
+        tft = RCTFilter()
+        hft = RCHFilter(hft_hz, 80)
+        lft = RCLFilter(lft_k1)
+        for i in range(0, s_count):
+            tmp_vals[i] = tft.ftr_val(now_valss[i])
+            tmp_vals[i] = hft.ftr_val(tmp_vals[i])
+            tmp_vals[i] = lft.ftr_val(tmp_vals[i])
+        for i in range(len(tmp_vals[0])):
+            sums = 0
+            for j in range(s_count):
+                if i < len(tmp_vals[j]):
+                    sums += math.fabs(tmp_vals[j][i])
+            out_vals.append(sums)
+        if len(out_vals) > cut_len:
+            del out_vals[0:(len(out_vals) - cut_len)]
+        for i in range(s_count):
+            if len(tmp_vals[i]) > cut_len:
+                del tmp_vals[i][0:(len(tmp_vals[i]) - cut_len)]
+            for j in range(len(tmp_vals[i])):
+                tmp_vals[i][j] = abs(tmp_vals[i][j])
+        return out_vals, tmp_vals
+
+
+def load_config(config):
+    return Filter(config)
\ No newline at end of file
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/force_move.py crealityShit/klippy/extras/force_move.py
--- klipperStock/klippy/extras/force_move.py	2024-01-14 23:01:59.481788498 -0600
+++ crealityShit/klippy/extras/force_move.py	2024-01-14 23:02:21.682060611 -0600
@@ -53,7 +53,7 @@
         self.steppers[mcu_stepper.get_name()] = mcu_stepper
     def lookup_stepper(self, name):
         if name not in self.steppers:
-            raise self.printer.config_error("Unknown stepper %s" % (name,))
+            raise self.printer.config_error("""{"code":"key31", "msg":"Unknown stepper %s", "values": ["%s"]}""" % (name, name))
         return self.steppers[name]
     def _force_enable(self, stepper):
         toolhead = self.printer.lookup_object('toolhead')
@@ -94,7 +94,7 @@
     def _lookup_stepper(self, gcmd):
         name = gcmd.get('STEPPER')
         if name not in self.steppers:
-            raise gcmd.error("Unknown stepper %s" % (name,))
+            raise gcmd.error("""{"code":"key31", "msg":"Unknown stepper %s", "values": ["%s"]}""" % (name, name))
         return self.steppers[name]
     cmd_STEPPER_BUZZ_help = "Oscillate a given stepper to help id it"
     def cmd_STEPPER_BUZZ(self, gcmd):
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/gcode_macro.py crealityShit/klippy/extras/gcode_macro.py
--- klipperStock/klippy/extras/gcode_macro.py	2024-01-14 23:01:59.445788055 -0600
+++ crealityShit/klippy/extras/gcode_macro.py	2024-01-14 23:02:21.642060121 -0600
@@ -50,8 +50,11 @@
         try:
             self.template = env.from_string(script)
         except Exception as e:
-            msg = "Error loading template '%s': %s" % (
-                 name, traceback.format_exception_only(type(e), e)[-1])
+            # msg = "Error loading template '%s': %s" % (
+            #      name, traceback.format_exception_only(type(e), e)[-1])
+            msg = """{"code":"key164", "msg": "Error loading template '%s': %s", "values": ["%s", "%s"]}""" % (
+                name, traceback.format_exception_only(type(e), e)[-1], name, traceback.format_exception_only(type(e), e)[-1]
+            )
             logging.exception(msg)
             raise printer.config_error(msg)
     def render(self, context=None):
@@ -60,8 +63,12 @@
         try:
             return str(self.template.render(context))
         except Exception as e:
-            msg = "Error evaluating '%s': %s" % (
-                self.name, traceback.format_exception_only(type(e), e)[-1])
+            # msg = "Error evaluating '%s': %s" % (
+            #     self.name, traceback.format_exception_only(type(e), e)[-1])
+            msg = """{"code":"key165", "msg": "Error evaluating '%s': %s", "values": ["%s", "%s"]}""" % (
+                self.name, traceback.format_exception_only(type(e), e)[-1],
+                self.name, traceback.format_exception_only(type(e), e)[-1]
+            )
             logging.exception(msg)
             raise self.gcode.error(msg)
     def run_gcode_from_command(self, context=None):
@@ -80,7 +87,7 @@
             script = config.get(option, default)
         return TemplateWrapper(self.printer, self.env, name, script)
     def _action_emergency_stop(self, msg="action_emergency_stop"):
-        self.printer.invoke_shutdown("Shutdown due to %s" % (msg,))
+        self.printer.invoke_shutdown("""{"code":"key170", "msg": "Shutdown due to %s", "values": ["%s"]}""" % (msg, msg))
         return ""
     def _action_respond_info(self, msg):
         self.printer.lookup_object('gcode').respond_info(msg)
@@ -115,8 +122,12 @@
     def __init__(self, config):
         if len(config.get_name().split()) > 2:
             raise config.error(
-                    "Name of section '%s' contains illegal whitespace"
-                    % (config.get_name()))
+                    # "Name of section '%s' contains illegal whitespace"
+                    # % (config.get_name())
+                    """{"code":"key166", "msg": "Name of section '%s' contains illegal whitespace", "values": ["%s"]}""" % (
+                        config.get_name(), config.get_name(),
+                    )
+            )
         name = config.get_name().split()[1]
         self.alias = name.upper()
         self.printer = printer = config.get_printer()
@@ -129,8 +140,9 @@
             if (self.gcode.is_traditional_gcode(self.alias)
                 != self.gcode.is_traditional_gcode(self.rename_existing)):
                 raise config.error(
-                    "G-Code macro rename of different types ('%s' vs '%s')"
-                    % (self.alias, self.rename_existing))
+                    # "G-Code macro rename of different types ('%s' vs '%s')"
+                    """{"code":"key167", "msg": "G-Code macro rename of different types ('%s' vs '%s')", "values": ["%s", "%s"]}"""
+                    % (self.alias, self.rename_existing, self.alias, self.rename_existing))
             printer.register_event_handler("klippy:connect",
                                            self.handle_connect)
         else:
@@ -154,8 +166,10 @@
         prev_cmd = self.gcode.register_command(self.alias, None)
         if prev_cmd is None:
             raise self.printer.config_error(
-                "Existing command '%s' not found in gcode_macro rename"
-                % (self.alias,))
+                """{"code":"key169", "msg": "Existing command '%s' not found in gcode_macro rename", "values": ["%s"]}""" % (
+                    self.alias, self.alias
+                )
+            )
         pdesc = "Renamed builtin of '%s'" % (self.alias,)
         self.gcode.register_command(self.rename_existing, prev_cmd, desc=pdesc)
         self.gcode.register_command(self.alias, self.cmd, desc=self.cmd_desc)
@@ -174,9 +188,25 @@
         v = dict(self.variables)
         v[variable] = literal
         self.variables = v
+        try:
+            import os, json
+            if "z_safe_pause" in variable:
+                logging.info("SET_GCODE_VARIABLE variable:%s literal:%s" % (variable, literal))
+                v_sd = self.printer.lookup_object('virtual_sdcard', None)
+                if os.path.exists(v_sd.print_file_name_path):
+                    result = {}
+                    with open(v_sd.print_file_name_path, "r") as f:
+                        result = (json.loads(f.read()))
+                        result["variable_z_safe_pause"] = literal
+                    with open(v_sd.print_file_name_path, "w") as f:
+                        f.write(json.dumps(result))
+                        f.flush()
+        except Exception as err:
+            logging.error("SET_GCODE_VARIABLE save z_safe_pause err:%s" % err)
     def cmd(self, gcmd):
         if self.in_script:
-            raise gcmd.error("Macro %s called recursively" % (self.alias,))
+            # raise gcmd.error("Macro %s called recursively" % (self.alias,))
+            raise gcmd.error("""{"code":"key172", "msg": "Macro %s called recursively", "values": ["%s"]}""" % (self.alias, self.alias))
         kwparams = dict(self.variables)
         kwparams.update(self.template.create_template_context())
         kwparams['params'] = gcmd.get_command_parameters()
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/gcode_move.py crealityShit/klippy/extras/gcode_move.py
--- klipperStock/klippy/extras/gcode_move.py	2024-01-14 23:01:59.481788498 -0600
+++ crealityShit/klippy/extras/gcode_move.py	2024-01-14 23:02:21.686060659 -0600
@@ -7,6 +7,10 @@
 
 class GCodeMove:
     def __init__(self, config):
+        self.variable_safe_z = 0
+        if config.has_section('gcode_macro PRINTER_PARAM'):
+            PRINTER_PARAM = config.getsection('gcode_macro PRINTER_PARAM')
+            self.variable_safe_z = PRINTER_PARAM.getfloat('variable_z_safe_g28', 0.0)
         self.printer = printer = config.get_printer()
         printer.register_event_handler("klippy:ready", self._handle_ready)
         printer.register_event_handler("klippy:shutdown", self._handle_shutdown)
@@ -36,6 +40,7 @@
         gcode.register_command('M114', self.cmd_M114, True)
         gcode.register_command('GET_POSITION', self.cmd_GET_POSITION, True,
                                desc=self.cmd_GET_POSITION_help)
+        gcode.register_command('SET_POSITION', self.cmd_SET_POSITION, True, desc=self.cmd_SET_POSITION_help)
         self.Coord = gcode.Coord
         # G-Code coordinate manipulation
         self.absolute_coord = self.absolute_extrude = True
@@ -134,12 +139,12 @@
             if 'F' in params:
                 gcode_speed = float(params['F'])
                 if gcode_speed <= 0.:
-                    raise gcmd.error("Invalid speed in '%s'"
-                                     % (gcmd.get_commandline(),))
+                    raise gcmd.error("""{"code":"key272": "msg":"Invalid speed in '%s'", "values":["%s"]}"""
+                                     % (gcmd.get_commandline(),gcmd.get_commandline()))
                 self.speed = gcode_speed * self.speed_factor
         except ValueError as e:
-            raise gcmd.error("Unable to parse move '%s'"
-                             % (gcmd.get_commandline(),))
+            raise gcmd.error("""{"code":"key273": "msg":"Unable to parse move '%s'", "values":["%s"]}"""
+                             % (gcmd.get_commandline(),gcmd.get_commandline()))
         self.move_with_transform(self.last_position, self.speed)
     # G-Code coordinate manipulation
     def cmd_G20(self, gcmd):
@@ -206,6 +211,141 @@
             for pos, delta in enumerate(move_delta):
                 self.last_position[pos] += delta
             self.move_with_transform(self.last_position, speed)
+    def recordPrintFileName(self, path, file_name, fan_state={}, filament_used=0, last_print_duration=0):
+        import json, os
+        fan = {}
+        M204_accel = ""
+        old_filament_used = 0
+        old_last_print_duration = 0
+        if os.path.exists(path):
+            with open(path, "r") as f:
+                result = (json.loads(f.read()))
+                # fan = result.get("fan_state", "")
+                fan = result.get("fan_state", {})
+                M204_accel = result.get("M204", "")
+                old_filament_used = result.get("filament_used", 0)
+                old_last_print_duration = result.get("last_print_duration", 0)
+        if fan_state.get("M106 S") and fan_state.get("M106 S", "") != fan.get("M106 S", ""):
+            fan["M106 S"] = fan_state.get("M106 S")
+        elif fan_state.get("M106 P0") and fan_state.get("M106 P0", "") != fan.get("M106 P0", ""):
+            fan["M106 P0"] = fan_state.get("M106 P0")
+        elif fan_state.get("M106 P1")  and fan_state.get("M106 P1", "") != fan.get("M106 P1", ""):
+            fan["M106 P1"] = fan_state.get("M106 P1")
+        elif fan_state.get("M106 P2")  and fan_state.get("M106 P2", "") != fan.get("M106 P2", ""):
+            fan["M106 P2"] = fan_state.get("M106 P2")
+
+        if filament_used and filament_used != old_filament_used:
+            pass
+        else:
+            filament_used = old_filament_used
+        if last_print_duration and last_print_duration != old_last_print_duration:
+            pass
+        else:
+            last_print_duration = old_last_print_duration
+        data = {
+            'file_path': file_name,
+            'absolute_coord': self.absolute_coord,
+            'absolute_extrude': self.absolute_extrude,
+            # 'fan_state': state,
+            'fan_state': fan,
+            'M204': M204_accel,
+            'filament_used': filament_used,
+            'last_print_duration': last_print_duration
+        }
+        with open(path, "w") as f:
+            f.write(json.dumps(data))
+            f.flush()
+    cmd_CX_RESTORE_GCODE_STATE_help = "Restore a previously saved G-Code state"
+    def cmd_CX_RESTORE_GCODE_STATE(self, print_info, file_name_path, XYZE):
+        try:
+            state = {
+                "absolute_extrude": True,
+                "file_position": 0,
+                "extrude_factor": 1.0,
+                "speed_factor": 0.016,
+                "homing_position": [0.0, 0.0, 0.0, 0.0],
+                "last_position": [0.0, 0.0, 0.0, 0.0],
+                "speed": 25.0,
+                "file_path": "",
+                "base_position": [0.0, 0.0, 0.0, -0.0],
+                "absolute_coord": True,
+                # "fan_state": "",
+                "fan_state": {},
+                "variable_z_safe_pause": 0,
+                "M204": "",
+                "filament_used": 0,
+                "last_print_duration": 0
+            }
+            import os, json
+            base_position_e = -1
+            state["file_position"] = print_info.get("file_position", 0)
+            state["base_position"] = [0.0, 0.0, 0.0, print_info.get("base_position_e", -1)]
+            base_position_e = print_info.get("base_position_e", -1)
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE base_position_e:%s" % base_position_e)
+            with open(file_name_path, "r") as f:
+                file_info = json.loads(f.read())
+                state["file_path"] = file_info.get("file_path", "")
+                state["absolute_extrude"] = file_info.get("absolute_extrude", True)
+                state["absolute_coord"] = file_info.get("absolute_coord", True)
+                state["fan_state"] = file_info.get("fan_state", {})
+                state["variable_z_safe_pause"] = file_info.get("variable_z_safe_pause", 0)
+                state["M204"] = file_info.get("M204", "")
+            state["last_position"] = [XYZE["X"], XYZE["Y"], XYZE["Z"], XYZE["E"]+base_position_e]
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE state:%s" % str(state))
+
+            # Restore state
+            self.absolute_coord = state['absolute_coord']
+            # self.absolute_extrude = state['absolute_extrude']
+            self.base_position = list(state['base_position'])
+            self.homing_position = list(state['homing_position'])
+            self.speed = state['speed']
+            self.speed_factor = state['speed_factor']
+            self.extrude_factor = state['extrude_factor']
+            # Restore the relative E position
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE base_position:%s" % str(self.base_position))
+            e_diff = self.last_position[3] - state['last_position'][3] - 0.7
+            self.base_position[3] += e_diff
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE self.last_position[3]:%s, state['last_position'][3]:%s, e_diff:%s, \
+                         base_position[3]:%s" % (self.last_position[3], state['last_position'][3], e_diff, self.base_position[3]))
+            # Move the toolhead back if requested
+            gcode = self.printer.lookup_object('gcode')
+            if state["fan_state"]:
+                logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE fan fan_state:%s" % str(state["fan_state"]))
+                for key in state["fan_state"]:
+                    logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE fan set fan:%s#" % str(state["fan_state"].get(key, "")))
+                    gcode.run_script_from_command(state["fan_state"].get(key, ""))
+                # gcode.run_script_from_command(state["fan_state"])
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE before G28 X Y self.last_position:%s" % str(self.last_position))
+            gcode.run_script_from_command("G28 X Y")
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE after G28 X Y self.last_position:%s" % str(self.last_position))
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE before BED_MESH_PROFILE LOAD='default'")
+            gcode.run_script_from_command('BED_MESH_PROFILE LOAD="default"')
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE after BED_MESH_PROFILE LOAD='default'")
+            x = self.last_position[0]
+            y = self.last_position[1]
+            z = state['last_position'][2] + self.variable_safe_z + state["variable_z_safe_pause"]
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE self.last_position[2]:%s, state['last_position'][2]:%s, self.variable_safe_z:%s, \
+                state['variable_z_safe_pause']:%s" % (self.last_position[2], state['last_position'][2], self.variable_safe_z, state["variable_z_safe_pause"]))
+            toolhead = self.printer.lookup_object("toolhead")
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE toolhead.set_position:%s" % str([x, y, z, self.last_position[3]]))
+            toolhead.set_position([x, y, z, self.last_position[3]], homing_axes=(2,))
+            speed = self.speed
+            self.last_position[:3] = state['last_position'][:3]
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE G1 X%s Y%s F3000" % (state['last_position'][0], state['last_position'][1]))
+            gcode.run_script_from_command("G1 X%s Y%s F3000" % (state['last_position'][0], state['last_position'][1]))
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE move_with_transform:%s, speed:%s" % (self.last_position, speed))
+            self.move_with_transform(self.last_position, speed)
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE G1 X%s Y%s F3000" % (state['last_position'][0], state['last_position'][1]))
+            gcode.run_script_from_command("G1 X%s Y%s F3000" % (state['last_position'][0], state['last_position'][1]))
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE M400")
+            gcode.run_script_from_command("M400")
+            if state["M204"]:
+                logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE SET M204:%s#" % state["M204"])
+                gcode.run_script_from_command(state["M204"])
+            self.absolute_extrude = state['absolute_extrude']
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE done")
+        except Exception as err:
+            logging.exception("cmd_CX_RESTORE_GCODE_STATE err:%s" % err)
     cmd_SAVE_GCODE_STATE_help = "Save G-Code coordinate state"
     def cmd_SAVE_GCODE_STATE(self, gcmd):
         state_name = gcmd.get('NAME', 'default')
@@ -223,7 +363,7 @@
         state_name = gcmd.get('NAME', 'default')
         state = self.saved_states.get(state_name)
         if state is None:
-            raise gcmd.error("Unknown g-code state: %s" % (state_name,))
+            raise gcmd.error("""{"code":"key274", "msg": "Unknown g-code state: %s", "values":["%s"]}""" % (state_name, state_name))
         # Restore state
         self.absolute_coord = state['absolute_coord']
         self.absolute_extrude = state['absolute_extrude']
@@ -245,7 +385,7 @@
     def cmd_GET_POSITION(self, gcmd):
         toolhead = self.printer.lookup_object('toolhead', None)
         if toolhead is None:
-            raise gcmd.error("Printer not ready")
+            raise gcmd.error("""{"code": "key283", "msg": ""Printer not ready"}""")
         kin = toolhead.get_kinematics()
         steppers = kin.get_steppers()
         mcu_pos = " ".join(["%s:%d" % (s.get_name(), s.get_mcu_position())
@@ -272,5 +412,24 @@
                           % (mcu_pos, stepper_pos, kin_pos, toolhead_pos,
                              gcode_pos, base_pos, homing_pos))
 
+    cmd_SET_POSITION_help = (
+        "SET_POSITION information on the current location of the toolhead")
+    def cmd_SET_POSITION(self, gcmd):
+        toolhead = self.printer.lookup_object('toolhead', None)
+        if toolhead is None:
+            raise gcmd.error("""{"code": "key283", "msg": ""Printer not ready"}""")
+        position = toolhead.get_position()
+        x = position[0]
+        y = position[1]
+        z = position[2]
+        e = position[3]
+        X = gcmd.get_float('X', x)
+        Y = gcmd.get_float('Y', y)
+        Z = gcmd.get_float('Z', z)
+        E = gcmd.get_float('E', e)
+        toolhead.set_position([X, Y, Z, E], homing_axes=(2,))
+        position = toolhead.get_position()
+        msg = "toolhead get_position X:%s, Y:%s, Z:%s, E:%s" % (position[0], position[1], position[2], position[3])
+        gcmd.respond_info(msg)
 def load_config(config):
     return GCodeMove(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/heater_bed.py crealityShit/klippy/extras/heater_bed.py
--- klipperStock/klippy/extras/heater_bed.py	2024-01-14 23:01:59.485788546 -0600
+++ crealityShit/klippy/extras/heater_bed.py	2024-01-14 23:02:21.694060758 -0600
@@ -15,9 +15,12 @@
         gcode = self.printer.lookup_object('gcode')
         gcode.register_command("M140", self.cmd_M140)
         gcode.register_command("M190", self.cmd_M190)
+        self.max_temp = config.getfloat('max_temp', above=0.0)
     def cmd_M140(self, gcmd, wait=False):
         # Set Bed Temperature
         temp = gcmd.get_float('S', 0.)
+        if temp > self.max_temp - 15.0:
+            temp = self.max_temp - 15.0
         pheaters = self.printer.lookup_object('heaters')
         pheaters.set_temperature(self.heater, temp, wait)
     def cmd_M190(self, gcmd):
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/heaters.py crealityShit/klippy/extras/heaters.py
--- klipperStock/klippy/extras/heaters.py	2024-01-14 23:01:59.465788301 -0600
+++ crealityShit/klippy/extras/heaters.py	2024-01-14 23:02:21.662060367 -0600
@@ -96,8 +96,8 @@
     def set_temp(self, degrees):
         if degrees and (degrees < self.min_temp or degrees > self.max_temp):
             raise self.printer.command_error(
-                "Requested temperature (%.1f) out of range (%.1f:%.1f)"
-                % (degrees, self.min_temp, self.max_temp))
+                """{"code":"key340", "msg":"Heaters %s Requested temperature (%.1f) out of range (%.1f:%.1f)", "values":["%s", %.1f, %.1f, %.1f]}"""
+                % (self.name, degrees, self.min_temp, self.max_temp, self.name, degrees, self.min_temp, self.max_temp))
         with self.lock:
             self.target_temp = degrees
     def get_temp(self, eventtime):
@@ -152,16 +152,77 @@
         self.heater_max_power = heater.get_max_power()
         self.max_delta = config.getfloat('max_delta', 2.0, above=0.)
         self.heating = False
+        self.long_temp =False
+        self.old_temp = 0.0
+        self.cnt_temp = 0
+        self.prev_temp = AMBIENT_TEMP
+        self.temp_coff = 1.
+        self.diff_tempa = 0
+        self.diff_tempb = 0
     def temperature_update(self, read_time, temp, target_temp):
-        if self.heating and temp >= target_temp+self.max_delta:
+        if (temp + 5.0) < target_temp:
+            self.long_temp = True
+            self.old_temp = 0.0
+            self.cnt_temp = 0
+        if target_temp >= 20 and target_temp<=120:
+            if temp + 0.7 > target_temp:
+                self.long_temp =False
+            if self.long_temp:
+                if self.old_temp <= 0.01 or self.old_temp < temp:
+                    self.old_temp = temp
+                    self.cnt_temp = 0
+                    # self.diff_tempa = 16.1 + (119-16.1)/100.*(target_temp-20.0)
+                    # self.diff_tempb = 16.3 + (119.5-16.3)/100.*(target_temp-20.0)
+                    self.diff_tempa = 16.1 + 1.029 * (target_temp-20.0)
+                    self.diff_tempb = 16.3 + 1.032 * (target_temp-20.0)
+                elif self.old_temp > temp:
+                    self.cnt_temp = self.cnt_temp + 1
+                    if self.cnt_temp > 10:
+                        self.long_temp =False
+            else:
+                # self.diff_tempa = 19.1 + (119.7-19.1)/100.*(target_temp-20.0)
+                # self.diff_tempb = 19.3 + (120.2-19.3)/100.*(target_temp-20.0)
+                self.diff_tempa = 19.1 + 1.006 * (target_temp-20.0)
+                self.diff_tempb = 19.3 + 1.009 * (target_temp-20.0)
+            if self.heating and temp >= self.diff_tempb:
+                self.heating = False
+            elif not self.heating and temp <= self.diff_tempa:
+                self.heating = True
+        else:
+            if self.heating and temp >= target_temp:
             self.heating = False
         elif not self.heating and temp <= target_temp-self.max_delta:
             self.heating = True
         if self.heating:
-            self.heater.set_pwm(read_time, self.heater_max_power)
+            if self.prev_temp > 0.1:
+                if self.prev_temp - target_temp > 3.:
+                    self.temp_coff = 0.3 * self.temp_coff
+                elif self.prev_temp - target_temp > 2.:
+                    self.temp_coff = 0.5 *self.temp_coff
+                elif self.prev_temp - target_temp > 1.5:
+                    self.temp_coff = 0.65 * self.temp_coff
+                elif self.prev_temp - target_temp > 1.:
+                    self.temp_coff = 0.8 * self.temp_coff
+                elif self.prev_temp < target_temp:
+                    self.temp_coff = 1.5 * self.temp_coff
+            if (temp + 1.5) < target_temp:
+                self.temp_coff = 1.0
+            if self.temp_coff < 0.3:
+                self.temp_coff = 0.3
+            elif self.temp_coff > 1.0:
+                self.temp_coff = 1.0
+            self.prev_temp = 0.
+            self.heater.set_pwm(read_time, self.heater_max_power * self.temp_coff)
         else:
             self.heater.set_pwm(read_time, 0.)
+            if target_temp > 0.1:
+                if self.prev_temp < temp:
+                    self.prev_temp = temp
+            else:
+                self.prev_temp = 0.
+                self.temp_coff = 1.0
     def check_busy(self, eventtime, smoothed_temp, target_temp):
+
         return smoothed_temp < target_temp-self.max_delta
 
 
@@ -169,11 +230,13 @@
 # Proportional Integral Derivative (PID) control algo
 ######################################################################
 
-PID_SETTLE_DELTA = 1.
-PID_SETTLE_SLOPE = .1
+PID_SETTLE_DELTA = 2.
+PID_SETTLE_SLOPE = .5
 
 class ControlPID:
     def __init__(self, heater, config):
+        self.printer = config.get_printer()
+        self.oldco = 0
         self.heater = heater
         self.heater_max_power = heater.get_max_power()
         self.Kp = config.getfloat('pid_Kp') / PID_PARAM_BASE
@@ -205,6 +268,18 @@
         #logging.debug("pid: %f@%.3f -> diff=%f deriv=%f err=%f integ=%f co=%d",
         #    temp, read_time, temp_diff, temp_deriv, temp_err, temp_integ, co)
         bounded_co = max(0., min(self.heater_max_power, co))
+       # self.powerpin = self.printer.lookup_object("power_pin")
+
+        # bounded_co = max(0., min(self.heater_max_power, co))
+        # if bounded_co == self.heater_max_power:
+        #     if self.oldco == 0:
+        #       #  self.powerpin.set_power_pin(0)
+        #         self.oldco = self.heater_max_power
+        #     else:
+        #         if self.oldco == self.heater_max_power:
+        #           #  self.powerpin.set_power_pin(1)
+        #
+        #         self.oldco = 0
         self.heater.set_pwm(read_time, bounded_co)
         # Store state for next measurement
         self.prev_temp = temp
@@ -213,7 +288,11 @@
         if co == bounded_co:
             self.prev_temp_integ = temp_integ
     def check_busy(self, eventtime, smoothed_temp, target_temp):
+
         temp_diff = target_temp - smoothed_temp
+
+
+
         return (abs(temp_diff) > PID_SETTLE_DELTA
                 or abs(self.prev_temp_deriv) > PID_SETTLE_SLOPE)
 
@@ -241,6 +320,20 @@
         gcode.register_command("M105", self.cmd_M105, when_not_ready=True)
         gcode.register_command("TEMPERATURE_WAIT", self.cmd_TEMPERATURE_WAIT,
                                desc=self.cmd_TEMPERATURE_WAIT_help)
+        # Register webhooks
+        webhooks = self.printer.lookup_object('webhooks')
+        webhooks.register_endpoint("breakheater", self._handle_breakheater)
+        self.can_break=False
+        self.can_break_flag = 0
+        self.extruder_temperature_wait = False
+        self.bed_temperature_wait = False
+    def _handle_breakheater(self,web_request):
+        reactor = self.printer.get_reactor()
+        for heater in self.heaters.values():
+            eventtime = reactor.monotonic()
+            if heater.check_busy(eventtime):
+                self.can_break = True
+
     def load_config(self, config):
         self.have_load_sensors = True
         # Load default temperature sensors
@@ -295,10 +388,13 @@
         self.gcode_id_to_sensor[gcode_id] = psensor
     def get_status(self, eventtime):
         return {'available_heaters': self.available_heaters,
-                'available_sensors': self.available_sensors}
+                'available_sensors': self.available_sensors,
+                'extruder_temperature_wait': self.extruder_temperature_wait,
+                'bed_temperature_wait': self.bed_temperature_wait}
     def turn_off_all_heaters(self, print_time=0.):
         for heater in self.heaters.values():
             heater.set_temp(0.)
+
     cmd_TURN_OFF_HEATERS_help = "Turn off all heaters"
     def cmd_TURN_OFF_HEATERS(self, gcmd):
         self.turn_off_all_heaters()
@@ -330,10 +426,31 @@
         gcode = self.printer.lookup_object("gcode")
         reactor = self.printer.get_reactor()
         eventtime = reactor.monotonic()
+        self.can_break_flag = 1
+        self.can_break = False
+        if "heater_bed" in heater.name:
+            self.bed_temperature_wait = True
+        else:
+            self.extruder_temperature_wait = True
         while not self.printer.is_shutdown() and heater.check_busy(eventtime):
+            if self.can_break:
+                self.can_break_flag = 2
+                self.can_break = False
+                # toolhead._handle_shutdown()
+                #toolhead.move_queue.reset()
+                # self.turn_off_all_heaters()
+                #gcode.run_script("G28")
+
+                break
             print_time = toolhead.get_last_move_time()
             gcode.respond_raw(self._get_temp(eventtime))
             eventtime = reactor.pause(eventtime + 1.)
+        if self.can_break_flag != 2:
+            self.can_break_flag = 3
+        if "heater_bed" in heater.name:
+            self.bed_temperature_wait = False
+        else:
+            self.extruder_temperature_wait = False
     def set_temperature(self, heater, temp, wait=False):
         toolhead = self.printer.lookup_object('toolhead')
         toolhead.register_lookahead_callback((lambda pt: None))
@@ -359,7 +476,7 @@
         toolhead = self.printer.lookup_object("toolhead")
         reactor = self.printer.get_reactor()
         eventtime = reactor.monotonic()
-        while not self.printer.is_shutdown():
+        while not self.printer.is_shutdown() and not self.can_break:
             temp, target = sensor.get_temp(eventtime)
             if temp >= min_temp and temp <= max_temp:
                 return
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/homing_heaters.py crealityShit/klippy/extras/homing_heaters.py
--- klipperStock/klippy/extras/homing_heaters.py	2024-01-14 23:01:59.469788348 -0600
+++ crealityShit/klippy/extras/homing_heaters.py	2024-01-14 23:02:21.670060464 -0600
@@ -28,8 +28,8 @@
         else:
             if not all(x in all_heaters for x in self.disable_heaters):
                 raise self.printer.config_error(
-                    "One or more of these heaters are unknown: %s"
-                    % (self.disable_heaters,))
+                    """{"code":"key68", "msg": "One or more of these heaters are unknown: %s", "values": ["%s"]}"""
+                    % (self.disable_heaters,self.disable_heaters,))
         # steppers valid?
         kin = self.printer.lookup_object('toolhead').get_kinematics()
         all_steppers = [s.get_name() for s in kin.get_steppers()]
@@ -37,8 +37,8 @@
             return
         if not all(x in all_steppers for x in self.flaky_steppers):
             raise self.printer.config_error(
-                "One or more of these steppers are unknown: %s"
-                % (self.flaky_steppers,))
+                """{"code":"key67", "msg":"One or more of these steppers are unknown: %s", "values": ["%s"]}"""
+                % (self.flaky_steppers, self.flaky_steppers,))
     def check_eligible(self, endstops):
         if self.flaky_steppers is None:
             return True
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/homing.py crealityShit/klippy/extras/homing.py
--- klipperStock/klippy/extras/homing.py	2024-01-14 23:01:59.489788594 -0600
+++ crealityShit/klippy/extras/homing.py	2024-01-14 23:02:21.706060905 -0600
@@ -93,7 +93,7 @@
         try:
             self.toolhead.drip_move(movepos, speed, all_endstop_trigger)
         except self.printer.command_error as e:
-            error = "Error during homing move: %s" % (str(e),)
+            error = """{"code":"key20", "msg":"Error during homing move: %s", "values": [%s]}""" % (str(e),str(e))
         # Wait for endstops to trigger
         trigger_times = {}
         move_end_print_time = self.toolhead.get_last_move_time()
@@ -102,9 +102,9 @@
             if trigger_time > 0.:
                 trigger_times[name] = trigger_time
             elif trigger_time < 0. and error is None:
-                error = "Communication timeout during homing %s" % (name,)
+                error = """{"code":"key21", "msg":"Communication timeout during homing %s", "values": ["%s"]}""" % (name, name)
             elif check_triggered and error is None:
-                error = "No trigger on %s after full movement" % (name,)
+                error = """{"code":"key22", "msg":"No trigger on %s after full movement", "values": ["%s"]}""" % (name, name)
         # Determine stepper halt positions
         self.toolhead.flush_step_generation()
         for sp in self.stepper_positions:
@@ -153,6 +153,7 @@
         self.changed_axes = []
         self.trigger_mcu_pos = {}
         self.adjust_pos = {}
+        self.stepper_z_sensorless_flag = False
     def set_axes(self, axes):
         self.changed_axes = axes
     def get_axes(self):
@@ -182,6 +183,9 @@
         endstops = [es for rail in rails for es in rail.get_endstops()]
         hi = rails[0].get_homing_info()
         hmove = HomingMove(self.printer, endstops)
+        if self.stepper_z_sensorless_flag:
+            hmove.homing_move(homepos, hi.speed, False, True, False)
+        else:
         hmove.homing_move(homepos, hi.speed)
         # Perform second home
         if hi.retract_dist:
@@ -202,8 +206,8 @@
             hmove.homing_move(homepos, hi.second_homing_speed)
             if hmove.check_no_movement() is not None:
                 raise self.printer.command_error(
-                    "Endstop %s still triggered after retract"
-                    % (hmove.check_no_movement(),))
+                    """{"code":"key23", "msg":"Endstop %s still triggered after retract", "values": ["%s"]}"""
+                    % (hmove.check_no_movement(), hmove.check_no_movement()))
         # Signal home operation complete
         self.toolhead.flush_step_generation()
         self.trigger_mcu_pos = {sp.stepper_name: sp.trig_pos
@@ -228,6 +232,12 @@
         # Register g-code commands
         gcode = self.printer.lookup_object('gcode')
         gcode.register_command('G28', self.cmd_G28)
+        gcode.register_command('STEPPER_Z_SENEORLESS', self.cmd_STEPPER_Z_SENEORLESS)
+        self.probe_type = ""
+        if config.has_section('prtouch_v2'):
+            self.probe_type = "prtouch_v2"
+        elif config.has_section('bltouch'):
+            self.probe_type = "bltouch"
     def manual_home(self, toolhead, endstops, pos, speed,
                     triggered, check_triggered):
         hmove = HomingMove(self.printer, endstops, toolhead)
@@ -237,22 +247,45 @@
         except self.printer.command_error:
             if self.printer.is_shutdown():
                 raise self.printer.command_error(
-                    "Homing failed due to printer shutdown")
+                    '{"code": "key4", "msg": "Homing failed due to printer shutdown"}')
             raise
     def probing_move(self, mcu_probe, pos, speed):
+
         endstops = [(mcu_probe, "probe")]
         hmove = HomingMove(self.printer, endstops)
         try:
+            if self.probe_type == "prtouch_v2":
+                epos = self.printer.lookup_object('probe').mcu_probe.run_G29_Z()
+            else:
             epos = hmove.homing_move(pos, speed, probe_pos=True)
         except self.printer.command_error:
             if self.printer.is_shutdown():
                 raise self.printer.command_error(
-                    "Probing failed due to printer shutdown")
+                    '{"code": "key5", "msg": "Probing failed due to printer shutdown"}')
             raise
         if hmove.check_no_movement() is not None:
             raise self.printer.command_error(
-                "Probe triggered prior to movement")
+                '{"code": "key6", "msg": "Probe triggered prior to movement"}')
         return epos
+        
+    def cmd_STEPPER_Z_SENEORLESS(self, gcmd):
+        toolhead = self.printer.lookup_object('toolhead')
+        move_dist = gcmd.get_int('MOVE_DIST', default=0, minval=0, maxval=30)
+        homing_state = Homing(self.printer)
+        homing_state.set_axes([2])
+        kin = self.printer.lookup_object('toolhead').get_kinematics()
+        homing_state.set_axes([2])
+        # gcode = self.printer.lookup_object('gcode')
+        # gcode.respond_info("cmd_STEPPER_Z_SENEORLESS")
+        kin.home_z_with_sensorless(homing_state, move_dist)
+        # gcode = self.printer.lookup_object('gcode')
+        pos = toolhead.get_position()
+        pos[2] = move_dist - 3
+        toolhead.set_position(pos, homing_axes=[2])
+        toolhead.manual_move([None, None, 0.], 5)
+        if hasattr(toolhead.get_kinematics(), "note_z_not_homed"):
+            toolhead.get_kinematics().note_z_not_homed()
+
     def cmd_G28(self, gcmd):
         # Move to origin
         axes = []
@@ -265,6 +298,14 @@
         homing_state.set_axes(axes)
         kin = self.printer.lookup_object('toolhead').get_kinematics()
         try:
+            if self.probe_type == "prtouch_v2":
+                for a in axes:
+                    if a == 0 or a == 1:
+                        homing_state.set_axes([a])
+                        kin.home(homing_state)
+                    else:
+                        self.printer.lookup_object('probe').mcu_probe.run_G28_Z()
+            else:
             kin.home(homing_state)
         except self.printer.command_error:
             if self.printer.is_shutdown():
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/htu21d.py crealityShit/klippy/extras/htu21d.py
--- klipperStock/klippy/extras/htu21d.py	2024-01-14 23:01:59.453788154 -0600
+++ crealityShit/klippy/extras/htu21d.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,248 +0,0 @@
-# HTU21D(F)/Si7013/Si7020/Si7021/SHT21 i2c based temperature sensors support
-#
-# Copyright (C) 2020  Lucio Tarantino <lucio.tarantino@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-from . import bus
-
-######################################################################
-# NOTE: The implementation requires write support of length 0
-#       before reading on the i2c bus of the mcu.
-#
-# Compatible Sensors:
-#       HTU21D - Tested on Linux MCU.
-#       Si7013 - Untested
-#       Si7020 - Untested
-#       Si7021 - Tested on Pico MCU
-#       SHT21  - Untested
-#
-######################################################################
-
-HTU21D_I2C_ADDR= 0x40
-
-HTU21D_COMMANDS = {
-    'HTU21D_TEMP'       :0xE3,
-    'HTU21D_HUMID'      :0xE5,
-    'HTU21D_TEMP_NH'    :0xF3,
-    'HTU21D_HUMID_NH'   :0xF5,
-    'WRITE'             :0xE6,
-    'READ'              :0xE7,
-    'RESET'             :0xFE,
-    'SERIAL'            :[0xFA,0x0F,0xFC,0xC9],
-    'FIRMWARE_READ'     :[0x84,0xB8]
-
-}
-
-HTU21D_RESOLUTION_MASK = 0x7E;
-HTU21D_RESOLUTIONS = {
-    'TEMP14_HUM12':int('00000000',2),
-    'TEMP13_HUM10':int('10000000',2),
-    'TEMP12_HUM08':int('00000001',2),
-    'TEMP11_HUM11':int('10000001',2)
-}
-
-# Device with conversion time for tmp/resolution bit
-# The format is:
-#  <CHIPNAME>:{id:<ID>, ..<RESOlUTION>:[<temp time>,<humidity time>].. }
-HTU21D_DEVICES = {
-    'SI7013':{'id':0x0D,
-        'TEMP14_HUM12':[.11,.12],
-        'TEMP13_HUM10':[ .7, .5],
-        'TEMP12_HUM08':[ .4, .4],
-        'TEMP11_HUM11':[ .3, .7]},
-    'SI7020':{'id':0x14,
-        'TEMP14_HUM12':[.11,.12],
-        'TEMP13_HUM10':[ .7, .5],
-        'TEMP12_HUM08':[ .4, .4],
-        'TEMP11_HUM11':[ .3, .7]},
-    'SI7021':{'id':0x15,
-        'TEMP14_HUM12':[.11,.12],
-        'TEMP13_HUM10':[ .7, .5],
-        'TEMP12_HUM08':[ .4, .4],
-        'TEMP11_HUM11':[ .3, .7]},
-    'SHT21': {'id':0x31,
-        'TEMP14_HUM12':[.85,.29],
-        'TEMP13_HUM10':[.43, .9],
-        'TEMP12_HUM08':[.22, .4],
-        'TEMP11_HUM11':[.11,.15]},
-    'HTU21D':{'id':0x32,
-        'TEMP14_HUM12':[.50,.16],
-        'TEMP13_HUM10':[.25, .5],
-        'TEMP12_HUM08':[.13, .3],
-        'TEMP11_HUM11':[.12, .8]}
-}
-#temperature coefficient for RH compensation at range 0C..80C,
-#  for HTU21D & SHT21 only
-HTU21D_TEMP_COEFFICIENT= -0.15
-#crc8 polynomial for 16bit value, CRC8 -> x^8 + x^5 + x^4 + 1
-HTU21D_CRC8_POLYNOMINAL= 0x13100
-
-class HTU21D:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.name = config.get_name().split()[-1]
-        self.reactor = self.printer.get_reactor()
-        self.i2c = bus.MCU_I2C_from_config(
-            config, default_addr=HTU21D_I2C_ADDR, default_speed=100000)
-        self.hold_master_mode = config.getboolean('htu21d_hold_master',False)
-        self.resolution = config.get('htu21d_resolution','TEMP12_HUM08')
-        self.report_time = config.getint('htu21d_report_time',30,minval=5)
-        if self.resolution not in HTU21D_RESOLUTIONS:
-            raise config.error("Invalid HTU21D Resolution. Valid are %s"
-                % '|'.join(HTU21D_RESOLUTIONS.keys()))
-        self.deviceId = config.get('sensor_type')
-        self.temp = self.min_temp = self.max_temp = self.humidity = 0.
-        self.sample_timer = self.reactor.register_timer(self._sample_htu21d)
-        self.printer.add_object("htu21d " + self.name, self)
-        self.printer.register_event_handler("klippy:connect",
-                                            self.handle_connect)
-
-    def handle_connect(self):
-        self._init_htu21d()
-        self.reactor.update_timer(self.sample_timer, self.reactor.NOW)
-
-    def setup_minmax(self, min_temp, max_temp):
-        self.min_temp = min_temp
-        self.max_temp = max_temp
-
-    def setup_callback(self, cb):
-        self._callback = cb
-
-    def get_report_time_delta(self):
-        return self.report_time
-
-    def _init_htu21d(self):
-        # Device Soft Reset
-        self.i2c.i2c_write([HTU21D_COMMANDS['RESET']])
-        # Wait 15ms after reset
-        self.reactor.pause(self.reactor.monotonic() + .15)
-
-        # Read ChipId
-        params = self.i2c.i2c_read([HTU21D_COMMANDS['SERIAL'][2],
-                                    HTU21D_COMMANDS['SERIAL'][3]], 3)
-        response = bytearray(params['response'])
-        rdevId = response[0] << 8
-        rdevId |= response[1]
-        checksum = response[2]
-        if self._chekCRC8(rdevId) != checksum:
-            logging.warn("htu21d: Reading deviceId !Checksum error!")
-        rdevId = rdevId >> 8
-        deviceId_list = list(
-            filter(
-              lambda elem: HTU21D_DEVICES[elem]['id'] == rdevId,HTU21D_DEVICES)
-            )
-        if len(deviceId_list) != 0:
-            logging.info("htu21d: Found Device Type %s" % deviceId_list[0])
-        else:
-            logging.warn("htu21d: Unknown Device ID %#x " % rdevId)
-
-        if(self.deviceId != deviceId_list[0]):
-            logging.warn(
-                "htu21d: Found device %s. Forcing to type %s as config.",
-                 deviceId_list[0],self.deviceId)
-
-        # Set Resolution
-        params = self.i2c.i2c_read([HTU21D_COMMANDS['READ']], 1)
-        response = bytearray(params['response'])
-        registerData = response[0] & HTU21D_RESOLUTION_MASK
-        registerData |= HTU21D_RESOLUTIONS[self.resolution]
-        self.i2c.i2c_write([HTU21D_COMMANDS['WRITE']],registerData)
-        logging.info("htu21d: Setting resolution to %s " % self.resolution)
-
-    def _sample_htu21d(self, eventtime):
-        try:
-            # Read Temeprature
-            if self.hold_master_mode:
-                params = self.i2c.i2c_write([HTU21D_COMMANDS['HTU21D_TEMP']])
-            else:
-                params = self.i2c.i2c_write([HTU21D_COMMANDS['HTU21D_TEMP_NH']])
-
-            # Wait
-            self.reactor.pause(self.reactor.monotonic()
-            + HTU21D_DEVICES[self.deviceId][self.resolution][0])
-
-
-            params = self.i2c.i2c_read([],3)
-
-            response = bytearray(params['response'])
-            rtemp  = response[0] << 8
-            rtemp |= response[1]
-            if self._chekCRC8(rtemp) != response[2]:
-                logging.warn("htu21d: Checksum error on Temperature reading!")
-            else:
-                self.temp = (0.002681 * float(rtemp) - 46.85)
-                logging.debug("htu21d: Temperature %.2f " % self.temp)
-
-            # Read Humidity
-            if self.hold_master_mode:
-                self.i2c.i2c_write([HTU21D_COMMANDS['HTU21D_HUMID']])
-            else:
-                self.i2c.i2c_write([HTU21D_COMMANDS['HTU21D_HUMID_NH']])
-
-            # Wait
-            self.reactor.pause(self.reactor.monotonic()
-            + HTU21D_DEVICES[self.deviceId][self.resolution][1])
-
-            params = self.i2c.i2c_read([],3)
-
-            response = bytearray(params['response'])
-            rhumid = response[0] << 8
-            rhumid|= response[1]
-            if self._chekCRC8(rhumid) != response[2]:
-                logging.warn("htu21d: Checksum error on Humidity reading!")
-            else:
-                #clear status bits,
-                # humidity always returns xxxxxx10 in the LSB field
-                rhumid   ^= 0x02;
-                self.humidity = (0.001907 * float(rhumid) - 6)
-                if (self.humidity < 0):
-                    #due to RH accuracy, measured value might be
-                    # slightly less than 0 or more 100
-                    self.humidity = 0
-                elif (self.humidity > 100):
-                    self.humidity = 100
-                # Only for HTU21D & SHT21.
-                # Calculates temperature compensated Humidity, %RH
-                if( self.deviceId in ['SHT21','HTU21D']
-                    and self.temp > 0 and self.temp < 80):
-                    logging.debug("htu21d: Do temp compensation..")
-                    self.humidity = self.humidity
-                    + (25.0 - self.temp) * HTU21D_TEMP_COEFFICIENT;
-                logging.debug("htu21d: Humidity %.2f " % self.humidity)
-        except Exception:
-            logging.exception("htu21d: Error reading data")
-            self.temp = self.humidity = .0
-            return self.reactor.NEVER
-
-        if self.temp < self.min_temp or self.temp > self.max_temp:
-            self.printer.invoke_shutdown(
-                "HTU21D temperature %0.1f outside range of %0.1f:%.01f"
-                % (self.temp, self.min_temp, self.max_temp))
-
-        measured_time = self.reactor.monotonic()
-        print_time = self.i2c.get_mcu().estimated_print_time(measured_time)
-        self._callback(print_time, self.temp)
-        return measured_time + self.report_time
-
-    def _chekCRC8(self,data):
-        for bit in range(0,16):
-            if (data & 0x8000):
-                data = (data << 1) ^ HTU21D_CRC8_POLYNOMINAL;
-            else:
-                data <<= 1
-        data = data >> 8
-        return data
-
-    def get_status(self, eventtime):
-        return {
-            'temperature': round(self.temp, 2),
-            'humidity': self.humidity,
-        }
-
-
-def load_config(config):
-    # Register sensor
-    pheater = config.get_printer().lookup_object("heaters")
-    for stype in HTU21D_DEVICES:
-        pheater.add_sensor_factory(stype, HTU21D)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/hx711s.py crealityShit/klippy/extras/hx711s.py
--- klipperStock/klippy/extras/hx711s.py	1969-12-31 18:00:00.000000000 -0600
+++ crealityShit/klippy/extras/hx711s.py	2024-01-14 23:02:21.658060316 -0600
@@ -0,0 +1,207 @@
+# Support for 1-wire based temperature sensors
+#
+# Copyright (C) 2020 Alan Lord <alanslists@gmail.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+from os import remove
+import time
+import mcu
+import math
+
+class HX711S:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.gcode = self.printer.lookup_object("gcode")
+        self.s_count = config.getint('count', 1, 1, 4)
+        self.base_avgs = [0, 0, 0, 0]
+        self.del_dirty = False
+        self.index_dirty = 0
+        self.start_tick = 0
+        self.need_wait = False
+        self.s_clk_pin = []
+        self.s_sdo_pin = []
+        self.all_params = []
+        self.all_vals = [[], [], [], []]
+        for i in range(self.s_count):
+            self.s_clk_pin.append(config.get('sensor%d_clk_pin' % i, None if i == 0 else self.s_clk_pin[i - 1]))
+            self.s_sdo_pin.append(config.get('sensor%d_sdo_pin' % i, None if i == 0 else self.s_sdo_pin[i - 1]))
+        self.mcu = mcu.get_printer_mcu(self.printer, config.get('use_mcu'))
+        self.oid = self.mcu.create_oid()
+        self.mcu.register_config_callback(self._build_config)
+        self.mcu.register_response(self._handle_debug_hx711s, "debug_hx711s", self.oid)
+        self.mcu.register_response(self._handle_result_hx711s, "result_hx711s", self.oid)
+        self.printer.register_event_handler('klippy:mcu_identify', self._handle_mcu_identify)
+        self.printer.register_event_handler("klippy:shutdown", self._handle_shutdown)
+        self.printer.register_event_handler("klippy:disconnect", self._handle_disconnect)
+        self.gcode.register_command('READ_HX711', self.cmd_READ_HX711, desc=self.cmd_READ_HX711_help)
+        self.pi_count = int(0)
+        self.show_msg = False
+        self.filter = None 
+        self.query_cmd = None
+        self.mcu_freq = 72000000
+        self.last_send_heart = 0.
+        self.is_shutdown = True
+        self.is_timeout = True
+        pass
+
+    def _build_config(self):
+        self.mcu.add_config_cmd("config_hx711s oid=%d hx711_count=%d" % (self.oid, self.s_count))
+        pins = self.printer.lookup_object("pins") 
+        for i in range(self.s_count):
+            clk_pin_params = pins.lookup_pin(self.s_clk_pin[i])
+            sdo_pin_params = pins.lookup_pin(self.s_sdo_pin[i])
+            self.mcu.add_config_cmd("add_hx711s oid=%d index=%d clk_pin=%s sdo_pin=%s" % (self.oid, i, clk_pin_params['pin'], sdo_pin_params['pin']))
+        # self.query_cmd = self.mcu.lookup_command("query_hx711s oid=%c times_read=%hu is_ck_con=%c", cq=None)
+        self.query_cmd = self.mcu.lookup_command("query_hx711s oid=%c times_read=%hu", cq=None)
+        self.filter = self.printer.lookup_object('filter')
+        self.mcu_freq = self.mcu.get_constant_float('CLOCK_FREQ')
+        pass
+
+    def _handle_mcu_identify(self):
+        # self.send_heart_beat_cmd = self.mcu.lookup_query_command(
+        #     "heart_beat_hx711s oid=%c",
+        #     "heart_beat_hx711s_result oid=%c",
+        #     oid=self.oid, cq=None)
+        pass
+
+        self.is_shutdown = False
+        self.is_timeout = False
+        pass
+
+    def _handle_debug_hx711s(self, params):
+        self.printer.lookup_object('prtouch').pnt_msg(str(params))
+        pass
+
+    def _handle_shutdown(self):
+        self.is_shutdown = True
+        pass
+
+    def _handle_disconnect(self):
+        self.is_timeout = True
+        pass
+
+    def _handle_result_hx711s(self, params):
+        while self.need_wait:
+            self.delay_s(0.001)
+        self.start_tick = self.start_tick if len(self.all_params) != 0 else params['nt']
+        if self.del_dirty and (params['vd'] != 0 or params['it'] > 20) and self.index_dirty == 0:
+            self.index_dirty = 1
+            return
+        self.index_dirty -= 1 if self.index_dirty == 1 else 0
+        self.all_params.append(params)
+        for i in range(self.s_count):
+            self.all_vals[i].append(params['v%d' % i] - self.base_avgs[i])
+        if self.show_msg:
+            self.gcode.respond_info('Hx711 Val=' + str(params))
+        if len(self.all_params) > self.pi_count:
+            del self.all_params[0]
+            for i in range(self.s_count):
+                del self.all_vals[i][0]
+        pass
+
+    def query_start(self, pi_count, cycle_count, del_dirty=False, show_msg=False, is_ck_con=False):
+        if self.is_shutdown or self.is_timeout:
+            pass
+        if cycle_count != 0:
+            self.pi_count = pi_count
+            self.all_params = []
+            self.all_vals = [[], [], [], []]
+            self.show_msg = show_msg
+            self.del_dirty = del_dirty
+            self.index_dirty = 0
+        # self.query_cmd.send([self.oid, cycle_count, 1 if is_ck_con else 0])
+        self.query_cmd.send([self.oid, cycle_count])
+        pass
+
+    def get_params(self):
+        self.need_wait = True
+        tmps = [x for x in self.all_params]
+        self.need_wait = False
+        return tmps, self.start_tick
+
+    def get_vals(self):
+        self.need_wait = True
+        tmps = [[], [], [], []]
+        for i in range(self.s_count):
+            tmps[i] = [x for x in self.all_vals[i]]
+        self.need_wait = False
+        return tmps
+
+    def delay_s(self, delay_s):
+        toolhead = self.printer.lookup_object("toolhead")
+        reactor = self.printer.get_reactor()
+        eventtime = reactor.monotonic()
+        if not self.printer.is_shutdown():
+            toolhead.get_last_move_time()
+            eventtime = reactor.pause(eventtime + delay_s)
+            pass
+
+    def send_heart_beat(self):
+        # if time.time() - self.last_send_heart > 0.1:
+        #     self.send_heart_beat_cmd.send([self.oid])
+        #     self.last_send_heart = time.time()
+        pass
+
+    def read_base(self, cnt, max_hold, reset_zero=True):
+        avgs = [0, 0, 0, 0]
+        rvs = [[], [], [], []]
+        for i in range(3):
+            self.base_avgs = [0, 0, 0, 0]
+            avgs = [0, 0, 0, 0]
+            self.query_start(cnt, cnt + 5, del_dirty=True, show_msg=False)
+            t_last = time.time()
+            while not (self.is_shutdown or self.is_timeout) and len(self.get_vals()[0]) < cnt and (time.time() - t_last) < cnt * 0.010 * 15:
+                self.delay_s(0.010)
+                pass
+            vals = self.get_vals()
+            if len(vals[0]) < cnt:
+                raise self.printer.command_error("""{"code":"key503", "msg":"z-Touch::read_base: Can not read z-Touch data."}""")
+                
+            for j in range(self.s_count):
+                del vals[j][0:int(len(vals[j]) / 2)]
+            for j in range(self.s_count):
+                del vals[j][vals[j].index(min(vals[j]))]
+                del vals[j][vals[j].index(min(vals[j]))]
+                del vals[j][vals[j].index(max(vals[j]))]
+                del vals[j][vals[j].index(max(vals[j]))]
+            rvs = [[], [], [], []]
+            tf = self.filter.get_tft()
+            lf = self.filter.get_lft(0.5)
+            for j in range(self.s_count):
+                vals[j] = tf.ftr_val(vals[j])
+                vals[j] = lf.ftr_val(vals[j])
+                rvs[j].append(min(vals[j]))
+                rvs[j].append(sum(vals[j]) / len(vals[j]))
+                rvs[j].append(max(vals[j]))
+                avgs[j] = sum(vals[j]) / len(vals[j])
+                self.printer.lookup_object('prtouch').pnt_msg('READ_BASE ch=%d min=%.2f avg=%.2f max=%.2f' % (j, rvs[j][-3], avgs[j], rvs[j][-1]))
+            if reset_zero:
+                self.base_avgs = avgs
+
+            sum_max = 0
+            for j in range(self.s_count):
+                sum_max += math.fabs(rvs[j][2] - rvs[j][0])
+            if sum_max < max_hold * 2:
+                break
+        return avgs, rvs
+
+    cmd_READ_HX711_help = "Read hx711s vals"
+
+    def cmd_READ_HX711(self, gcmd):
+        cnt = gcmd.get_int('C', 1, minval=1, maxval=9999) 
+        self.query_start(cnt, cnt, False, False, False)
+        self.delay_s(1.)
+        self.base_avgs = [0, 0, 0, 0]
+        vals = self.get_vals()
+        for i in range(self.s_count):
+            self.gcode.respond_info('CH%d=' % i)
+            sv = '['
+            for j in range(len(vals[i])):
+                sv += '%.2f, ' % vals[i][j]
+            self.gcode.respond_info(sv + ']')
+        self.read_base(40, 500000)
+        pass
+
+
+def load_config(config):
+    return HX711S(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/input_shaper.py crealityShit/klippy/extras/input_shaper.py
--- klipperStock/klippy/extras/input_shaper.py	2024-01-14 23:01:59.477788447 -0600
+++ crealityShit/klippy/extras/input_shaper.py	2024-01-14 23:02:21.678060562 -0600
@@ -16,7 +16,8 @@
         self.shaper_type = config.get('shaper_type_' + axis, shaper_type)
         if self.shaper_type not in self.shapers:
             raise config.error(
-                    'Unsupported shaper type: %s' % (self.shaper_type,))
+                    """{"code":"key24", "msg":"Unsupported shaper type: %s", "values": ["%s"]}""" % (
+                        self.shaper_type, self.shaper_type))
         self.damping_ratio = config.getfloat('damping_ratio_' + axis,
                                              shaper_defs.DEFAULT_DAMPING_RATIO,
                                              minval=0., maxval=1.)
@@ -32,7 +33,8 @@
         if shaper_type is None:
             shaper_type = gcmd.get('SHAPER_TYPE_' + axis, self.shaper_type)
         if shaper_type.lower() not in self.shapers:
-            raise gcmd.error('Unsupported shaper type: %s' % (shaper_type,))
+            raise gcmd.error("""{"code":"key24", "msg":"Unsupported shaper type: %s", "values": ["%s"]}""" % (
+                shaper_type, shaper_type))
         self.shaper_type = shaper_type.lower()
     def get_shaper(self):
         if not self.shaper_freq:
@@ -105,6 +107,9 @@
         gcode.register_command("SET_INPUT_SHAPER",
                                self.cmd_SET_INPUT_SHAPER,
                                desc=self.cmd_SET_INPUT_SHAPER_help)
+        gcode.register_command("UPDATE_INPUT_SHAPER",
+                               self.cmd_UPDATE_INPUT_SHAPER,
+                               desc=self.cmd_UPDATE_INPUT_SHAPER_help)
     def get_shapers(self):
         return self.shapers
     def connect(self):
@@ -139,8 +144,8 @@
                     failed.append(shaper)
         if failed:
             error = error or self.printer.command_error
-            raise error("Failed to configure shaper(s) %s with given parameters"
-                        % (', '.join([s.get_name() for s in failed])))
+            raise error("""{"code":"key25", "msg":"Failed to configure shaper(s) %s with given parameters", "values": ["%s"]}"""
+                        % (', '.join([s.get_name() for s in failed]), ', '.join([s.get_name() for s in failed])))
     def disable_shaping(self):
         for shaper in self.shapers:
             shaper.disable_shaping()
@@ -158,6 +163,9 @@
             self._update_input_shaping()
         for shaper in self.shapers:
             shaper.report(gcmd)
+    cmd_UPDATE_INPUT_SHAPER_help = "cmd_UPDATE_INPUT_SHAPER parameters for input shaper"
+    def cmd_UPDATE_INPUT_SHAPER(self, gcmd):
+        self.connect()
 
 def load_config(config):
     return InputShaper(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/led.py crealityShit/klippy/extras/led.py
--- klipperStock/klippy/extras/led.py	2024-01-14 23:01:59.453788154 -0600
+++ crealityShit/klippy/extras/led.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,232 +0,0 @@
-# Support for PWM driven LEDs
-#
-# Copyright (C) 2019-2022  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging, ast
-from .display import display
-
-# Time between each led template update
-RENDER_TIME = 0.500
-
-# Helper code for common LED initialization and control
-class LEDHelper:
-    def __init__(self, config, update_func, led_count=1):
-        self.printer = config.get_printer()
-        self.update_func = update_func
-        self.led_count = led_count
-        self.need_transmit = False
-        # Initial color
-        red = config.getfloat('initial_RED', 0., minval=0., maxval=1.)
-        green = config.getfloat('initial_GREEN', 0., minval=0., maxval=1.)
-        blue = config.getfloat('initial_BLUE', 0., minval=0., maxval=1.)
-        white = config.getfloat('initial_WHITE', 0., minval=0., maxval=1.)
-        self.led_state = [(red, green, blue, white)] * led_count
-        # Register commands
-        name = config.get_name().split()[-1]
-        gcode = self.printer.lookup_object('gcode')
-        gcode.register_mux_command("SET_LED", "LED", name, self.cmd_SET_LED,
-                                   desc=self.cmd_SET_LED_help)
-    def get_led_count(self):
-        return self.led_count
-    def set_color(self, index, color):
-        if index is None:
-            new_led_state = [color] * self.led_count
-            if self.led_state == new_led_state:
-                return
-        else:
-            if self.led_state[index - 1] == color:
-                return
-            new_led_state = list(self.led_state)
-            new_led_state[index - 1] = color
-        self.led_state = new_led_state
-        self.need_transmit = True
-    def check_transmit(self, print_time):
-        if not self.need_transmit:
-            return
-        self.need_transmit = False
-        try:
-            self.update_func(self.led_state, print_time)
-        except self.printer.command_error as e:
-            logging.exception("led update transmit error")
-    cmd_SET_LED_help = "Set the color of an LED"
-    def cmd_SET_LED(self, gcmd):
-        # Parse parameters
-        red = gcmd.get_float('RED', 0., minval=0., maxval=1.)
-        green = gcmd.get_float('GREEN', 0., minval=0., maxval=1.)
-        blue = gcmd.get_float('BLUE', 0., minval=0., maxval=1.)
-        white = gcmd.get_float('WHITE', 0., minval=0., maxval=1.)
-        index = gcmd.get_int('INDEX', None, minval=1, maxval=self.led_count)
-        transmit = gcmd.get_int('TRANSMIT', 1)
-        sync = gcmd.get_int('SYNC', 1)
-        color = (red, green, blue, white)
-        # Update and transmit data
-        def lookahead_bgfunc(print_time):
-            self.set_color(index, color)
-            if transmit:
-                self.check_transmit(print_time)
-        if sync:
-            #Sync LED Update with print time and send
-            toolhead = self.printer.lookup_object('toolhead')
-            toolhead.register_lookahead_callback(lookahead_bgfunc)
-        else:
-            #Send update now (so as not to wake toolhead and reset idle_timeout)
-            lookahead_bgfunc(None)
-    def get_status(self, eventtime=None):
-        return {'color_data': self.led_state}
-
-# Main LED tracking code
-class PrinterLED:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.led_helpers = {}
-        self.active_templates = {}
-        self.render_timer = None
-        # Load templates
-        dtemplates = display.lookup_display_templates(config)
-        self.templates = dtemplates.get_display_templates()
-        gcode_macro = self.printer.lookup_object("gcode_macro")
-        self.create_template_context = gcode_macro.create_template_context
-        # Register handlers
-        gcode = self.printer.lookup_object('gcode')
-        gcode.register_command("SET_LED_TEMPLATE", self.cmd_SET_LED_TEMPLATE,
-                               desc=self.cmd_SET_LED_TEMPLATE_help)
-    def setup_helper(self, config, update_func, led_count=1):
-        led_helper = LEDHelper(config, update_func, led_count)
-        name = config.get_name().split()[-1]
-        self.led_helpers[name] = led_helper
-        return led_helper
-    def _activate_timer(self):
-        if self.render_timer is not None or not self.active_templates:
-            return
-        reactor = self.printer.get_reactor()
-        self.render_timer = reactor.register_timer(self._render, reactor.NOW)
-    def _activate_template(self, led_helper, index, template, lparams):
-        key = (led_helper, index)
-        if template is not None:
-            uid = (template,) + tuple(sorted(lparams.items()))
-            self.active_templates[key] = (uid, template, lparams)
-            return
-        if key in self.active_templates:
-            del self.active_templates[key]
-    def _render(self, eventtime):
-        if not self.active_templates:
-            # Nothing to do - unregister timer
-            reactor = self.printer.get_reactor()
-            reactor.register_timer(self.render_timer)
-            self.render_timer = None
-            return reactor.NEVER
-        # Setup gcode_macro template context
-        context = self.create_template_context(eventtime)
-        def render(name, **kwargs):
-            return self.templates[name].render(context, **kwargs)
-        context['render'] = render
-        # Render all templates
-        need_transmit = {}
-        rendered = {}
-        template_info = self.active_templates.items()
-        for (led_helper, index), (uid, template, lparams) in template_info:
-            color = rendered.get(uid)
-            if color is None:
-                try:
-                    text = template.render(context, **lparams)
-                    parts = [max(0., min(1., float(f)))
-                             for f in text.split(',', 4)]
-                except Exception as e:
-                    logging.exception("led template render error")
-                    parts = []
-                if len(parts) < 4:
-                    parts += [0.] * (4 - len(parts))
-                rendered[uid] = color = tuple(parts)
-            need_transmit[led_helper] = 1
-            led_helper.set_color(index, color)
-        context.clear() # Remove circular references for better gc
-        # Transmit pending changes
-        for led_helper in need_transmit.keys():
-            led_helper.check_transmit(None)
-        return eventtime + RENDER_TIME
-    cmd_SET_LED_TEMPLATE_help = "Assign a display_template to an LED"
-    def cmd_SET_LED_TEMPLATE(self, gcmd):
-        led_name = gcmd.get("LED")
-        led_helper = self.led_helpers.get(led_name)
-        if led_helper is None:
-            raise gcmd.error("Unknown LED '%s'" % (led_name,))
-        led_count = led_helper.get_led_count()
-        index = gcmd.get_int("INDEX", None, minval=1, maxval=led_count)
-        template = None
-        lparams = {}
-        tpl_name = gcmd.get("TEMPLATE")
-        if tpl_name:
-            template = self.templates.get(tpl_name)
-            if template is None:
-                raise gcmd.error("Unknown display_template '%s'" % (tpl_name,))
-            tparams = template.get_params()
-            for p, v in gcmd.get_command_parameters().items():
-                if not p.startswith("PARAM_"):
-                    continue
-                p = p.lower()
-                if p not in tparams:
-                    raise gcmd.error("Invalid display_template parameter: %s"
-                                     % (p,))
-                try:
-                    lparams[p] = ast.literal_eval(v)
-                except ValueError as e:
-                    raise gcmd.error("Unable to parse '%s' as a literal" % (v,))
-        if index is not None:
-            self._activate_template(led_helper, index, template, lparams)
-        else:
-            for i in range(led_count):
-                self._activate_template(led_helper, i+1, template, lparams)
-        self._activate_timer()
-
-PIN_MIN_TIME = 0.100
-MAX_SCHEDULE_TIME = 5.0
-
-# Handler for PWM controlled LEDs
-class PrinterPWMLED:
-    def __init__(self, config):
-        self.printer = printer = config.get_printer()
-        # Configure pwm pins
-        ppins = printer.lookup_object('pins')
-        cycle_time = config.getfloat('cycle_time', 0.010, above=0.,
-                                     maxval=MAX_SCHEDULE_TIME)
-        hardware_pwm = config.getboolean('hardware_pwm', False)
-        self.pins = []
-        for i, name in enumerate(("red", "green", "blue", "white")):
-            pin_name = config.get(name + '_pin', None)
-            if pin_name is None:
-                continue
-            mcu_pin = ppins.setup_pin('pwm', pin_name)
-            mcu_pin.setup_max_duration(0.)
-            mcu_pin.setup_cycle_time(cycle_time, hardware_pwm)
-            self.pins.append((i, mcu_pin))
-        if not self.pins:
-            raise config.error("No LED pin definitions found in '%s'"
-                               % (config.get_name(),))
-        self.last_print_time = 0.
-        # Initialize color data
-        pled = printer.load_object(config, "led")
-        self.led_helper = pled.setup_helper(config, self.update_leds, 1)
-        self.prev_color = color = self.led_helper.get_status()['color_data'][0]
-        for idx, mcu_pin in self.pins:
-            mcu_pin.setup_start_value(color[idx], 0.)
-    def update_leds(self, led_state, print_time):
-        if print_time is None:
-            eventtime = self.printer.get_reactor().monotonic()
-            mcu = self.pins[0][1].get_mcu()
-            print_time = mcu.estimated_print_time(eventtime) + PIN_MIN_TIME
-        print_time = max(print_time, self.last_print_time + PIN_MIN_TIME)
-        color = led_state[0]
-        for idx, mcu_pin in self.pins:
-            if self.prev_color[idx] != color[idx]:
-                mcu_pin.set_pwm(print_time, color[idx])
-                self.last_print_time = print_time
-        self.prev_color = color
-    def get_status(self, eventtime=None):
-        return self.led_helper.get_status(eventtime)
-
-def load_config(config):
-    return PrinterLED(config)
-
-def load_config_prefix(config):
-    return PrinterPWMLED(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/lm75.py crealityShit/klippy/extras/lm75.py
--- klipperStock/klippy/extras/lm75.py	2024-01-14 23:01:59.465788301 -0600
+++ crealityShit/klippy/extras/lm75.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,108 +0,0 @@
-# Support for I2C based LM75/LM75A temperature sensors
-#
-# Copyright (C) 2020  Boleslaw Ciesielski <combolek@users.noreply.github.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-from . import bus
-
-LM75_CHIP_ADDR = 0x48
-LM75_I2C_SPEED = 100000
-LM75_REGS = {
-    'TEMP'   : 0x00,
-    'CONF'   : 0x01,
-    'THYST'  : 0x02,
-    'TOS'    : 0x03,
-    'PRODID' : 0x07    # TI LM75A chips only?
-}
-LM75_REPORT_TIME = .8
-# Temperature can be sampled at any time but the read aborts
-# the current conversion. Conversion time is 300ms so make
-# sure not to read too often.
-LM75_MIN_REPORT_TIME = .5
-
-class LM75:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.name = config.get_name().split()[-1]
-        self.reactor = self.printer.get_reactor()
-        self.i2c = bus.MCU_I2C_from_config(config, LM75_CHIP_ADDR,
-                                           LM75_I2C_SPEED)
-        self.mcu = self.i2c.get_mcu()
-        self.report_time = config.getfloat('lm75_report_time', LM75_REPORT_TIME,
-                                           minval=LM75_MIN_REPORT_TIME)
-        self.temp = self.min_temp = self.max_temp = 0.0
-        self.sample_timer = self.reactor.register_timer(self._sample_lm75)
-        self.printer.add_object("lm75 " + self.name, self)
-        self.printer.register_event_handler("klippy:connect",
-                                            self.handle_connect)
-
-    def handle_connect(self):
-        self._init_lm75()
-        self.reactor.update_timer(self.sample_timer, self.reactor.NOW)
-
-    def setup_minmax(self, min_temp, max_temp):
-        self.min_temp = min_temp
-        self.max_temp = max_temp
-
-    def setup_callback(self, cb):
-        self._callback = cb
-
-    def get_report_time_delta(self):
-        return self.report_time
-
-    def degrees_from_sample(self, x):
-        # The temp sample is encoded in the top 9 bits of a 16-bit
-        # value. Resolution is 0.5 degrees C.
-        return x[0] + (x[1] >> 7) * 0.5
-
-    def _init_lm75(self):
-        # Check and report the chip ID but ignore errors since many
-        # chips don't have it
-        try:
-            prodid = self.read_register('PRODID', 1)[0]
-            logging.info("lm75: Chip ID %#x" % prodid)
-        except:
-            pass
-
-    def _sample_lm75(self, eventtime):
-        try:
-            sample = self.read_register('TEMP', 2)
-            self.temp = self.degrees_from_sample(sample)
-        except Exception:
-            logging.exception("lm75: Error reading data")
-            self.temp = 0.0
-            return self.reactor.NEVER
-
-        if self.temp < self.min_temp or self.temp > self.max_temp:
-            self.printer.invoke_shutdown(
-                "LM75 temperature %0.1f outside range of %0.1f:%.01f"
-                % (self.temp, self.min_temp, self.max_temp))
-
-        measured_time = self.reactor.monotonic()
-        self._callback(self.mcu.estimated_print_time(measured_time), self.temp)
-        return measured_time + self.report_time
-
-    def read_register(self, reg_name, read_len):
-        # read a single register
-        regs = [LM75_REGS[reg_name]]
-        params = self.i2c.i2c_read(regs, read_len)
-        return bytearray(params['response'])
-
-    def write_register(self, reg_name, data):
-        if type(data) is not list:
-            data = [data]
-        reg = LM75_REGS[reg_name]
-        data.insert(0, reg)
-        self.i2c.i2c_write(data)
-
-    def get_status(self, eventtime):
-        return {
-            'temperature': round(self.temp, 2),
-        }
-
-
-def load_config(config):
-    # Register sensor
-    pheaters = config.get_printer().load_object(config, "heaters")
-    pheaters.add_sensor_factory("LM75", LM75)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/manual_stepper.py crealityShit/klippy/extras/manual_stepper.py
--- klipperStock/klippy/extras/manual_stepper.py	2024-01-14 23:01:59.441788007 -0600
+++ crealityShit/klippy/extras/manual_stepper.py	2024-01-14 23:02:21.626059926 -0600
@@ -75,7 +75,7 @@
     def do_homing_move(self, movepos, speed, accel, triggered, check_trigger):
         if not self.can_home:
             raise self.printer.command_error(
-                "No endstop for this manual stepper")
+                """{"code":"key198", "msg": "No endstop for this manual stepper", "values": []}""")
         self.homing_accel = accel
         pos = [movepos, 0., 0., 0.]
         endstops = self.rail.get_endstops()
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/mcp4018.py crealityShit/klippy/extras/mcp4018.py
--- klipperStock/klippy/extras/mcp4018.py	2024-01-14 23:01:59.481788498 -0600
+++ crealityShit/klippy/extras/mcp4018.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,97 +0,0 @@
-# MCP4018 digipot support (via bit-banging)
-#
-# Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-class SoftwareI2C:
-    def __init__(self, config, addr):
-        self.addr = addr << 1
-        self.update_pin_cmd = None
-        # Lookup pins
-        ppins = config.get_printer().lookup_object('pins')
-        scl_pin = config.get('scl_pin')
-        scl_params = ppins.lookup_pin(scl_pin, share_type='sw_scl')
-        self.mcu = scl_params['chip']
-        self.scl_pin = scl_params['pin']
-        self.scl_main = scl_params.get('class')
-        if self.scl_main is None:
-            self.scl_main = scl_params['class'] = self
-            self.scl_oid = self.mcu.create_oid()
-            self.cmd_queue = self.mcu.alloc_command_queue()
-            self.mcu.register_config_callback(self.build_config)
-        else:
-            self.scl_oid = self.scl_main.scl_oid
-            self.cmd_queue = self.scl_main.cmd_queue
-        sda_params = ppins.lookup_pin(config.get('sda_pin'))
-        self.sda_oid = self.mcu.create_oid()
-        if sda_params['chip'] != self.mcu:
-            raise ppins.error("%s: scl_pin and sda_pin must be on same mcu" % (
-                config.get_name(),))
-        self.mcu.add_config_cmd("config_digital_out oid=%d pin=%s"
-                                " value=%d default_value=%d max_duration=%d" % (
-                                    self.sda_oid, sda_params['pin'], 1, 1, 0))
-    def get_mcu(self):
-        return self.mcu
-    def build_config(self):
-        self.mcu.add_config_cmd("config_digital_out oid=%d pin=%s value=%d"
-                                " default_value=%d max_duration=%d" % (
-                                    self.scl_oid, self.scl_pin, 1, 1, 0))
-        self.update_pin_cmd = self.mcu.lookup_command(
-            "update_digital_out oid=%c value=%c", cq=self.cmd_queue)
-    def i2c_write(self, msg, minclock=0, reqclock=0):
-        msg = [self.addr] + msg
-        send = self.scl_main.update_pin_cmd.send
-        # Send ack
-        send([self.sda_oid, 0], minclock=minclock, reqclock=reqclock)
-        send([self.scl_oid, 0], minclock=minclock, reqclock=reqclock)
-        # Send bytes
-        sda_last = 0
-        for data in msg:
-            # Transmit 8 data bits
-            for i in range(8):
-                sda_next = not not (data & (0x80 >> i))
-                if sda_last != sda_next:
-                    sda_last = sda_next
-                    send([self.sda_oid, sda_last],
-                         minclock=minclock, reqclock=reqclock)
-                send([self.scl_oid, 1], minclock=minclock, reqclock=reqclock)
-                send([self.scl_oid, 0], minclock=minclock, reqclock=reqclock)
-            # Transmit clock for ack
-            send([self.scl_oid, 1], minclock=minclock, reqclock=reqclock)
-            send([self.scl_oid, 0], minclock=minclock, reqclock=reqclock)
-        # Send stop
-        if sda_last:
-            send([self.sda_oid, 0], minclock=minclock, reqclock=reqclock)
-        send([self.scl_oid, 1], minclock=minclock, reqclock=reqclock)
-        send([self.sda_oid, 1], minclock=minclock, reqclock=reqclock)
-
-class mcp4018:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.i2c = SoftwareI2C(config, 0x2f)
-        self.scale = config.getfloat('scale', 1., above=0.)
-        self.start_value = config.getfloat('wiper',
-                                           minval=0., maxval=self.scale)
-        config.get_printer().register_event_handler("klippy:connect",
-                                                    self.handle_connect)
-        # Register commands
-        self.name = config.get_name().split()[1]
-        gcode = self.printer.lookup_object('gcode')
-        gcode.register_mux_command("SET_DIGIPOT", "DIGIPOT", self.name,
-                                   self.cmd_SET_DIGIPOT,
-                                   desc=self.cmd_SET_DIGIPOT_help)
-    def handle_connect(self):
-        self.set_dac(self.start_value)
-    def set_dac(self, value):
-        val = int(value * 127. / self.scale + .5)
-        self.i2c.i2c_write([val])
-    cmd_SET_DIGIPOT_help = "Set digipot value"
-    def cmd_SET_DIGIPOT(self, gcmd):
-        wiper = gcmd.get_float('WIPER', minval=0., maxval=self.scale)
-        if wiper is not None:
-            self.set_dac(wiper)
-            gcmd.respond_info("New value for DIGIPOT = %s, wiper = %.2f"
-                               % (self.name, wiper))
-def load_config_prefix(config):
-    return mcp4018(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/mcp4451.py crealityShit/klippy/extras/mcp4451.py
--- klipperStock/klippy/extras/mcp4451.py	2024-01-14 23:01:59.489788594 -0600
+++ crealityShit/klippy/extras/mcp4451.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,30 +0,0 @@
-# MCP4451 digipot code
-#
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-from . import bus
-
-WiperRegisters = [0x00, 0x01, 0x06, 0x07]
-
-class mcp4451:
-    def __init__(self, config):
-        self.i2c = bus.MCU_I2C_from_config(config)
-        i2c_addr = self.i2c.get_i2c_address()
-        if i2c_addr < 44 or i2c_addr > 47:
-            raise config.error("mcp4451 address must be between 44 and 47")
-        scale = config.getfloat('scale', 1., above=0.)
-        # Configure registers
-        self.set_register(0x04, 0xff)
-        self.set_register(0x0a, 0xff)
-        for i in range(4):
-            val = config.getfloat('wiper_%d' % (i,), None,
-                                  minval=0., maxval=scale)
-            if val is not None:
-                val = int(val * 255. / scale + .5)
-                self.set_register(WiperRegisters[i], val)
-    def set_register(self, reg, value):
-        self.i2c.i2c_write([(reg << 4) | ((value >> 8) & 0x03), value])
-
-def load_config_prefix(config):
-    return mcp4451(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/mcp4728.py crealityShit/klippy/extras/mcp4728.py
--- klipperStock/klippy/extras/mcp4728.py	2024-01-14 23:01:59.445788055 -0600
+++ crealityShit/klippy/extras/mcp4728.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,23 +0,0 @@
-# MCP4728 dac code
-#
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-from . import bus
-
-class mcp4728:
-    def __init__(self, config):
-        self.i2c = bus.MCU_I2C_from_config(config, default_addr=0x60)
-        scale = config.getfloat('scale', 1., above=0.)
-        # Configure registers
-        for i, name in enumerate('abcd'):
-            val = config.getfloat('channel_%s' % (name,), None,
-                                  minval=0., maxval=scale)
-            if val is not None:
-                self.set_dac(i, int(val * 4095. / scale + .5))
-    def set_dac(self, dac, value):
-        self.i2c.i2c_write([0x40 | (dac << 1),
-                            ((value >> 8) & 0x0f) | 0x80, value & 0xff])
-
-def load_config_prefix(config):
-    return mcp4728(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/metadata.py crealityShit/klippy/extras/metadata.py
--- klipperStock/klippy/extras/metadata.py	1969-12-31 18:00:00.000000000 -0600
+++ crealityShit/klippy/extras/metadata.py	2024-01-14 23:02:21.686060659 -0600
@@ -0,0 +1,1196 @@
+#!/usr/bin/env python3
+# GCode metadata extraction utility
+#
+# Copyright (C) 2020 Eric Callahan <arksine.code@gmail.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+
+from __future__ import annotations
+import json
+import argparse
+import re
+import os
+import sys
+import base64
+import traceback
+import tempfile
+import zipfile
+import shutil
+import uuid
+from PIL import Image
+
+# Annotation imports
+from typing import (
+    TYPE_CHECKING,
+    Any,
+    Optional,
+    Dict,
+    List,
+    Tuple,
+    Type,
+)
+if TYPE_CHECKING:
+    pass
+
+UFP_MODEL_PATH = "/3D/model.gcode"
+UFP_THUMB_PATH = "/Metadata/thumbnail.png"
+
+def log_to_stderr(msg: str) -> None:
+    sys.stderr.write(f"{msg}\n")
+    sys.stderr.flush()
+
+# regex helpers
+def _regex_find_floats(pattern: str,
+                       data: str,
+                       strict: bool = False
+                       ) -> List[float]:
+    # If strict is enabled, pattern requires a floating point
+    # value, otherwise it can be an integer value
+    fptrn = r'\d+\.\d*' if strict else r'\d+\.?\d*'
+    matches = re.findall(pattern, data)
+    if matches:
+        # return the maximum height value found
+        try:
+            return [float(h) for h in re.findall(
+                    fptrn, " ".join(matches))]
+        except Exception:
+            pass
+    return []
+
+def _regex_find_ints(pattern: str, data: str) -> List[int]:
+    matches = re.findall(pattern, data)
+    if matches:
+        # return the maximum height value found
+        try:
+            return [int(h) for h in re.findall(
+                    r'\d+', " ".join(matches))]
+        except Exception:
+            pass
+    return []
+
+def _regex_find_first(pattern: str, data: str) -> Optional[float]:
+    match = re.search(pattern, data)
+    val: Optional[float] = None
+    if match:
+        try:
+            val = float(match.group(1))
+        except Exception:
+            return None
+    return val
+
+def _regex_find_int(pattern: str, data: str) -> Optional[int]:
+    match = re.search(pattern, data)
+    val: Optional[int] = None
+    if match:
+        try:
+            val = int(match.group(1))
+        except Exception:
+            return None
+    return val
+
+def _regex_find_string(pattern: str, data: str) -> Optional[str]:
+    match = re.search(pattern, data)
+    if match:
+        return match.group(1).strip('"')
+    return None
+
+def get_print_file_metadata(file_path):
+    result = {}
+    count = 3000
+    try:
+        with open(file_path, "r") as f:
+            while count:
+                count -= 1
+                line = f.readline() 
+                if not line.startswith(";"):
+                    continue
+                if re.findall(r";MINX:(.*)\n", line):  
+                    result["MINX"] = float(re.findall(r";MINX:(.*)\n", line)[0].strip())
+                if re.findall(r";MINY:(.*)\n", line):  
+                    result["MINY"] = float(re.findall(r";MINY:(.*)\n", line)[0].strip()) 
+                if re.findall(r";MINZ:(.*)\n", line):  
+                    result["MINZ"] = float(re.findall(r";MINZ:(.*)\n", line)[0].strip())
+                if re.findall(r";MAXX:(.*)\n", line):  
+                    result["MAXX"] = float(re.findall(r";MAXX:(.*)\n", line)[0].strip()) 
+                if re.findall(r";MAXY:(.*)\n", line):  
+                    result["MAXY"] = float(re.findall(r";MAXY:(.*)\n", line)[0].strip())
+                if re.findall(r";MAXZ:(.*)\n", line):  
+                    result["MAXZ"] = float(re.findall(r";MAXZ:(.*)\n", line)[0].strip())
+                if re.findall(r";Machine Height:(.*)\n", line):  
+                    result["MachineHeight"] = float(re.findall(r";Machine Height:(.*)\n", line)[0].strip())
+                if re.findall(r";Machine Width:(.*)\n", line):  
+                    result["MachineWidth"] = float(re.findall(r";Machine Width:(.*)\n", line)[0].strip())
+                if re.findall(r";Machine Depth:(.*)\n", line):  
+                    result["MachineDepth"] = float(re.findall(r";Machine Depth:(.*)\n", line)[0].strip())
+                if re.findall(r";Material Name:(.*)\n", line):  
+                    result["MaterialName"] = str(re.findall(r";Material Name:(.*)\n", line)[0].strip())
+                if re.findall(r";Material Type:(.*)\n", line):  
+                    result["MaterialType"] = str(re.findall(r";Material Type:(.*)\n", line)[0].strip())
+    except Exception as err:
+        print(err)
+        return None
+    return result
+
+# Slicer parsing implementations
+class BaseSlicer(object):
+    def __init__(self, file_path: str) -> None:
+        self.path = file_path
+        self.header_data: str = ""
+        self.footer_data: str = ""
+        self.layer_height: Optional[float] = None
+        self.has_m486_objects: bool = False
+
+    def set_data(self,
+                 header_data: str,
+                 footer_data: str,
+                 fsize: int) -> None:
+        self.header_data = header_data
+        self.footer_data = footer_data
+        self.size: int = fsize
+
+    def _parse_min_float(self,
+                         pattern: str,
+                         data: str,
+                         strict: bool = False
+                         ) -> Optional[float]:
+        result = _regex_find_floats(pattern, data, strict)
+        if result:
+            return min(result)
+        else:
+            return None
+
+    def _parse_max_float(self,
+                         pattern: str,
+                         data: str,
+                         strict: bool = False
+                         ) -> Optional[float]:
+        result = _regex_find_floats(pattern, data, strict)
+        if result:
+            return max(result)
+        else:
+            return None
+
+    def _check_has_objects(self,
+                           data: str,
+                           pattern: Optional[str] = None
+                           ) -> bool:
+        match = re.search(
+            r"\n((DEFINE_OBJECT)|(EXCLUDE_OBJECT_DEFINE)) NAME=",
+            data
+        )
+        if match is not None:
+            # Objects already processed
+            fname = os.path.basename(self.path)
+            log_to_stderr(
+                f"File '{fname}' currently supports cancellation, "
+                "processing aborted"
+            )
+            if match.group(1).startswith("DEFINE_OBJECT"):
+                log_to_stderr(
+                    "Legacy object processing detected.  This is not "
+                    "compatible with official versions of Klipper."
+                )
+            return False
+        # Always check M486
+        patterns = [r"\nM486"]
+        if pattern is not None:
+            patterns.append(pattern)
+        for regex in patterns:
+            if re.search(regex, data) is not None:
+                self.has_m486_objects = regex == r"\nM486"
+                return True
+        return False
+
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        return None
+
+    def has_objects(self) -> bool:
+        return self._check_has_objects(self.header_data)
+
+    def parse_gcode_start_byte(self) -> Optional[int]:
+        m = re.search(r"\n[MG]\d+\s.*\n", self.header_data)
+        if m is None:
+            return None
+        return m.start()
+
+    def parse_gcode_end_byte(self) -> Optional[int]:
+        rev_data = self.footer_data[::-1]
+        m = re.search(r"\n.*\s\d+[MG]\n", rev_data)
+        if m is None:
+            return None
+        return self.size - m.start()
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        return None
+
+    def parse_model_info(self):
+        return None
+
+    def parse_layer_height(self) -> Optional[float]:
+        return None
+
+    def parse_object_height(self) -> Optional[float]:
+        return None
+
+    def parse_filament_total(self) -> Optional[float]:
+        return None
+
+    def parse_filament_weight_total(self) -> Optional[float]:
+        return None
+
+    def parse_filament_name(self) -> Optional[str]:
+        return None
+
+    def parse_filament_type(self) -> Optional[str]:
+        return None
+
+    def parse_estimated_time(self) -> Optional[float]:
+        return None
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return None
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return None
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return None
+
+    def parse_layer_count(self) -> Optional[int]:
+        return None
+
+    def parse_nozzle_diameter(self) -> Optional[float]:
+        return None
+
+class UnknownSlicer(BaseSlicer):
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        return {'slicer': "Unknown"}
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        return self._parse_min_float(r"G1\sZ\d+\.\d*", self.header_data)
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_object_height(self) -> Optional[float]:
+        return self._parse_max_float(r"G1\sZ\d+\.\d*", self.footer_data)
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M109 S(\d+\.?\d*)", self.header_data)
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M190 S(\d+\.?\d*)", self.header_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M191 S(\d+\.?\d*)", self.header_data)
+
+
+class PrusaSlicer(BaseSlicer):
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        aliases = {
+            'PrusaSlicer': r"PrusaSlicer\s(.*)\son",
+            'SuperSlicer': r"SuperSlicer\s(.*)\son",
+            'OrcaSlicer': r"OrcaSlicer\s(.*)\son",
+            'SliCR-3D': r"SliCR-3D\s(.*)\son",
+            'BambuStudio': r"BambuStudio[^ ]*\s(.*)\n",
+            'A3dp-Slicer': r"A3dp-Slicer\s(.*)\son",
+        }
+        for name, expr in aliases.items():
+            match = re.search(expr, data)
+            if match:
+                return {
+                    'slicer': name,
+                    'slicer_version': match.group(1)
+                }
+        return None
+
+    def has_objects(self) -> bool:
+        return self._check_has_objects(
+            self.header_data, r"\n; printing object")
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        # Check percentage
+        pct = _regex_find_first(
+            r"; first_layer_height = (\d+)%", self.footer_data)
+        if pct is not None:
+            if self.layer_height is None:
+                # Failed to parse the original layer height, so it is not
+                # possible to calculate a percentage
+                return None
+            return round(pct / 100. * self.layer_height, 6)
+        return _regex_find_first(
+            r"; first_layer_height = (\d+\.?\d*)", self.footer_data)
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_layer_height(self) -> Optional[float]:
+        self.layer_height = _regex_find_first(
+            r"; layer_height = (\d+\.?\d*)", self.footer_data)
+        return self.layer_height
+
+    def parse_object_height(self) -> Optional[float]:
+        matches = re.findall(
+            r";BEFORE_LAYER_CHANGE\n(?:.*\n)?;(\d+\.?\d*)", self.footer_data)
+        if matches:
+            try:
+                matches = [float(m) for m in matches]
+            except Exception:
+                pass
+            else:
+                return max(matches)
+        return self._parse_max_float(r"G1\sZ\d+\.\d*\sF", self.footer_data)
+
+    def parse_filament_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r"filament\sused\s\[mm\]\s=\s(\d+\.\d*)", self.footer_data)
+
+    def parse_filament_weight_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r"total\sfilament\sused\s\[g\]\s=\s(\d+\.\d*)", self.footer_data)
+
+    def parse_filament_type(self) -> Optional[str]:
+        return _regex_find_string(
+            r";\sfilament_type\s=\s(.*)", self.footer_data)
+
+    def parse_filament_name(self) -> Optional[str]:
+        return _regex_find_string(
+            r";\sfilament_settings_id\s=\s(.*)", self.footer_data)
+
+    def parse_estimated_time(self) -> Optional[float]:
+        time_match = re.search(
+            r';\sestimated\sprinting\stime.*', self.footer_data)
+        if not time_match:
+            return None
+        total_time = 0
+        time_group = time_match.group()
+        time_patterns = [(r"(\d+)d", 24*60*60), (r"(\d+)h", 60*60),
+                         (r"(\d+)m", 60), (r"(\d+)s", 1)]
+        try:
+            for pattern, multiplier in time_patterns:
+                t = re.search(pattern, time_group)
+                if t:
+                    total_time += int(t.group(1)) * multiplier
+        except Exception:
+            return None
+        return round(total_time, 2)
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; first_layer_temperature = (\d+\.?\d*)", self.footer_data)
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; first_layer_bed_temperature = (\d+\.?\d*)", self.footer_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; chamber_temperature = (\d+\.?\d*)", self.footer_data)
+
+    def parse_nozzle_diameter(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\snozzle_diameter\s=\s(\d+\.\d*)", self.footer_data)
+
+    def parse_layer_count(self) -> Optional[int]:
+        return _regex_find_int(
+            r"; total layers count = (\d+)", self.footer_data)
+
+class Slic3rPE(PrusaSlicer):
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        match = re.search(r"Slic3r\sPrusa\sEdition\s(.*)\son", data)
+        if match:
+            return {
+                'slicer': "Slic3r PE",
+                'slicer_version': match.group(1)
+            }
+        return None
+
+    def parse_filament_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r"filament\sused\s=\s(\d+\.\d+)mm", self.footer_data)
+
+
+class Slic3r(Slic3rPE):
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        match = re.search(r"Slic3r\s(\d.*)\son", data)
+        if match:
+            return {
+                'slicer': "Slic3r",
+                'slicer_version': match.group(1)
+            }
+        return None
+
+    def parse_filament_total(self) -> Optional[float]:
+        filament = _regex_find_first(
+            r";\sfilament\_length\_m\s=\s(\d+\.\d*)", self.footer_data)
+        if filament is not None:
+            filament *= 1000
+        return filament
+
+    def parse_filament_weight_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\sfilament\smass\_g\s=\s(\d+\.\d*)", self.footer_data)
+
+    def parse_estimated_time(self) -> Optional[float]:
+        return None
+
+class Cura(BaseSlicer):
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        match = re.search(r"Cura_SteamEngine\s(.*)", data)
+        if match:
+            return {
+                'slicer': "Cura",
+                'slicer_version': match.group(1)
+            }
+        return None
+
+    def has_objects(self) -> bool:
+        return self._check_has_objects(
+            self.header_data, r"\n;MESH:")
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        return _regex_find_first(r";MINZ:(\d+\.?\d*)", self.header_data)
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_layer_height(self) -> Optional[float]:
+        self.layer_height = _regex_find_first(
+            r";Layer\sheight:\s(\d+\.?\d*)", self.header_data)
+        return self.layer_height
+
+    def parse_object_height(self) -> Optional[float]:
+        return _regex_find_first(r";MAXZ:(\d+\.?\d*)", self.header_data)
+
+    def parse_filament_total(self) -> Optional[float]:
+        filament = _regex_find_first(
+            r";Filament\sused:\s(\d+\.?\d*)m", self.header_data)
+        if filament is not None:
+            filament *= 1000
+        return filament
+
+    def parse_filament_weight_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r";Filament\sweight\s=\s.(\d+\.\d+).", self.header_data)
+
+    def parse_filament_type(self) -> Optional[str]:
+        return _regex_find_string(
+            r";Filament\stype\s=\s(.*)", self.header_data)
+
+    def parse_filament_name(self) -> Optional[str]:
+        return _regex_find_string(
+            r";Filament\sname\s=\s(.*)", self.header_data)
+
+    def parse_estimated_time(self) -> Optional[float]:
+        return self._parse_max_float(r";TIME:.*", self.header_data)
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M109 S(\d+\.?\d*)", self.header_data)
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M190 S(\d+\.?\d*)", self.header_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M191 S(\d+\.?\d*)", self.header_data)
+
+    def parse_layer_count(self) -> Optional[int]:
+        return _regex_find_int(
+            r";LAYER_COUNT\:(\d+)", self.header_data)
+
+    def parse_nozzle_diameter(self) -> Optional[float]:
+        return _regex_find_first(
+            r";Nozzle\sdiameter\s=\s(\d+\.\d*)", self.header_data)
+
+class Simplify3D(BaseSlicer):
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        match = re.search(r"Simplify3D\(R\)\sVersion\s(.*)", data)
+        if match:
+            self._version = match.group(1)
+            self._is_v5 = self._version.startswith("5")
+            return {
+                'slicer': "Simplify3D",
+                'slicer_version': match.group(1)
+            }
+        return None
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        return self._parse_min_float(r"G1\sZ\d+\.\d*", self.header_data)
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_layer_height(self) -> Optional[float]:
+        self.layer_height = _regex_find_first(
+            r";\s+layerHeight,(\d+\.?\d*)", self.header_data)
+        return self.layer_height
+
+    def parse_object_height(self) -> Optional[float]:
+        return self._parse_max_float(r"G1\sZ\d+\.\d*", self.footer_data)
+
+    def parse_filament_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\s+(?:Filament\slength|Material\sLength):\s(\d+\.?\d*)\smm",
+            self.footer_data
+        )
+
+    def parse_filament_weight_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\s+(?:Plastic\sweight|Material\sWeight):\s(\d+\.?\d*)\sg",
+            self.footer_data
+        )
+
+    def parse_filament_name(self) -> Optional[str]:
+        return _regex_find_string(
+            r";\s+printMaterial,(.*)", self.header_data)
+
+    def parse_filament_type(self) -> Optional[str]:
+        return _regex_find_string(
+            r";\s+makerBotModelMaterial,(.*)", self.footer_data)
+
+    def parse_estimated_time(self) -> Optional[float]:
+        time_match = re.search(
+            r';\s+Build (t|T)ime:.*', self.footer_data)
+        if not time_match:
+            return None
+        total_time = 0
+        time_group = time_match.group()
+        time_patterns = [(r"(\d+)\shours?", 60*60), (r"(\d+)\smin", 60),
+                         (r"(\d+)\ssec", 1)]
+        try:
+            for pattern, multiplier in time_patterns:
+                t = re.search(pattern, time_group)
+                if t:
+                    total_time += int(t.group(1)) * multiplier
+        except Exception:
+            return None
+        return round(total_time, 2)
+
+    def _get_temp_items(self, pattern: str) -> List[str]:
+        match = re.search(pattern, self.header_data)
+        if match is None:
+            return []
+        return match.group().split(",")[1:]
+
+    def _get_first_layer_temp(self, heater: str) -> Optional[float]:
+        heaters = self._get_temp_items(r"temperatureName.*")
+        temps = self._get_temp_items(r"temperatureSetpointTemperatures.*")
+        for h, temp in zip(heaters, temps):
+            if h == heater:
+                try:
+                    return float(temp)
+                except Exception:
+                    return None
+        return None
+
+    def _get_first_layer_temp_v5(self, heater_type: str) -> Optional[float]:
+        pattern = (
+            r";\s+temperatureController,.+?"
+            r";\s+temperatureType,"f"{heater_type}"r".+?"
+            r";\s+temperatureSetpoints,\d+\|(\d+)"
+        )
+        match = re.search(pattern, self.header_data, re.MULTILINE | re.DOTALL)
+        if match is not None:
+            try:
+                return float(match.group(1))
+            except Exception:
+                return None
+        return None
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        if self._is_v5:
+            return self._get_first_layer_temp_v5("extruder")
+        else:
+            return self._get_first_layer_temp("Extruder 1")
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        if self._is_v5:
+            return self._get_first_layer_temp_v5("platform")
+        else:
+            return self._get_first_layer_temp("Heated Bed")
+
+    def parse_nozzle_diameter(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\s+(?:extruderDiameter|nozzleDiameter),(\d+\.\d*)",
+            self.header_data
+        )
+
+class KISSlicer(BaseSlicer):
+    def check_identity(self, data: str) -> Optional[Dict[str, Any]]:
+        match = re.search(r";\sKISSlicer", data)
+        if match:
+            ident = {'slicer': "KISSlicer"}
+            vmatch = re.search(r";\sversion\s(.*)", data)
+            if vmatch:
+                version = vmatch.group(1).replace(" ", "-")
+                ident['slicer_version'] = version
+            return ident
+        return None
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\s+first_layer_thickness_mm\s=\s(\d+\.?\d*)", self.header_data)
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_layer_height(self) -> Optional[float]:
+        self.layer_height = _regex_find_first(
+            r";\s+max_layer_thickness_mm\s=\s(\d+\.?\d*)", self.header_data)
+        return self.layer_height
+
+    def parse_object_height(self) -> Optional[float]:
+        return self._parse_max_float(
+            r";\sEND_LAYER_OBJECT\sz.*", self.footer_data)
+
+    def parse_filament_total(self) -> Optional[float]:
+        filament = _regex_find_floats(
+            r";\s+Ext\s.*mm", self.footer_data, strict=True)
+        if filament:
+            return sum(filament)
+        return None
+
+    def parse_estimated_time(self) -> Optional[float]:
+        time = _regex_find_first(
+            r";\sCalculated.*Build\sTime:\s(\d+\.?\d*)\sminutes",
+            self.footer_data)
+        if time is not None:
+            time *= 60
+            return round(time, 2)
+        return None
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; first_layer_C = (\d+\.?\d*)", self.header_data)
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; bed_C = (\d+\.?\d*)", self.header_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; chamber_C = (\d+\.?\d*)", self.header_data)
+
+
+class IdeaMaker(BaseSlicer):
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        match = re.search(r"\sideaMaker\s(.*),", data)
+        if match:
+            return {
+                'slicer': "IdeaMaker",
+                'slicer_version': match.group(1)
+            }
+        return None
+
+    def has_objects(self) -> bool:
+        return self._check_has_objects(
+            self.header_data, r"\n;PRINTING:")
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        layer_info = _regex_find_floats(
+            r";LAYER:0\s*.*\s*;HEIGHT.*", self.header_data)
+        if len(layer_info) >= 3:
+            return layer_info[2]
+        return None
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_layer_height(self) -> Optional[float]:
+        layer_info = _regex_find_floats(
+            r";LAYER:1\s*.*\s*;HEIGHT.*", self.header_data)
+        if len(layer_info) >= 3:
+            self.layer_height = layer_info[2]
+            return self.layer_height
+        return None
+
+    def parse_object_height(self) -> Optional[float]:
+        bounds = _regex_find_floats(
+            r";Bounding Box:.*", self.header_data)
+        if len(bounds) >= 6:
+            return bounds[5]
+        return None
+
+    def parse_filament_total(self) -> Optional[float]:
+        filament = _regex_find_floats(
+            r";Material.\d\sUsed:.*", self.footer_data, strict=True)
+        if filament:
+            return sum(filament)
+        return None
+
+    def parse_filament_type(self) -> Optional[str]:
+        return _regex_find_string(
+            r";Filament\stype\s=\s(.*)", self.header_data)
+
+    def parse_filament_name(self) -> Optional[str]:
+        return _regex_find_string(
+            r";Filament\sname\s=\s(.*)", self.header_data)
+
+    def parse_filament_weight_total(self) -> Optional[float]:
+        pi = 3.141592653589793
+        length = _regex_find_floats(
+            r";Material.\d\sUsed:.*", self.footer_data, strict=True)
+        diameter = _regex_find_floats(
+            r";Filament\sDiameter\s.\d:.*", self.header_data, strict=True)
+        density = _regex_find_floats(
+            r";Filament\sDensity\s.\d:.*", self.header_data, strict=True)
+        if len(length) == len(density) == len(diameter):
+            # calc individual weight for each filament with m=pi/4*d²*l*rho
+            weights = [(pi/4 * diameter[i]**2 * length[i] * density[i]/10**6)
+                       for i in range(len(length))]
+            return sum(weights)
+        return None
+
+    def parse_estimated_time(self) -> Optional[float]:
+        return _regex_find_first(
+            r";Print\sTime:\s(\d+\.?\d*)", self.footer_data)
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M109 T0 S(\d+\.?\d*)", self.header_data)
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M190 S(\d+\.?\d*)", self.header_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M191 S(\d+\.?\d*)", self.header_data)
+
+    def parse_nozzle_diameter(self) -> Optional[float]:
+        return _regex_find_first(
+            r";Dimension:(?:\s\d+\.\d+){3}\s(\d+\.\d+)", self.header_data)
+
+class IceSL(BaseSlicer):
+    def check_identity(self, data) -> Optional[Dict[str, Any]]:
+        match = re.search(r"<IceSL\s(.*)>", data)
+        if match:
+            version = match.group(1) if match.group(1)[0].isdigit() else "-"
+            return {
+                'slicer': "IceSL",
+                'slicer_version': version
+            }
+        return None
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\sz_layer_height_first_layer_mm\s:\s+(\d+\.\d+)",
+            self.header_data)
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_layer_height(self) -> Optional[float]:
+        self.layer_height = _regex_find_first(
+            r";\sz_layer_height_mm\s:\s+(\d+\.\d+)",
+            self.header_data)
+        return self.layer_height
+
+    def parse_object_height(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\sprint_height_mm\s:\s+(\d+\.\d+)", self.header_data)
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\sextruder_temp_degree_c_0\s:\s+(\d+\.?\d*)", self.header_data)
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\sbed_temp_degree_c\s:\s+(\d+\.?\d*)", self.header_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\schamber_temp_degree_c\s:\s+(\d+\.?\d*)", self.header_data)
+
+    def parse_filament_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\sfilament_used_mm\s:\s+(\d+\.\d+)", self.header_data)
+
+    def parse_filament_weight_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\sfilament_used_g\s:\s+(\d+\.\d+)", self.header_data)
+
+    def parse_filament_name(self) -> Optional[str]:
+        return _regex_find_string(
+            r";\sfilament_name\s:\s+(.*)", self.header_data)
+
+    def parse_filament_type(self) -> Optional[str]:
+        return _regex_find_string(
+            r";\sfilament_type\s:\s+(.*)", self.header_data)
+
+    def parse_estimated_time(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\sestimated_print_time_s\s:\s+(\d*\.*\d*)", self.header_data)
+
+    def parse_layer_count(self) -> Optional[int]:
+        return _regex_find_int(
+            r";\slayer_count\s:\s+(\d+)", self.header_data)
+
+    def parse_nozzle_diameter(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\snozzle_diameter_mm_0\s:\s+(\d+\.\d+)", self.header_data)
+
+class KiriMoto(BaseSlicer):
+    def check_identity(self, data) -> Optional[Dict[str, Any]]:
+        variants: Dict[str, str] = {
+            "Kiri:Moto": r"; Generated by Kiri:Moto (\d.+)",
+            "SimplyPrint": r"; Generated by Kiri:Moto \(SimplyPrint\) (.+)"
+        }
+        for name, pattern in variants.items():
+            match = re.search(pattern, data)
+            if match:
+                return {
+                    "slicer": name,
+                    "slicer_version": match.group(1)
+                }
+        return None
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; firstSliceHeight = (\d+\.\d+)", self.header_data
+        )
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_layer_height(self) -> Optional[float]:
+        self.layer_height = _regex_find_first(
+            r"; sliceHeight = (\d+\.\d+)", self.header_data
+        )
+        return self.layer_height
+
+    def parse_object_height(self) -> Optional[float]:
+        return self._parse_max_float(
+            r"G1 Z\d+\.\d+ (?:; z-hop end|F\d+\n)",
+            self.footer_data, strict=True
+        )
+
+    def parse_layer_count(self) -> Optional[int]:
+        matches = re.findall(
+            r";; --- layer (\d+) \(.+", self.footer_data
+        )
+        if not matches:
+            return None
+        try:
+            return int(matches[-1]) + 1
+        except Exception:
+            return None
+
+    def parse_estimated_time(self) -> Optional[float]:
+        return _regex_find_int(r"; --- print time: (\d+)s", self.footer_data)
+
+    def parse_filament_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; --- filament used: (\d+\.?\d*) mm", self.footer_data
+        )
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; firstLayerNozzleTemp = (\d+\.?\d*)", self.header_data
+        )
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; firstLayerBedTemp = (\d+\.?\d*)", self.header_data
+        )
+
+class Creality(BaseSlicer):
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        aliases = {
+            'Creative3D': r"Creative3D",
+            'Creality': r"Creality"
+        }
+        pattern = r'Version : V([\d\.]+)'
+        match_version = re.search(pattern, data)
+        slicer_version = match_version.group(1) if match_version else "1.0"
+        for name, expr in aliases.items():
+            match = re.search(expr, data)
+            # ;Creality Print Version : V4.3.7.6456
+            if match:
+                return {
+                    'slicer': name,
+                    'slicer_version': slicer_version
+                }
+        return None
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        return _regex_find_first(
+            r";MINZ:(\d+\.?\d*)", self.footer_data)
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_layer_height(self) -> Optional[float]:
+        pattern = r";Layer\sheight:\s(\d+\.?\d*)"
+        self.layer_height = _regex_find_first(
+            pattern, self.footer_data)
+        return self.layer_height
+
+    def parse_object_height(self) -> Optional[float]:
+        matches = re.findall(
+            r";MAXZ:(\d+\.?\d*)", self.footer_data)
+        if matches:
+            try:
+                matches = [float(m) for m in matches]
+            except Exception:
+                pass
+            else:
+                return max(matches)
+        return self._parse_max_float(r"G1\sZ\d+\.\d*\sF", self.footer_data)
+
+    def parse_layer_count(self) -> Optional[int]:
+        return _regex_find_int(
+            r";LAYER_COUNT\:(\d+)", self.header_data)
+
+    def parse_filament_type(self) -> Optional[str]:
+        return _regex_find_string(
+            r";Material Type:(\S+)", self.header_data)
+
+    def parse_filament_name(self) -> Optional[str]:
+        return _regex_find_string(
+            r";Material Name:(.+)", self.header_data)
+
+    def parse_filament_total(self) -> Optional[float]:
+        filament_total = _regex_find_first(
+            r";Filament used:(\d+\.?\d*)m", self.footer_data)
+        filament_total = filament_total * 1000
+        return filament_total
+
+    def parse_filament_weight_total(self) -> Optional[float]:
+        filament_total = _regex_find_first(
+            r";Filament used:(\d+\.?\d*)m", self.footer_data)
+        filament_weight_total = filament_total * 5.88
+        return filament_weight_total
+
+    def parse_estimated_time(self) -> Optional[float]:
+        total_time = _regex_find_first(
+            r";TIME:(\d+)", self.footer_data)
+        return total_time
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        # return _regex_find_first(
+        #     r"; first_layer_temperature = (\d+\.?\d*)", self.footer_data)
+        return _regex_find_first(
+            r";Print Temperature:(\d+\.?\d*)", self.footer_data)
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r";Bed Temperature:(\d+\.?\d*)", self.footer_data)
+
+
+READ_SIZE = 512 * 1024
+SUPPORTED_SLICERS: List[Type[BaseSlicer]] = [
+    PrusaSlicer, Slic3rPE, Slic3r, Cura, Simplify3D,
+    KISSlicer, IdeaMaker, IceSL, KiriMoto, Creality
+]
+SUPPORTED_DATA = [
+    'gcode_start_byte',
+    'gcode_end_byte',
+    'layer_count',
+    'object_height',
+    'estimated_time',
+    'nozzle_diameter',
+    'layer_height',
+    'first_layer_height',
+    'first_layer_extr_temp',
+    'first_layer_bed_temp',
+    'chamber_temp',
+    'filament_name',
+    'filament_type',
+    'filament_total',
+    'filament_weight_total',
+    'model_info']
+
+def process_objects(file_path: str, slicer: BaseSlicer, name: str) -> bool:
+    try:
+        from preprocess_cancellation import (
+            preprocess_slicer,
+            preprocess_cura,
+            preprocess_ideamaker,
+            preprocess_m486
+        )
+    except ImportError:
+        log_to_stderr("Module 'preprocess-cancellation' failed to load")
+        return False
+    fname = os.path.basename(file_path)
+    log_to_stderr(
+        f"Performing Object Processing on file: {fname}, "
+        f"sliced by {name}"
+    )
+    with tempfile.TemporaryDirectory() as tmp_dir_name:
+        tmp_file = os.path.join(tmp_dir_name, fname)
+        with open(file_path, 'r') as in_file:
+            with open(tmp_file, 'w') as out_file:
+                try:
+                    if slicer.has_m486_objects:
+                        processor = preprocess_m486
+                    elif isinstance(slicer, PrusaSlicer):
+                        processor = preprocess_slicer
+                    elif isinstance(slicer, Cura):
+                        processor = preprocess_cura
+                    elif isinstance(slicer, IdeaMaker):
+                        processor = preprocess_ideamaker
+                    else:
+                        log_to_stderr(
+                            f"Object Processing Failed, slicer {name}"
+                            "not supported"
+                        )
+                        return False
+                    for line in processor(in_file):
+                        out_file.write(line)
+                except Exception as e:
+                    log_to_stderr(f"Object processing failed: {e}")
+                    return False
+        if os.path.islink(file_path):
+            file_path = os.path.realpath(file_path)
+        shutil.move(tmp_file, file_path)
+    return True
+
+def get_slicer(file_path: str) -> Tuple[BaseSlicer, Dict[str, str]]:
+    header_data = footer_data = ""
+    slicer: Optional[BaseSlicer] = None
+    size = os.path.getsize(file_path)
+    with open(file_path, 'r') as f:
+        # read the default size, which should be enough to
+        # identify the slicer
+        header_data = f.read(READ_SIZE)
+        for impl in SUPPORTED_SLICERS:
+            slicer = impl(file_path)
+            ident = slicer.check_identity(header_data)
+            if ident is not None:
+                break
+        else:
+            slicer = UnknownSlicer(file_path)
+            ident = slicer.check_identity(header_data)
+        if size > READ_SIZE * 2:
+            if type(slicer) == Creality:
+                footer_data = header_data
+            else:
+                f.seek(size - READ_SIZE)
+                footer_data = f.read()
+        elif size > READ_SIZE:
+            if type(slicer) == Creality:
+                footer_data = header_data
+            else:
+                remaining = size - READ_SIZE
+                footer_data = header_data[remaining - READ_SIZE:] + f.read()
+        else:
+            footer_data = header_data
+        slicer.set_data(header_data, footer_data, size)
+    if ident is None:
+        ident = {"slicer": "unknown"}
+    return slicer, ident
+
+def extract_metadata(
+    file_path: str, check_objects: bool
+) -> Dict[str, Any]:
+    metadata: Dict[str, Any] = {}
+    slicer, ident = get_slicer(file_path)
+    if check_objects and slicer.has_objects():
+        name = ident.get("slicer", "unknown")
+        if process_objects(file_path, slicer, name):
+            slicer, ident = get_slicer(file_path)
+    metadata['size'] = os.path.getsize(file_path)
+    metadata['modified'] = os.path.getmtime(file_path)
+    metadata['uuid'] = str(uuid.uuid4())
+    metadata.update(ident)
+    for key in SUPPORTED_DATA:
+        func = getattr(slicer, "parse_" + key)
+        result = func()
+        if result is not None:
+            metadata[key] = result
+    if metadata.get("filament_type"):
+        metadata["model_info"]["MaterialType"] = metadata.get("filament_type")
+    if metadata.get("filament_name"):
+        metadata["model_info"]["MaterialName"] = metadata.get("filament_name")
+    return metadata
+
+def extract_ufp(ufp_path: str, dest_path: str) -> None:
+    if not os.path.isfile(ufp_path):
+        log_to_stderr(f"UFP file Not Found: {ufp_path}")
+        sys.exit(-1)
+    thumb_name = os.path.splitext(
+        os.path.basename(dest_path))[0] + ".png"
+    dest_thumb_dir = os.path.join(os.path.dirname(dest_path), ".thumbs")
+    dest_thumb_path = os.path.join(dest_thumb_dir, thumb_name)
+    try:
+        with tempfile.TemporaryDirectory() as tmp_dir_name:
+            tmp_thumb_path = ""
+            with zipfile.ZipFile(ufp_path) as zf:
+                tmp_model_path = zf.extract(
+                    UFP_MODEL_PATH, path=tmp_dir_name)
+                if UFP_THUMB_PATH in zf.namelist():
+                    tmp_thumb_path = zf.extract(
+                        UFP_THUMB_PATH, path=tmp_dir_name)
+            if os.path.islink(dest_path):
+                dest_path = os.path.realpath(dest_path)
+            shutil.move(tmp_model_path, dest_path)
+            if tmp_thumb_path:
+                if not os.path.exists(dest_thumb_dir):
+                    os.mkdir(dest_thumb_dir)
+                shutil.move(tmp_thumb_path, dest_thumb_path)
+    except Exception:
+        log_to_stderr(traceback.format_exc())
+        sys.exit(-1)
+    try:
+        os.remove(ufp_path)
+    except Exception:
+        log_to_stderr(f"Error removing ufp file: {ufp_path}")
+
+def main(path: str,
+         filename: str,
+         ufp: Optional[str],
+         check_objects: bool
+         ) -> None:
+    file_path = os.path.join(path, filename)
+    if ufp is not None:
+        extract_ufp(ufp, file_path)
+    metadata: Dict[str, Any] = {}
+    if not os.path.isfile(file_path):
+        log_to_stderr(f"File Not Found: {file_path}")
+        sys.exit(-1)
+    try:
+        metadata = extract_metadata(file_path, check_objects)
+    except Exception:
+        log_to_stderr(traceback.format_exc())
+        sys.exit(-1)
+    fd = sys.stdout.fileno()
+    data = json.dumps(
+        {'file': filename, 'metadata': metadata}).encode()
+    while data:
+        try:
+            ret = os.write(fd, data)
+        except OSError:
+            continue
+        data = data[ret:]
+
+
+if __name__ == "__main__":
+    # Parse start arguments
+    parser = argparse.ArgumentParser(
+        description="GCode Metadata Extraction Utility")
+    parser.add_argument(
+        "-f", "--filename", metavar='<filename>',
+        help="name gcode file to parse")
+    parser.add_argument(
+        "-p", "--path", default=os.path.abspath(os.path.dirname(__file__)),
+        metavar='<path>',
+        help="optional absolute path for file"
+    )
+    parser.add_argument(
+        "-u", "--ufp", metavar="<ufp file>", default=None,
+        help="optional path of ufp file to extract"
+    )
+    parser.add_argument(
+        "-o", "--check-objects", dest='check_objects', action='store_true',
+        help="process gcode file for exclude opbject functionality")
+    args = parser.parse_args()
+    check_objects = args.check_objects
+    enabled_msg = "enabled" if check_objects else "disabled"
+    log_to_stderr(f"Object Processing is {enabled_msg}")
+    main(args.path, args.filename, args.ufp, check_objects)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/mpu9250.py crealityShit/klippy/extras/mpu9250.py
--- klipperStock/klippy/extras/mpu9250.py	2024-01-14 23:01:59.449788103 -0600
+++ crealityShit/klippy/extras/mpu9250.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,278 +0,0 @@
-# Support for reading acceleration data from an mpu9250 chip
-#
-# Copyright (C) 2022  Harry Beyel <harry3b9@gmail.com>
-# Copyright (C) 2020-2021 Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging, time, collections, threading, multiprocessing, os
-from . import bus, motion_report, adxl345
-
-MPU9250_ADDR =      0x68
-
-MPU_DEV_IDS = {
-    0x74: "mpu-9515",
-    0x73: "mpu-9255",
-    0x71: "mpu-9250",
-    0x70: "mpu-6500",
-    0x68: "mpu-6050",
-    #everything above are normal MPU IDs
-    0x75: "mpu-unknown (DEFECTIVE! USE WITH CAUTION!)",
-    0x69: "mpu-unknown (DEFECTIVE! USE WITH CAUTION!)",
-    }
-
-# MPU9250 registers
-REG_DEVID =         0x75
-REG_FIFO_EN =       0x23
-REG_SMPLRT_DIV =    0x19
-REG_CONFIG =        0x1A
-REG_ACCEL_CONFIG =  0x1C
-REG_ACCEL_CONFIG2 = 0x1D
-REG_USER_CTRL =     0x6A
-REG_PWR_MGMT_1 =    0x6B
-REG_PWR_MGMT_2 =    0x6C
-
-SAMPLE_RATE_DIVS = { 4000:0x00 }
-
-SET_CONFIG =        0x01 # FIFO mode 'stream' style
-SET_ACCEL_CONFIG =  0x10 # 8g full scale
-SET_ACCEL_CONFIG2 = 0x08 # 1046Hz BW, 0.503ms delay 4kHz sample rate
-SET_PWR_MGMT_1_WAKE =     0x00
-SET_PWR_MGMT_1_SLEEP=     0x40
-SET_PWR_MGMT_2_ACCEL_ON = 0x07
-SET_PWR_MGMT_2_OFF  =     0x3F
-
-FREEFALL_ACCEL = 9.80665 * 1000.
-# SCALE = 1/4096 g/LSB @8g scale * Earth gravity in mm/s**2
-SCALE = 0.000244140625 * FREEFALL_ACCEL
-
-FIFO_SIZE = 512
-
-Accel_Measurement = collections.namedtuple(
-    'Accel_Measurement', ('time', 'accel_x', 'accel_y', 'accel_z'))
-
-MIN_MSG_TIME = 0.100
-
-BYTES_PER_SAMPLE = 6
-SAMPLES_PER_BLOCK = 8
-
-# Printer class that controls MPU9250 chip
-class MPU9250:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        adxl345.AccelCommandHelper(config, self)
-        self.query_rate = 0
-        am = {'x': (0, SCALE), 'y': (1, SCALE), 'z': (2, SCALE),
-              '-x': (0, -SCALE), '-y': (1, -SCALE), '-z': (2, -SCALE)}
-        axes_map = config.getlist('axes_map', ('x','y','z'), count=3)
-        if any([a not in am for a in axes_map]):
-            raise config.error("Invalid mpu9250 axes_map parameter")
-        self.axes_map = [am[a.strip()] for a in axes_map]
-        self.data_rate = config.getint('rate', 4000)
-        if self.data_rate not in SAMPLE_RATE_DIVS:
-            raise config.error("Invalid rate parameter: %d" % (self.data_rate,))
-        # Measurement storage (accessed from background thread)
-        self.lock = threading.Lock()
-        self.raw_samples = []
-        # Setup mcu sensor_mpu9250 bulk query code
-        self.i2c = bus.MCU_I2C_from_config(config,
-                                           default_addr=MPU9250_ADDR,
-                                           default_speed=400000)
-        self.mcu = mcu = self.i2c.get_mcu()
-        self.oid = oid = mcu.create_oid()
-        self.query_mpu9250_cmd = self.query_mpu9250_end_cmd = None
-        self.query_mpu9250_status_cmd = None
-        mcu.register_config_callback(self._build_config)
-        mcu.register_response(self._handle_mpu9250_data, "mpu9250_data", oid)
-        # Clock tracking
-        self.last_sequence = self.max_query_duration = 0
-        self.last_limit_count = self.last_error_count = 0
-        self.clock_sync = adxl345.ClockSyncRegression(self.mcu, 640)
-        # API server endpoints
-        self.api_dump = motion_report.APIDumpHelper(
-            self.printer, self._api_update, self._api_startstop, 0.100)
-        self.name = config.get_name().split()[-1]
-        wh = self.printer.lookup_object('webhooks')
-        wh.register_mux_endpoint("mpu9250/dump_mpu9250", "sensor", self.name,
-                                 self._handle_dump_mpu9250)
-    def _build_config(self):
-        cmdqueue = self.i2c.get_command_queue()
-        self.mcu.add_config_cmd("config_mpu9250 oid=%d i2c_oid=%d"
-                           % (self.oid, self.i2c.get_oid()))
-        self.mcu.add_config_cmd("query_mpu9250 oid=%d clock=0 rest_ticks=0"
-                           % (self.oid,), on_restart=True)
-        self.query_mpu9250_cmd = self.mcu.lookup_command(
-            "query_mpu9250 oid=%c clock=%u rest_ticks=%u", cq=cmdqueue)
-        self.query_mpu9250_end_cmd = self.mcu.lookup_query_command(
-            "query_mpu9250 oid=%c clock=%u rest_ticks=%u",
-            "mpu9250_status oid=%c clock=%u query_ticks=%u next_sequence=%hu"
-            " buffered=%c fifo=%u limit_count=%hu", oid=self.oid, cq=cmdqueue)
-        self.query_mpu9250_status_cmd = self.mcu.lookup_query_command(
-            "query_mpu9250_status oid=%c",
-            "mpu9250_status oid=%c clock=%u query_ticks=%u next_sequence=%hu"
-            " buffered=%c fifo=%u limit_count=%hu", oid=self.oid, cq=cmdqueue)
-    def read_reg(self, reg):
-        params = self.i2c.i2c_read([reg], 1)
-        return bytearray(params['response'])[0]
-
-    def set_reg(self, reg, val, minclock=0):
-        self.i2c.i2c_write([reg, val & 0xFF], minclock=minclock)
-
-    # Measurement collection
-    def is_measuring(self):
-        return self.query_rate > 0
-    def _handle_mpu9250_data(self, params):
-        with self.lock:
-            self.raw_samples.append(params)
-    def _extract_samples(self, raw_samples):
-        # Load variables to optimize inner loop below
-        (x_pos, x_scale), (y_pos, y_scale), (z_pos, z_scale) = self.axes_map
-        last_sequence = self.last_sequence
-        time_base, chip_base, inv_freq = self.clock_sync.get_time_translation()
-        # Process every message in raw_samples
-        count = seq = 0
-        samples = [None] * (len(raw_samples) * SAMPLES_PER_BLOCK)
-        for params in raw_samples:
-            seq_diff = (last_sequence - params['sequence']) & 0xffff
-            seq_diff -= (seq_diff & 0x8000) << 1
-            seq = last_sequence - seq_diff
-            d = bytearray(params['data'])
-            msg_cdiff = seq * SAMPLES_PER_BLOCK - chip_base
-
-            for i in range(len(d) // BYTES_PER_SAMPLE):
-                d_xyz = d[i*BYTES_PER_SAMPLE:(i+1)*BYTES_PER_SAMPLE]
-                xhigh, xlow, yhigh, ylow, zhigh, zlow = d_xyz
-                # Merge and perform twos-complement
-                rx = ((xhigh << 8) | xlow) - ((xhigh & 0x80) << 9)
-                ry = ((yhigh << 8) | ylow) - ((yhigh & 0x80) << 9)
-                rz = ((zhigh << 8) | zlow) - ((zhigh & 0x80) << 9)
-
-                raw_xyz = (rx, ry, rz)
-                x = round(raw_xyz[x_pos] * x_scale, 6)
-                y = round(raw_xyz[y_pos] * y_scale, 6)
-                z = round(raw_xyz[z_pos] * z_scale, 6)
-                ptime = round(time_base + (msg_cdiff + i) * inv_freq, 6)
-                samples[count] = (ptime, x, y, z)
-                count += 1
-        self.clock_sync.set_last_chip_clock(seq * SAMPLES_PER_BLOCK + i)
-        del samples[count:]
-        return samples
-
-    def _update_clock(self, minclock=0):
-        # Query current state
-        for retry in range(5):
-            params = self.query_mpu9250_status_cmd.send([self.oid],
-                                                        minclock=minclock)
-            fifo = params['fifo'] & 0x1fff
-            if fifo <= FIFO_SIZE:
-                break
-        else:
-            raise self.printer.command_error("Unable to query mpu9250 fifo")
-        mcu_clock = self.mcu.clock32_to_clock64(params['clock'])
-        sequence = (self.last_sequence & ~0xffff) | params['next_sequence']
-        if sequence < self.last_sequence:
-            sequence += 0x10000
-        self.last_sequence = sequence
-        buffered = params['buffered']
-        limit_count = (self.last_limit_count & ~0xffff) | params['limit_count']
-        if limit_count < self.last_limit_count:
-            limit_count += 0x10000
-        self.last_limit_count = limit_count
-        duration = params['query_ticks']
-        if duration > self.max_query_duration:
-            # Skip measurement as a high query time could skew clock tracking
-            self.max_query_duration = max(2 * self.max_query_duration,
-                                          self.mcu.seconds_to_clock(.000005))
-            return
-        self.max_query_duration = 2 * duration
-        msg_count = (sequence * SAMPLES_PER_BLOCK
-                     + buffered // BYTES_PER_SAMPLE + fifo)
-        # The "chip clock" is the message counter plus .5 for average
-        # inaccuracy of query responses and plus .5 for assumed offset
-        # of mpu9250 hw processing time.
-        chip_clock = msg_count + 1
-        self.clock_sync.update(mcu_clock + duration // 2, chip_clock)
-    def _start_measurements(self):
-        if self.is_measuring():
-            return
-        # In case of miswiring, testing MPU9250 device ID prevents treating
-        # noise or wrong signal as a correctly initialized device
-        dev_id = self.read_reg(REG_DEVID)
-        if dev_id not in MPU_DEV_IDS.keys():
-            raise self.printer.command_error(
-                "Invalid mpu id (got %x).\n"
-                "This is generally indicative of connection problems\n"
-                "(e.g. faulty wiring) or a faulty chip."
-                % (dev_id))
-        else:
-            logging.info("Found %s with id %x"% (MPU_DEV_IDS[dev_id], dev_id))
-        # Setup chip in requested query rate
-        self.set_reg(REG_PWR_MGMT_1, SET_PWR_MGMT_1_WAKE)
-        self.set_reg(REG_PWR_MGMT_2, SET_PWR_MGMT_2_ACCEL_ON)
-        time.sleep(20. / 1000) # wait for accelerometer chip wake up
-        self.set_reg(REG_SMPLRT_DIV, SAMPLE_RATE_DIVS[self.data_rate])
-        self.set_reg(REG_CONFIG, SET_CONFIG)
-        self.set_reg(REG_ACCEL_CONFIG, SET_ACCEL_CONFIG)
-        self.set_reg(REG_ACCEL_CONFIG2, SET_ACCEL_CONFIG2)
-
-        # Setup samples
-        with self.lock:
-            self.raw_samples = []
-        # Start bulk reading
-        systime = self.printer.get_reactor().monotonic()
-        print_time = self.mcu.estimated_print_time(systime) + MIN_MSG_TIME
-        reqclock = self.mcu.print_time_to_clock(print_time)
-        rest_ticks = self.mcu.seconds_to_clock(1. / self.data_rate)
-        self.query_rate = self.data_rate
-        self.query_mpu9250_cmd.send([self.oid, reqclock, rest_ticks],
-                                    reqclock=reqclock)
-        logging.info("MPU9250 starting '%s' measurements", self.name)
-        # Initialize clock tracking
-        self.last_sequence = 0
-        self.last_limit_count = self.last_error_count = 0
-        self.clock_sync.reset(reqclock, 0)
-        self.max_query_duration = 1 << 31
-        self._update_clock(minclock=reqclock)
-        self.max_query_duration = 1 << 31
-    def _finish_measurements(self):
-        if not self.is_measuring():
-            return
-        # Halt bulk reading
-        params = self.query_mpu9250_end_cmd.send([self.oid, 0, 0])
-        self.query_rate = 0
-        with self.lock:
-            self.raw_samples = []
-        logging.info("MPU9250 finished '%s' measurements", self.name)
-        self.set_reg(REG_PWR_MGMT_1, SET_PWR_MGMT_1_SLEEP)
-        self.set_reg(REG_PWR_MGMT_2, SET_PWR_MGMT_2_OFF)
-
-    # API interface
-    def _api_update(self, eventtime):
-        self._update_clock()
-        with self.lock:
-            raw_samples = self.raw_samples
-            self.raw_samples = []
-        if not raw_samples:
-            return {}
-        samples = self._extract_samples(raw_samples)
-        if not samples:
-            return {}
-        return {'data': samples, 'errors': self.last_error_count,
-                'overflows': self.last_limit_count}
-    def _api_startstop(self, is_start):
-        if is_start:
-            self._start_measurements()
-        else:
-            self._finish_measurements()
-    def _handle_dump_mpu9250(self, web_request):
-        self.api_dump.add_client(web_request)
-        hdr = ('time', 'x_acceleration', 'y_acceleration', 'z_acceleration')
-        web_request.send({'header': hdr})
-    def start_internal_client(self):
-        cconn = self.api_dump.add_internal_client()
-        return adxl345.AccelQueryHelper(self.printer, cconn)
-
-def load_config(config):
-    return MPU9250(config)
-
-def load_config_prefix(config):
-    return MPU9250(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/multi_pin.py crealityShit/klippy/extras/multi_pin.py
--- klipperStock/klippy/extras/multi_pin.py	2024-01-14 23:01:59.465788301 -0600
+++ crealityShit/klippy/extras/multi_pin.py	2024-01-14 23:02:21.662060367 -0600
@@ -21,7 +21,7 @@
         pin = self.printer.lookup_object('multi_pin ' + pin_name, None)
         if pin is not self:
             if pin is None:
-                raise ppins.error("multi_pin %s not configured" % (pin_name,))
+                raise ppins.error("""{"code":"key40", "msg":"multi_pin %s not configured", "values": ["%s"]}""" % (pin_name, pin_name))
             return pin.setup_pin(pin_type, pin_params)
         if self.pin_type is not None:
             raise ppins.error("Can't setup multi_pin %s twice" % (pin_name,))
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/output_pin.py crealityShit/klippy/extras/output_pin.py
--- klipperStock/klippy/extras/output_pin.py	2024-01-14 23:01:59.441788007 -0600
+++ crealityShit/klippy/extras/output_pin.py	2024-01-14 23:02:21.634060022 -0600
@@ -7,7 +7,7 @@
 PIN_MIN_TIME = 0.100
 RESEND_HOST_TIME = 0.300 + PIN_MIN_TIME
 MAX_SCHEDULE_TIME = 5.0
-
+import logging
 class PrinterOutputPin:
     def __init__(self, config):
         self.printer = config.get_printer()
@@ -50,13 +50,52 @@
                 'shutdown_value', 0., minval=0., maxval=self.scale) / self.scale
             self.mcu_pin.setup_start_value(self.last_value, self.shutdown_value)
             pin_name = config.get_name().split()[1]
+
             gcode = self.printer.lookup_object('gcode')
             gcode.register_mux_command("SET_PIN", "PIN", pin_name,
                                        self.cmd_SET_PIN,
                                        desc=self.cmd_SET_PIN_help)
+            self.heaters = self.printer.load_object(config,"heaters")
+
+            if pin_name == "power":
+                self.power_timer = self.reactor.register_timer(
+                    self.checkpwm, self.reactor.NOW+10)
+                self.ispweron = False
+    def set_poewon(self,value):
+
+        value /= self.scale
+        cycle_time = self.default_cycle_time
+
+        toolhead = self.printer.lookup_object('toolhead')
+        toolhead.register_lookahead_callback(
+            lambda print_time: self._set_pin(print_time, value, cycle_time))
+
+
+        # toolhead = self.printer.lookup_object('toolhead')
+        # toolhead.register_lookahead_callback(
+        #     lambda print_time: self._set_pin(print_time, value, 0))
+    def checkpwm(self, eventtime):
+        systime = self.reactor.monotonic()
+        for heater in self.heaters.heaters.values():
+
+            eventtime = self.reactor.monotonic()
+            if heater.name == "heater_bed" :
+                if heater.check_busy(eventtime) :
+                    if self.ispweron == False and heater.target_temp != 0:
+                        self.set_poewon(0)
+                        self.ispweron = True
+
+                else:
+                    if self.ispweron == True:
+                        self.ispweron = False
+                        self.set_poewon(1)
+                        return systime + 10
+        return systime + 3
     def get_status(self, eventtime):
         return {'value': self.last_value}
     def _set_pin(self, print_time, value, cycle_time, is_resend=False):
+
+
         if value == self.last_value and cycle_time == self.last_cycle_time:
             if not is_resend:
                 return
@@ -71,8 +110,10 @@
         if self.resend_interval and self.resend_timer is None:
             self.resend_timer = self.reactor.register_timer(
                 self._resend_current_val, self.reactor.NOW)
+
     cmd_SET_PIN_help = "Set the value of an output pin"
     def cmd_SET_PIN(self, gcmd):
+
         value = gcmd.get_float('VALUE', minval=0., maxval=self.scale)
         value /= self.scale
         cycle_time = gcmd.get_float('CYCLE_TIME', self.default_cycle_time,
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/palette2.py crealityShit/klippy/extras/palette2.py
--- klipperStock/klippy/extras/palette2.py	2024-01-14 23:01:59.441788007 -0600
+++ crealityShit/klippy/extras/palette2.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,653 +0,0 @@
-# Palette 2 MMU support, Firmware 9.0.9 and newer supported only!
-#
-# Copyright (C) 2021 Clifford Roche <clifford.roche@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-import logging
-import os
-import serial
-
-from serial import SerialException
-
-try:
-    from queue import Queue, Empty
-except ImportError:
-    from Queue import Queue, Empty
-
-COMMAND_HEARTBEAT = "O99"
-COMMAND_CUT = "O10 D5"
-COMMAND_CLEAR = [
-    "O10 D5",
-    "O10 D0 D0 D0 DFFE1",
-    "O10 D1 D0 D0 DFFE1",
-    "O10 D2 D0 D0 DFFE1",
-    "O10 D3 D0 D0 DFFE1",
-    "O10 D4 D0 D0 D0069"]
-COMMAND_FILENAME = "O51"
-COMMAND_FILENAMES_DONE = "O52"
-COMMAND_FIRMWARE = "O50"
-COMMAND_PING = "O31"
-COMMAND_SMART_LOAD_STOP = "O102 D1"
-
-HEARTBEAT_SEND = 5.
-HEARTBEAT_TIMEOUT = (HEARTBEAT_SEND * 2.) + 1.
-SETUP_TIMEOUT = 10
-
-SERIAL_TIMER = 0.1
-AUTOLOAD_TIMER = 5.
-
-INFO_NOT_CONNECTED = "Palette 2 is not connected, connect first"
-
-
-class Palette2:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.reactor = self.printer.get_reactor()
-        try:
-            self.virtual_sdcard = self.printer.load_object(
-                config, "virtual_sdcard")
-        except config.error:
-            raise self.printer.config_error(
-                "Palette 2 requires [virtual_sdcard] to work,"
-                " please add it to your config!")
-        try:
-            self.pause_resume = self.printer.load_object(
-                config, "pause_resume")
-        except config.error:
-            raise self.printer.config_error(
-                "Palette 2 requires [pause_resume] to work,"
-                " please add it to your config!")
-        self.gcode_move = self.printer.load_object(config, 'gcode_move')
-        self.gcode = self.printer.lookup_object("gcode")
-        self.gcode.register_command(
-            "PALETTE_CONNECT", self.cmd_Connect, desc=self.cmd_Connect_Help)
-        self.gcode.register_command(
-            "PALETTE_DISCONNECT",
-            self.cmd_Disconnect,
-            desc=self.cmd_Disconnect_Help)
-        self.gcode.register_command(
-            "PALETTE_CLEAR", self.cmd_Clear, desc=self.cmd_Clear_Help)
-        self.gcode.register_command(
-            "PALETTE_CUT", self.cmd_Cut, desc=self.cmd_Cut_Help)
-        self.gcode.register_command(
-            "PALETTE_SMART_LOAD",
-            self.cmd_Smart_Load,
-            desc=self.cmd_Smart_Load_Help)
-        self.serial = None
-        self.serial_port = config.get("serial")
-        if not self.serial_port:
-            raise config.error("Invalid serial port specific for Palette 2")
-        self.baud = config.getint("baud", default=115200)
-        self.feedrate_splice = config.getfloat(
-            "feedrate_splice", default=0.8, minval=0., maxval=1.)
-        self.feedrate_normal = config.getfloat(
-            "feedrate_normal", default=1.0, minval=0., maxval=1.)
-        self.auto_load_speed = config.getint("auto_load_speed", 2)
-        self.auto_cancel_variation = config.getfloat(
-            "auto_cancel_variation", default=None, minval=0.01, maxval=0.2)
-
-        # Omega code matchers
-        self.omega_header = [None] * 9
-        omega_handlers = ["O" + str(i) for i in range(33)]
-        for cmd in omega_handlers:
-            func = getattr(self, 'cmd_' + cmd, None)
-            desc = getattr(self, 'cmd_' + cmd + '_help', None)
-            if func:
-                self.gcode.register_command(cmd, func, desc=desc)
-            else:
-                self.gcode.register_command(cmd, self.cmd_OmegaDefault)
-
-        self._reset()
-
-        self.read_timer = None
-        self.read_buffer = ""
-        self.read_queue = Queue()
-        self.write_timer = None
-        self.write_queue = Queue()
-        self.heartbeat_timer = None
-        self.heartbeat = None
-        self.signal_disconnect = False
-
-        self.is_printing = False
-        self.smart_load_timer = None
-
-    def _reset(self):
-        self.files = []
-        self.is_setup_complete = False
-        self.is_splicing = False
-        self.is_loading = False
-        self.remaining_load_length = None
-        self.omega_algorithms = []
-        self.omega_algorithms_counter = 0
-        self.omega_splices = []
-        self.omega_splices_counter = 0
-        self.omega_pings = []
-        self.omega_pongs = []
-        self.omega_current_ping = None
-        self.omega_header = [None] * 9
-        self.omega_header_counter = 0
-        self.omega_last_command = ""
-        self.omega_drivers = []
-
-    def _check_P2(self, gcmd=None):
-        if self.serial:
-            return True
-        if gcmd:
-            gcmd.respond_info(INFO_NOT_CONNECTED)
-        return False
-
-    cmd_Connect_Help = ("Connect to the Palette 2")
-
-    def cmd_Connect(self, gcmd):
-        if self.serial:
-            gcmd.respond_info(
-                "Palette 2 serial port is already active, disconnect first")
-            return
-
-        self.signal_disconnect = False
-        logging.info("Connecting to Palette 2 on port (%s) at (%s)" %
-                     (self.serial_port, self.baud))
-        try:
-            self.serial = serial.Serial(
-                self.serial_port, self.baud, timeout=0, write_timeout=0)
-        except SerialException:
-            gcmd.respond_info("Unable to connect to the Palette 2")
-            return
-
-        with self.write_queue.mutex:
-            self.write_queue.queue.clear()
-        with self.read_queue.mutex:
-            self.read_queue.queue.clear()
-
-        self.read_timer = self.reactor.register_timer(
-            self._run_Read, self.reactor.NOW)
-        self.write_timer = self.reactor.register_timer(
-            self._run_Write, self.reactor.NOW)
-        self.heartbeat_timer = self.reactor.register_timer(
-            self._run_Heartbeat, self.reactor.NOW)
-
-        # Tell the device we're alive
-        self.write_queue.put("\n")
-        self.write_queue.put(COMMAND_FIRMWARE)
-        self._wait_for_heartbeat()
-
-    cmd_Disconnect_Help = ("Disconnect from the Palette 2")
-
-    def cmd_Disconnect(self, gcmd=None):
-        self.gcode.respond_info("Disconnecting from Palette 2")
-        if self.serial:
-            self.serial.close()
-            self.serial = None
-
-        self.reactor.unregister_timer(self.read_timer)
-        self.reactor.unregister_timer(self.write_timer)
-        self.reactor.unregister_timer(self.heartbeat_timer)
-        self.read_timer = None
-        self.write_timer = None
-        self.heartbeat = None
-        self.is_printing = False
-
-    cmd_Clear_Help = ("Clear the input and output of the Palette 2")
-
-    def cmd_Clear(self, gcmd):
-        logging.info("Clearing Palette 2 input and output")
-        if self._check_P2(gcmd):
-            for l in COMMAND_CLEAR:
-                self.write_queue.put(l)
-
-    cmd_Cut_Help = ("Cut the outgoing filament")
-
-    def cmd_Cut(self, gcmd):
-        logging.info("Cutting outgoing filament in Palette 2")
-        if self._check_P2(gcmd):
-            self.write_queue.put(COMMAND_CUT)
-
-    cmd_Smart_Load_Help = ("Automatically load filament through the extruder")
-
-    def cmd_Smart_Load(self, gcmd):
-        if self._check_P2(gcmd):
-            if not self.is_loading:
-                gcmd.respond_info(
-                    "Cannot auto load when the Palette 2 is not ready")
-                return
-            self.p2cmd_O102(params=None)
-
-    def cmd_OmegaDefault(self, gcmd):
-        logging.debug("Omega Code: %s" % (gcmd.get_command()))
-        if self._check_P2(gcmd):
-            self.write_queue.put(gcmd.get_commandline())
-
-    def _wait_for_heartbeat(self):
-        startTs = self.reactor.monotonic()
-        currTs = startTs
-        while self.heartbeat is None and self.heartbeat < (
-                currTs - SETUP_TIMEOUT) and startTs > (
-                currTs - SETUP_TIMEOUT):
-            currTs = self.reactor.pause(currTs + 1.)
-
-        if self.heartbeat < (currTs - SETUP_TIMEOUT):
-            self.signal_disconnect = True
-            raise self.printer.command_error(
-                "No response from Palette 2")
-
-    cmd_O1_help = (
-        "Initialize the print, and check connection with the Palette 2")
-
-    def cmd_O1(self, gcmd):
-        logging.info("Initializing print with Pallete 2")
-        if not self._check_P2(gcmd):
-            raise self.printer.command_error(
-                "Cannot initialize print, palette 2 is not connected")
-
-        self.reactor.update_timer(self.heartbeat_timer, self.reactor.NOW)
-        self._wait_for_heartbeat()
-        self.write_queue.put(gcmd.get_commandline())
-        self.gcode.respond_info(
-            "Palette 2 waiting on user to complete setup")
-        self.pause_resume.send_pause_command()
-
-    cmd_O9_help = ("Reset print information")
-
-    def cmd_O9(self, gcmd):
-        logging.info("Print finished, resetting Palette 2 state")
-        if self._check_P2(gcmd):
-            self.write_queue.put(gcmd.get_commandline())
-        self.is_printing = False
-
-    def cmd_O21(self, gcmd):
-        logging.debug("Omega version: %s" % (gcmd.get_commandline()))
-        self._reset()
-        self.omega_header[0] = gcmd.get_commandline()
-        self.is_printing = True
-
-    def cmd_O22(self, gcmd):
-        logging.debug("Omega printer profile: %s" % (gcmd.get_commandline()))
-        self.omega_header[1] = gcmd.get_commandline()
-
-    def cmd_O23(self, gcmd):
-        logging.debug("Omega slicer profile: %s" % (gcmd.get_commandline()))
-        self.omega_header[2] = gcmd.get_commandline()
-
-    def cmd_O24(self, gcmd):
-        logging.debug("Omega PPM: %s" % (gcmd.get_commandline()))
-        self.omega_header[3] = gcmd.get_commandline()
-
-    def cmd_O25(self, gcmd):
-        logging.debug("Omega inputs: %s" % (gcmd.get_commandline()))
-        self.omega_header[4] = gcmd.get_commandline()
-        drives = self.omega_header[4][4:].split()
-        for idx in range(len(drives)):
-            state = drives[idx][:2]
-            if state == "D1":
-                drives[idx] = "U" + str(60 + idx)
-        self.omega_drives = [d for d in drives if d != "D0"]
-        logging.info("Omega drives: %s" % self.omega_drives)
-
-    def cmd_O26(self, gcmd):
-        logging.debug("Omega splices %s" % (gcmd.get_commandline()))
-        self.omega_header[5] = gcmd.get_commandline()
-
-    def cmd_O27(self, gcmd):
-        logging.debug("Omega pings: %s" % (gcmd.get_commandline()))
-        self.omega_header[6] = gcmd.get_commandline()
-
-    def cmd_O28(self, gcmd):
-        logging.debug("Omega MSF NA: %s" % (gcmd.get_commandline()))
-        self.omega_header[7] = gcmd.get_commandline()
-
-    def cmd_O29(self, gcmd):
-        logging.debug("Omega MSF NH: %s" % (gcmd.get_commandline()))
-        self.omega_header[8] = gcmd.get_commandline()
-
-    def cmd_O30(self, gcmd):
-        try:
-            param_drive = gcmd.get_commandline()[5:6]
-            param_distance = gcmd.get_commandline()[8:]
-        except IndexError:
-            gcmd.respond_info(
-                "Incorrect number of arguments for splice command")
-        try:
-            self.omega_splices.append((int(param_drive), param_distance))
-        except ValueError:
-            gcmd.respond_info("Incorrectly formatted splice command")
-        logging.debug("Omega splice command drive %s distance %s" %
-                      (param_drive, param_distance))
-
-    def cmd_O31(self, gcmd):
-        if self._check_P2(gcmd):
-            self.omega_current_ping = gcmd.get_commandline()
-            logging.debug("Omega ping command: %s" %
-                          (gcmd.get_commandline()))
-
-            self.write_queue.put(COMMAND_PING)
-            self.gcode.create_gcode_command("G4", "G4", {"P": "10"})
-
-    def cmd_O32(self, gcmd):
-        logging.debug("Omega algorithm: %s" % (gcmd.get_commandline()))
-        self.omega_algorithms.append(gcmd.get_commandline())
-
-    def p2cmd_O20(self, params):
-        if not self.is_printing:
-            return
-
-        # First print, we can ignore
-        if params[0] == "D5":
-            logging.info("First print on Palette")
-            return
-
-        try:
-            n = int(params[0][1:])
-        except (TypeError, IndexError):
-            logging.error("O20 command has invalid parameters")
-            return
-
-        if n == 0:
-            logging.info("Sending omega header %s" % self.omega_header_counter)
-            self.write_queue.put(self.omega_header[self.omega_header_counter])
-            self.omega_header_counter = self.omega_header_counter + 1
-        elif n == 1:
-            logging.info("Sending splice info %s" % self.omega_splices_counter)
-            splice = self.omega_splices[self.omega_splices_counter]
-            self.write_queue.put("O30 D%d D%s" % (splice[0], splice[1]))
-            self.omega_splices_counter = self.omega_splices_counter + 1
-        elif n == 2:
-            logging.info("Sending current ping info %s" %
-                         self.omega_current_ping)
-            self.write_queue.put(self.omega_current_ping)
-        elif n == 4:
-            logging.info("Sending algorithm info %s" %
-                         self.omega_algorithms_counter)
-            self.write_queue.put(
-                self.omega_algorithms[self.omega_algorithms_counter])
-            self.omega_algorithms_counter = self.omega_algorithms_counter + 1
-        elif n == 8:
-            logging.info("Resending the last command to Palette 2")
-            self.write_queue.put(self.omega_last_command)
-
-    def p2cmd_O34(self, params):
-        if not self.is_printing:
-            return
-
-        def check_ping_variation(last_ping):
-            if self.auto_cancel_variation is not None:
-                ping_max = 100. + (self.auto_cancel_variation * 100.)
-                ping_min = 100. - (self.auto_cancel_variation * 100.)
-                if last_ping < ping_min or last_ping > ping_max:
-                    logging.info("Ping variation is too high, "
-                                 "cancelling print")
-                    self.gcode.run_script("CANCEL_PRINT")
-
-        if len(params) > 2:
-            percent = float(params[1][1:])
-            if params[0] == "D1":
-                number = len(self.omega_pings) + 1
-                d = {"number": number, "percent": percent}
-                logging.info("Ping %d, %d percent" % (number, percent))
-                self.omega_pings.append(d)
-                check_ping_variation(percent)
-            elif params[0] == "D2":
-                number = len(self.omega_pongs) + 1
-                d = {"number": number, "percent": percent}
-                logging.info("Pong %d, %d percent" % (number, percent))
-                self.omega_pongs.append(d)
-
-    def p2cmd_O40(self, params):
-        logging.info("Resume request from Palette 2")
-        self.pause_resume.send_resume_command()
-
-    def p2cmd_O50(self, params):
-        if len(params) > 1:
-            try:
-                fw = params[0][1:]
-                logging.info(
-                    "Palette 2 firmware version %s detected" % os.fwalk)
-            except (TypeError, IndexError):
-                logging.error("Unable to parse firmware version")
-
-            if fw < "9.0.9":
-                raise self.printer.command_error(
-                    "Palette 2 firmware version is too old, "
-                    "update to at least 9.0.9")
-        else:
-            self.files = [
-                file for (
-                    file,
-                    size) in self.virtual_sdcard.get_file_list(
-                    check_subdirs=True) if ".mcf.gcode" in file]
-            for file in self.files:
-                self.write_queue.put("%s D%s" % (COMMAND_FILENAME, file))
-            self.write_queue.put(COMMAND_FILENAMES_DONE)
-
-    def p2cmd_O53(self, params):
-        if len(params) > 1 and params[0] == "D1":
-            try:
-                idx = int(params[1][1:], 16)
-                file = self.files[::-1][idx]
-                self.gcode.run_script("SDCARD_PRINT_FILE FILENAME=%s" % file)
-            except (TypeError, IndexError):
-                logging.error("O53 has invalid command parameters")
-
-    def p2cmd_O88(self, params):
-        logging.error("Palette 2 error detected")
-        try:
-            error = int(params[0][1:], 16)
-            logging.error("Palette 2 error code %d" % error)
-        except (TypeError, IndexError):
-            logging.error("Unable to parse Palette 2 error")
-
-    def p2cmd_O97(self, params):
-        def printCancelling(params):
-            logging.info("Print Cancelling")
-            self.gcode.run_script("CLEAR_PAUSE")
-            self.gcode.run_script("CANCEL_PRINT")
-
-        def printCancelled(params):
-            logging.info("Print Cancelled")
-            self._reset()
-
-        def loadingOffsetStart(params):
-            logging.info("Waiting for user to load filament into printer")
-            self.is_loading = True
-
-        def loadingOffset(params):
-            self.remaining_load_length = int(params[1][1:])
-            logging.debug("Loading filamant remaining %d" %
-                          self.remaining_load_length)
-            if self.remaining_load_length >= 0 and self.smart_load_timer:
-                logging.info("Smart load filament is complete")
-                self.reactor.unregister_timer(self.smart_load_timer)
-                self.smart_load_timer = None
-                self.is_loading = False
-
-        def feedrateStart(params):
-            logging.info("Setting feedrate to %f for splice" %
-                         self.feedrate_splice)
-            self.is_splicing = True
-            self.gcode.run_script("M220 S%d" % (self.feedrate_splice * 100))
-
-        def feedrateEnd(params):
-            logging.info("Setting feedrate to %f splice done" %
-                         self.feedrate_normal)
-            self.is_splicing = False
-            self.gcode.run_script("M220 S%d" % (self.feedrate_normal * 100))
-
-        matchers = []
-        if self.is_printing:
-            matchers = matchers + [
-                [printCancelling, 2, "U0", "D2"],
-                [printCancelled, 2, "U0", "D3"],
-                [loadingOffset, 2, "U39"],
-                [loadingOffsetStart, 1, "U39"],
-            ]
-
-        matchers.append([feedrateStart, 3, "U25", "D0"])
-        matchers.append([feedrateEnd, 3, "U25", "D1"])
-        self._param_Matcher(matchers, params)
-
-    def p2cmd_O100(self, params):
-        logging.info("Pause request from Palette 2")
-        self.is_setup_complete = True
-        self.pause_resume.send_pause_command()
-
-    def p2cmd_O102(self, params):
-        toolhead = self.printer.lookup_object("toolhead")
-        if not toolhead.get_extruder().get_heater().can_extrude:
-            self.write_queue.put(COMMAND_SMART_LOAD_STOP)
-            self.gcode.respond_info(
-                "Unable to auto load filament, extruder is below minimum temp")
-            return
-
-        if self.smart_load_timer is None:
-            logging.info("Smart load starting")
-            self.smart_load_timer = self.reactor.register_timer(
-                self._run_Smart_Load, self.reactor.NOW)
-
-    def p2cmd(self, line):
-        t = line.split()
-        ocode = t[0]
-        params = t[1:]
-        params_count = len(params)
-        if params_count:
-            res = [i for i in params if i[0] == "D" or i[0] == "U"]
-            if not all(res):
-                logging.error("Omega parameters are invalid")
-                return
-
-        func = getattr(self, 'p2cmd_' + ocode, None)
-        if func is not None:
-            func(params)
-
-    def _param_Matcher(self, matchers, params):
-        # Match the command with the handling table
-        for matcher in matchers:
-            if len(params) >= matcher[1]:
-                match_params = matcher[2:]
-                res = all([match_params[i] == params[i]
-                           for i in range(len(match_params))])
-                if res:
-                    matcher[0](params)
-                    return True
-        return False
-
-    def _run_Read(self, eventtime):
-        if self.signal_disconnect:
-            self.cmd_Disconnect()
-            return self.reactor.NEVER
-
-        # Do non-blocking reads from serial and try to find lines
-        while True:
-            try:
-                raw_bytes = self.serial.read()
-            except SerialException:
-                logging.error("Unable to communicate with the Palette 2")
-                self.cmd_Disconnect()
-                return self.reactor.NEVER
-            if len(raw_bytes):
-                new_buffer = str(raw_bytes.decode(encoding='UTF-8',
-                                                  errors='ignore'))
-                text_buffer = self.read_buffer + new_buffer
-                while True:
-                    i = text_buffer.find("\n")
-                    if i >= 0:
-                        line = text_buffer[0:i + 1]
-                        self.read_queue.put(line.strip())
-                        text_buffer = text_buffer[i + 1:]
-                    else:
-                        break
-                self.read_buffer = text_buffer
-            else:
-                break
-
-        # Process any decoded lines from the device
-        while not self.read_queue.empty():
-            try:
-                text_line = self.read_queue.get_nowait()
-            except Empty:
-                pass
-
-            heartbeat_strings = [COMMAND_HEARTBEAT, "Connection Okay"]
-            if not any(x in text_line for x in heartbeat_strings):
-                logging.debug("%0.3f P2 -> : %s" % (eventtime, text_line))
-
-            # Received a heartbeat from the device
-            if text_line == COMMAND_HEARTBEAT:
-                self.heartbeat = eventtime
-
-            elif text_line[0] == "O":
-                self.p2cmd(text_line)
-
-        return eventtime + SERIAL_TIMER
-
-    def _run_Heartbeat(self, eventtime):
-        self.write_queue.put(COMMAND_HEARTBEAT)
-        eventtime = self.reactor.pause(eventtime + 5)
-        if self.heartbeat and self.heartbeat < (
-                eventtime - HEARTBEAT_TIMEOUT):
-            logging.error(
-                "P2 has not responded to heartbeat")
-            if not self.is_printing or self.is_setup_complete:
-                self.cmd_Disconnect()
-                return self.reactor.NEVER
-        return eventtime + HEARTBEAT_SEND
-
-    def _run_Write(self, eventtime):
-        while not self.write_queue.empty():
-            try:
-                text_line = self.write_queue.get_nowait()
-            except Empty:
-                continue
-
-            if text_line:
-                self.omega_last_command = text_line
-                l = text_line.strip()
-                if COMMAND_HEARTBEAT not in l:
-                    logging.debug(
-                        "%s -> P2 : %s" %
-                        (self.reactor.monotonic(), l))
-                terminated_line = "%s\n" % (l)
-                try:
-                    self.serial.write(terminated_line.encode())
-                except SerialException:
-                    logging.error("Unable to communicate with the Palette 2")
-                    self.signal_disconnect = True
-                    return self.reactor.NEVER
-        return eventtime + SERIAL_TIMER
-
-    def _run_Smart_Load(self, eventtime):
-        if not self.is_splicing and self.remaining_load_length < 0:
-            # Make sure toolhead class isn't busy
-            toolhead = self.printer.lookup_object("toolhead")
-            print_time, est_print_time, lookahead_empty = toolhead.check_busy(
-                eventtime)
-            idle_time = est_print_time - print_time
-            if not lookahead_empty or idle_time < 0.5:
-                return eventtime + \
-                       max(0., min(1., print_time - est_print_time))
-
-            extrude = abs(self.remaining_load_length)
-            extrude = min(50, extrude / 2)
-            if extrude <= 10:
-                extrude = 1
-            logging.info("Smart loading %dmm filament with %dmm remaining" % (
-                extrude, abs(self.remaining_load_length)))
-
-            self.gcode.run_script("G92 E0")
-            self.gcode.run_script("G1 E%d F%d" % (
-                extrude, self.auto_load_speed * 60))
-            return self.reactor.NOW
-        return eventtime + AUTOLOAD_TIMER
-
-    def get_status(self, eventtime=None):
-        status = {
-            "ping": None,
-            "remaining_load_length": self.remaining_load_length,
-            "is_splicing": self.is_splicing
-        }
-        if self.omega_pings:
-            status["ping"] = self.omega_pings[-1]
-        return status
-
-
-def load_config(config):
-    return Palette2(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/pause_resume.py crealityShit/klippy/extras/pause_resume.py
--- klipperStock/klippy/extras/pause_resume.py	2024-01-14 23:01:59.485788546 -0600
+++ crealityShit/klippy/extras/pause_resume.py	2024-01-14 23:02:21.694060758 -0600
@@ -3,6 +3,8 @@
 # Copyright (C) 2019  Eric Callahan <arksine.code@gmail.com>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
+import os, json, logging
+from .tool import reportInformation
 
 class PauseResume:
     def __init__(self, config):
@@ -13,6 +15,7 @@
         self.is_paused = False
         self.sd_paused = False
         self.pause_command_sent = False
+        self.config = config
         self.printer.register_event_handler("klippy:connect",
                                             self.handle_connect)
         self.gcode.register_command("PAUSE", self.cmd_PAUSE,
@@ -24,14 +27,99 @@
         self.gcode.register_command("CANCEL_PRINT", self.cmd_CANCEL_PRINT,
                                     desc=self.cmd_CANCEL_PRINT_help)
         webhooks = self.printer.lookup_object('webhooks')
+        webhooks.register_endpoint("pause_resume/cancel_continue_print",
+                                   self._handle_cancel_continue_print_request)
+        webhooks.register_endpoint("pause_resume/check_continue_print_state",
+                                   self._check_power_loss_state_request)
+        webhooks.register_endpoint("pause_resume/set_print_first_layer",
+                                   self._set_print_first_layer_request)
         webhooks.register_endpoint("pause_resume/cancel",
                                    self._handle_cancel_request)
         webhooks.register_endpoint("pause_resume/pause",
                                    self._handle_pause_request)
         webhooks.register_endpoint("pause_resume/resume",
                                    self._handle_resume_request)
+        webhooks.register_endpoint("getBootLoaderVersion",
+                                   self._getBootLoaderVersion)
+        self._setBootLoaderStateCmdOid = None
     def handle_connect(self):
         self.v_sd = self.printer.lookup_object('virtual_sdcard', None)
+        
+    def _getBootLoaderVersion(self, web_request):
+        mcu = self.printer.lookup_object('mcu')
+        result = mcu.get_constants().get('software_version', '')
+        web_request.send({'software_version': result})
+        return {"software_version": result}
+    
+    def _setBootLoaderState(self, web_request):
+        mcu = self.printer.lookup_object('mcu')
+        oid = mcu.create_oid() if not self._setBootLoaderStateCmdOid else self._setBootLoaderStateCmdOid
+        self._setBootLoaderStateCmdOid = oid
+        mcu.add_config_cmd("config_usrboot oid=%d" % (oid,))
+        # sendf("usrboot_ack oid=%c enter_boot_status=%c",args[0],status)
+        result = mcu.lookup_query_command("jump_to_usrboot_query oid=%c", "usrboot_ack oid=%c enter_boot_status=%c", oid=oid).send()
+        return {"result": result}
+
+    def _set_print_first_layer_request(self, web_request): 
+        self.v_sd.first_layer_stop = False
+        self.v_sd.print_first_layer = False
+        response = {"state": "success"}
+        web_request.send(response)
+        return response
+
+    def _check_power_loss_state_request(self, web_request): 
+        from subprocess import call
+        response = {"file_state": False, "eeprom_state": False}
+        if os.path.exists(self.v_sd.print_file_name_path):
+            try:
+                with open(self.v_sd.print_file_name_path, "r") as f:
+                    data = f.read()
+                    if len(data) == 0:
+                        logging.error("%s f.read()==None read fail!!!" % self.v_sd.print_file_name_path)
+                    response["file_state"] = True if json.loads(data) else False
+            except Exception as err:
+                os.remove(self.v_sd.print_file_name_path)
+                bl24c16f = self.printer.lookup_object('bl24c16f') if "bl24c16f" in self.printer.objects else None
+                if bl24c16f:
+                    self.gcode.run_script("EEPROM_WRITE_BYTE ADDR=1 VAL=255")
+                logging.exception(err)
+        power_loss_switch = False
+        if os.path.exists(self.v_sd.user_print_refer_path):
+            with open(self.v_sd.user_print_refer_path, "r") as f:
+                data = json.loads(f.read())
+                power_loss_switch = data.get("power_loss", {}).get("switch", False)
+        bl24c16f = self.printer.lookup_object('bl24c16f') if "bl24c16f" in self.printer.objects else None
+        eepromState = bl24c16f.checkEepromFirstEnable() if power_loss_switch and bl24c16f else True
+        if not eepromState:
+            response["eeprom_state"] = True
+        print_stats = self.printer.lookup_object('print_stats', None)
+        if response["file_state"] == True and response["eeprom_state"] == True and print_stats and print_stats.state == "standby":
+            print_stats.power_loss = 1
+        if print_stats and print_stats.state != "standby":
+            response["file_state"] = False
+            response["eeprom_state"] = False
+            logging.info("current printer state:%s" % print_stats.state)
+        web_request.send(response)
+        return response
+    
+    def _handle_cancel_continue_print_request(self, web_request):
+        from subprocess import call
+        if os.path.exists(self.v_sd.print_file_name_path):
+            os.remove(self.v_sd.print_file_name_path)
+        call("sync", shell=True)
+        bl24c16f = self.printer.lookup_object('bl24c16f') if "bl24c16f" in self.printer.objects else None
+        power_loss_switch = False
+        if os.path.exists(self.v_sd.user_print_refer_path):
+            with open(self.v_sd.user_print_refer_path, "r") as f:
+                data = json.loads(f.read())
+                power_loss_switch = data.get("power_loss", {}).get("switch", False)
+        bl24c16f = self.printer.lookup_object('bl24c16f') if "bl24c16f" in self.printer.objects else None
+        if power_loss_switch and bl24c16f:
+            self.gcode.run_script("EEPROM_WRITE_BYTE ADDR=1 VAL=255")
+            self.gcode.respond_info("cancel_continue_print:success")
+        print_stats = self.printer.lookup_object('print_stats', None)
+        if print_stats:
+            print_stats.power_loss = 0
     def _handle_cancel_request(self, web_request):
         self.gcode.run_script("CANCEL_PRINT")
     def _handle_pause_request(self, web_request):
@@ -60,14 +148,16 @@
     cmd_PAUSE_help = ("Pauses the current print")
     def cmd_PAUSE(self, gcmd):
         if self.is_paused:
-            gcmd.respond_info("Print already paused")
+            gcmd.respond_info("""{"code":"key211", "msg": "Print already paused", "values": []}""")
             return
         self.send_pause_command()
         self.gcode.run_script_from_command("SAVE_GCODE_STATE NAME=PAUSE_STATE")
         self.is_paused = True
+        reportInformation("key601")
     def send_resume_command(self):
         if self.sd_paused:
             # Printing from virtual sd, run pause command
+            self.v_sd.do_resume_status = True
             self.v_sd.do_resume()
             self.sd_paused = False
         else:
@@ -76,7 +166,7 @@
     cmd_RESUME_help = ("Resumes the print from a pause")
     def cmd_RESUME(self, gcmd):
         if not self.is_paused:
-            gcmd.respond_info("Print is not paused, resume aborted")
+            gcmd.respond_info("""{"code": "key16", "msg": "Print is not paused, resume aborted"}""")
             return
         velocity = gcmd.get_float('VELOCITY', self.recover_velocity)
         self.gcode.run_script_from_command(
@@ -84,6 +174,15 @@
             % (velocity))
         self.send_resume_command()
         self.is_paused = False
+        result = {}
+        if os.path.exists(self.v_sd.print_file_name_path):
+            with open(self.v_sd.print_file_name_path, "r") as f:
+                result = (json.loads(f.read()))
+                result["variable_z_safe_pause"] = 0
+            with open(self.v_sd.print_file_name_path, "w") as f:
+                f.write(json.dumps(result))
+                f.flush()
+        reportInformation("key602")
     cmd_CLEAR_PAUSE_help = (
         "Clears the current paused state without resuming the print")
     def cmd_CLEAR_PAUSE(self, gcmd):
@@ -95,6 +194,7 @@
         else:
             gcmd.respond_info("action:cancel")
         self.cmd_CLEAR_PAUSE(gcmd)
+        reportInformation("key603")
 
 def load_config(config):
     return PauseResume(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/pca9533.py crealityShit/klippy/extras/pca9533.py
--- klipperStock/klippy/extras/pca9533.py	2024-01-14 23:01:59.453788154 -0600
+++ crealityShit/klippy/extras/pca9533.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,37 +0,0 @@
-# Support for the PCA9533 LED driver ic
-#
-# Copyright (C) 2021  Marc-Andre Denis <marcadenis@msn.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-from . import bus
-
-BACKGROUND_PRIORITY_CLOCK = 0x7fffffff00000000
-
-PCA9533_PWM0=0b010
-PCA9533_PWM1=0b100
-PCA9533_PLS0=0b101
-
-class PCA9533:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.i2c = bus.MCU_I2C_from_config(config, default_addr=98)
-        pled = self.printer.load_object(config, "led")
-        self.led_helper = pled.setup_helper(config, self.update_leds, 1)
-        self.i2c.i2c_write([PCA9533_PWM0, 85])
-        self.i2c.i2c_write([PCA9533_PWM1, 170])
-        self.update_leds(self.led_helper.get_status()['color_data'], None)
-    def update_leds(self, led_state, print_time):
-        rmap = [0, 2, 3, 1, 1]
-        red, green, blue, white = [rmap[int(v * 4.)] for v in led_state[0]]
-        ls0 = (white<<6) | (blue<<4) | (green<<2) | red
-        minclock = 0
-        if print_time is not None:
-            minclock = self.i2c.get_mcu().print_time_to_clock(print_time)
-        self.i2c.i2c_write([PCA9533_PLS0, ls0], minclock=minclock,
-                           reqclock=BACKGROUND_PRIORITY_CLOCK)
-    def get_status(self, eventtime):
-        return self.led_helper.get_status(eventtime)
-
-def load_config_prefix(config):
-    return PCA9533(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/pca9632.py crealityShit/klippy/extras/pca9632.py
--- klipperStock/klippy/extras/pca9632.py	2024-01-14 23:01:59.473788399 -0600
+++ crealityShit/klippy/extras/pca9632.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,74 +0,0 @@
-# Support for the PCA9632 LED driver ic
-#
-# Copyright (C) 2022  Ricardo Alcantara <ricardo@vulcanolabs.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-from . import bus, mcp4018
-
-BACKGROUND_PRIORITY_CLOCK = 0x7fffffff00000000
-
-# Register addresses
-PCA9632_MODE1 = 0x00
-PCA9632_MODE2 = 0x01
-PCA9632_PWM0 = 0x02
-PCA9632_PWM1 = 0x03
-PCA9632_PWM2 = 0x04
-PCA9632_PWM3 = 0x05
-PCA9632_LEDOUT = 0x08
-
-LED_PWM = 0x02
-PCA9632_LED0 = 0x00
-PCA9632_LED1 = 0x02
-PCA9632_LED2 = 0x04
-PCA9632_LED3 = 0x06
-
-class PCA9632:
-    def __init__(self, config):
-        self.printer = printer = config.get_printer()
-        if config.get("scl_pin", None) is not None:
-            self.i2c = mcp4018.SoftwareI2C(config, 98)
-        else:
-            self.i2c = bus.MCU_I2C_from_config(config, default_addr=98)
-        color_order = config.get("color_order", "RGBW")
-        if sorted(color_order) != sorted("RGBW"):
-            raise config.error("Invalid color_order '%s'" % (color_order,))
-        self.color_map = ["RGBW".index(c) for c in color_order]
-        self.prev_regs = {}
-        pled = printer.load_object(config, "led")
-        self.led_helper = pled.setup_helper(config, self.update_leds, 1)
-        printer.register_event_handler("klippy:connect", self.handle_connect)
-    def reg_write(self, reg, val, minclock=0):
-        if self.prev_regs.get(reg) == val:
-            return
-        self.prev_regs[reg] = val
-        self.i2c.i2c_write([reg, val], minclock=minclock,
-                           reqclock=BACKGROUND_PRIORITY_CLOCK)
-    def handle_connect(self):
-        #Configure MODE1
-        self.reg_write(PCA9632_MODE1, 0x00)
-        #Configure MODE2 (DIMMING, INVERT, CHANGE ON STOP,TOTEM)
-        self.reg_write(PCA9632_MODE2, 0x15)
-
-        self.update_leds(self.led_helper.get_status()['color_data'], None)
-    def update_leds(self, led_state, print_time):
-        minclock = 0
-        if print_time is not None:
-            minclock = self.i2c.get_mcu().print_time_to_clock(print_time)
-
-        color = [int(v * 255. + .5) for v in led_state[0]]
-        led0, led1, led2, led3 = [color[idx] for idx in self.color_map]
-        self.reg_write(PCA9632_PWM0, led0, minclock=minclock)
-        self.reg_write(PCA9632_PWM1, led1, minclock=minclock)
-        self.reg_write(PCA9632_PWM2, led2, minclock=minclock)
-        self.reg_write(PCA9632_PWM3, led3, minclock=minclock)
-
-        LEDOUT = (LED_PWM << PCA9632_LED0 if led0 else 0)
-        LEDOUT |= (LED_PWM << PCA9632_LED1 if led1 else 0)
-        LEDOUT |= (LED_PWM << PCA9632_LED2 if led2 else 0)
-        LEDOUT |= (LED_PWM << PCA9632_LED3 if led3 else 0)
-        self.reg_write(PCA9632_LEDOUT, LEDOUT, minclock=minclock)
-    def get_status(self, eventtime):
-        return self.led_helper.get_status(eventtime)
-
-def load_config_prefix(config):
-    return PCA9632(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/pid_calibrate.py crealityShit/klippy/extras/pid_calibrate.py
--- klipperStock/klippy/extras/pid_calibrate.py	2024-01-14 23:01:59.453788154 -0600
+++ crealityShit/klippy/extras/pid_calibrate.py	2024-01-14 23:02:21.650060220 -0600
@@ -34,7 +34,7 @@
         if write_file:
             calibrate.write_file('/tmp/heattest.txt')
         if calibrate.check_busy(0., 0., 0.):
-            raise gcmd.error("pid_calibrate interrupted")
+            raise gcmd.error('{"code": "key7", "msg": "pid_calibrate interrupted"}')
         # Log and report results
         Kp, Ki, Kd = calibrate.calc_final_pid()
         logging.info("Autotune: final: Kp=%f Ki=%f Kd=%f", Kp, Ki, Kd)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/print_stats.py crealityShit/klippy/extras/print_stats.py
--- klipperStock/klippy/extras/print_stats.py	2024-01-14 23:01:59.489788594 -0600
+++ crealityShit/klippy/extras/print_stats.py	2024-01-14 23:02:21.702060856 -0600
@@ -3,7 +3,7 @@
 # Copyright (C) 2020  Eric Callahan <arksine.code@gmail.com>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
-
+import os, json, logging
 class PrintStats:
     def __init__(self, config):
         printer = config.get_printer()
@@ -15,6 +15,20 @@
         self.gcode.register_command(
             "SET_PRINT_STATS_INFO", self.cmd_SET_PRINT_STATS_INFO,
             desc=self.cmd_SET_PRINT_STATS_INFO_help)
+        # G28 down 12mm flag
+        self.power_loss = 0
+        self.print_duration = 0
+        self.z_pos_filepath = "/usr/data/creality/userdata/config/z_pos.json"
+        self.z_pos = self.get_z_pos()
+    def get_z_pos(self):
+        z_pos = 0
+        if os.path.exists(self.z_pos_filepath):
+            try:
+                with open(self.z_pos_filepath, "r") as f:
+                    z_pos = float(json.loads(f.read()).get("z_pos", 0))
+            except Exception as err:
+                logging.error(err)
+        return z_pos
     def _update_filament_usage(self, eventtime):
         gc_status = self.gcode_move.get_status(eventtime)
         cur_epos = gc_status['position'].e
@@ -24,17 +38,35 @@
     def set_current_file(self, filename):
         self.reset()
         self.filename = filename
-    def note_start(self):
+    def note_start(self, info_path=""):
         curtime = self.reactor.monotonic()
+        # if self.print_start_time is None:
+        #     self.print_start_time = curtime
+        # elif self.last_pause_time is not None:
+        #     # Update pause time duration
+        #     pause_duration = curtime - self.last_pause_time
+        #     self.prev_pause_duration += pause_duration
+        #     self.last_pause_time = None
+        # Reset last e-position
+        gc_status = self.gcode_move.get_status(curtime)
+        ret = {}
+        if info_path and os.path.exists(info_path):
+            try:
+                with open(info_path, "r") as f:
+                    ret = json.loads(f.read())
+                    self.filament_used = ret.get("filament_used", 0)
+            except Exception as err:
+                pass
         if self.print_start_time is None:
+            if info_path and ret and ret.get("last_print_duration"):
+                self.print_start_time = curtime - int(ret.get("last_print_duration", 0))
+            else:
             self.print_start_time = curtime
         elif self.last_pause_time is not None:
             # Update pause time duration
             pause_duration = curtime - self.last_pause_time
             self.prev_pause_duration += pause_duration
             self.last_pause_time = None
-        # Reset last e-position
-        gc_status = self.gcode_move.get_status(curtime)
         self.last_epos = gc_status['position'].e
         self.state = "printing"
         self.error_message = ""
@@ -105,6 +137,7 @@
                 # Track duration prior to extrusion
                 self.init_duration = self.total_duration - time_paused
         print_duration = self.total_duration - self.init_duration - time_paused
+        self.print_duration = print_duration
         return {
             'filename': self.filename,
             'total_duration': self.total_duration,
@@ -113,7 +146,9 @@
             'state': self.state,
             'message': self.error_message,
             'info': {'total_layer': self.info_total_layer,
-                     'current_layer': self.info_current_layer}
+                     'current_layer': self.info_current_layer},
+            'power_loss': self.power_loss,
+            'z_pos': self.z_pos,
         }
 
 def load_config(config):
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/probe.py crealityShit/klippy/extras/probe.py
--- klipperStock/klippy/extras/probe.py	2024-01-14 23:01:59.441788007 -0600
+++ crealityShit/klippy/extras/probe.py	2024-01-14 23:02:21.626059926 -0600
@@ -116,7 +116,7 @@
         toolhead = self.printer.lookup_object('toolhead')
         curtime = self.printer.get_reactor().monotonic()
         if 'z' not in toolhead.get_status(curtime)['homed_axes']:
-            raise self.printer.command_error("Must home before probe")
+            raise self.printer.command_error("""{"code":"key96", "msg": "Must home before probe", "values": []}""")
         phoming = self.printer.lookup_object('homing')
         pos = toolhead.get_position()
         pos[2] = self.z_position
@@ -369,10 +369,15 @@
         self.lift_speed = self.speed
         self.probe_offsets = (0., 0., 0.)
         self.results = []
+        self.probe_type = ""
+        if config.has_section('prtouch_v2'):
+            self.probe_type = "prtouch_v2"
+        elif config.has_section('bltouch'):
+            self.probe_type = "bltouch"
     def minimum_points(self,n):
         if len(self.probe_points) < n:
             raise self.printer.config_error(
-                "Need at least %d probe points for %s" % (n, self.name))
+                """{"code":"key98", "msg": "Need at least %d probe points for %s", "values": [%d, "%s"]}""" % (n, self.name, n, self.name))
     def update_probe_points(self, points, min_points):
         self.probe_points = points
         self.minimum_points(min_points)
@@ -387,6 +392,7 @@
         if not self.results:
             # Use full speed to first probe position
             speed = self.speed
+        if self.probe_type != "prtouch_v2":
         toolhead.manual_move([None, None, self.horizontal_move_z], speed)
         # Check if done probing
         if len(self.results) >= len(self.probe_points):
@@ -400,6 +406,9 @@
         if self.use_offsets:
             nextpos[0] -= self.probe_offsets[0]
             nextpos[1] -= self.probe_offsets[1]
+        if self.probe_type == "prtouch_v2":
+            self.printer.lookup_object('probe').mcu_probe.run_to_next(nextpos)
+        else:
         toolhead.manual_move(nextpos, self.speed)
         return False
     def start_probe(self, gcmd):
@@ -418,9 +427,12 @@
         self.lift_speed = probe.get_lift_speed(gcmd)
         self.probe_offsets = probe.get_offsets()
         if self.horizontal_move_z < self.probe_offsets[2]:
-            raise gcmd.error("horizontal_move_z can't be less than"
-                             " probe's z_offset")
+            raise gcmd.error("""{"code": "key15", "msg": "horizontal_move_z can't be less than probe's z_offset"}""")
         probe.multi_probe_begin()
+        # gcode = self.printer.lookup_object('gcode')
+        # g28_gcmd = gcode.create_gcode_command("G28", "G28", {'X': '0', 'Y': '0', 'Z': '0'})
+        # self.safe_z_home = self.printer.lookup_object('safe_z_home')
+        # self.safe_z_home.cmd_G28(g28_gcmd)
         while 1:
             done = self._move_next()
             if done:
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/prtouch.py crealityShit/klippy/extras/prtouch.py
--- klipperStock/klippy/extras/prtouch.py	1969-12-31 18:00:00.000000000 -0600
+++ crealityShit/klippy/extras/prtouch.py	2024-01-14 23:02:21.630059974 -0600
@@ -0,0 +1,819 @@
+# Support for button detection and callbacks
+#
+# Copyright (C) 2022-12-09  CC <wangyulong878@sina.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import logging
+import math
+import random
+from . import probe
+import mcu
+import time
+import socket
+
+class PRTouchCFG:
+    def __init__(self, config):
+        self.base_count = config.getint('base_count', default=40, minval=10, maxval=100)
+        self.pi_count = config.getint('pi_count', default=32, minval=16, maxval=128)
+        self.min_hold = config.getint('min_hold', default=3000, minval=100, maxval=50000)
+        self.max_hold = config.getint('max_hold', default=50000, minval=100, maxval=100000)
+        self.hot_min_temp = config.getfloat('s_hot_min_temp', default=140, minval=80, maxval=200)
+        self.hot_max_temp = config.getfloat('s_hot_max_temp', default=200, minval=180, maxval=300)
+        self.bed_max_temp = config.getfloat('s_bed_max_temp', default=60, minval=45, maxval=100)
+        self.pa_fil_len_mm = config.getint('pa_fil_len_mm', default=2, minval=2, maxval=100)
+        self.pa_fil_dis_mm = config.getint('pa_fil_dis_mm', default=30, minval=2, maxval=100)
+        self.pa_clr_dis_mm = config.getint('pa_clr_dis_mm', default=20, minval=2, maxval=100)
+        self.pa_clr_down_mm = config.getfloat('pa_clr_down_mm', default=-0.1, minval=-1, maxval=1)
+        self.clr_noz_start_x = config.getfloat('clr_noz_start_x', default=0, minval=0, maxval=1000)
+        self.clr_noz_start_y = config.getfloat('clr_noz_start_y', default=0, minval=0, maxval=1000)
+        self.clr_noz_len_x = config.getfloat('clr_noz_len_x', default=0, minval=self.pa_clr_dis_mm + 6, maxval=1000)
+        self.clr_noz_len_y = config.getfloat('clr_noz_len_y', default=0, minval=0, maxval=1000)
+        self.bed_max_err = config.getint('bed_max_err', default=2, minval=2, maxval=10)
+        self.max_z = config.getsection('stepper_z').getfloat('position_max', default=300, minval=100, maxval=500)
+        self.g29_xy_speed = config.getfloat('g29_xy_speed', default=150, minval=10, maxval=1000)
+        self.fix_z_offset = config.getfloat('fix_z_offset', default=0.0, minval=-1, maxval=1)
+        self.max_dis_bef_g28 = config.getfloat('max_dis_bef_g28', default=10, minval=0, maxval=50)
+        self.dead_zone_bef_g28 = config.getfloat('dead_zone_bef_g28', default=self.max_dis_bef_g28 / 2, minval=0, maxval=50) 
+        self.g28_sta0_speed = config.getfloat('g28_sta0_speed', default=2.0, minval=0.1, maxval=10)
+        self.g28_sta1_speed = config.getfloat('g28_sta1_speed', default=2.5, minval=0.1, maxval=10)
+        self.g29_rdy_speed = config.getfloat('g29_rdy_speed', default=2.5, minval=0.1, maxval=10)
+        self.g29_speed = config.getfloat('g29_speed', default=2.0, minval=0.1, maxval=10)
+        self.show_msg = config.getboolean('show_msg', default=False)
+        self.best_above_z = config.getfloat('best_above_z', default=1.5, minval=0.5, maxval=10)
+        self.g28_wait_cool_down = config.getboolean('g28_wait_cool_down', default=False)
+        self.shake_cnt = config.getint('shake_cnt', default=4, minval=1, maxval=512)
+        self.shake_range = config.getint('shake_range', default=0.5, minval=0.1, maxval=2)
+        self.shake_max_velocity = config.getfloat('shake_max_velocity', default=100, minval=1, maxval=5000)
+        self.shake_max_accel = config.getfloat('shake_max_accel', default=1000, minval=1, maxval=50000)
+        self.g28_sta0_min_hold = config.getint('g28_sta0_min_hold', default=self.min_hold * 2, minval=100, maxval=100000)
+        self.need_measure_gap = config.getboolean('need_measure_gap', default=True)
+        self.gap_dis_range = config.getfloat('gap_dis_range', default=0.6, minval=0.2, maxval=2)
+        self.z_gap_00 = config.getfloat('z_gap_00', default=0, minval=-1, maxval=1)
+        self.z_gap_01 = config.getfloat('z_gap_01', default=0, minval=-1, maxval=1)
+        self.z_gap_10 = config.getfloat('z_gap_10', default=0, minval=-1, maxval=1)
+        self.z_gap_11 = config.getfloat('z_gap_11', default=0, minval=-1, maxval=1)
+        self.check_bed_mesh_max_err = config.getfloat('check_bed_mesh_max_err', default=0.2, minval=0.01, maxval=1)
+        self.tri_wave_ip    = config.get('tri_wave_ip', None)
+        self.self_z_offset = config.getfloat('self_z_offset', default=0.0, minval=-2, maxval=2)
+
+        self.stored_profs = config.get_prefix_sections('prtouch')
+        self.stored_profs = self.stored_profs[1] if (len(self.stored_profs) == 2 and self.need_measure_gap) else None
+        pass
+
+
+class PRTouchVAL:
+    def __init__(self, config):
+        self.out_index = 0
+        self.out_val_mm = 0.
+        self.rdy_pos = [[0., 0., 0.] * 4]
+        self.gap_pos = None
+        self.g29_cnt = int(0)
+        self.re_probe_cnt = 0
+        self.home_xy = None
+        self.jump_probe_ready = False
+        pass
+
+
+class PRTouchOBJ:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.toolhead = None
+        self.hx711s = None
+        self.pheaters = None
+        self.heater_hot = None
+        self.heater_bed = None
+        self.bed_mesh = None
+        self.mcu = None
+        self.dirzctl = None
+        self.kin = None
+        self.gcode = self.printer.lookup_object('gcode')
+        pass
+
+    def find_objs(self):
+        self.toolhead = self.printer.lookup_object('toolhead')
+        self.hx711s = self.printer.lookup_object('hx711s')
+        self.pheaters = self.printer.lookup_object('heaters')
+        self.heater_hot = self.printer.lookup_object('extruder').heater
+        self.heater_bed = self.printer.lookup_object('heater_bed').heater
+        self.bed_mesh = self.printer.lookup_object('bed_mesh')
+        self.dirzctl = self.printer.lookup_object('dirzctl')
+        self.mcu = self.hx711s.mcu
+        self.filter = self.printer.lookup_object('filter')
+        self.kin = self.toolhead.get_kinematics()
+        pass
+
+
+class PRTouchEndstopWrapper:
+    def __init__(self, config):
+        self.cfg = PRTouchCFG(config)
+        self.val = PRTouchVAL(config)
+        self.obj = PRTouchOBJ(config)
+
+        self.obj.printer.register_event_handler('klippy:mcu_identify', self._handle_mcu_identify)
+        self.obj.gcode.register_command('PRTOUCH_TEST', self.cmd_PRTOUCH_TEST, desc=self.cmd_PRTOUCH_TEST_help)
+        self.obj.gcode.register_command('PRTOUCH_READY', self.cmd_PRTOUCH_READY, desc=self.cmd_PRTOUCH_READY_help)
+        self.obj.gcode.register_command('NOZZLE_CLEAR', self.cmd_NOZZLE_CLEAR, desc=self.cmd_NOZZLE_CLEAR_help)
+        self.obj.gcode.register_command('CHECK_BED_MESH', self.cmd_CHECK_BED_MESH, desc=self.cmd_CHECK_BED_MESH_help)
+        self.obj.gcode.register_command('MEASURE_GAP_TEST', self.cmd_MEASURE_GAP_TEST, desc=self.cmd_MEASURE_GAP_TEST_help)
+        pass
+
+    def _handle_mcu_identify(self):
+        self.obj.find_objs()
+        min_x, min_y = self.obj.bed_mesh.bmc.mesh_min
+        max_x, max_y = self.obj.bed_mesh.bmc.mesh_max
+        self.val.rdy_pos = [[min_x, min_y, self.cfg.bed_max_err + 1.],
+                            [min_x, max_y, self.cfg.bed_max_err + 1.],
+                            [max_x, max_y, self.cfg.bed_max_err + 1.],
+                            [max_x, min_y, self.cfg.bed_max_err + 1.]]
+        self.val.gap_pos = [[min_x + 1., min_y + 1., self.cfg.z_gap_00], # if self.cfg.stored_profs is None else self.cfg.stored_profs.getfloat('z_gap_00', default=self.cfg.z_gap_00, minval=0, maxval=1)],
+                            [min_x + 1., max_y - 1., self.cfg.z_gap_01], # if self.cfg.stored_profs is None else self.cfg.stored_profs.getfloat('z_gap_01', default=self.cfg.z_gap_01, minval=0, maxval=1)],
+                            [max_x - 1., max_y - 1., self.cfg.z_gap_11], # if self.cfg.stored_profs is None else self.cfg.stored_profs.getfloat('z_gap_11', default=self.cfg.z_gap_11, minval=0, maxval=1)],
+                            [max_x - 1., min_y + 1., self.cfg.z_gap_10]] # if self.cfg.stored_profs is None else self.cfg.stored_profs.getfloat('z_gap_10', default=self.cfg.z_gap_10, minval=0, maxval=1)]]
+        if self.cfg.clr_noz_start_x <= 0 or self.cfg.clr_noz_start_y <= 0 or self.cfg.clr_noz_len_x <= 0 or self.cfg.clr_noz_len_y <= 0:
+            self.cfg.clr_noz_start_x = (max_x - min_x) * 1 / 3 + min_x
+            self.cfg.clr_noz_start_y = max_y - 6
+            self.cfg.clr_noz_len_x = (max_x - min_x) * 1 / 3
+            self.cfg.clr_noz_len_y = 5
+        self.val.home_xy = [(max_x - min_x) / 2 + min_x, (max_y - min_y) / 2 + min_y]
+        pass
+
+    def get_mcu(self):
+        return self.obj.mcu
+
+    def multi_probe_begin(self):
+        pass
+
+    def multi_probe_end(self):
+        pass
+
+    def probe_prepare(self, hmove):
+        pass
+
+    def home_start(self, print_time, sample_time, sample_count, rest_time,
+                   triggered=True):
+        return True
+
+    def add_stepper(self, stepper):
+        pass
+
+    def get_steppers(self):
+        return self.obj.dirzctl.steppers
+
+    def ck_sys_sta(self):
+        return not self.obj.hx711s.is_shutdown and not self.obj.hx711s.is_timeout and  not self.obj.dirzctl.is_shutdown and not self.obj.dirzctl.is_timeout
+
+    def _ck_g28ed(self, is_precision=True):
+        for i in range(3):
+            if self.obj.kin.limits[i][0] > self.obj.kin.limits[i][1]:
+                self.obj.gcode.run_script_from_command('G28')
+                break
+        pass
+
+    def _move(self, pos, speed, wait=True):
+        if not self.obj.hx711s.is_shutdown and not self.obj.hx711s.is_timeout and  not self.obj.dirzctl.is_shutdown and not self.obj.dirzctl.is_timeout:
+            # self.obj.toolhead.manual_move(pos, speed)
+            self.obj.gcode.run_script_from_command('G1 F%d X%.3f Y%.3f Z%.3f' % (speed * 60, pos[0], pos[1], pos[2]) if len(pos) >= 3 else 'G1 F%d X%.3f Y%.3f' % (speed * 60, pos[0], pos[1]))
+            if wait:
+                self.obj.toolhead.wait_moves()
+            pass
+
+    def _check_index(self, index):
+        if (index <= self.cfg.pi_count - 3) and (index >= self.cfg.pi_count * 2 / 3):
+            return True
+        return False
+
+    def _get_linear2(self, p1, p2, po, is_base_x):
+        if (math.fabs(p1[0] - p2[0]) < 0.001 and is_base_x) or (math.fabs(p1[1] - p2[1]) < 0.001 and not is_base_x):
+            return po
+        a = (p2[2] - p1[2]) / ((p2[0] - p1[0]) if is_base_x else (p2[1] - p1[1]))
+        b = p1[2] - (p1[0] if is_base_x else p1[1]) * a
+        po[2] = a * (po[0] if is_base_x else po[1]) + b
+        return po
+
+    def _pnt_tri_msg(self, index, msg,  ary):
+        if self.cfg.show_msg:
+            self.pnt_msg('TRI SUCCESS BY: ' + msg)
+            self.pnt_array('TRI CH=%d ARY=' % index, ary)
+        pass
+
+    def _check_trigger(self, arg_index, fit_vals, unfit_vals, min_hold, max_hold):
+        all_params, tick = self.obj.dirzctl.get_params()
+        if len(all_params) == 2:
+            self._pnt_tri_msg(arg_index, 'Tri by Dirzctl run over!', fit_vals)
+            return True
+        fit_vals_t = [x for x in fit_vals]
+        self.val.out_index = self.cfg.pi_count - 1
+        if len(fit_vals) >= (self.cfg.pi_count / 2) and math.fabs(fit_vals[-1]) >= max_hold and \
+                math.fabs(fit_vals[-2]) >= max_hold and math.fabs(fit_vals[-3]) >= max_hold:
+            self._pnt_tri_msg(arg_index, 'Tri by out max_hold!', fit_vals)
+            return True
+        if len(fit_vals) != self.cfg.pi_count:
+            return False           
+        for i in range(1, self.cfg.pi_count - 1):
+            if fit_vals_t[i] >= max_hold and fit_vals_t[i - 1] < (max_hold / 2) and fit_vals_t[i + 1] < (max_hold / 2):
+                fit_vals_t[i] = fit_vals_t[i - 1]
+        
+        vals_p = [x for x in fit_vals_t]
+        max_val = max(vals_p)
+        min_val = min(vals_p)
+        max_val += 1 if (max_val - min_val) == 0 else 0
+        for i in range(len(vals_p)):
+            vals_p[i] = (vals_p[i] - min_val) / (max_val - min_val)
+        angle = math.atan((vals_p[-1] - vals_p[0]) / len(vals_p))
+        sin_angle = math.sin(-angle)
+        cos_angle = math.cos(-angle)
+        for i in range(len(vals_p)):
+            vals_p[i] = (i - 0) * sin_angle + (vals_p[i] - 0) * cos_angle + 0
+        self.val.out_index = vals_p.index(min(vals_p))
+        if(self.val.out_index > 0):
+            for i in range(self.val.out_index, self.cfg.pi_count):
+                fit_vals_t[self.val.out_index] = fit_vals_t[self.val.out_index] * (self.obj.filter.lft_k1_oft / 2) + fit_vals_t[self.val.out_index - 1] * (1 - (self.obj.filter.lft_k1_oft / 2))
+        vals_p = [x for x in fit_vals_t]
+
+        if not (fit_vals_t[-1] > fit_vals_t[-2] > fit_vals_t[-3]):
+            return False
+        max_val = max(fit_vals_t[0:(self.cfg.pi_count - 3)])
+        if not ((fit_vals_t[-1] > max_val) and (fit_vals_t[-2] > max_val) and (fit_vals_t[-3] > max_val)):
+            return False
+        max_val = max(fit_vals_t)
+        min_val = min(fit_vals_t)
+        for i in range(0, self.cfg.pi_count):
+            fit_vals_t[i] = (fit_vals_t[i] - min_val) / (max_val - min_val)
+        for i in range(0, self.cfg.pi_count - 1):
+            if (fit_vals_t[-1] - fit_vals_t[i]) / ((self.cfg.pi_count - i) * 1. / self.cfg.pi_count) < 0.8:
+                return False
+        if fit_vals[-1] < min_hold or fit_vals[-2] < (min_hold / 2) or fit_vals[-3] < (min_hold / 3):
+            return False
+        self._pnt_tri_msg(arg_index, 'Tri by fit all rule!', vals_p)
+        return True
+
+    def _set_hot_temps(self, temp, fan_spd, wait=False, err=5):
+        self.obj.pheaters.set_temperature(self.obj.heater_hot, temp, False)
+        self.obj.gcode.run_script_from_command('M106 P0 S%d' % (fan_spd))
+        # self.obj.gcode.run_script_from_command('M106 P1 S%d' % (fan_spd))
+        self.obj.gcode.run_script_from_command('M106 P2 S%d' % (fan_spd))
+        # self.obj.gcode.run_script_from_command('SET_PIN PIN=fan0 VALUE=%d' % (fan_spd))
+        # self.obj.gcode.run_script_from_command('SET_PIN PIN=fan1 VALUE=%d' % (fan_spd))
+        # self.obj.gcode.run_script_from_command('SET_PIN PIN=fan2 VALUE=%d' % (fan_spd))
+        if wait:
+            while self.ck_sys_sta() and abs(self.obj.heater_hot.target_temp - self.obj.heater_hot.smoothed_temp) > err and self.obj.heater_hot.target_temp > 0:
+                self.obj.hx711s.delay_s(0.100) 
+        pass
+
+    def _set_bed_temps(self, temp, wait=False, err=5):
+        self.obj.pheaters.set_temperature(self.obj.heater_bed, temp, False)           
+        if wait:
+            while self.ck_sys_sta() and abs(self.obj.heater_bed.target_temp - self.obj.heater_bed.smoothed_temp) > err and self.obj.heater_bed.target_temp > 0:
+                self.obj.hx711s.delay_s(0.100)          
+        pass
+
+    def pnt_msg(self, msg):
+        logging.info(msg)
+        if self.cfg.show_msg:
+            self.obj.gcode.respond_info(msg)
+        pass
+
+    def pnt_array(self, title, ary, lent=32):
+        logging.info('[%s] %s' , title, str(ary))
+        if self.cfg.show_msg:
+            st = title + ' ['
+            for i in range(len(ary) - lent, len(ary)):
+                st = st + "%.2f, " % (ary[i])
+            self.pnt_msg(st + ']')
+        pass
+
+    def _probe_times(self, max_times, rdy_pos, speed_mm, min_dis_mm, max_z_err, min_hold, max_hold):
+        o_mm = 0
+        rdy_pos_z = rdy_pos[2]
+        now_pos = self.obj.toolhead.get_position()
+        self._move(now_pos[:2] + [rdy_pos[2]], self.cfg.g29_rdy_speed)        
+        self._move(rdy_pos, self.cfg.g29_xy_speed)
+        for i in range(max_times):
+            o_index0, o_mm0, deal_sta = self.probe_by_step(rdy_pos[:2] + [rdy_pos_z], speed_mm, min_dis_mm, min_hold, max_hold, True)
+            if not deal_sta and rdy_pos_z == rdy_pos[2]:
+                rdy_pos_z += 2
+                continue
+            o_index1, o_mm1, deal_sta = self.probe_by_step(rdy_pos[:2] + [rdy_pos_z], speed_mm, min_dis_mm, min_hold, max_hold, True)
+            o_mm = (o_mm0 + o_mm1) / 2
+            if math.fabs(o_mm0 - o_mm1) <= max_z_err or not self.ck_sys_sta():
+                break
+            self.val.re_probe_cnt += 1
+            self.pnt_msg('***_probe_times must be reprobe= o_mm0=%.2f, o_mm1=%.2f' % (o_mm0, o_mm1))
+        return o_mm
+    
+    def send_wave_tri(self, ch, ary):
+        if self.cfg.tri_wave_ip is None:
+            return
+        msg = '%d' % ch
+        for i in range(len(ary)):
+            msg += ',%d' % ary[i]
+        ss = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+        ss.sendto(msg.encode(), (str(self.cfg.tri_wave_ip), 21021))
+        ss.close()    
+
+    def get_best_rdy_z(self, rdy_x, rdy_y, base_pos=None):
+        if not base_pos:
+            base_pos = self.val.rdy_pos
+        p_left = [base_pos[0][0], rdy_y, 0]
+        p_right = [base_pos[2][0], rdy_y, 0]
+        p_mid = [rdy_x, rdy_y, 0]
+        p_left = self._get_linear2(base_pos[0], base_pos[1], p_left, False)
+        p_right = self._get_linear2(base_pos[2], base_pos[3], p_right, False)
+        p_mid = self._get_linear2(p_left, p_right, p_mid, True)
+        self.pnt_msg("Get best rdy z: Src=%s, x=%.2f, y=%.2f, cal_z=%.2f" % (('RDY' if base_pos == self.val.rdy_pos else 'GAP'), rdy_x, rdy_y, p_mid[2]))
+        return p_mid[2] if p_mid[2] < self.cfg.bed_max_err else self.cfg.bed_max_err
+                
+    def shake_motor(self, cnt):
+        max_velocity = self.obj.toolhead.max_velocity
+        max_accel = self.obj.toolhead.max_accel
+        max_z_velocity = self.obj.toolhead.kin.max_z_velocity
+        max_z_accel = self.obj.toolhead.kin.max_z_accel
+
+        self.obj.toolhead.max_velocity = self.cfg.shake_max_velocity
+        self.obj.toolhead.max_accel = self.cfg.shake_max_accel
+        self.obj.toolhead.kin.max_z_velocity = self.cfg.shake_max_velocity
+        self.obj.toolhead.kin.max_z_accel = self.cfg.shake_max_accel
+
+        now_pos = self.obj.toolhead.get_position()
+        for i in range(int(cnt / 2)):
+            self.obj.gcode.run_script_from_command('G1 X%.2f Y%.2f Z%.2f F600' % (now_pos[0] - self.cfg.shake_range, now_pos[1] - self.cfg.shake_range, now_pos[2] - self.cfg.shake_range / 2))
+            self.obj.gcode.run_script_from_command('G1 X%.2f Y%.2f Z%.2f F600' % (now_pos[0] + self.cfg.shake_range, now_pos[1] - self.cfg.shake_range, now_pos[2] + self.cfg.shake_range / 2))
+            self.obj.gcode.run_script_from_command('G1 X%.2f Y%.2f Z%.2f F600' % (now_pos[0] + self.cfg.shake_range, now_pos[1] + self.cfg.shake_range, now_pos[2] - self.cfg.shake_range / 2))
+            self.obj.gcode.run_script_from_command('G1 X%.2f Y%.2f Z%.2f F600' % (now_pos[0] - self.cfg.shake_range, now_pos[1] + self.cfg.shake_range, now_pos[2] + self.cfg.shake_range / 2))
+            while len(self.obj.toolhead.move_queue.queue) >= 4 and self.ck_sys_sta():
+                self.obj.hx711s.delay_s(0.010)
+        self._move(now_pos, self.cfg.g29_xy_speed)
+
+        self.obj.toolhead.max_velocity = max_velocity
+        self.obj.toolhead.max_accel = max_accel
+        self.obj.toolhead.kin.max_z_velocity = max_z_velocity
+        self.obj.toolhead.kin.max_z_accel = max_z_accel
+        pass
+
+    def clear_nozzle(self, hot_min_temp, hot_max_temp, bed_max_temp, min_hold, max_hold):
+        min_x, min_y = self.cfg.clr_noz_start_x, self.cfg.clr_noz_start_y
+        max_x, max_y = self.cfg.clr_noz_start_x + self.cfg.clr_noz_len_x, self.cfg.clr_noz_start_y + self.cfg.clr_noz_len_y
+        self._set_bed_temps(temp=bed_max_temp, wait=False)
+        self._set_hot_temps(temp=hot_min_temp, fan_spd=0, wait=False, err=10)
+        self._ck_g28ed(False)
+        random.seed(time.time())  
+        cur_pos = self.obj.toolhead.get_position()
+        src_pos = [min_x + random.uniform(0, self.cfg.clr_noz_len_x - self.cfg.pa_clr_dis_mm - 5), 
+                   min_y + random.uniform(0, self.cfg.clr_noz_len_y), self.cfg.bed_max_err + 1, cur_pos[3]]
+        end_pos = [src_pos[0] + self.cfg.pa_clr_dis_mm, src_pos[1], src_pos[2], src_pos[3]]
+        self._set_hot_temps(temp=hot_min_temp, fan_spd=0, wait=True, err=10)   
+        src_pos[2] = self._probe_times(3, [src_pos[0] - 5, src_pos[1], src_pos[2]], self.cfg.g29_speed, 10, 0.2, min_hold * 2, max_hold)
+        self._set_hot_temps(temp=hot_min_temp + 40, fan_spd=0, wait=False, err=10)
+        end_pos[2] = self._probe_times(3, [end_pos[0] - 5, end_pos[1], end_pos[2]], self.cfg.g29_speed, 10, 0.2, min_hold * 2, max_hold)     
+        self._move(src_pos[:2] + [self.cfg.bed_max_err + 1], self.cfg.g29_xy_speed) 
+        self._move(src_pos[:2] + [src_pos[2] + 0.2], self.cfg.g29_rdy_speed) 
+        self._set_hot_temps(temp=hot_max_temp, fan_spd=0, wait=True, err=10)
+        self._set_hot_temps(temp=hot_min_temp, fan_spd=0, wait=False)
+        self._move(end_pos[:2] + [end_pos[2] + self.cfg.pa_clr_down_mm], self.cfg.g29_speed)
+        self._set_hot_temps(temp=hot_min_temp, fan_spd=255, wait=True, err=5)
+        self._move([end_pos[0] + 10, end_pos[1], end_pos[2] + 10], self.cfg.g29_speed)
+        self._set_hot_temps(temp=hot_min_temp, fan_spd=0, wait=False) 
+        self._set_bed_temps(temp=bed_max_temp, wait=True, err=5)
+
+        self._move(self.val.home_xy + [10], self.cfg.g29_xy_speed)
+        # self.obj.gcode.run_script_from_command('G28 Z')
+        pass
+
+    def measure_gap(self, zero_z):
+        min_dis_mm = self.cfg.gap_dis_range
+        speed_mm = self.cfg.gap_dis_range
+        p0_vals = None
+        p1_vals = None
+
+        rd_cnt = int(2 * 80 * (min_dis_mm / speed_mm))            
+        step_cnt = int(min_dis_mm / (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base))
+        step_us = int(((min_dis_mm / speed_mm) * 1000 * 1000) / step_cnt)
+
+        now_pos = self.obj.toolhead.get_position()  
+        self._move(now_pos[:2] + [zero_z + min_dis_mm / 2, now_pos[3]], self.cfg.g29_rdy_speed)
+        self.obj.hx711s.read_base(int(self.cfg.base_count / 2), self.cfg.max_hold)
+
+        self.obj.hx711s.query_start(rd_cnt, rd_cnt, del_dirty=False, show_msg=False)       
+        self.obj.dirzctl.check_and_run(0, int(step_us), int(step_cnt), wait_finish=True)
+        p0_valss = self.obj.hx711s.get_vals()
+
+        self.obj.hx711s.query_start(rd_cnt, rd_cnt, del_dirty=False, show_msg=False)       
+        self.obj.dirzctl.check_and_run(1, int(step_us), int(step_cnt), wait_finish=True)
+        p1_valss = self.obj.hx711s.get_vals()
+
+        self.obj.hx711s.query_start(rd_cnt, int(0), del_dirty=False, show_msg=False)
+        if len(p0_valss[0]) == 0 or len(p1_valss[0]) == 0:
+            self.pnt_msg('measure_gap: Error! Cannot recv datas from hx711s!!!.')
+            return 0
+        
+        self.pnt_msg('---------------------------------')
+        for i in range(int(self.obj.hx711s.s_count)):
+            self.pnt_array('p0_%d_valss = ' % i, p0_valss[i], len(p0_valss[i]))
+        self.pnt_msg('---------------------------------')
+        for i in range(int(self.obj.hx711s.s_count)):
+            self.pnt_array('p1_%d_valss = ' % i, p1_valss[i], len(p1_valss[i]))
+        self.pnt_msg('---------------------------------')
+
+        p0_diss = []
+        p1_diss = []
+        gaps = []
+        for gap_index in range(int(self.obj.hx711s.s_count)):
+            p0_vals = p0_valss[gap_index]
+            p1_vals = p1_valss[gap_index]
+
+            if p0_vals[0] > p0_vals[-1]:
+                p0_vals = [item * -1 for item in p0_vals]
+
+            if p1_vals[0] < p1_vals[-1]:
+                p1_vals = [item * -1 for item in p1_vals]
+
+            max_val = max(p0_vals)
+            min_val = min(p0_vals)
+            for i in range(len(p0_vals)):
+                p0_vals[i] = (p0_vals[i] - min_val) / (max_val - min_val)
+            angle = math.atan((p0_vals[-1] - p0_vals[0]) / len(p0_vals))
+            sin_angle = math.sin(-angle)
+            cos_angle = math.cos(-angle)
+            for i in range(len(p0_vals)):
+                p0_vals[i] = (i - 0) * sin_angle + (p0_vals[i] - 0) * cos_angle + 0
+            p0_out_index = p0_vals.index(min(p0_vals))
+            p0_dis = (len(p0_vals) - p0_out_index) * 0.012 * speed_mm
+            p0_diss.append(p0_dis)
+
+            p1_vals = p1_vals[::-1]
+            max_val = max(p1_vals)
+            min_val = min(p1_vals)
+            for i in range(len(p1_vals)):
+                p1_vals[i] = (p1_vals[i] - min_val) / (max_val - min_val)
+            angle = math.atan((p1_vals[-1] - p1_vals[0]) / len(p1_vals))
+            sin_angle = math.sin(-angle)
+            cos_angle = math.cos(-angle)
+            for i in range(len(p1_vals)):
+                p1_vals[i] = (i - 0) * sin_angle + (p1_vals[i] - 0) * cos_angle + 0
+            p1_out_index = p1_vals.index(min(p1_vals))
+            p1_dis = (len(p1_vals) - p1_out_index) * 0.012 * speed_mm
+            p1_diss.append(p1_dis)
+
+            gaps.append(p1_dis - p0_dis)
+            pass
+
+        self.pnt_array('measure_gap: p0_diss = ', p0_diss, len(p0_diss))
+        self.pnt_array('measure_gap: p1_diss = ', p1_diss, len(p1_diss))
+        self.pnt_array('measure_gap: gaps = ', gaps, len(gaps))      
+
+        v_cnt = int(0)
+        v_gap = 0.
+        for i in range(int(self.obj.hx711s.s_count)):
+            if not ((0 < p0_diss[i] < min_dis_mm) and (0 < p1_diss[i] < min_dis_mm) and (0 <= gaps[i] < 0.2)):
+                continue
+            v_cnt += 1
+            v_gap += (gaps[i] if gaps[i] <= 0.1 else 0.1)
+            pass
+
+        v_gap = (0 if v_cnt == 0 else (v_gap / v_cnt))
+
+
+        self.pnt_msg('measure_gap: v_cnt=%d v_gap = %.2f' % (v_cnt, v_gap)) 
+
+        return v_gap
+
+    def _gap_times(self, max_times, zero_pos):
+        gaps = []
+        now_pos = self.obj.toolhead.get_position()          
+        for i in range(max_times):
+            self._move(now_pos[:2] + [zero_pos + 2, now_pos[3]], self.cfg.g29_rdy_speed)
+            self.shake_motor(int(self.cfg.shake_cnt / 2))
+            gaps.append(self.measure_gap(zero_pos))
+        gaps.sort()
+        self.pnt_array('Gap measure vals = ', gaps, len(gaps))
+        now_pos = self.obj.toolhead.get_position()  
+        self._move(now_pos[:2] + [self.cfg.bed_max_err + 1., now_pos[3]], self.cfg.g29_rdy_speed)
+        return gaps[int((max_times + 1) / 2)]
+
+    def probe_ready(self):
+        if self.val.jump_probe_ready:
+            self.val.jump_probe_ready = False
+            return False
+        self._ck_g28ed()
+        min_x, min_y = self.obj.bed_mesh.bmc.mesh_min
+        max_x, max_y = self.obj.bed_mesh.bmc.mesh_max
+        random.seed(time.time()) 
+        self.val.rdy_pos = [[min_x, min_y, self.cfg.bed_max_err + 1.],
+                            [min_x, max_y, self.cfg.bed_max_err + 1.],
+                            [max_x, max_y, self.cfg.bed_max_err + 1.],
+                            [max_x, min_y, self.cfg.bed_max_err + 1.]]
+        mesh = self.obj.bed_mesh.get_mesh()
+        self.obj.bed_mesh.set_mesh(None)
+        for i in range(4):
+            self.val.rdy_pos[i][2] = self._probe_times(3, self.val.rdy_pos[i], self.cfg.g29_speed, 10, 0.2, self.cfg.min_hold, self.cfg.max_hold)
+            # if self.cfg.need_measure_gap:
+            #     self.val.gap_pos[i] = [x for x in self.val.rdy_pos[i]]
+            #     self.val.gap_pos[i][2] = self._gap_times(3, self.val.rdy_pos[i][2])
+            # else:
+            #     self.val.gap_pos[i][2] = 0
+            pass
+        if self.cfg.need_measure_gap:        
+            configfile = self.obj.printer.lookup_object('configfile')
+            configfile.set('prtouch default', 'z_gap_00', self.val.gap_pos[0][2])
+            configfile.set('prtouch default', 'z_gap_01', self.val.gap_pos[1][2])
+            configfile.set('prtouch default', 'z_gap_11', self.val.gap_pos[2][2])
+            configfile.set('prtouch default', 'z_gap_10', self.val.gap_pos[3][2])
+        self.pnt_msg("RDY_POS = [00=%.2f, 01=%.2f, 11=%.2f, 10=%.2f]" % (self.val.rdy_pos[0][2], self.val.rdy_pos[1][2], self.val.rdy_pos[2][2], self.val.rdy_pos[3][2]))
+        self.pnt_msg("GAP_POS = [00=%.2f, 01=%.2f, 11=%.2f, 10=%.2f]" % (self.val.gap_pos[0][2], self.val.gap_pos[1][2], self.val.gap_pos[2][2], self.val.gap_pos[3][2]))
+        self.obj.bed_mesh.set_mesh(mesh)
+        pass
+
+    def check_bed_mesh(self, auto_g29=True):
+        min_x, min_y = self.obj.bed_mesh.bmc.mesh_min
+        max_x, max_y = self.obj.bed_mesh.bmc.mesh_max
+        self.val.rdy_pos = [[min_x + random.uniform(2.0, +5.0), min_y + random.uniform(2.0, +5.0), self.cfg.bed_max_err + 1.],
+                            [min_x + random.uniform(2.0, +5.0), max_y - random.uniform(2.0, +5.0), self.cfg.bed_max_err + 1.],
+                            [max_x - random.uniform(2.0, +5.0), max_y - random.uniform(2.0, +5.0), self.cfg.bed_max_err + 1.],
+                            [max_x - random.uniform(2.0, +5.0), min_y + random.uniform(2.0, +5.0), self.cfg.bed_max_err + 1.]]
+        err_cnt = int(0)
+        self.val.jump_probe_ready = True
+        mesh = self.obj.bed_mesh.get_mesh()
+        if mesh is None:
+            if auto_g29:
+                self.pnt_msg("The bed_mesh data is invalid and cannot be verified.")
+                self._ck_g28ed()   
+                self.obj.gcode.run_script_from_command('BED_MESH_CALIBRATE')
+                self.obj.gcode.run_script_from_command('CXSAVE_CONFIG')
+            else:
+                #raise self.obj.printer.command_error("The bed_mesh data is invalid and cannot be verified.")
+                raise self.obj.printer.command_error("""{"code":"key504", "msg":"The bed_mesh data is invalid and cannot be verified."}""")
+            return
+
+        self.obj.bed_mesh.set_mesh(None)
+        self._ck_g28ed()        
+        self._move([self.val.home_xy[0], self.val.home_xy[1], self.cfg.bed_max_err + 1.0, self.obj.toolhead.get_position()[3]], self.cfg.g29_xy_speed)     
+        for i in range(4):
+            self.val.rdy_pos[i][2] = self._probe_times(3, self.val.rdy_pos[i], self.cfg.g29_speed, 10, self.cfg.check_bed_mesh_max_err * 2, self.cfg.min_hold, self.cfg.max_hold) + self.cfg.fix_z_offset
+            self.val.rdy_pos[i][2] += self.get_best_rdy_z(self.val.rdy_pos[i][0], self.val.rdy_pos[i][1], self.val.gap_pos) if self.cfg.need_measure_gap else 0
+            pass       
+        self.obj.bed_mesh.set_mesh(mesh)
+        errs = []
+        for i in range(4):
+            mesh_z = self.obj.bed_mesh.z_mesh.calc_z(self.val.rdy_pos[i][0], self.val.rdy_pos[i][1])
+            errs.append(abs(self.val.rdy_pos[i][2] - mesh_z))
+            err_cnt += (1 if errs[i] > self.cfg.check_bed_mesh_max_err else 0)
+            self.pnt_msg('P%d = [x=%.2f, y=%.2f, mest_z=%.2f, probe_z=%.2f, err_z=%.2f]' % (i, self.val.rdy_pos[i][0], self.val.rdy_pos[i][1], mesh_z, self.val.rdy_pos[i][2], errs[i]))        
+        if err_cnt >= 2:
+            if auto_g29:
+                self.pnt_array("check_bed_mesh: Due to the great change of the hot bed, it needs to be re-leveled. errs = ", errs, len(errs))
+                self.val.g29_cnt = 0
+                self.obj.gcode.run_script_from_command('BED_MESH_CALIBRATE')
+                self.obj.gcode.run_script_from_command('CXSAVE_CONFIG')
+            else:
+                # raise self.obj.printer.command_error("check_bed_mesh: Due to the large change of the hot bed, it can not print normally!! Errs = [%.2f, %.2f, %.2f, %.2f]" \
+                #                                         % (errs[0], errs[1], errs[2], errs[3]))
+                raise self.obj.printer.command_error("""{"code":"key501", "msg":"check_bed_mesh: Due to the large change of the hot bed, it can not print normally. Errs = [%.2f, %.2f, %.2f, %.2f]"}""" \
+                                                        % (errs[0], errs[1], errs[2], errs[3]))
+                                                        
+        else:
+            self.pnt_array("check_bed_mesh: Errs = ", errs, len(errs))
+        pass
+
+    def raise_z_bef_g28(self):
+        if self.obj.kin.limits[2][0] <= self.obj.kin.limits[2][1] and self.obj.toolhead.get_position()[2] < 5:
+            self.obj.toolhead.manual_move(self.obj.toolhead.get_position()[:2] + [5], 5)
+            self.obj.toolhead.wait_moves()
+            pass
+
+    def _cal_min_z(self, start_z, hx711_vals):
+        hx711_params, hx711_start_tick = self.obj.hx711s.get_params()
+        dirzctl_params, dirzctl_start_tick = self.obj.dirzctl.get_params()
+        if dirzctl_params is None or len(dirzctl_params) != 2:     
+            raise self.obj.printer.command_error("""{"code":"key502", "msg":"probe_by_step: Can not recv stepper-z status."}""")
+        if len(hx711_vals) < self.cfg.pi_count or len(hx711_params) < self.cfg.pi_count:
+            up_all_cnt = dirzctl_params[0]['step'] - dirzctl_params[1]['step'] + 1
+            return up_all_cnt, up_all_cnt, False
+        del hx711_params[0:(len(hx711_params) - self.cfg.pi_count)]
+
+        vals_p = [x for x in hx711_vals]
+        max_val = max(vals_p)
+        min_val = min(vals_p)
+        for i in range(len(vals_p)):
+            vals_p[i] = (vals_p[i] - min_val) / (max_val - min_val)
+        angle = math.atan((vals_p[-1] - vals_p[0]) / len(vals_p))
+        sin_angle = math.sin(-angle)
+        cos_angle = math.cos(-angle)
+        for i in range(len(vals_p)):
+            vals_p[i] = (i - 0) * sin_angle + (vals_p[i] - 0) * cos_angle + 0
+        self.val.out_index = vals_p.index(min(vals_p))
+
+        dirzctl_params[0]['tick'] = (dirzctl_params[0]['tick'] - dirzctl_start_tick) / self.obj.dirzctl.mcu_freq
+        dirzctl_params[1]['tick'] = ((4294967296 if dirzctl_params[1]['tick'] < dirzctl_start_tick else 0) + dirzctl_params[1]['tick'] - dirzctl_start_tick) / self.obj.dirzctl.mcu_freq
+        dirzctl_params[0]['z'] = start_z
+        dirzctl_params[1]['z'] = start_z - (dirzctl_params[0]['step'] - dirzctl_params[1]['step'] + 1) * (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base)
+        tick_p = ((4294967296 if hx711_params[self.val.out_index]['nt'] < hx711_start_tick else 0) + hx711_params[self.val.out_index]['nt'] - hx711_start_tick) / self.obj.hx711s.mcu_freq
+        self.val.out_val_mm = self._get_linear2([dirzctl_params[0]['tick'], 0, dirzctl_params[0]['z']], [dirzctl_params[1]['tick'], 0, dirzctl_params[1]['z']], [tick_p, 0, 0], True)[2]
+        self.pnt_msg('call_min_z, re_probe_cnt=%d, out_index=%d, out_val_mm=%.2f' % (self.val.re_probe_cnt, self.val.out_index, self.val.out_val_mm))
+        up_min_cnt = int((self.val.out_val_mm - dirzctl_params[1]['z']) / (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base))
+        up_all_cnt = dirzctl_params[0]['step'] - dirzctl_params[1]['step'] + 1
+        limt_up_cnt = int(10 / (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base))
+        up_min_cnt = up_min_cnt if up_min_cnt < limt_up_cnt else limt_up_cnt  
+        up_all_cnt = up_all_cnt if up_all_cnt < limt_up_cnt else limt_up_cnt
+        return (up_min_cnt if up_min_cnt >= 0 else 0), up_all_cnt, True
+
+    def probe_by_step(self, rdy_pos, speed_mm, min_dis_mm, min_hold, max_hold, up_after=True):
+        self.obj.hx711s.read_base(int(self.cfg.base_count / 2), max_hold)
+        step_cnt = int(min_dis_mm / (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base))
+        step_us = int(((min_dis_mm / speed_mm) * 1000 * 1000) / step_cnt)
+        self.obj.hx711s.query_start(self.cfg.pi_count * 2, int(65535), del_dirty=True, show_msg=False, is_ck_con=True)        
+        self.obj.dirzctl.check_and_run(0, int(step_us), int(step_cnt), wait_finish=False, is_ck_con=True)
+        self.obj.hx711s.delay_s(0.015)
+        self.pnt_msg('*********************************************************')
+        self.pnt_msg('PROBE_BY_STEP x=%.2f y=%.2f z=%.2f speed_mm=%.2f step_us=%d step_cnt=%d' % (rdy_pos[0], rdy_pos[1], rdy_pos[2], speed_mm, step_us, step_cnt))
+        while self.ck_sys_sta():
+            self.obj.hx711s.send_heart_beat()
+            self.obj.dirzctl.send_heart_beat()
+            all_valss = self.obj.hx711s.get_vals()
+            if all_valss is None or len(all_valss[0]) == 0:
+                self.obj.hx711s.delay_s(0.005)
+                continue
+            unfit_vals, tmp_unfit_vals = self.obj.filter.cal_offset_by_vals(self.obj.hx711s.s_count, all_valss, self.obj.filter.lft_k1_oft, self.cfg.pi_count)
+            fit_vals, tmp_fit_vals = self.obj.filter.cal_filter_by_vals(self.obj.hx711s.s_count, all_valss, self.obj.filter.hft_hz, self.obj.filter.lft_k1, self.cfg.pi_count)
+            
+            for i in range(self.obj.hx711s.s_count):
+                if not self._check_trigger(i, tmp_fit_vals[i], tmp_unfit_vals[i], min_hold, max_hold):
+                    continue
+                self.obj.dirzctl.check_and_run(0, 0, 0, wait_finish=False)
+                self.obj.hx711s.query_start(self.cfg.pi_count * 2, int(0), del_dirty=False, show_msg=False)
+                self.obj.hx711s.delay_s(0.015)
+                for j in range(int(self.obj.hx711s.s_count)):
+                    self.pnt_array('TRIGGER_USE_CH=%d, FIT_VALS=' % (j), tmp_fit_vals[j], 16)
+                self.obj.hx711s.delay_s(0.2)
+                all_valss = self.obj.hx711s.get_vals()
+                self.pnt_array('WAIT_AND_CAL_CH=%d, ARY=' % (i), all_valss[i])
+                hx711_vals, tmp_hx711_vs = self.obj.filter.cal_filter_by_vals(self.obj.hx711s.s_count, all_valss, self.obj.filter.hft_hz, self.obj.filter.lft_k1_cal, self.cfg.pi_count)
+                self.pnt_array('WAIT_AND_CAL_CH=%d, ARY=' % (i), tmp_hx711_vs[i])
+                for m in range(self.obj.hx711s.s_count):
+                    self.send_wave_tri(m, tmp_hx711_vs[m])
+                up_min_cnt, up_all_cnt, deal_sta = self._cal_min_z(rdy_pos[2], tmp_hx711_vs[i])
+                if up_after:
+                    self.obj.dirzctl.check_and_run(1, int(step_us / 2), int(up_all_cnt))
+                return self.val.out_index, self.val.out_val_mm, deal_sta
+            self.obj.hx711s.delay_s(0.005)
+        return self.val.out_index, self.val.out_val_mm, True
+
+    def run_G28_Z(self):
+        self.pnt_msg('***run_G28_Z*** Start...')
+        self.val.re_probe_cnt = 0
+        self.val.g29_cnt = 0
+        self.obj.toolhead.wait_moves()
+        target_temp = self.obj.heater_hot.target_temp
+        now_pos = self.obj.toolhead.get_position()
+        self.val.home_xy = [now_pos[0], now_pos[1]]
+        now_pos[2] = 2
+        random.seed(int(time.time()))  
+        now_pos_sta0 = [now_pos[0] + (1 if (int(time.time() * 1000) % 2 == 0) else -1) * random.uniform(10, 20),
+                        now_pos[1] + (1 if (int(time.time() * 100) % 2 == 0) else -1) * random.uniform(10, 20),
+                        now_pos[2], now_pos[3]]
+        mesh = self.obj.bed_mesh.get_mesh()
+        self.obj.bed_mesh.set_mesh(None)                
+        self.obj.toolhead.set_position(now_pos, homing_axes=[2])
+        self._move(now_pos_sta0, 20)
+        if self.cfg.g28_wait_cool_down and self.obj.heater_hot.smoothed_temp > (self.cfg.hot_min_temp + 5):
+            self.pnt_msg('G28_Z: Wait for Nozzle to cool down[%.2f -> %.2f]...' % (target_temp, self.cfg.hot_min_temp))
+            self._set_hot_temps(temp=self.cfg.hot_min_temp, fan_spd=255, wait=True, err=5) 
+            self._set_hot_temps(temp=self.cfg.hot_min_temp, fan_spd=0, wait=False, err=5) 
+        if self.cfg.max_dis_bef_g28 != 0:
+            step_cnt = int(self.cfg.max_dis_bef_g28 / (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base))
+            step_us = int(((self.cfg.max_dis_bef_g28 / self.cfg.g28_sta0_speed) * 1000 * 1000) / step_cnt)
+            self.obj.dirzctl.check_and_run(1, step_us, step_cnt)
+        if self.cfg.dead_zone_bef_g28 != 0:
+            step_cnt = int(self.cfg.dead_zone_bef_g28 / (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base))
+            step_us = int(((self.cfg.dead_zone_bef_g28 / self.cfg.g28_sta0_speed) * 1000 * 1000) / step_cnt)
+            self.obj.dirzctl.check_and_run(0, step_us, step_cnt)
+        is_uped = False
+        for i in range(10):
+            self.obj.toolhead.set_position(now_pos_sta0[:2] + [(2 if i == 0 else 0), now_pos_sta0[3]], homing_axes=[2])
+            self._move(now_pos_sta0[:3], self.cfg.g29_rdy_speed)
+            out_index, out_mm, deal_sta = self.probe_by_step(now_pos_sta0, self.cfg.g28_sta0_speed, self.cfg.max_z, self.cfg.g28_sta0_min_hold, self.cfg.max_hold, up_after=False)
+            if not deal_sta and not is_uped:
+                is_uped = True
+                self.obj.toolhead.set_position(now_pos_sta0[:2] + [0, now_pos_sta0[3]], homing_axes=[2])
+                self._move(now_pos_sta0[:2] + [5, now_pos_sta0[3]], self.cfg.g29_rdy_speed)
+                pass
+            if (-1 < out_mm < 1 and deal_sta) or not self.ck_sys_sta():
+                break
+        self.obj.toolhead.set_position(now_pos_sta0[:2] + [-0.5, now_pos[3]], homing_axes=[2])
+        self._move(now_pos_sta0[:2] + [2, now_pos[3]], self.cfg.g29_rdy_speed)
+
+        now_pos = [now_pos[0] + random.uniform(-1.0, +1.0), now_pos[1] + random.uniform(-1.0, +1.0), 2, now_pos[3]]
+        self._move(now_pos, 30)
+        self.shake_motor(int(self.cfg.shake_cnt * 2))
+        out_mms = []
+        for i in range(5):
+            o_index0, o_mm0, deal_sta = self.probe_by_step(now_pos, self.cfg.g28_sta1_speed, self.cfg.max_z, self.cfg.min_hold, self.cfg.max_hold, True)
+            out_mms.append(o_mm0)
+        out_mms.sort()
+        self.pnt_array('G28_ZS = ', out_mms, len(out_mms))
+        if math.fabs(out_mms[3] - out_mms[1]) > 5.0:
+             raise self.obj.printer.command_error("""{"code":"key504", "msg":"run_G28_Z: Homing Z failure, During zeroing, please place the machine on a stable platform and do not touch the hot bed."}""")
+        self.obj.toolhead.set_position(now_pos[:2] + [now_pos[2] - out_mms[2] - self.cfg.self_z_offset, now_pos[3]], homing_axes=[2])
+
+        self.obj.bed_mesh.set_mesh(mesh)
+
+        # self.obj.gcode.run_script_from_command('G1 F300 Z10')
+        self._move(now_pos[:2] + [10, now_pos[3]], self.cfg.g29_rdy_speed)
+
+        if self.cfg.g28_wait_cool_down:
+            self.pnt_msg('G28_Z: Wait for Nozzle to recovery[%.2f -> %.2f]...' % (self.cfg.hot_min_temp, target_temp))
+            self._set_hot_temps(temp=target_temp, fan_spd=0, wait=True if target_temp > self.cfg.hot_min_temp else False, err=5)
+        pass
+
+    def run_G29_Z(self):
+        x_cnt = self.obj.bed_mesh.bmc.mesh_config['x_count']
+        y_cnt = self.obj.bed_mesh.bmc.mesh_config['y_count']
+        self.obj.toolhead.wait_moves()
+        now_pos = self.obj.toolhead.get_position()
+        self.val.jump_probe_ready = False
+
+        if self.val.g29_cnt == 0:
+            self.shake_motor(self.cfg.shake_cnt)
+            self.probe_ready()
+            now_pos[2] = self.get_best_rdy_z(now_pos[0], now_pos[1], self.val.rdy_pos) + self.cfg.best_above_z
+            self._move(now_pos, self.cfg.g29_xy_speed)        
+
+        if (int(self.val.g29_cnt) % int(x_cnt)) == 0:
+            self.shake_motor(self.cfg.shake_cnt)
+            pass
+
+        now_pos[2] = self._probe_times(10, now_pos, self.cfg.g29_speed, self.cfg.bed_max_err, 0.06, self.cfg.min_hold, self.cfg.max_hold) + self.get_best_rdy_z(now_pos[0], now_pos[1], self.val.gap_pos) + self.cfg.fix_z_offset
+       
+        self.val.g29_cnt += 1
+        if self.val.g29_cnt == x_cnt * y_cnt:
+            self.val.g29_cnt = 0
+            self._move([now_pos[0], now_pos[1], self.cfg.bed_max_err + 1], self.cfg.g29_rdy_speed) 
+            self._move([self.val.home_xy[0], self.val.home_xy[1], self.cfg.bed_max_err + 1], self.cfg.g29_xy_speed)  
+            home_z = self._probe_times(3, [self.val.home_xy[0], self.val.home_xy[1], self.cfg.bed_max_err + 1], 
+                                       self.cfg.g29_speed, self.cfg.bed_max_err * 2, 0.20, self.cfg.min_hold, self.cfg.max_hold)
+            self.pnt_msg('CHECK_STEP_LOST need=0, tri=%.2f' % home_z)
+            if home_z > 1.0:
+                raise self.obj.printer.command_error("""{"code":"key503", "msg":"run_G29_Z: Z-axis motor lost of step detected, Please restart the machine and try again"}""")
+
+        return now_pos
+
+    cmd_PRTOUCH_TEST_help = "Test the PR-Touch."
+    def cmd_PRTOUCH_TEST(self, gcmd):   # PRTOUCH_TEST X=20 Y=20 Z=-4 S=0.0125
+        pos = self.obj.toolhead.get_position()
+        rdy_x = gcmd.get_float('X', pos[0])
+        rdy_y = gcmd.get_float('Y', pos[1])
+        rdy_z = gcmd.get_float('Z', pos[2])
+        speed = gcmd.get_float('SPEED', 1.0)
+        min_hold = gcmd.get_int('MIN_HOLD', self.cfg.min_hold)
+        max_hold = gcmd.get_int('MAX_HOLD', self.cfg.max_hold)
+        self._move([rdy_x, rdy_y, rdy_z], self.cfg.g29_xy_speed)
+        self.probe_by_step([rdy_x, rdy_y, rdy_z], speed, 50, min_hold, max_hold, True)
+        pass
+
+    cmd_PRTOUCH_READY_help = "Test the ready point."
+    def cmd_PRTOUCH_READY(self, gcmd):
+        self.probe_ready()
+        pass
+
+    cmd_CHECK_BED_MESH_help = "Check the bed mesh."
+    def cmd_CHECK_BED_MESH(self, gcmd):
+        self.check_bed_mesh(gcmd.get_int('AUTO_G29', 0) > 0)
+        pass
+
+    cmd_MEASURE_GAP_TEST_help = "Measure z gap."
+    def cmd_MEASURE_GAP_TEST(self, gcmd):
+        self._ck_g28ed()
+        gap_index = gcmd.get_int('INDEX', 0)
+        n_index = [0, 3, 1, 2]
+        self._move([self.val.rdy_pos[n_index[gap_index]][0], self.val.rdy_pos[n_index[gap_index]][1], self.cfg.bed_max_err + 1.], self.cfg.g29_xy_speed)  
+        zero_z = self._probe_times(10, [self.val.rdy_pos[n_index[gap_index]][0], self.val.rdy_pos[n_index[gap_index]][1], self.cfg.bed_max_err + 1.], 
+                                        self.cfg.g29_speed, 10, 0.05, self.cfg.min_hold, self.cfg.max_hold) 
+        self._gap_times(5, zero_z)
+        pass
+
+    cmd_NOZZLE_CLEAR_help = "Clear the nozzle on bed."
+    def cmd_NOZZLE_CLEAR(self, gcmd):
+        hot_min_temp = gcmd.get_float('HOT_MIN_TEMP', self.cfg.hot_min_temp)
+        hot_max_temp = gcmd.get_float('HOT_MAX_TEMP', self.cfg.hot_max_temp)
+        bed_max_temp = gcmd.get_float('BED_MAX_TEMP', self.cfg.bed_max_temp)
+        min_hold = gcmd.get_int('MIN_HOLD', self.cfg.min_hold)
+        max_hold = gcmd.get_int('MAX_HOLD', self.cfg.max_hold)
+        self.clear_nozzle(hot_min_temp, hot_max_temp, bed_max_temp, min_hold, max_hold)
+
+    def change_hot_min_temp(self, temp):
+        self.cfg.hot_min_temp = temp
+
+def load_config(config):
+    prt = PRTouchEndstopWrapper(config)
+    config.get_printer().add_object('probe', probe.PrinterProbe(config, prt))
+    return prt
+
+# G28
+# READ_HX711 C=1
+# NOZZLE_CLEAR
+# PRTOUCH_READY
+# BED_MESH_CALIBRATE
+# CHECK_BED_MESH AUTO_G29=0
+# MEASURE_GAP_TEST INDEX=0
+# FORCE_MOVE STEPPER=stepper_x DISTANCE=10 VELOCITY=5
+
+# g28_sta0_speed、g28_sta1_speed和g29_speed都改为1.8
\ No newline at end of file
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/prtouch_v2.py crealityShit/klippy/extras/prtouch_v2.py
--- klipperStock/klippy/extras/prtouch_v2.py	1969-12-31 18:00:00.000000000 -0600
+++ crealityShit/klippy/extras/prtouch_v2.py	2024-01-14 23:02:21.642060121 -0600
@@ -0,0 +1,26 @@
+# prtouch support
+#
+# Copyright (C) 2018-2021  Creality <wangyulong878@sina.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+from . import probe
+from . import prtouch_v2_wrapper
+from . import prtouch_v1_wrapper
+
+def load_config(config):
+    pr_version = config.getint('pr_version', default=1, minval=0, maxval=100)
+    if pr_version == 2:
+        vrt = prtouch_v2_wrapper.PRTouchEndstopWrapper(config)
+    if pr_version == 1:
+        vrt = prtouch_v1_wrapper.PRTouchEndstopWrapper(config)
+    config.get_printer().add_object('probe', probe.PrinterProbe(config, vrt))
+    return vrt
+
+
+# /home/cc/moonraker-env/bin/python3.10 /home/cc/moonraker/moonraker/moonraker.py -d /home/cc/printer_data
+# sudo service klipper stop
+# /home/cc/klippy-env/bin/python3.10 /home/cc/klipper/klippy/klippy.py /home/cc/printer_data/config/printer.cfg -a /home/cc/printer_data/comms/klippy.sock -l /home/cc/printer_data/logs/klippy.log
+
+# ./micropython /home/cc/klipper/klippy/klippy.py /home/cc/printer_data/config/printer.cfg -a /home/cc/printer_data/comms/klippy.sock -l /home/cc/printer_data/logs/klippy.log
+
+# /home/cc/klippy-env/bin/python3.10 /home/cc/micropython_test/klipper/klippy/klippy.py /home/cc/printer_data/config/printer.cfg -a /home/cc/printer_data/comms/klippy.sock -l /home/cc/printer_data/logs/klippy.log
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/quad_gantry_level.py crealityShit/klippy/extras/quad_gantry_level.py
--- klipperStock/klippy/extras/quad_gantry_level.py	2024-01-14 23:01:59.489788594 -0600
+++ crealityShit/klippy/extras/quad_gantry_level.py	2024-01-14 23:02:21.698060806 -0600
@@ -32,14 +32,14 @@
         self.probe_helper = probe.ProbePointsHelper(config, self.probe_finalize)
         if len(self.probe_helper.probe_points) != 4:
             raise config.error(
-                "Need exactly 4 probe points for quad_gantry_level")
+                """{"code":"key213", "msg": "Need exactly 4 probe points for quad_gantry_level" "values": []}""")
         self.z_status = z_tilt.ZAdjustStatus(self.printer)
         self.z_helper = z_tilt.ZAdjustHelper(config, 4)
         self.gantry_corners = config.getlists('gantry_corners', parser=float,
                                               seps=(',', '\n'), count=2)
         if len(self.gantry_corners) < 2:
             raise config.error(
-                "quad_gantry_level requires at least two gantry_corners")
+                """{"code":"key214", "msg": "quad_gantry_level requires at least two gantry_corners" "values": []}""")
         # Register QUAD_GANTRY_LEVEL command
         self.gcode = self.printer.lookup_object('gcode')
         self.gcode.register_command(
@@ -102,10 +102,8 @@
 
         adjust_max = max(z_adjust)
         if adjust_max > self.max_adjust:
-            raise self.gcode.error("Aborting quad_gantry_level"
-                                   " required adjustment %0.6f"
-                                   " is greater than max_adjust %0.6f"
-                                   % (adjust_max, self.max_adjust))
+            raise self.gcode.error("""{"code":"key215", "msg": "Aborting quad_gantry_level required adjustment %0.6f is greater than max_adjust %0.6f" "values": [%0.6f,%0.6f]}"""
+                                   % (adjust_max, self.max_adjust, adjust_max, self.max_adjust))
 
         speed = self.probe_helper.get_lift_speed()
         self.z_helper.adjust_steppers(z_adjust, speed)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/replicape.py crealityShit/klippy/extras/replicape.py
--- klipperStock/klippy/extras/replicape.py	2024-01-14 23:01:59.477788447 -0600
+++ crealityShit/klippy/extras/replicape.py	2024-01-14 23:02:21.678060562 -0600
@@ -18,7 +18,7 @@
         self._replicape = replicape
         self._channel = channel
         if pin_type not in ['digital_out', 'pwm']:
-            raise pins.error("Pin type not supported on replicape")
+            raise pins.error("""{"code":"key276": "msg":"Pin type not supported on replicape", "values":[]}""")
         self._mcu = replicape.host_mcu
         self._mcu.register_config_callback(self._build_config)
         self._bus = REPLICAPE_PCA9685_BUS
@@ -38,13 +38,13 @@
         self._max_duration = max_duration
     def setup_cycle_time(self, cycle_time, hardware_pwm=False):
         if hardware_pwm:
-            raise pins.error("pca9685 does not support hardware_pwm parameter")
+            raise pins.error("""{"code":"key216", "msg": "pca9685 does not support hardware_pwm parameter" "values": []}""")
         if cycle_time != self._cycle_time:
             logging.info("Ignoring pca9685 cycle time of %.6f (using %.6f)",
                          cycle_time, self._cycle_time)
     def setup_start_value(self, start_value, shutdown_value, is_static=False):
         if is_static and start_value != shutdown_value:
-            raise pins.error("Static pin can not have shutdown value")
+            raise pins.error("""{"code":"key277": "msg":"Static pin can not have shutdown value", "values":[]}""")
         if self._invert:
             start_value = 1. - start_value
             shutdown_value = 1. - shutdown_value
@@ -93,9 +93,9 @@
 class ReplicapeDACEnable:
     def __init__(self, replicape, channel, pin_type, pin_params):
         if pin_type != 'digital_out':
-            raise pins.error("Replicape virtual enable pin must be digital_out")
+            raise pins.error("""{"code":"key277": "msg":"Static pin can not have shutdown value", "values":[]}""")
         if pin_params['invert']:
-            raise pins.error("Replicape virtual enable pin can not be inverted")
+            raise pins.error("""{"code":"key278": "msg":"Replicape virtual enable pin can not be invertede", "values":[]}""")
         self.mcu = replicape.host_mcu
         self.value = replicape.stepper_dacs[channel]
         self.pwm = pca9685_pwm(replicape, channel, pin_type, pin_params)
@@ -130,7 +130,7 @@
                 '/sys/devices/platform/ocp/48302000.epwmss/48302200.pwm/pwm/')
                 pwmchip = [pc for pc in pwmdev if pc.startswith('pwmchip')][0]
             except:
-                raise pins.error("Replicape unable to determine pwmchip")
+                raise pins.error("""{"code":"key279": "msg":"Replicape unable to determine pwmchip", "values":[]}""")
         pwm_pin, resv1, resv2 = SERVO_PINS[config_name]
         pin_params = dict(pin_params)
         pin_params['pin'] = pwmchip + pwm_pin
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/resonance_tester.py crealityShit/klippy/extras/resonance_tester.py
--- klipperStock/klippy/extras/resonance_tester.py	2024-01-14 23:01:59.469788348 -0600
+++ crealityShit/klippy/extras/resonance_tester.py	2024-01-14 23:02:21.670060464 -0600
@@ -5,6 +5,7 @@
 # This file may be distributed under the terms of the GNU GPLv3 license.
 import logging, math, os, time
 from . import shaper_calibrate
+from subprocess import call
 
 class TestAxis:
     def __init__(self, axis=None, vib_dir=None):
@@ -36,13 +37,13 @@
         return TestAxis(axis=raw_axis)
     dirs = raw_axis.split(',')
     if len(dirs) != 2:
-        raise gcmd.error("Invalid format of axis '%s'" % (raw_axis,))
+        raise gcmd.error("""{"code": "key304", "msg": "Invalid format of axiss '%s'", "values":["%s"]}""" % (raw_axis,raw_axis))
     try:
         dir_x = float(dirs[0].strip())
         dir_y = float(dirs[1].strip())
     except:
         raise gcmd.error(
-                "Unable to parse axis direction '%s'" % (raw_axis,))
+                """{"code": "key305", "msg": "Unable to parse axis direction '%s'", "values":["%s"]}""" % (raw_axis, raw_axis))
     return TestAxis(vib_dir=(dir_x, dir_y))
 
 class VibrationPulseTest:
@@ -59,6 +60,8 @@
 
         self.probe_points = config.getlists('probe_points', seps=(',', '\n'),
                                             parser=float, count=3)
+        self.low_mem = config.getboolean('low_mem', True)
+
     def get_start_test_points(self):
         return self.probe_points
     def prepare_test(self, gcmd):
@@ -199,8 +202,11 @@
                 for chip_axis, aclient, chip_name in raw_values:
                     if not aclient.has_valid_samples():
                         raise gcmd.error(
-                            "accelerometer '%s' measured no data" % (
-                                chip_name,))
+						        """{"code":"key56", "msg":"accelerometer '%s' measured no data", "values": ["%s"]}""" % (
+                                    chip_name, chip_name))
+                    if self.test.low_mem:
+                        new_data = helper.lowmem_process_accelerometer_data(aclient)
+                    else:
                     new_data = helper.process_accelerometer_data(aclient)
                     if calibration_data[axis] is None:
                         calibration_data[axis] = new_data
@@ -237,14 +243,12 @@
         outputs = gcmd.get("OUTPUT", "resonances").lower().split(',')
         for output in outputs:
             if output not in ['resonances', 'raw_data']:
-                raise gcmd.error("Unsupported output '%s', only 'resonances'"
-                                 " and 'raw_data' are supported" % (output,))
+                raise gcmd.error("""{"code": "key306", "msg": "Unsupported output '%s', only 'resonances' and 'raw_data' are supported", "values":["%s"]}""" % (output, output))
         if not outputs:
-            raise gcmd.error("No output specified, at least one of 'resonances'"
-                             " or 'raw_data' must be set in OUTPUT parameter")
+            raise gcmd.error("""{"code": "key307", "msg": "No output specified, at least one of 'resonances' or 'raw_data' must be set in OUTPUT parameter", "values":[]}""")
         name_suffix = gcmd.get("NAME", time.strftime("%Y%m%d_%H%M%S"))
         if not self.is_valid_name_suffix(name_suffix):
-            raise gcmd.error("Invalid NAME parameter")
+            raise gcmd.error("""{"code":"key55", "msg":"Invalid NAME parameter", "values": []}""")
         csv_output = 'resonances' in outputs
         raw_output = 'raw_data' in outputs
 
@@ -270,12 +274,15 @@
     def cmd_SHAPER_CALIBRATE(self, gcmd):
         # Parse parameters
         axis = gcmd.get("AXIS", None)
+        copy_TestAxis_y_to_x = False
         if not axis:
             calibrate_axes = [TestAxis('x'), TestAxis('y')]
         elif axis.lower() not in 'xy':
             raise gcmd.error("Unsupported axis '%s'" % (axis,))
         else:
             calibrate_axes = [TestAxis(axis.lower())]
+            if axis.lower() == "y":
+                copy_TestAxis_y_to_x = True
 
         max_smoothing = gcmd.get_float(
                 "MAX_SMOOTHING", self.max_smoothing, minval=0.05)
@@ -307,8 +314,23 @@
             csv_name = self.save_calibration_data(
                     'calibration_data', name_suffix, helper, axis,
                     calibration_data[axis], all_shapers)
+            if copy_TestAxis_y_to_x:
+                helper.save_params(configfile, "x", best_shaper.name, best_shaper.freq)
+                csv_name_x = self.save_calibration_data('calibration_data', name_suffix, helper, TestAxis('x'), calibration_data[axis], all_shapers)
+                gcmd.respond_info("copy_TestAxis_y_to_x Recommended shaper_type_%s = %s, shaper_freq_%s = %.1f Hz" % ("x", best_shaper.name, "x", best_shaper.freq))
+                gcmd.respond_info("copy_TestAxis_y_to_x Shaper calibration data written to %s file" % (csv_name_x,))
             gcmd.respond_info(
                     "Shaper calibration data written to %s file" % (csv_name,))
+        gcode = self.printer.lookup_object('gcode')
+        gcode.run_script_from_command("CXSAVE_CONFIG")
+        call("sync", shell=True)
+        input_shaper = self.printer.lookup_object("input_shaper", None)
+        if not input_shaper:
+            config = configfile.read_main_config()
+            self.printer.reload_object(config, "input_shaper")
+            gcode.run_script_from_command("UPDATE_INPUT_SHAPER")
+            input_shaper = self.printer.lookup_object("input_shaper", None)
+            input_shaper.enable_shaping()
         gcmd.respond_info(
             "The SAVE_CONFIG command will update the printer config file\n"
             "with these parameters and restart the printer.")
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/respond.py crealityShit/klippy/extras/respond.py
--- klipperStock/klippy/extras/respond.py	2024-01-14 23:01:59.457788201 -0600
+++ crealityShit/klippy/extras/respond.py	2024-01-14 23:02:21.658060316 -0600
@@ -42,8 +42,8 @@
                 no_space = True
             else:
                 raise gcmd.error(
-                    "RESPOND TYPE '%s' is invalid. Must be one"
-                    " of 'echo', 'command', or 'error'" % (respond_type,))
+                    """{"code": "key309", "msg": "RESPOND TYPE '%s' is invalid. Must be one of 'echo', 'command', or 'error'", "values":["%s"]}""" % (
+                        respond_type, respond_type))
         prefix = gcmd.get('PREFIX', prefix)
         msg = gcmd.get('MSG', '')
         if(no_space):
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/safe_z_home.py crealityShit/klippy/extras/safe_z_home.py
--- klipperStock/klippy/extras/safe_z_home.py	2024-01-14 23:01:59.481788498 -0600
+++ crealityShit/klippy/extras/safe_z_home.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,91 +0,0 @@
-# Perform Z Homing at specific XY coordinates.
-#
-# Copyright (C) 2019 Florian Heilmann <Florian.Heilmann@gmx.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-class SafeZHoming:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        x_pos, y_pos = config.getfloatlist("home_xy_position", count=2)
-        self.home_x_pos, self.home_y_pos = x_pos, y_pos
-        self.z_hop = config.getfloat("z_hop", default=0.0)
-        self.z_hop_speed = config.getfloat('z_hop_speed', 15., above=0.)
-        zconfig = config.getsection('stepper_z')
-        self.max_z = zconfig.getfloat('position_max', note_valid=False)
-        self.speed = config.getfloat('speed', 50.0, above=0.)
-        self.move_to_previous = config.getboolean('move_to_previous', False)
-        self.printer.load_object(config, 'homing')
-        self.gcode = self.printer.lookup_object('gcode')
-        self.prev_G28 = self.gcode.register_command("G28", None)
-        self.gcode.register_command("G28", self.cmd_G28)
-
-        if config.has_section("homing_override"):
-            raise config.error("homing_override and safe_z_homing cannot"
-                               +" be used simultaneously")
-
-    def cmd_G28(self, gcmd):
-        toolhead = self.printer.lookup_object('toolhead')
-
-        # Perform Z Hop if necessary
-        if self.z_hop != 0.0:
-            # Check if Z axis is homed and its last known position
-            curtime = self.printer.get_reactor().monotonic()
-            kin_status = toolhead.get_kinematics().get_status(curtime)
-            pos = toolhead.get_position()
-
-            if 'z' not in kin_status['homed_axes']:
-                # Always perform the z_hop if the Z axis is not homed
-                pos[2] = 0
-                toolhead.set_position(pos, homing_axes=[2])
-                toolhead.manual_move([None, None, self.z_hop],
-                                     self.z_hop_speed)
-                if hasattr(toolhead.get_kinematics(), "note_z_not_homed"):
-                    toolhead.get_kinematics().note_z_not_homed()
-            elif pos[2] < self.z_hop:
-                # If the Z axis is homed, and below z_hop, lift it to z_hop
-                toolhead.manual_move([None, None, self.z_hop],
-                                     self.z_hop_speed)
-
-        # Determine which axes we need to home
-        need_x, need_y, need_z = [gcmd.get(axis, None) is not None
-                                  for axis in "XYZ"]
-        if not need_x and not need_y and not need_z:
-            need_x = need_y = need_z = True
-
-        # Home XY axes if necessary
-        new_params = {}
-        if need_x:
-            new_params['X'] = '0'
-        if need_y:
-            new_params['Y'] = '0'
-        if new_params:
-            g28_gcmd = self.gcode.create_gcode_command("G28", "G28", new_params)
-            self.prev_G28(g28_gcmd)
-
-        # Home Z axis if necessary
-        if need_z:
-            # Throw an error if X or Y are not homed
-            curtime = self.printer.get_reactor().monotonic()
-            kin_status = toolhead.get_kinematics().get_status(curtime)
-            if ('x' not in kin_status['homed_axes'] or
-                'y' not in kin_status['homed_axes']):
-                raise gcmd.error("Must home X and Y axes first")
-            # Move to safe XY homing position
-            prevpos = toolhead.get_position()
-            toolhead.manual_move([self.home_x_pos, self.home_y_pos], self.speed)
-            # Home Z
-            g28_gcmd = self.gcode.create_gcode_command("G28", "G28", {'Z': '0'})
-            self.prev_G28(g28_gcmd)
-            # Perform Z Hop again for pressure-based probes
-            if self.z_hop:
-                pos = toolhead.get_position()
-                if pos[2] < self.z_hop:
-                    toolhead.manual_move([None, None, self.z_hop],
-                                         self.z_hop_speed)
-            # Move XY back to previous positions
-            if self.move_to_previous:
-                toolhead.manual_move(prevpos[:2], self.speed)
-
-def load_config(config):
-    return SafeZHoming(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/samd_sercom.py crealityShit/klippy/extras/samd_sercom.py
--- klipperStock/klippy/extras/samd_sercom.py	2024-01-14 23:01:59.485788546 -0600
+++ crealityShit/klippy/extras/samd_sercom.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,41 +0,0 @@
-# SAMD Sercom configuration
-#
-# Copyright (C) 2019  Florian Heilmann <Florian.Heilmann@gmx.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-class SamdSERCOM:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-
-        self.sercom = config.get("sercom")
-        self.tx_pin = config.get("tx_pin")
-        self.rx_pin = config.get("rx_pin", None)
-        self.clk_pin = config.get("clk_pin")
-
-        ppins = self.printer.lookup_object("pins")
-        tx_pin_params = ppins.lookup_pin(self.tx_pin)
-        self.mcu = tx_pin_params['chip']
-        self.mcu.add_config_cmd(
-            "set_sercom_pin bus=%s sercom_pin_type=tx pin=%s" % (
-                self.sercom, tx_pin_params['pin']))
-
-        clk_pin_params = ppins.lookup_pin(self.clk_pin)
-        if self.mcu is not clk_pin_params['chip']:
-            raise ppins.error("%s: SERCOM pins must be on same mcu" % (
-                config.get_name(),))
-        self.mcu.add_config_cmd(
-            "set_sercom_pin bus=%s sercom_pin_type=clk pin=%s" % (
-                self.sercom, clk_pin_params['pin']))
-
-        if self.rx_pin:
-            rx_pin_params = ppins.lookup_pin(self.rx_pin)
-            if self.mcu is not rx_pin_params['chip']:
-                raise ppins.error("%s: SERCOM pins must be on same mcu" % (
-                    config.get_name(),))
-            self.mcu.add_config_cmd(
-                "set_sercom_pin bus=%s sercom_pin_type=rx pin=%s" % (
-                    self.sercom, rx_pin_params['pin']))
-
-def load_config_prefix(config):
-    return SamdSERCOM(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/save_variables.py crealityShit/klippy/extras/save_variables.py
--- klipperStock/klippy/extras/save_variables.py	2024-01-14 23:01:59.465788301 -0600
+++ crealityShit/klippy/extras/save_variables.py	2024-01-14 23:02:21.662060367 -0600
@@ -29,7 +29,7 @@
                 for name, val in varfile.items('Variables'):
                     allvars[name] = ast.literal_eval(val)
         except:
-            msg = "Unable to parse existing variable file"
+            msg = """{"code": "key284", "msg": ""Unable to parse existing variable file", "values": []}"""
             logging.exception(msg)
             raise self.printer.command_error(msg)
         self.allVariables = allvars
@@ -40,7 +40,7 @@
         try:
             value = ast.literal_eval(value)
         except ValueError as e:
-            raise gcmd.error("Unable to parse '%s' as a literal" % (value,))
+            raise gcmd.error("""{"code": "key285", "msg": "Unable to parse '%s' as a literal", "values": ["%s"]}""" % (value, value))
         newvars = dict(self.allVariables)
         newvars[varname] = value
         # Write file
@@ -53,7 +53,7 @@
             varfile.write(f)
             f.close()
         except:
-            msg = "Unable to save variable"
+            msg = """{"code": "key286", "msg": "Unable to save variable", "values": []}"""
             logging.exception(msg)
             raise gcmd.error(msg)
         self.loadVariables()
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/screws_tilt_adjust.py crealityShit/klippy/extras/screws_tilt_adjust.py
--- klipperStock/klippy/extras/screws_tilt_adjust.py	2024-01-14 23:01:59.457788201 -0600
+++ crealityShit/klippy/extras/screws_tilt_adjust.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,127 +0,0 @@
-# Helper script to adjust bed screws tilt using Z probe
-#
-# Copyright (C) 2019  Rui Caridade <rui.mcbc@gmail.com>
-# Copyright (C) 2021  Matthew Lloyd <github@matthewlloyd.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import math
-from . import probe
-
-class ScrewsTiltAdjust:
-    def __init__(self, config):
-        self.config = config
-        self.printer = config.get_printer()
-        self.screws = []
-        self.results = []
-        self.max_diff = None
-        self.max_diff_error = False
-        # Read config
-        for i in range(99):
-            prefix = "screw%d" % (i + 1,)
-            if config.get(prefix, None) is None:
-                break
-            screw_coord = config.getfloatlist(prefix, count=2)
-            screw_name = "screw at %.3f,%.3f" % screw_coord
-            screw_name = config.get(prefix + "_name", screw_name)
-            self.screws.append((screw_coord, screw_name))
-        if len(self.screws) < 3:
-            raise config.error("screws_tilt_adjust: Must have "
-                               "at least three screws")
-        self.threads = {'CW-M3': 0, 'CCW-M3': 1, 'CW-M4': 2, 'CCW-M4': 3,
-                        'CW-M5': 4, 'CCW-M5': 5}
-        self.thread = config.getchoice('screw_thread', self.threads,
-                                       default='CW-M3')
-        # Initialize ProbePointsHelper
-        points = [coord for coord, name in self.screws]
-        self.probe_helper = probe.ProbePointsHelper(self.config,
-                                                    self.probe_finalize,
-                                                    default_points=points)
-        self.probe_helper.minimum_points(3)
-        # Register command
-        self.gcode = self.printer.lookup_object('gcode')
-        self.gcode.register_command("SCREWS_TILT_CALCULATE",
-                                    self.cmd_SCREWS_TILT_CALCULATE,
-                                    desc=self.cmd_SCREWS_TILT_CALCULATE_help)
-    cmd_SCREWS_TILT_CALCULATE_help = "Tool to help adjust bed leveling " \
-                                     "screws by calculating the number " \
-                                     "of turns to level it."
-
-    def cmd_SCREWS_TILT_CALCULATE(self, gcmd):
-        self.max_diff = gcmd.get_float("MAX_DEVIATION", None)
-        # Option to force all turns to be in the given direction (CW or CCW)
-        direction = gcmd.get("DIRECTION", default=None)
-        if direction is not None:
-            direction = direction.upper()
-            if direction not in ('CW', 'CCW'):
-                raise gcmd.error(
-                    "Error on '%s': DIRECTION must be either CW or CCW" % (
-                        gcmd.get_commandline(),))
-        self.direction = direction
-        self.probe_helper.start_probe(gcmd)
-
-    def get_status(self, eventtime):
-        return {'error': self.max_diff_error,
-            'results': self.results}
-
-    def probe_finalize(self, offsets, positions):
-        self.results = []
-        self.max_diff_error = False
-        # Factors used for CW-M3, CCW-M3, CW-M4, CCW-M4, CW-M5 and CCW-M5
-        threads_factor = {0: 0.5, 1: 0.5, 2: 0.7, 3: 0.7, 4: 0.8, 5: 0.8}
-        is_clockwise_thread = (self.thread & 1) == 0
-        screw_diff = []
-        # Process the read Z values
-        if self.direction is not None:
-            # Lowest or highest screw is the base position used for comparison
-            use_max = ((is_clockwise_thread and self.direction == 'CW')
-                    or (not is_clockwise_thread and self.direction == 'CCW'))
-            min_or_max = max if use_max else min
-            i_base, z_base = min_or_max(
-                enumerate([pos[2] for pos in positions]), key=lambda v: v[1])
-        else:
-            # First screw is the base position used for comparison
-            i_base, z_base = 0, positions[0][2]
-        # Provide the user some information on how to read the results
-        self.gcode.respond_info("01:20 means 1 full turn and 20 minutes, "
-                                "CW=clockwise, CCW=counter-clockwise")
-        for i, screw in enumerate(self.screws):
-            z = positions[i][2]
-            coord, name = screw
-            if i == i_base:
-                # Show the results
-                self.gcode.respond_info(
-                    "%s : x=%.1f, y=%.1f, z=%.5f" %
-                    (name + ' (base)', coord[0], coord[1], z))
-                self.results.append({'name': name + ' (base)', 'x': coord[0],
-                    'y': coord[1], 'z': z, 'sign': 'CW', 'adjust':'00:00'})
-            else:
-                # Calculate how knob must be adjusted for other positions
-                diff = z_base - z
-                screw_diff.append(abs(diff))
-                if abs(diff) < 0.001:
-                    adjust = 0
-                else:
-                    adjust = diff / threads_factor.get(self.thread, 0.5)
-                if is_clockwise_thread:
-                    sign = "CW" if adjust >= 0 else "CCW"
-                else:
-                    sign = "CCW" if adjust >= 0 else "CW"
-                adjust = abs(adjust)
-                full_turns = math.trunc(adjust)
-                decimal_part = adjust - full_turns
-                minutes = round(decimal_part * 60, 0)
-                # Show the results
-                self.gcode.respond_info(
-                    "%s : x=%.1f, y=%.1f, z=%.5f : adjust %s %02d:%02d" %
-                    (name, coord[0], coord[1], z, sign, full_turns, minutes))
-                self.results.append({'name': name, 'x': coord[0], 'y': coord[1],
-                    'z': z, 'sign': sign,
-                    'adjust':"%02d:%02d" % (full_turns, minutes)})
-        if self.max_diff and any((d > self.max_diff) for d in screw_diff):
-            self.max_diff_error = True
-            raise self.gcode.error(
-                "bed level exceeds configured limits ({}mm)! " \
-                "Adjust screws and restart print.".format(self.max_diff))
-
-def load_config(config):
-    return ScrewsTiltAdjust(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/sdcard_loop.py crealityShit/klippy/extras/sdcard_loop.py
--- klipperStock/klippy/extras/sdcard_loop.py	2024-01-14 23:01:59.437787956 -0600
+++ crealityShit/klippy/extras/sdcard_loop.py	2024-01-14 23:02:21.626059926 -0600
@@ -25,15 +25,15 @@
     def cmd_SDCARD_LOOP_BEGIN(self, gcmd):
         count = gcmd.get_int("COUNT", minval=0)
         if not self.loop_begin(count):
-            raise gcmd.error("Only permitted in SD file.")
+            raise gcmd.error("""{"code":"key176", "msg": "Only permitted in SD file.", "values": []}""")
     cmd_SDCARD_LOOP_END_help = "Ends a looped section in the SD file."
     def cmd_SDCARD_LOOP_END(self, gcmd):
         if not self.loop_end():
-            raise gcmd.error("Only permitted in SD file.")
+            raise gcmd.error("""{"code":"key176", "msg": "Only permitted in SD file.", "values": []}""")
     cmd_SDCARD_LOOP_DESIST_help = "Stops iterating the current loop stack."
     def cmd_SDCARD_LOOP_DESIST(self, gcmd):
         if not self.loop_desist():
-            raise gcmd.error("Only permitted outside of a SD file.")
+            raise gcmd.error("""{"code":"key177", "msg": "Only permitted outside of a SD file..", "values": []}""")
     def loop_begin(self, count):
         if not self.sdcard.is_cmd_from_sd():
             # Can only run inside of an SD file
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/servo.py crealityShit/klippy/extras/servo.py
--- klipperStock/klippy/extras/servo.py	2024-01-14 23:01:59.469788348 -0600
+++ crealityShit/klippy/extras/servo.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,70 +0,0 @@
-# Support for servos
-#
-# Copyright (C) 2017-2020  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-SERVO_SIGNAL_PERIOD = 0.020
-PIN_MIN_TIME = 0.100
-
-class PrinterServo:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.min_width = config.getfloat('minimum_pulse_width', .001,
-                                         above=0., below=SERVO_SIGNAL_PERIOD)
-        self.max_width = config.getfloat('maximum_pulse_width', .002,
-                                         above=self.min_width,
-                                         below=SERVO_SIGNAL_PERIOD)
-        self.max_angle = config.getfloat('maximum_servo_angle', 180.)
-        self.angle_to_width = (self.max_width - self.min_width) / self.max_angle
-        self.width_to_value = 1. / SERVO_SIGNAL_PERIOD
-        self.last_value = self.last_value_time = 0.
-        initial_pwm = 0.
-        iangle = config.getfloat('initial_angle', None, minval=0., maxval=360.)
-        if iangle is not None:
-            initial_pwm = self._get_pwm_from_angle(iangle)
-        else:
-            iwidth = config.getfloat('initial_pulse_width', 0.,
-                                     minval=0., maxval=self.max_width)
-            initial_pwm = self._get_pwm_from_pulse_width(iwidth)
-        # Setup mcu_servo pin
-        ppins = self.printer.lookup_object('pins')
-        self.mcu_servo = ppins.setup_pin('pwm', config.get('pin'))
-        self.mcu_servo.setup_max_duration(0.)
-        self.mcu_servo.setup_cycle_time(SERVO_SIGNAL_PERIOD)
-        self.mcu_servo.setup_start_value(initial_pwm, 0.)
-        # Register commands
-        servo_name = config.get_name().split()[1]
-        gcode = self.printer.lookup_object('gcode')
-        gcode.register_mux_command("SET_SERVO", "SERVO", servo_name,
-                                   self.cmd_SET_SERVO,
-                                   desc=self.cmd_SET_SERVO_help)
-    def get_status(self, eventtime):
-        return {'value': self.last_value}
-    def _set_pwm(self, print_time, value):
-        if value == self.last_value:
-            return
-        print_time = max(print_time, self.last_value_time + PIN_MIN_TIME)
-        self.mcu_servo.set_pwm(print_time, value)
-        self.last_value = value
-        self.last_value_time = print_time
-    def _get_pwm_from_angle(self, angle):
-        angle = max(0., min(self.max_angle, angle))
-        width = self.min_width + angle * self.angle_to_width
-        return width * self.width_to_value
-    def _get_pwm_from_pulse_width(self, width):
-        if width:
-            width = max(self.min_width, min(self.max_width, width))
-        return width * self.width_to_value
-    cmd_SET_SERVO_help = "Set servo angle"
-    def cmd_SET_SERVO(self, gcmd):
-        print_time = self.printer.lookup_object('toolhead').get_last_move_time()
-        width = gcmd.get_float('WIDTH', None)
-        if width is not None:
-            self._set_pwm(print_time, self._get_pwm_from_pulse_width(width))
-        else:
-            angle = gcmd.get_float('ANGLE')
-            self._set_pwm(print_time, self._get_pwm_from_angle(angle))
-
-def load_config_prefix(config):
-    return PrinterServo(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/shaper_calibrate.py crealityShit/klippy/extras/shaper_calibrate.py
--- klipperStock/klippy/extras/shaper_calibrate.py	2024-01-14 23:01:59.477788447 -0600
+++ crealityShit/klippy/extras/shaper_calibrate.py	2024-01-14 23:02:21.682060611 -0600
@@ -3,7 +3,9 @@
 # Copyright (C) 2020  Dmitry Butyugin <dmbutyugin@google.com>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
-import collections, importlib, logging, math, multiprocessing, traceback
+import collections, importlib, logging, math, multiprocessing, traceback, os
+import time, subprocess, shlex
+from multiprocessing import shared_memory
 shaper_defs = importlib.import_module('.shaper_defs', 'extras')
 
 MIN_FREQ = 5.
@@ -19,6 +21,27 @@
 # Frequency response calculation and shaper auto-tuning
 ######################################################################
 
+def exec_cmd(conn, method):
+    try:
+        val = os.nice(10)
+    except:
+        pass
+
+    try:
+        process = subprocess.Popen(shlex.split(method), stdout=subprocess.PIPE)
+        output = process.communicate()[0]
+        retcode = process.poll()
+    except:
+        retcode = -1
+        conn.send((True, retcode))
+        conn.close()
+        return
+    if retcode is 0:
+        conn.send((False, retcode))
+    else:
+        conn.send((True, retcode))
+    conn.close()
+
 class CalibrationData:
     def __init__(self, freq_bins, psd_sum, psd_x, psd_y, psd_z):
         self.freq_bins = freq_bins
@@ -61,6 +84,17 @@
     def __init__(self, printer):
         self.printer = printer
         self.error = printer.command_error if printer else Exception
+        self.autotune_shapers = ['zv', 'mzv', 'ei', '2hump_ei', '3hump_ei']
+        configfile = self.printer.lookup_object('configfile')
+        gcode_macro_path = '/usr/data/printer_data/config/gcode_macro.cfg'
+        gconfig = None
+        try:
+            gconfig = configfile.read_config(gcode_macro_path)
+            if gconfig and gconfig.has_section('gcode_macro AUTOTUNE_SHAPERS'):
+                AUTOTUNE_SHAPERS = gconfig.getsection('gcode_macro AUTOTUNE_SHAPERS')
+                self.autotune_shapers = list(map(lambda x: x.replace("'", "") , AUTOTUNE_SHAPERS.getlist('variable_autotune_shapers', ['zv', 'mzv', 'ei', '2hump_ei', '3hump_ei'])))
+        except Exception as err:
+            logging.error("gcode_macro_path: %s, configfile.read_config error:%s" % (gcode_macro_path, err))
         try:
             self.numpy = importlib.import_module('numpy')
         except ImportError:
@@ -75,6 +109,14 @@
         import queuelogger
         parent_conn, child_conn = multiprocessing.Pipe()
         def wrapper():
+            try:
+                gcode = self.printer.lookup_object("gcode")
+                gcode.respond_info("current nice: %d" % os.nice(0), log=False)
+                val = os.nice(10)
+                gcode.respond_info("process id: %d, current nice: %d" % (os.getpid(), val), log=False)
+            except:
+                gcode.respond_info("nice process failed", log=False)
+                pass
             queuelogger.clear_bg_logging()
             try:
                 res = method(*args)
@@ -100,7 +142,7 @@
         # Return results
         is_err, res = parent_conn.recv()
         if is_err:
-            raise self.error("Error in remote calculation: %s" % (res,))
+            raise self.error("""{"code": "key312", "msg": "Error in remote calculation: %s", "values":["%s"]}""" % (res,res))
         calc_proc.join()
         parent_conn.close()
         return res
@@ -177,7 +219,77 @@
                 self.calc_freq_response, (data,))
         if calibration_data is None:
             raise self.error(
-                    "Internal error processing accelerometer data %s" % (data,))
+                    """{"code": "key313", "msg": "Internal error processing accelerometer data %s", "values":["%s"]}""" % (data,data))
+        calibration_data.set_numpy(self.numpy)
+        return calibration_data
+
+    def lowmem_background_process_exec(self, method):
+        if self.printer is None:
+            return None
+
+        ctx = multiprocessing.get_context('spawn')
+        parent_conn, child_conn = multiprocessing.Pipe()
+
+        # Start a process to perform the calculation
+        calc_proc = ctx.Process(target=exec_cmd, args=(child_conn, method))
+        calc_proc.daemon = True
+        calc_proc.start()
+        # Wait for the process to finish
+        reactor = self.printer.get_reactor()
+        gcode = self.printer.lookup_object("gcode")
+        eventtime = last_report_time = reactor.monotonic()
+        while calc_proc.is_alive():
+            if eventtime > last_report_time + 5.:
+                last_report_time = eventtime
+                gcode.respond_info("Wait for calculations..")
+            eventtime = reactor.pause(eventtime + .1)
+        # Return results
+        is_err, res = parent_conn.recv()
+        if is_err:
+            raise self.error("""{"code": "key312", "msg": "Error in remote calculation: %s", "values":["%s"]}""" % (res,res))
+        calc_proc.join()
+        parent_conn.close()
+        return res
+
+    def copy_samples_to_shared_memory(self, data):
+        data.get_samples_to_shared_mem()
+
+    def read_results_from_shared_memory(self, name):
+        gcode = self.printer.lookup_object("gcode")
+        try:
+            shm = shared_memory.SharedMemory(name)
+        except:
+            gcode.respond_info("open shared memory %s fail!" % (name))
+            return None
+
+        np = self.numpy
+        array = np.ndarray((shm.size // 8, ), dtype = np.float64, buffer = shm.buf, offset = 0)
+        shm.unlink()
+
+        return array.copy()
+
+    def lowmem_process_accelerometer_data(self, data):
+        gcode = self.printer.lookup_object("gcode")
+
+        self.copy_samples_to_shared_memory(data)
+
+        # call c++ program and return result by shared memory
+        ret = self.lowmem_background_process_exec("/usr/bin/calc_psd")
+        gcode.respond_info("calc_freq_response return (%d)" % (ret))
+
+        if ret is 0:
+            fx = self.read_results_from_shared_memory("psm_freq")
+            px = self.read_results_from_shared_memory("psm_px")
+            py = self.read_results_from_shared_memory("psm_py")
+            pz = self.read_results_from_shared_memory("psm_pz")
+
+            calibration_data = CalibrationData(fx, px+py+pz, px, py, pz)
+        else:
+            calibration_data = None
+
+        if calibration_data is None:
+            raise self.error(
+                    """{"code": "key313", "msg": "Internal error processing accelerometer data %s", "values":["%s"]}""" % (data,data))
         calibration_data.set_numpy(self.numpy)
         return calibration_data
 
@@ -304,7 +416,8 @@
         best_shaper = None
         all_shapers = []
         for shaper_cfg in shaper_defs.INPUT_SHAPERS:
-            if shaper_cfg.name not in AUTOTUNE_SHAPERS:
+            # if shaper_cfg.name not in AUTOTUNE_SHAPERS:
+            if shaper_cfg.name not in self.autotune_shapers:
                 continue
             shaper = self.background_process_exec(self.fit_shaper, (
                 shaper_cfg, calibration_data, max_smoothing))
@@ -357,4 +470,4 @@
                             csvfile.write(",%.3f" % (shaper.vals[i],))
                     csvfile.write("\n")
         except IOError as e:
-            raise self.error("Error writing to file '%s': %s", output, str(e))
+            raise self.error({"code": "key314", "msg": "Error writing to file '%s': %s", "values":["%s", "%s"]}, output, str(e), output, str(e))
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/skew_correction.py crealityShit/klippy/extras/skew_correction.py
--- klipperStock/klippy/extras/skew_correction.py	2024-01-14 23:01:59.449788103 -0600
+++ crealityShit/klippy/extras/skew_correction.py	2024-01-14 23:02:21.646060169 -0600
@@ -109,8 +109,8 @@
                         raise Exception
                 except Exception:
                     raise gcmd.error(
-                        "skew_correction: improperly formatted entry for "
-                        "plane [%s]\n%s" % (plane, gcmd.get_commandline()))
+                        """{"code": "key315", "msg": "skew_correction: improperly formatted entry for plane [%s]\n%s", "values":["%s", "%s"]}""" % (
+                            plane, gcmd.get_commandline(), plane, gcmd.get_commandline()))
                 factor = plane.lower() + '_factor'
                 setattr(self, factor, calc_skew_factor(*lengths))
     cmd_SKEW_PROFILE_help = "Profile management for skew_correction"
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/spi_temperature.py crealityShit/klippy/extras/spi_temperature.py
--- klipperStock/klippy/extras/spi_temperature.py	2024-01-14 23:01:59.469788348 -0600
+++ crealityShit/klippy/extras/spi_temperature.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,355 +0,0 @@
-# Support for common SPI based thermocouple and RTD temperature sensors
-#
-# Copyright (C) 2018  Petri Honkala <cruwaller@gmail.com>
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import math, logging
-from . import bus
-
-
-######################################################################
-# SensorBase
-######################################################################
-
-REPORT_TIME = 0.300
-MAX_INVALID_COUNT = 3
-
-class SensorBase:
-    def __init__(self, config, chip_type, config_cmd=None, spi_mode=1):
-        self.printer = config.get_printer()
-        self.chip_type = chip_type
-        self._callback = None
-        self.min_sample_value = self.max_sample_value = 0
-        self._report_clock = 0
-        self.spi = bus.MCU_SPI_from_config(
-            config, spi_mode, pin_option="sensor_pin", default_speed=4000000)
-        if config_cmd is not None:
-            self.spi.spi_send(config_cmd)
-        self.mcu = mcu = self.spi.get_mcu()
-        # Reader chip configuration
-        self.oid = oid = mcu.create_oid()
-        mcu.register_response(self._handle_spi_response,
-                              "thermocouple_result", oid)
-        mcu.register_config_callback(self._build_config)
-    def setup_minmax(self, min_temp, max_temp):
-        adc_range = [self.calc_adc(min_temp), self.calc_adc(max_temp)]
-        self.min_sample_value = min(adc_range)
-        self.max_sample_value = max(adc_range)
-    def setup_callback(self, cb):
-        self._callback = cb
-    def get_report_time_delta(self):
-        return REPORT_TIME
-    def _build_config(self):
-        self.mcu.add_config_cmd(
-            "config_thermocouple oid=%u spi_oid=%u thermocouple_type=%s" % (
-                self.oid, self.spi.get_oid(), self.chip_type))
-        clock = self.mcu.get_query_slot(self.oid)
-        self._report_clock = self.mcu.seconds_to_clock(REPORT_TIME)
-        self.mcu.add_config_cmd(
-            "query_thermocouple oid=%u clock=%u rest_ticks=%u"
-            " min_value=%u max_value=%u max_invalid_count=%u" % (
-                self.oid, clock, self._report_clock,
-                self.min_sample_value, self.max_sample_value,
-                MAX_INVALID_COUNT), is_init=True)
-    def _handle_spi_response(self, params):
-        if params['fault']:
-            self.handle_fault(params['value'], params['fault'])
-            return
-        temp = self.calc_temp(params['value'])
-        next_clock      = self.mcu.clock32_to_clock64(params['next_clock'])
-        last_read_clock = next_clock - self._report_clock
-        last_read_time  = self.mcu.clock_to_print_time(last_read_clock)
-        self._callback(last_read_time, temp)
-    def report_fault(self, msg):
-        logging.warn(msg)
-
-
-######################################################################
-# MAX31856 thermocouple
-######################################################################
-
-MAX31856_CR0_REG           = 0x00
-MAX31856_CR0_AUTOCONVERT   = 0x80
-MAX31856_CR0_1SHOT         = 0x40
-MAX31856_CR0_OCFAULT1      = 0x20
-MAX31856_CR0_OCFAULT0      = 0x10
-MAX31856_CR0_CJ            = 0x08
-MAX31856_CR0_FAULT         = 0x04
-MAX31856_CR0_FAULTCLR      = 0x02
-MAX31856_CR0_FILT50HZ      = 0x01
-MAX31856_CR0_FILT60HZ      = 0x00
-
-MAX31856_CR1_REG           = 0x01
-MAX31856_CR1_AVGSEL1       = 0x00
-MAX31856_CR1_AVGSEL2       = 0x10
-MAX31856_CR1_AVGSEL4       = 0x20
-MAX31856_CR1_AVGSEL8       = 0x30
-MAX31856_CR1_AVGSEL16      = 0x70
-
-MAX31856_MASK_REG                          = 0x02
-MAX31856_MASK_COLD_JUNCTION_HIGH_FAULT     = 0x20
-MAX31856_MASK_COLD_JUNCTION_LOW_FAULT      = 0x10
-MAX31856_MASK_THERMOCOUPLE_HIGH_FAULT      = 0x08
-MAX31856_MASK_THERMOCOUPLE_LOW_FAULT       = 0x04
-MAX31856_MASK_VOLTAGE_UNDER_OVER_FAULT     = 0x02
-MAX31856_MASK_THERMOCOUPLE_OPEN_FAULT      = 0x01
-
-MAX31856_CJHF_REG          = 0x03
-MAX31856_CJLF_REG          = 0x04
-MAX31856_LTHFTH_REG        = 0x05
-MAX31856_LTHFTL_REG        = 0x06
-MAX31856_LTLFTH_REG        = 0x07
-MAX31856_LTLFTL_REG        = 0x08
-MAX31856_CJTO_REG          = 0x09
-MAX31856_CJTH_REG          = 0x0A
-MAX31856_CJTL_REG          = 0x0B
-MAX31856_LTCBH_REG         = 0x0C
-MAX31856_LTCBM_REG         = 0x0D
-MAX31856_LTCBL_REG         = 0x0E
-
-MAX31856_SR_REG            = 0x0F
-MAX31856_FAULT_CJRANGE     = 0x80  # Cold Junction out of range
-MAX31856_FAULT_TCRANGE     = 0x40  # Thermocouple out of range
-MAX31856_FAULT_CJHIGH      = 0x20  # Cold Junction High
-MAX31856_FAULT_CJLOW       = 0x10  # Cold Junction Low
-MAX31856_FAULT_TCHIGH      = 0x08  # Thermocouple Low
-MAX31856_FAULT_TCLOW       = 0x04  # Thermocouple Low
-MAX31856_FAULT_OVUV        = 0x02  # Under Over Voltage
-MAX31856_FAULT_OPEN        = 0x01
-
-MAX31856_SCALE = 5
-MAX31856_MULT = 0.0078125
-
-class MAX31856(SensorBase):
-    def __init__(self, config):
-        SensorBase.__init__(self, config, "MAX31856",
-                            self.build_spi_init(config))
-    def handle_fault(self, adc, fault):
-        if fault & MAX31856_FAULT_CJRANGE:
-            self.report_fault("Max31856: Cold Junction Range Fault")
-        if fault & MAX31856_FAULT_TCRANGE:
-            self.report_fault("Max31856: Thermocouple Range Fault")
-        if fault & MAX31856_FAULT_CJHIGH:
-            self.report_fault("Max31856: Cold Junction High Fault")
-        if fault & MAX31856_FAULT_CJLOW:
-            self.report_fault("Max31856: Cold Junction Low Fault")
-        if fault & MAX31856_FAULT_TCHIGH:
-            self.report_fault("Max31856: Thermocouple High Fault")
-        if fault & MAX31856_FAULT_TCLOW:
-            self.report_fault("Max31856: Thermocouple Low Fault")
-        if fault & MAX31856_FAULT_OVUV:
-            self.report_fault("Max31856: Over/Under Voltage Fault")
-        if fault & MAX31856_FAULT_OPEN:
-            self.report_fault("Max31856: Thermocouple Open Fault")
-    def calc_temp(self, adc):
-        adc = adc >> MAX31856_SCALE
-        # Fix sign bit:
-        if adc & 0x40000:
-            adc = ((adc & 0x3FFFF) + 1) * -1
-        temp = MAX31856_MULT * adc
-        return temp
-    def calc_adc(self, temp):
-        adc = int( ( temp / MAX31856_MULT ) + 0.5 ) # convert to ADC value
-        adc = max(0, min(0x3FFFF, adc)) << MAX31856_SCALE
-        return adc
-    def build_spi_init(self, config):
-        cmds = []
-        value = MAX31856_CR0_AUTOCONVERT
-        if config.getboolean('tc_use_50Hz_filter', False):
-            value |= MAX31856_CR0_FILT50HZ
-        cmds.append(0x80 + MAX31856_CR0_REG)
-        cmds.append(value)
-
-        types = {
-            "B" : 0b0000,
-            "E" : 0b0001,
-            "J" : 0b0010,
-            "K" : 0b0011,
-            "N" : 0b0100,
-            "R" : 0b0101,
-            "S" : 0b0110,
-            "T" : 0b0111,
-        }
-        value = config.getchoice('tc_type', types, default="K")
-        averages = {
-            1  : MAX31856_CR1_AVGSEL1,
-            2  : MAX31856_CR1_AVGSEL2,
-            4  : MAX31856_CR1_AVGSEL4,
-            8  : MAX31856_CR1_AVGSEL8,
-            16 : MAX31856_CR1_AVGSEL16
-        }
-        value |= config.getchoice('tc_averaging_count', averages, 1)
-        cmds.append(value)
-
-        value = (MAX31856_MASK_VOLTAGE_UNDER_OVER_FAULT |
-                 MAX31856_MASK_THERMOCOUPLE_OPEN_FAULT)
-        cmds.append(value)
-        return cmds
-
-
-######################################################################
-# MAX31855 thermocouple
-######################################################################
-
-MAX31855_SCALE = 18
-MAX31855_MULT = 0.25
-
-class MAX31855(SensorBase):
-    def __init__(self, config):
-        SensorBase.__init__(self, config, "MAX31855", spi_mode=0)
-    def handle_fault(self, adc, fault):
-        if fault & 0x1:
-            self.report_fault("MAX31855 : Open Circuit")
-        if fault & 0x2:
-            self.report_fault("MAX31855 : Short to GND")
-        if fault & 0x4:
-            self.report_fault("MAX31855 : Short to Vcc")
-    def calc_temp(self, adc):
-        adc = adc >> MAX31855_SCALE
-        # Fix sign bit:
-        if adc & 0x2000:
-            adc = ((adc & 0x1FFF) + 1) * -1
-        temp = MAX31855_MULT * adc
-        return temp
-    def calc_adc(self, temp):
-        adc = int( ( temp / MAX31855_MULT ) + 0.5 ) # convert to ADC value
-        adc = max(0, min(0x1FFF, adc)) << MAX31855_SCALE
-        return adc
-
-
-######################################################################
-# MAX6675 thermocouple
-######################################################################
-
-MAX6675_SCALE = 3
-MAX6675_MULT = 0.25
-
-class MAX6675(SensorBase):
-    def __init__(self, config):
-        SensorBase.__init__(self, config, "MAX6675", spi_mode=0)
-    def handle_fault(self, adc, fault):
-        if fault & 0x02:
-            self.report_fault("Max6675 : Device ID error")
-        if fault & 0x04:
-            self.report_fault("Max6675 : Thermocouple Open Fault")
-    def calc_temp(self, adc):
-        adc = adc >> MAX6675_SCALE
-        # Fix sign bit:
-        if adc & 0x2000:
-            adc = ((adc & 0x1FFF) + 1) * -1
-        temp = MAX6675_MULT * adc
-        return temp
-    def calc_adc(self, temp):
-        adc = int( ( temp / MAX6675_MULT ) + 0.5 ) # convert to ADC value
-        adc = max(0, min(0x1FFF, adc)) << MAX6675_SCALE
-        return adc
-
-
-######################################################################
-# MAX31865 (RTD sensor)
-######################################################################
-
-MAX31865_CONFIG_REG            = 0x00
-MAX31865_RTDMSB_REG            = 0x01
-MAX31865_RTDLSB_REG            = 0x02
-MAX31865_HFAULTMSB_REG         = 0x03
-MAX31865_HFAULTLSB_REG         = 0x04
-MAX31865_LFAULTMSB_REG         = 0x05
-MAX31865_LFAULTLSB_REG         = 0x06
-MAX31865_FAULTSTAT_REG         = 0x07
-
-MAX31865_CONFIG_BIAS           = 0x80
-MAX31865_CONFIG_MODEAUTO       = 0x40
-MAX31865_CONFIG_1SHOT          = 0x20
-MAX31865_CONFIG_3WIRE          = 0x10
-MAX31865_CONFIG_FAULTCLEAR     = 0x02
-MAX31865_CONFIG_FILT50HZ       = 0x01
-
-MAX31865_FAULT_HIGHTHRESH      = 0x80
-MAX31865_FAULT_LOWTHRESH       = 0x40
-MAX31865_FAULT_REFINLOW        = 0x20
-MAX31865_FAULT_REFINHIGH       = 0x10
-MAX31865_FAULT_RTDINLOW        = 0x08
-MAX31865_FAULT_OVUV            = 0x04
-
-MAX31865_ADC_MAX = 1<<15
-
-# Callendar-Van Dusen constants for platinum resistance thermometers (RTD)
-CVD_A = 3.9083e-3
-CVD_B = -5.775e-7
-
-class MAX31865(SensorBase):
-    def __init__(self, config):
-        rtd_nominal_r = config.getfloat('rtd_nominal_r', 100., above=0.)
-        rtd_reference_r = config.getfloat('rtd_reference_r', 430., above=0.)
-        adc_to_resist = rtd_reference_r / float(MAX31865_ADC_MAX)
-        self.adc_to_resist_div_nominal = adc_to_resist / rtd_nominal_r
-        self.config_reg = self.build_spi_init(config)
-        SensorBase.__init__(self, config, "MAX31865", self.config_reg)
-    def handle_fault(self, adc, fault):
-        if fault & 0x80:
-            self.report_fault("Max31865 RTD input is disconnected")
-        if fault & 0x40:
-            self.report_fault("Max31865 RTD input is shorted")
-        if fault & 0x20:
-            self.report_fault(
-                "Max31865 VREF- is greater than 0.85 * VBIAS, FORCE- open")
-        if fault & 0x10:
-            self.report_fault(
-                "Max31865 VREF- is less than 0.85 * VBIAS, FORCE- open")
-        if fault & 0x08:
-            self.report_fault(
-                "Max31865 VRTD- is less than 0.85 * VBIAS, FORCE- open")
-        if fault & 0x04:
-            self.report_fault("Max31865 Overvoltage or undervoltage fault")
-        if not fault & 0xfc:
-            self.report_fault("Max31865 Unspecified error")
-        # Attempt to clear the fault
-        self.spi.spi_send(self.config_reg)
-    def calc_temp(self, adc):
-        adc = adc >> 1 # remove fault bit
-        R_div_nominal = adc * self.adc_to_resist_div_nominal
-        # Resistance (relative to rtd_nominal_r) is calculated using:
-        #  R_div_nominal = 1. + CVD_A * temp + CVD_B * temp**2
-        # Solve for temp using quadratic equation:
-        #  temp = (-b +- sqrt(b**2 - 4ac)) / 2a
-        discriminant = math.sqrt(CVD_A**2 - 4. * CVD_B * (1. - R_div_nominal))
-        temp = (-CVD_A + discriminant) / (2. * CVD_B)
-        return temp
-    def calc_adc(self, temp):
-        # Calculate relative resistance via Callendar-Van Dusen formula:
-        #  resistance = rtd_nominal_r * (1 + CVD_A * temp + CVD_B * temp**2)
-        R_div_nominal = 1. + CVD_A * temp + CVD_B * temp * temp
-        adc = int(R_div_nominal / self.adc_to_resist_div_nominal + 0.5)
-        adc = max(0, min(MAX31865_ADC_MAX, adc))
-        adc = adc << 1 # Add fault bit
-        return adc
-    def build_spi_init(self, config):
-        value = (MAX31865_CONFIG_BIAS |
-                 MAX31865_CONFIG_MODEAUTO |
-                 MAX31865_CONFIG_FAULTCLEAR)
-        if config.getboolean('rtd_use_50Hz_filter', False):
-            value |= MAX31865_CONFIG_FILT50HZ
-        if config.getint('rtd_num_of_wires', 2) == 3:
-            value |= MAX31865_CONFIG_3WIRE
-        cmd = 0x80 + MAX31865_CONFIG_REG
-        return [cmd, value]
-
-
-######################################################################
-# Sensor registration
-######################################################################
-
-Sensors = {
-    "MAX6675": MAX6675,
-    "MAX31855": MAX31855,
-    "MAX31856": MAX31856,
-    "MAX31865": MAX31865,
-}
-
-def load_config(config):
-    # Register sensors
-    pheaters = config.get_printer().load_object(config, "heaters")
-    for name, klass in Sensors.items():
-        pheaters.add_sensor_factory(name, klass)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/statistics.py crealityShit/klippy/extras/statistics.py
--- klipperStock/klippy/extras/statistics.py	2024-01-14 23:01:59.489788594 -0600
+++ crealityShit/klippy/extras/statistics.py	2024-01-14 23:02:21.702060856 -0600
@@ -67,7 +67,7 @@
         if max([s[0] for s in stats]):
             logging.info("Stats %.1f: %s", eventtime,
                          ' '.join([s[1] for s in stats]))
-        return eventtime + 1.
+        return eventtime + 3.
 
 def load_config(config):
     config.get_printer().add_object('system_stats', PrinterSysStats(config))
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/sx1509.py crealityShit/klippy/extras/sx1509.py
--- klipperStock/klippy/extras/sx1509.py	2024-01-14 23:01:59.469788348 -0600
+++ crealityShit/klippy/extras/sx1509.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,201 +0,0 @@
-# SX1509 Extra
-#
-# Copyright (C) 2018  Florian Heilmann <Florian.Heilmann@gmx.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import pins
-from . import bus
-
-# Word registers
-REG_RESET = 0x7D
-REG_CLOCK = 0x1E
-REG_MISC = 0x1F
-REG_DIR = 0x0E
-REG_DATA = 0x10
-REG_PULLUP = 0x06
-REG_PULLDOWN = 0x08
-REG_INPUT_DISABLE = 0x00
-REG_ANALOG_DRIVER_ENABLE = 0x20
-
-
-# Byte registers
-REG_I_ON = [0x2A, 0x2D, 0x30, 0x33, 0x36, 0x3B, 0x40, 0x45,
-            0x4A, 0x4D, 0x50, 0x53, 0x56, 0x5B, 0x5F, 0x65]
-class SX1509(object):
-    def __init__(self, config):
-        self._printer = config.get_printer()
-        self._name = config.get_name().split()[1]
-        self._i2c = bus.MCU_I2C_from_config(config, default_speed=400000)
-        self._ppins = self._printer.lookup_object("pins")
-        self._ppins.register_chip("sx1509_" + self._name, self)
-        self._mcu = self._i2c.get_mcu()
-        self._mcu.register_config_callback(self._build_config)
-        self._oid = self._i2c.get_oid()
-        self._last_clock = 0
-        # Set up registers default values
-        self.reg_dict = {REG_DIR : 0xFFFF, REG_DATA : 0,
-                         REG_PULLUP : 0, REG_PULLDOWN : 0,
-                         REG_INPUT_DISABLE : 0, REG_ANALOG_DRIVER_ENABLE : 0}
-        self.reg_i_on_dict = {reg : 0 for reg in REG_I_ON}
-    def _build_config(self):
-        # Reset the chip
-        self._mcu.add_config_cmd("i2c_write oid=%d data=%02x%02x" % (
-            self._oid, REG_RESET, 0x12))
-        self._mcu.add_config_cmd("i2c_write oid=%d data=%02x%02x" % (
-            self._oid, REG_RESET, 0x34))
-        # Enable Oscillator
-        self._mcu.add_config_cmd("i2c_modify_bits oid=%d reg=%02x"
-                                 " clear_set_bits=%02x%02x" % (
-                                     self._oid, REG_CLOCK, 0, (1 << 6)))
-        # Setup Clock Divider
-        self._mcu.add_config_cmd("i2c_modify_bits oid=%d reg=%02x"
-                                 " clear_set_bits=%02x%02x" % (
-                                     self._oid, REG_MISC, 0, (1 << 4)))
-        # Transfer all regs with their initial cached state
-        for _reg, _data in self.reg_dict.items():
-            self._mcu.add_config_cmd("i2c_write oid=%d data=%02x%04x" % (
-                self._oid, _reg, _data), is_init=True)
-    def setup_pin(self, pin_type, pin_params):
-        if pin_type == 'digital_out' and pin_params['pin'][0:4] == "PIN_":
-            return SX1509_digital_out(self, pin_params)
-        elif pin_type == 'pwm' and pin_params['pin'][0:4] == "PIN_":
-            return SX1509_pwm(self, pin_params)
-        raise pins.error("Wrong pin or incompatible type: %s with type %s! " % (
-            pin_params['pin'][0:4], pin_type))
-    def get_mcu(self):
-        return self._mcu
-    def get_oid(self):
-        return self._oid
-    def clear_bits_in_register(self, reg, bitmask):
-        if reg in self.reg_dict:
-            self.reg_dict[reg] &= ~(bitmask)
-        elif reg in self.reg_i_on_dict:
-            self.reg_i_on_dict[reg] &= ~(bitmask)
-    def set_bits_in_register(self, reg, bitmask):
-        if reg in self.reg_dict:
-            self.reg_dict[reg] |= bitmask
-        elif reg in self.reg_i_on_dict:
-            self.reg_i_on_dict[reg] |= bitmask
-    def set_register(self, reg, value):
-        if reg in self.reg_dict:
-            self.reg_dict[reg] = value
-        elif reg in self.reg_i_on_dict:
-            self.reg_i_on_dict[reg] = value
-    def send_register(self, reg, print_time):
-        data = [reg & 0xFF]
-        if reg in self.reg_dict:
-            # Word
-            data += [(self.reg_dict[reg] >> 8) & 0xFF,
-                     self.reg_dict[reg] & 0xFF]
-        elif reg in self.reg_i_on_dict:
-            # Byte
-            data += [self.reg_i_on_dict[reg] & 0xFF]
-        clock = self._mcu.print_time_to_clock(print_time)
-        self._i2c.i2c_write(data, minclock=self._last_clock, reqclock=clock)
-        self._last_clock = clock
-
-class SX1509_digital_out(object):
-    def __init__(self, sx1509, pin_params):
-        self._sx1509 = sx1509
-        self._mcu = sx1509.get_mcu()
-        self._sxpin = int(pin_params['pin'].split('_')[1])
-        self._bitmask = 1 << self._sxpin
-        self._pin = pin_params['pin']
-        self._invert = pin_params['invert']
-        self._mcu.register_config_callback(self._build_config)
-        self._start_value = self._shutdown_value = self._invert
-        self._is_static = False
-        self._max_duration = 2.
-        self._set_cmd = self._clear_cmd = None
-        # Set direction to output
-        self._sx1509.clear_bits_in_register(REG_DIR, self._bitmask)
-    def _build_config(self):
-        if self._max_duration:
-            raise pins.error("SX1509 pins are not suitable for heaters")
-    def get_mcu(self):
-        return self._mcu
-    def setup_max_duration(self, max_duration):
-        self._max_duration = max_duration
-    def setup_start_value(self, start_value, shutdown_value, is_static=False):
-        if is_static and start_value != shutdown_value:
-            raise pins.error("Static pin can not have shutdown value")
-        self._start_value = (not not start_value) ^ self._invert
-        self._shutdown_value = self._invert
-        self._is_static = is_static
-        # We need to set the start value here so the register is
-        # updated before the SX1509 class writes it.
-        if self._start_value:
-            self._sx1509.set_bits_in_register(REG_DATA, self._bitmask)
-        else:
-            self._sx1509.clear_bits_in_register(REG_DATA, self._bitmask)
-    def set_digital(self, print_time, value):
-        if int(value) ^ self._invert:
-            self._sx1509.set_bits_in_register(REG_DATA, self._bitmask)
-        else:
-            self._sx1509.clear_bits_in_register(REG_DATA, self._bitmask)
-        self._sx1509.send_register(REG_DATA, print_time)
-    def set_pwm(self, print_time, value, cycle_time=None):
-        self.set_digital(print_time, value >= 0.5)
-
-class SX1509_pwm(object):
-    def __init__(self, sx1509, pin_params):
-        self._sx1509 = sx1509
-        self._mcu = sx1509.get_mcu()
-        self._sxpin = int(pin_params['pin'].split('_')[1])
-        self._bitmask = 1 << self._sxpin
-        self._i_on_reg = REG_I_ON[self._sxpin]
-        self._pin = pin_params['pin']
-        self._invert = pin_params['invert']
-        self._mcu.register_config_callback(self._build_config)
-        self._start_value = self._shutdown_value = float(self._invert)
-        self._is_static = False
-        self._max_duration = 2.
-        self._hardware_pwm = False
-        self._pwm_max = 0.
-        self._set_cmd = None
-        self._cycle_time = 0.
-        # Set required registers
-        self._sx1509.set_bits_in_register(REG_INPUT_DISABLE, self._bitmask)
-        self._sx1509.clear_bits_in_register(REG_PULLUP, self._bitmask)
-        self._sx1509.clear_bits_in_register(REG_DIR, self._bitmask)
-        self._sx1509.set_bits_in_register(REG_ANALOG_DRIVER_ENABLE,
-                                          self._bitmask)
-        self._sx1509.clear_bits_in_register(REG_DATA, self._bitmask)
-    def _build_config(self):
-        if not self._hardware_pwm:
-            raise pins.error("SX1509_pwm must have hardware_pwm enabled")
-        if self._max_duration:
-            raise pins.error("SX1509 pins are not suitable for heaters")
-        # Send initial value
-        self._sx1509.set_register(self._i_on_reg,
-                                  ~int(255 * self._start_value) & 0xFF)
-        self._mcu.add_config_cmd("i2c_write oid=%d data=%02x%02x" % (
-            self._sx1509.get_oid(),
-            self._i_on_reg,
-            self._sx1509.reg_i_on_dict[self._i_on_reg]
-            ),
-                                 is_init=True)
-    def get_mcu(self):
-        return self._mcu
-    def setup_max_duration(self, max_duration):
-        self._max_duration = max_duration
-    def setup_cycle_time(self, cycle_time, hardware_pwm=False):
-        self._cycle_time = cycle_time
-        self._hardware_pwm = hardware_pwm
-    def setup_start_value(self, start_value, shutdown_value, is_static=False):
-        if is_static and start_value != shutdown_value:
-            raise pins.error("Static pin can not have shutdown value")
-        if self._invert:
-            start_value = 1. - start_value
-            shutdown_value = 1. - shutdown_value
-        self._start_value = max(0., min(1., start_value))
-        self._shutdown_value = max(0., min(1., shutdown_value))
-        self._is_static = is_static
-    def set_pwm(self, print_time, value, cycle_time=None):
-        self._sx1509.set_register(self._i_on_reg, ~int(255 * value)
-                                  if not self._invert
-                                  else int(255 * value) & 0xFF)
-        self._sx1509.send_register(self._i_on_reg, print_time)
-
-def load_config_prefix(config):
-    return SX1509(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/temperature_fan.py crealityShit/klippy/extras/temperature_fan.py
--- klipperStock/klippy/extras/temperature_fan.py	2024-01-14 23:01:59.477788447 -0600
+++ crealityShit/klippy/extras/temperature_fan.py	2024-01-14 23:02:21.678060562 -0600
@@ -92,8 +92,8 @@
     def set_temp(self, degrees):
         if degrees and (degrees < self.min_temp or degrees > self.max_temp):
             raise self.printer.command_error(
-                "Requested temperature (%.1f) out of range (%.1f:%.1f)"
-                % (degrees, self.min_temp, self.max_temp))
+                """{"code":"key339", "msg":"TemperatureFan %s Requested temperature (%.1f) out of range (%.1f:%.1f)", "values":["%s", %.1f, %.1f, %.1f]}"""
+                % (self.name, degrees, self.min_temp, self.max_temp, self.name, degrees, self.min_temp, self.max_temp))
         self.target_temp = degrees
 
     def set_min_speed(self, speed):
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/temperature_host.py crealityShit/klippy/extras/temperature_host.py
--- klipperStock/klippy/extras/temperature_host.py	2024-01-14 23:01:59.445788055 -0600
+++ crealityShit/klippy/extras/temperature_host.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,80 +0,0 @@
-# Support for Raspberry Pi temperature sensor
-#
-# Copyright (C) 2020  Al Crate <al3ph@users.noreply.github.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-import logging
-
-HOST_REPORT_TIME = 1.0
-RPI_PROC_TEMP_FILE = "/sys/class/thermal/thermal_zone0/temp"
-
-class Temperature_HOST:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.reactor = self.printer.get_reactor()
-        self.name = config.get_name().split()[-1]
-        self.path = config.get("sensor_path", RPI_PROC_TEMP_FILE)
-
-        self.temp = self.min_temp = self.max_temp = 0.0
-
-        self.printer.add_object("temperature_host " + self.name, self)
-        if self.printer.get_start_args().get('debugoutput') is not None:
-            return
-        self.sample_timer = self.reactor.register_timer(
-            self._sample_pi_temperature)
-        try:
-            self.file_handle = open(self.path, "r")
-        except:
-            raise config.error("Unable to open temperature file '%s'"
-                               % (self.path,))
-
-        self.printer.register_event_handler("klippy:connect",
-                                            self.handle_connect)
-
-    def handle_connect(self):
-        self.reactor.update_timer(self.sample_timer, self.reactor.NOW)
-
-    def setup_minmax(self, min_temp, max_temp):
-        self.min_temp = min_temp
-        self.max_temp = max_temp
-
-    def setup_callback(self, cb):
-        self._callback = cb
-
-    def get_report_time_delta(self):
-        return HOST_REPORT_TIME
-
-    def _sample_pi_temperature(self, eventtime):
-        try:
-            self.file_handle.seek(0)
-            self.temp = float(self.file_handle.read())/1000.0
-        except Exception:
-            logging.exception("temperature_host: Error reading data")
-            self.temp = 0.0
-            return self.reactor.NEVER
-
-        if self.temp < self.min_temp:
-            self.printer.invoke_shutdown(
-                "HOST temperature %0.1f below minimum temperature of %0.1f."
-                % (self.temp, self.min_temp,))
-        if self.temp > self.max_temp:
-            self.printer.invoke_shutdown(
-                "HOST temperature %0.1f above maximum temperature of %0.1f."
-                % (self.temp, self.max_temp,))
-
-        mcu = self.printer.lookup_object('mcu')
-        measured_time = self.reactor.monotonic()
-        self._callback(mcu.estimated_print_time(measured_time), self.temp)
-        return measured_time + HOST_REPORT_TIME
-
-    def get_status(self, eventtime):
-        return {
-            'temperature': round(self.temp, 2),
-        }
-
-
-def load_config(config):
-    # Register sensor
-    pheaters = config.get_printer().load_object(config, "heaters")
-    pheaters.add_sensor_factory("temperature_host", Temperature_HOST)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/temperature_mcu.py crealityShit/klippy/extras/temperature_mcu.py
--- klipperStock/klippy/extras/temperature_mcu.py	2024-01-14 23:01:59.457788201 -0600
+++ crealityShit/klippy/extras/temperature_mcu.py	2024-01-14 23:02:21.658060316 -0600
@@ -76,6 +76,7 @@
             ('stm32l4', self.config_stm32g0),
             ('stm32h723', self.config_stm32h723),
             ('stm32h7', self.config_stm32h7),
+            ('gd32f303xe', self.config_gd32f303xe),
             ('', self.config_unknown)]
         for name, func in cfg_funcs:
             if self.mcu_type.startswith(name):
@@ -157,6 +158,9 @@
         cal_adc_110 = self.read16(0x1FF1E840) / 65535.
         self.slope = (110. - 30.) / (cal_adc_110 - cal_adc_30)
         self.base_temperature = self.calc_base(30., cal_adc_30)
+    def config_gd32f303xe(self):
+        self.slope = 3.3 / -.004100
+        self.base_temperature = self.calc_base(25., 1.45 / 3.3)
     def read16(self, addr):
         params = self.debug_read_cmd.send([1, addr])
         return params['val']
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/temperature_sensors.cfg crealityShit/klippy/extras/temperature_sensors.cfg
--- klipperStock/klippy/extras/temperature_sensors.cfg	2024-01-14 23:01:59.489788594 -0600
+++ crealityShit/klippy/extras/temperature_sensors.cfg	2024-01-14 23:02:21.702060856 -0600
@@ -10,22 +10,22 @@
 [adc_temperature]
 
 # Load "BME280" sensor
-[bme280]
+# [bme280]
 
 # Load "DS18B20" sensor
-[ds18b20]
+# [ds18b20]
 
 # Load "SI7013", "SI7020", "SI7021", "SHT21", and "HTU21D" sensors
-[htu21d]
+# [htu21d]
 
 # Load "LM75" sensor
-[lm75]
+# [lm75]
 
 # Load "MAX6675", "MAX31855", "MAX31856", and "MAX31865" sensors
-[spi_temperature]
+# [spi_temperature]
 
 # Load "temperature_host" sensor
-[temperature_host]
+# [temperature_host]
 
 # Load "temperature_mcu" sensor
 [temperature_mcu]
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/tmc2660.py crealityShit/klippy/extras/tmc2660.py
--- klipperStock/klippy/extras/tmc2660.py	2024-01-14 23:01:59.485788546 -0600
+++ crealityShit/klippy/extras/tmc2660.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,274 +0,0 @@
-# TMC2660 configuration
-#
-# Copyright (C) 2018-2019  Florian Heilmann <Florian.Heilmann@gmx.net>
-# Copyright (C) 2019-2021  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import math, logging
-from . import bus, tmc, tmc2130
-
-Registers = {
-    "DRVCONF": 0xE, "SGCSCONF": 0xC, "SMARTEN": 0xA,
-    "CHOPCONF": 0x8, "DRVCTRL": 0x0
-}
-
-ReadRegisters = [ "READRSP@RDSEL0", "READRSP@RDSEL1", "READRSP@RDSEL2" ]
-
-Fields = {}
-
-Fields["DRVCTRL"] = {
-    "mres": 0x0f,
-    "dedge": 0x01 << 8,
-    "intpol": 0x01 << 9,
-}
-
-Fields["CHOPCONF"] = {
-    "toff": 0x0f,
-    "hstrt": 0x7 << 4,
-    "hend": 0x0f << 7,
-    "hdec": 0x03 << 11,
-    "rndtf": 0x01 << 13,
-    "chm": 0x01 << 14,
-    "tbl": 0x03 << 15
-}
-
-Fields["SMARTEN"] = {
-    "semin" : 0x0f,
-    "seup": 0x03 << 5,
-    "semax": 0x0f << 8,
-    "sedn": 0x03 << 13,
-    "seimin": 0x01 << 15
-}
-
-Fields["SGCSCONF"] = {
-    "cs": 0x1f,
-    "sgt": 0x7F << 8,
-    "sfilt": 0x01 << 16
-}
-
-Fields["DRVCONF"] = {
-    "rdsel": 0x03 << 4,
-    "vsense": 0x01 << 6,
-    "sdoff": 0x01 << 7,
-    "ts2g": 0x03 << 8,
-    "diss2g": 0x01 << 10,
-    "slpl": 0x03 << 12,
-    "slph": 0x03 << 14,
-    "tst": 0x01 << 16
-}
-
-Fields["READRSP@RDSEL0"] = {
-    "stallguard": 0x01 << 4,
-    "ot": 0x01 << 5,
-    "otpw": 0x01 << 6,
-    "s2ga": 0x01 << 7,
-    "s2gb": 0x01 << 8,
-    "ola": 0x01 << 9,
-    "olb": 0x01 << 10,
-    "stst": 0x01 << 11,
-    "mstep": 0x3ff << 14
-}
-
-Fields["READRSP@RDSEL1"] = {
-    "stallguard": 0x01 << 4,
-    "ot": 0x01 << 5,
-    "otpw": 0x01 << 6,
-    "s2ga": 0x01 << 7,
-    "s2gb": 0x01 << 8,
-    "ola": 0x01 << 9,
-    "olb": 0x01 << 10,
-    "stst": 0x01 << 11,
-    "sg_result": 0x3ff << 14
-}
-
-Fields["READRSP@RDSEL2"] = {
-    "stallguard": 0x01 << 4,
-    "ot": 0x01 << 5,
-    "otpw": 0x01 << 6,
-    "s2ga": 0x01 << 7,
-    "s2gb": 0x01 << 8,
-    "ola": 0x01 << 9,
-    "olb": 0x01 << 10,
-    "stst": 0x01 << 11,
-    "se": 0x1f << 14,
-    "sg_result@rdsel2": 0x1f << 19
-}
-
-SignedFields = ["sgt"]
-
-FieldFormatters = dict(tmc2130.FieldFormatters)
-FieldFormatters.update({
-    "chm": (lambda v: "1(constant toff)" if v else "0(spreadCycle)"),
-    "vsense": (lambda v: "1(165mV)" if v else "0(305mV)"),
-    "sdoff": (lambda v: "1(Step/Dir disabled!)" if v else ""),
-    "diss2g": (lambda v: "1(Short to GND disabled!)" if v else ""),
-    "se": (lambda v: ("%d" % v) if v else "0(Reset?)"),
-})
-
-
-######################################################################
-# TMC stepper current config helper
-######################################################################
-
-MAX_CURRENT = 2.400
-
-class TMC2660CurrentHelper:
-    def __init__(self, config, mcu_tmc):
-        self.printer = config.get_printer()
-        self.name = config.get_name().split()[-1]
-        self.mcu_tmc = mcu_tmc
-        self.fields = mcu_tmc.get_fields()
-        self.current = config.getfloat('run_current', minval=0.1,
-                                       maxval=MAX_CURRENT)
-        self.sense_resistor = config.getfloat('sense_resistor')
-        vsense, cs = self._calc_current(self.current)
-        self.fields.set_field("cs", cs)
-        self.fields.set_field("vsense", vsense)
-
-        # Register ready/printing handlers
-        self.idle_current_percentage = config.getint(
-            'idle_current_percent', default=100, minval=0, maxval=100)
-        if self.idle_current_percentage < 100:
-            self.printer.register_event_handler("idle_timeout:printing",
-                                                self._handle_printing)
-            self.printer.register_event_handler("idle_timeout:ready",
-                                                self._handle_ready)
-
-    def _calc_current_bits(self, current, vsense):
-        vref = 0.165 if vsense else 0.310
-        sr = self.sense_resistor
-        cs = int(32. * sr * current * math.sqrt(2.) / vref + .5) - 1
-        return max(0, min(31, cs))
-
-    def _calc_current_from_bits(self, cs, vsense):
-        vref = 0.165 if vsense else 0.310
-        return (cs + 1) * vref / (32. * self.sense_resistor * math.sqrt(2.))
-
-    def _calc_current(self, run_current):
-        vsense = True
-        irun = self._calc_current_bits(run_current, True)
-        if irun == 31:
-            cur = self._calc_current_from_bits(irun, True)
-            if cur < run_current:
-                irun2 = self._calc_current_bits(run_current, False)
-                cur2 = self._calc_current_from_bits(irun2, False)
-                if abs(run_current - cur2) < abs(run_current - cur):
-                    vsense = False
-                    irun = irun2
-        return vsense, irun
-
-    def _handle_printing(self, print_time):
-        print_time -= 0.100 # Schedule slightly before deadline
-        self.printer.get_reactor().register_callback(
-            (lambda ev: self._update_current(self.current, print_time)))
-
-    def _handle_ready(self, print_time):
-        current = self.current * float(self.idle_current_percentage) / 100.
-        self.printer.get_reactor().register_callback(
-            (lambda ev: self._update_current(current, print_time)))
-
-    def _update_current(self, current, print_time):
-        vsense, cs = self._calc_current(current)
-        val = self.fields.set_field("cs", cs)
-        self.mcu_tmc.set_register("SGCSCONF", val, print_time)
-        # Only update VSENSE if we need to
-        if vsense != self.fields.get_field("vsense"):
-            val = self.fields.set_field("vsense", vsense)
-            self.mcu_tmc.set_register("DRVCONF", val, print_time)
-
-    def get_current(self):
-        return self.current, None, None, MAX_CURRENT
-
-    def set_current(self, run_current, hold_current, print_time):
-        self.current = run_current
-        self._update_current(run_current, print_time)
-
-
-######################################################################
-# TMC2660 SPI
-######################################################################
-
-# Helper code for working with TMC2660 devices via SPI
-class MCU_TMC2660_SPI:
-    def __init__(self, config, name_to_reg, fields):
-        self.printer = config.get_printer()
-        self.mutex = self.printer.get_reactor().mutex()
-        self.spi = bus.MCU_SPI_from_config(config, 0, default_speed=4000000)
-        self.name_to_reg = name_to_reg
-        self.fields = fields
-    def get_fields(self):
-        return self.fields
-    def get_register(self, reg_name):
-        new_rdsel = ReadRegisters.index(reg_name)
-        reg = self.name_to_reg["DRVCONF"]
-        if self.printer.get_start_args().get('debugoutput') is not None:
-            return 0
-        with self.mutex:
-            old_rdsel = self.fields.get_field("rdsel")
-            val = self.fields.set_field("rdsel", new_rdsel)
-            msg = [((val >> 16) | reg) & 0xff, (val >> 8) & 0xff, val & 0xff]
-            if new_rdsel != old_rdsel:
-                # Must set RDSEL value first
-                self.spi.spi_send(msg)
-            params = self.spi.spi_transfer(msg)
-        pr = bytearray(params['response'])
-        return (pr[0] << 16) | (pr[1] << 8) | pr[2]
-    def set_register(self, reg_name, val, print_time=None):
-        minclock = 0
-        if print_time is not None:
-            minclock = self.spi.get_mcu().print_time_to_clock(print_time)
-        reg = self.name_to_reg[reg_name]
-        msg = [((val >> 16) | reg) & 0xff, (val >> 8) & 0xff, val & 0xff]
-        with self.mutex:
-            self.spi.spi_send(msg, minclock)
-
-
-######################################################################
-# TMC2660 printer object
-######################################################################
-
-class TMC2660:
-    def __init__(self, config):
-        # Setup mcu communication
-        self.fields = tmc.FieldHelper(Fields, SignedFields, FieldFormatters)
-        self.fields.set_field("sdoff", 0) # Access DRVCTRL in step/dir mode
-        self.mcu_tmc = MCU_TMC2660_SPI(config, Registers, self.fields)
-        # Register commands
-        current_helper = TMC2660CurrentHelper(config, self.mcu_tmc)
-        cmdhelper = tmc.TMCCommandHelper(config, self.mcu_tmc, current_helper)
-        cmdhelper.setup_register_dump(ReadRegisters)
-        self.get_phase_offset = cmdhelper.get_phase_offset
-        self.get_status = cmdhelper.get_status
-
-        # CHOPCONF
-        set_config_field = self.fields.set_config_field
-        set_config_field(config, "tbl", 2)
-        set_config_field(config, "rndtf", 0)
-        set_config_field(config, "hdec", 0)
-        set_config_field(config, "chm", 0)
-        set_config_field(config, "hend", 3)
-        set_config_field(config, "hstrt", 3)
-        set_config_field(config, "toff", 4)
-        if not self.fields.get_field("chm"):
-            if (self.fields.get_field("hstrt") +
-                self.fields.get_field("hend")) > 15:
-                raise config.error("driver_HEND + driver_HSTRT must be <= 15")
-        # SMARTEN
-        set_config_field(config, "seimin", 0)
-        set_config_field(config, "sedn", 0)
-        set_config_field(config, "semax", 0)
-        set_config_field(config, "seup", 0)
-        set_config_field(config, "semin", 0)
-
-        # SGSCONF
-        set_config_field(config, "sfilt", 0)
-        set_config_field(config, "sgt", 0)
-
-        # DRVCONF
-        set_config_field(config, "slph", 0)
-        set_config_field(config, "slpl", 0)
-        set_config_field(config, "diss2g", 0)
-        set_config_field(config, "ts2g", 3)
-
-def load_config_prefix(config):
-    return TMC2660(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/tmc5160.py crealityShit/klippy/extras/tmc5160.py
--- klipperStock/klippy/extras/tmc5160.py	2024-01-14 23:01:59.477788447 -0600
+++ crealityShit/klippy/extras/tmc5160.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,362 +0,0 @@
-# TMC5160 configuration
-#
-# Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import math, logging
-from . import bus, tmc, tmc2130
-
-TMC_FREQUENCY=12000000.
-
-Registers = {
-    "GCONF":            0x00,
-    "GSTAT":            0x01,
-    "IFCNT":            0x02,
-    "SLAVECONF":        0x03,
-    "IOIN":             0x04,
-    "X_COMPARE":        0x05,
-    "OTP_READ":         0x07,
-    "FACTORY_CONF":     0x08,
-    "SHORT_CONF":       0x09,
-    "DRV_CONF":         0x0A,
-    "GLOBALSCALER":     0x0B,
-    "OFFSET_READ":      0x0C,
-    "IHOLD_IRUN":       0x10,
-    "TPOWERDOWN":       0x11,
-    "TSTEP":            0x12,
-    "TPWMTHRS":         0x13,
-    "TCOOLTHRS":        0x14,
-    "THIGH":            0x15,
-    "RAMPMODE":         0x20,
-    "XACTUAL":          0x21,
-    "VACTUAL":          0x22,
-    "VSTART":           0x23,
-    "A1":               0x24,
-    "V1":               0x25,
-    "AMAX":             0x26,
-    "VMAX":             0x27,
-    "DMAX":             0x28,
-    "D1":               0x2A,
-    "VSTOP":            0x2B,
-    "TZEROWAIT":        0x2C,
-    "XTARGET":          0x2D,
-    "VDCMIN":           0x33,
-    "SW_MODE":          0x34,
-    "RAMP_STAT":        0x35,
-    "XLATCH":           0x36,
-    "ENCMODE":          0x38,
-    "X_ENC":            0x39,
-    "ENC_CONST":        0x3A,
-    "ENC_STATUS":       0x3B,
-    "ENC_LATCH":        0x3C,
-    "ENC_DEVIATION":    0x3D,
-    "MSLUT0":           0x60,
-    "MSLUT1":           0x61,
-    "MSLUT2":           0x62,
-    "MSLUT3":           0x63,
-    "MSLUT4":           0x64,
-    "MSLUT5":           0x65,
-    "MSLUT6":           0x66,
-    "MSLUT7":           0x67,
-    "MSLUTSEL":         0x68,
-    "MSLUTSTART":       0x69,
-    "MSCNT":            0x6A,
-    "MSCURACT":         0x6B,
-    "CHOPCONF":         0x6C,
-    "COOLCONF":         0x6D,
-    "DCCTRL":           0x6E,
-    "DRV_STATUS":       0x6F,
-    "PWMCONF":          0x70,
-    "PWM_SCALE":        0x71,
-    "PWM_AUTO":         0x72,
-    "LOST_STEPS":       0x73,
-}
-
-ReadRegisters = [
-    "GCONF", "CHOPCONF", "GSTAT", "DRV_STATUS", "FACTORY_CONF", "IOIN",
-    "LOST_STEPS", "MSCNT", "MSCURACT", "OTP_READ", "PWM_SCALE",
-    "PWM_AUTO", "TSTEP"
-]
-
-Fields = {}
-Fields["COOLCONF"] = {
-    "semin":                    0x0F << 0,
-    "seup":                     0x03 << 5,
-    "semax":                    0x0F << 8,
-    "sedn":                     0x03 << 13,
-    "seimin":                   0x01 << 15,
-    "sgt":                      0x7F << 16,
-    "sfilt":                    0x01 << 24
-}
-Fields["CHOPCONF"] = {
-    "toff":                     0x0F << 0,
-    "hstrt":                    0x07 << 4,
-    "hend":                     0x0F << 7,
-    "fd3":                      0x01 << 11,
-    "disfdcc":                  0x01 << 12,
-    "chm":                      0x01 << 14,
-    "tbl":                      0x03 << 15,
-    "vhighfs":                  0x01 << 18,
-    "vhighchm":                 0x01 << 19,
-    "tpfd":                     0x0F << 20, # midrange resonances
-    "mres":                     0x0F << 24,
-    "intpol":                   0x01 << 28,
-    "dedge":                    0x01 << 29,
-    "diss2g":                   0x01 << 30,
-    "diss2vs":                  0x01 << 31
-}
-Fields["DRV_STATUS"] = {
-    "sg_result":                0x3FF << 0,
-    "s2vsa":                    0x01 << 12,
-    "s2vsb":                    0x01 << 13,
-    "stealth":                  0x01 << 14,
-    "fsactive":                 0x01 << 15,
-    "csactual":                 0xFF << 16,
-    "stallguard":               0x01 << 24,
-    "ot":                       0x01 << 25,
-    "otpw":                     0x01 << 26,
-    "s2ga":                     0x01 << 27,
-    "s2gb":                     0x01 << 28,
-    "ola":                      0x01 << 29,
-    "olb":                      0x01 << 30,
-    "stst":                     0x01 << 31
-}
-Fields["FACTORY_CONF"] = {
-    "factory_conf":             0x1F << 0
-}
-Fields["GCONF"] = {
-    "recalibrate":              0x01 << 0,
-    "faststandstill":           0x01 << 1,
-    "en_pwm_mode":              0x01 << 2,
-    "multistep_filt":           0x01 << 3,
-    "shaft":                    0x01 << 4,
-    "diag0_error":              0x01 << 5,
-    "diag0_otpw":               0x01 << 6,
-    "diag0_stall":              0x01 << 7,
-    "diag1_stall":              0x01 << 8,
-    "diag1_index":              0x01 << 9,
-    "diag1_onstate":            0x01 << 10,
-    "diag1_steps_skipped":      0x01 << 11,
-    "diag0_int_pushpull":       0x01 << 12,
-    "diag1_poscomp_pushpull":   0x01 << 13,
-    "small_hysteresis":         0x01 << 14,
-    "stop_enable":              0x01 << 15,
-    "direct_mode":              0x01 << 16,
-    "test_mode":                0x01 << 17
-}
-Fields["GSTAT"] = {
-    "reset":                    0x01 << 0,
-    "drv_err":                  0x01 << 1,
-    "uv_cp":                    0x01 << 2
-}
-Fields["GLOBALSCALER"] = {
-    "globalscaler":             0xFF << 0
-}
-Fields["IHOLD_IRUN"] = {
-    "ihold":                    0x1F << 0,
-    "irun":                     0x1F << 8,
-    "iholddelay":               0x0F << 16
-}
-Fields["IOIN"] = {
-    "refl_step":                0x01 << 0,
-    "refr_dir":                 0x01 << 1,
-    "encb_dcen_cfg4":           0x01 << 2,
-    "enca_dcin_cfg5":           0x01 << 3,
-    "drv_enn":                  0x01 << 4,
-    "enc_n_dco_cfg6":           0x01 << 5,
-    "sd_mode":                  0x01 << 6,
-    "swcomp_in":                0x01 << 7,
-    "version":                  0xFF << 24
-}
-Fields["LOST_STEPS"] = {
-    "lost_steps":               0xfffff << 0
-}
-Fields["MSLUT0"] = { "mslut0": 0xffffffff }
-Fields["MSLUT1"] = { "mslut1": 0xffffffff }
-Fields["MSLUT2"] = { "mslut2": 0xffffffff }
-Fields["MSLUT3"] = { "mslut3": 0xffffffff }
-Fields["MSLUT4"] = { "mslut4": 0xffffffff }
-Fields["MSLUT5"] = { "mslut5": 0xffffffff }
-Fields["MSLUT6"] = { "mslut6": 0xffffffff }
-Fields["MSLUT7"] = { "mslut7": 0xffffffff }
-Fields["MSLUTSEL"] = {
-    "x3":                       0xFF << 24,
-    "x2":                       0xFF << 16,
-    "x1":                       0xFF << 8,
-    "w3":                       0x03 << 6,
-    "w2":                       0x03 << 4,
-    "w1":                       0x03 << 2,
-    "w0":                       0x03 << 0,
-}
-Fields["MSLUTSTART"] = {
-    "start_sin":                0xFF << 0,
-    "start_sin90":              0xFF << 16,
-}
-Fields["MSCNT"] = {
-    "mscnt":                    0x3ff << 0
-}
-Fields["MSCURACT"] = {
-    "cur_a":                    0x1ff << 0,
-    "cur_b":                    0x1ff << 16
-}
-Fields["OTP_READ"] = {
-    "otp_fclktrim":             0x1f << 0,
-    "otp_s2_level":             0x01 << 5,
-    "otp_bbm":                  0x01 << 6,
-    "otp_tbl":                  0x01 << 7
-}
-Fields["PWM_AUTO"] = {
-    "pwm_ofs_auto":             0xff << 0,
-    "pwm_grad_auto":            0xff << 16
-}
-Fields["PWMCONF"] = {
-    "pwm_ofs":                  0xFF << 0,
-    "pwm_grad":                 0xFF << 8,
-    "pwm_freq":                 0x03 << 16,
-    "pwm_autoscale":            0x01 << 18,
-    "pwm_autograd":             0x01 << 19,
-    "freewheel":                0x03 << 20,
-    "pwm_reg":                  0x0F << 24,
-    "pwm_lim":                  0x0F << 28
-}
-Fields["PWM_SCALE"] = {
-    "pwm_scale_sum":            0xff << 0,
-    "pwm_scale_auto":           0x1ff << 16
-}
-Fields["TPOWERDOWN"] = {
-    "tpowerdown":               0xff << 0
-}
-Fields["TPWMTHRS"] = {
-    "tpwmthrs":                 0xfffff << 0
-}
-Fields["TCOOLTHRS"] = {
-    "tcoolthrs":                0xfffff << 0
-}
-Fields["TSTEP"] = {
-    "tstep":                    0xfffff << 0
-}
-
-SignedFields = ["cur_a", "cur_b", "sgt", "xactual", "vactual", "pwm_scale_auto"]
-
-FieldFormatters = dict(tmc2130.FieldFormatters)
-
-
-######################################################################
-# TMC stepper current config helper
-######################################################################
-
-VREF = 0.325
-MAX_CURRENT = 3.000
-
-class TMC5160CurrentHelper:
-    def __init__(self, config, mcu_tmc):
-        self.printer = config.get_printer()
-        self.name = config.get_name().split()[-1]
-        self.mcu_tmc = mcu_tmc
-        self.fields = mcu_tmc.get_fields()
-        run_current = config.getfloat('run_current',
-                                      above=0., maxval=MAX_CURRENT)
-        hold_current = config.getfloat('hold_current', MAX_CURRENT,
-                                       above=0., maxval=MAX_CURRENT)
-        self.req_hold_current = hold_current
-        self.sense_resistor = config.getfloat('sense_resistor', 0.075, above=0.)
-        self._set_globalscaler(run_current)
-        irun, ihold = self._calc_current(run_current, hold_current)
-        self.fields.set_field("ihold", ihold)
-        self.fields.set_field("irun", irun)
-    def _set_globalscaler(self, current):
-        globalscaler = int((current * 256. * math.sqrt(2.)
-                            * self.sense_resistor / VREF) + .5)
-        globalscaler = max(32, globalscaler)
-        if globalscaler >= 256:
-            globalscaler = 0
-        self.fields.set_field("globalscaler", globalscaler)
-    def _calc_current_bits(self, current):
-        globalscaler = self.fields.get_field("globalscaler")
-        if not globalscaler:
-            globalscaler = 256
-        cs = int((current * 256. * 32. * math.sqrt(2.) * self.sense_resistor)
-                 / (globalscaler * VREF)
-                 - 1. + .5)
-        return max(0, min(31, cs))
-    def _calc_current(self, run_current, hold_current):
-        irun = self._calc_current_bits(run_current)
-        ihold = self._calc_current_bits(min(hold_current, run_current))
-        return irun, ihold
-    def _calc_current_from_field(self, field_name):
-        globalscaler = self.fields.get_field("globalscaler")
-        if not globalscaler:
-            globalscaler = 256
-        bits = self.fields.get_field(field_name)
-        return (globalscaler * (bits + 1) * VREF
-                / (256. * 32. * math.sqrt(2.) * self.sense_resistor))
-    def get_current(self):
-        run_current = self._calc_current_from_field("irun")
-        hold_current = self._calc_current_from_field("ihold")
-        return run_current, hold_current, self.req_hold_current, MAX_CURRENT
-    def set_current(self, run_current, hold_current, print_time):
-        self.req_hold_current = hold_current
-        irun, ihold = self._calc_current(run_current, hold_current)
-        self.fields.set_field("ihold", ihold)
-        val = self.fields.set_field("irun", irun)
-        self.mcu_tmc.set_register("IHOLD_IRUN", val, print_time)
-
-
-######################################################################
-# TMC5160 printer object
-######################################################################
-
-class TMC5160:
-    def __init__(self, config):
-        # Setup mcu communication
-        self.fields = tmc.FieldHelper(Fields, SignedFields, FieldFormatters)
-        self.mcu_tmc = tmc2130.MCU_TMC_SPI(config, Registers, self.fields)
-        # Allow virtual pins to be created
-        tmc.TMCVirtualPinHelper(config, self.mcu_tmc)
-        # Register commands
-        current_helper = TMC5160CurrentHelper(config, self.mcu_tmc)
-        cmdhelper = tmc.TMCCommandHelper(config, self.mcu_tmc, current_helper)
-        cmdhelper.setup_register_dump(ReadRegisters)
-        self.get_phase_offset = cmdhelper.get_phase_offset
-        self.get_status = cmdhelper.get_status
-        # Setup basic register values
-        tmc.TMCWaveTableHelper(config, self.mcu_tmc)
-        tmc.TMCStealthchopHelper(config, self.mcu_tmc, TMC_FREQUENCY)
-        #   CHOPCONF
-        set_config_field = self.fields.set_config_field
-        set_config_field(config, "toff", 3)
-        set_config_field(config, "hstrt", 5)
-        set_config_field(config, "hend", 2)
-        set_config_field(config, "fd3", 0)
-        set_config_field(config, "disfdcc", 0)
-        set_config_field(config, "chm", 0)
-        set_config_field(config, "tbl", 2)
-        set_config_field(config, "vhighfs", 0)
-        set_config_field(config, "vhighchm", 0)
-        set_config_field(config, "tpfd", 4)
-        set_config_field(config, "diss2g", 0)
-        set_config_field(config, "diss2vs", 0)
-        #   COOLCONF
-        set_config_field(config, "semin", 0)    # page 52
-        set_config_field(config, "seup", 0)
-        set_config_field(config, "semax", 0)
-        set_config_field(config, "sedn", 0)
-        set_config_field(config, "seimin", 0)
-        set_config_field(config, "sgt", 0)
-        set_config_field(config, "sfilt", 0)
-        #   IHOLDIRUN
-        set_config_field(config, "iholddelay", 6)
-        #   PWMCONF
-        set_config_field(config, "pwm_ofs", 30)
-        set_config_field(config, "pwm_grad", 0)
-        set_config_field(config, "pwm_freq", 0)
-        set_config_field(config, "pwm_autoscale", True)
-        set_config_field(config, "pwm_autograd", True)
-        set_config_field(config, "freewheel", 0)
-        set_config_field(config, "pwm_reg", 4)
-        set_config_field(config, "pwm_lim", 12)
-        #   TPOWERDOWN
-        set_config_field(config, "tpowerdown", 10)
-
-def load_config_prefix(config):
-    return TMC5160(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/tmc.py crealityShit/klippy/extras/tmc.py
--- klipperStock/klippy/extras/tmc.py	2024-01-14 23:01:59.485788546 -0600
+++ crealityShit/klippy/extras/tmc.py	2024-01-14 23:02:21.690060709 -0600
@@ -154,8 +154,9 @@
             count += 1
             if count >= 3:
                 fmt = self.fields.pretty_format(reg_name, val)
-                raise self.printer.command_error("TMC '%s' reports error: %s"
-                                                 % (self.stepper_name, fmt))
+                code_key = "key505"
+                m = """{"code":"%s","msg":"TMC '%s' reports error: %s"}""" % (code_key, self.stepper_name, fmt)
+                raise self.printer.command_error(m)
             if try_clear and val & err_mask:
                 try_clear = False
                 cleared_flags |= val & err_mask
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/tool.py crealityShit/klippy/extras/tool.py
--- klipperStock/klippy/extras/tool.py	1969-12-31 18:00:00.000000000 -0600
+++ crealityShit/klippy/extras/tool.py	2024-01-14 23:02:21.630059974 -0600
@@ -0,0 +1,31 @@
+import re, os, logging, threading
+from subprocess import call
+import json, random, time
+
+def send(msg, data={}):
+    pipeFilePath = "/usr/data/creality/userdata/config/pipe.json"
+    try:
+        if not os.path.exists(pipeFilePath):
+            call("touch %s" % pipeFilePath, shell=True)
+            os.chmod(pipeFilePath, 0o700)
+        net_state = call("ping -c 2 -w 2 api.crealitycloud.com > /dev/null 2>&1", shell=True)
+        if net_state:
+            return
+        ret = re.findall('key(\d+)', msg)
+        if ret:
+            msg = "key%s" % ret[0]
+            if os.path.getsize(pipeFilePath) > 0:
+                random_float = random.uniform(0.1, 1)
+                time.sleep(random_float)
+
+            if os.path.getsize(pipeFilePath) == 0:
+                send_data = {"reqId": str(int(time.time()*1000)), "dn": "00000000000000", "code": msg, "data": data}
+                with open(pipeFilePath, "w") as f:
+                    f.write(json.dumps(send_data))
+                    f.flush()
+    except Exception as err:
+        logging.error("reportInformation err:%s" % err)
+
+def reportInformation(msg, data={}):
+    t = threading.Thread(target=send, args=(msg, data))
+    t.start()
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/verify_heater.py crealityShit/klippy/extras/verify_heater.py
--- klipperStock/klippy/extras/verify_heater.py	2024-01-14 23:01:59.485788546 -0600
+++ crealityShit/klippy/extras/verify_heater.py	2024-01-14 23:02:21.694060758 -0600
@@ -86,7 +86,21 @@
     def heater_fault(self):
         msg = "Heater %s not heating at expected rate" % (self.heater_name,)
         logging.error(msg)
-        self.printer.invoke_shutdown(msg + HINT_THERMAL)
+        #code_key = "key507"
+        code_key = "key564"
+        if self.heater_name == "extruder":
+            code_key = "key564"
+        elif self.heater_name == "heater_bed":
+            code_key = "key565"
+        m = """{"code":"%s","msg":"Heater %s not heating at expected rate"}""" % (code_key, self.heater_name)
+        try:
+            gcode = self.printer.lookup_object('gcode')
+            if gcode:
+                gcode.run_script_from_command("M140 S0")
+                gcode.run_script_from_command("M104 S0")
+        except Exception as err:
+            logging.error(err)
+        self.printer.invoke_shutdown(m)
         return self.printer.get_reactor().NEVER
 
 def load_config_prefix(config):
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/virtual_sdcard.py crealityShit/klippy/extras/virtual_sdcard.py
--- klipperStock/klippy/extras/virtual_sdcard.py	2024-01-14 23:01:59.477788447 -0600
+++ crealityShit/klippy/extras/virtual_sdcard.py	2024-01-14 23:02:21.678060562 -0600
@@ -3,9 +3,11 @@
 # Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
-import os, logging, io
+import os, logging, io, json, time
+from .tool import reportInformation
 
 VALID_GCODE_EXTS = ['gcode', 'g', 'gco']
+LAYER_KEYS = [";LAYER:", "; layer:", "; LAYER:", ";AFTER_LAYER_CHANGE", ";LAYER_CHANGE"]
 
 class VirtualSD:
     def __init__(self, config):
@@ -40,6 +42,26 @@
         self.gcode.register_command(
             "SDCARD_PRINT_FILE", self.cmd_SDCARD_PRINT_FILE,
             desc=self.cmd_SDCARD_PRINT_FILE_help)
+        self.count_G1 = 0 
+        self.count_line = 0
+        self.do_resume_status = False
+        self.eepromWriteCount = 1
+        self.fan_state = {}
+        self.gcode_layer_path = "/usr/data/creality/userdata/config/gcode_layer.json"
+        self.user_print_refer_path = "/usr/data/creality/userdata/config/user_print_refer.json"
+        self.print_file_name_path = "/usr/data/creality/userdata/config/print_file_name.json"
+        self.print_first_layer = False
+        self.first_layer_stop = False
+        self.count_M204 = 0
+        self.layer = 0
+        self.layer_count = 0
+        self.is_continue_print = False
+        self.slow_print = False
+        self.slow_count = 0
+        self.speed_factor = 1.0/60.0
+        self.run_dis = 0.0
+        self.print_history_file_path = "/usr/data/creality/userdata/config/print_history.json"
+        self.print_id = ""
     def handle_shutdown(self):
         if self.work_timer is not None:
             self.must_pause_work = True
@@ -54,6 +76,11 @@
             logging.info("Virtual sdcard (%d): %s\nUpcoming (%d): %s",
                          readpos, repr(data[:readcount]),
                          self.file_position, repr(data[readcount:]))
+        self.print_first_layer = False
+        self.first_layer_stop = False
+        self.print_stats.power_loss = 0
+        self.count_M204 = 0
+        self.fan_state = {}
     def stats(self, eventtime):
         if self.work_timer is None:
             return False, ""
@@ -90,6 +117,10 @@
             'is_active': self.is_active(),
             'file_position': self.file_position,
             'file_size': self.file_size,
+            'first_layer_stop':  self.first_layer_stop,
+            'layer': self.layer,
+            'layer_count': self.layer_count,
+            'run_dis': self.run_dis
         }
     def file_path(self):
         if self.current_file:
@@ -114,12 +145,37 @@
         self.work_timer = self.reactor.register_timer(
             self.work_handler, self.reactor.NOW)
     def do_cancel(self):
+        self.print_stats.power_loss = 0
+        self.first_layer_stop = False
+        self.print_first_layer = False
+        self.count_M204 = 0
+        self.layer = 0
+        self.layer_count = 0
+        self.fan_state = {}
+        self.resume_print_speed()
         if self.current_file is not None:
             self.do_pause()
             self.current_file.close()
             self.current_file = None
             self.print_stats.note_cancel()
         self.file_position = self.file_size = 0.
+        from subprocess import call
+        if os.path.exists(self.print_file_name_path):
+            os.remove(self.print_file_name_path)
+        call("sync", shell=True)
+        try:
+            power_loss_switch = False
+            if os.path.exists(self.user_print_refer_path):
+                with open(self.user_print_refer_path, "r") as f:
+                    data = json.loads(f.read())
+                    power_loss_switch = data.get("power_loss", {}).get("switch", False)
+            bl24c16f = self.printer.lookup_object('bl24c16f') if "bl24c16f" in self.printer.objects else None
+            if power_loss_switch and bl24c16f:
+                bl24c16f.setEepromDisable()
+                # self.gcode.run_script("EEPROM_WRITE_BYTE ADDR=1 VAL=255")
+        except Exception as err:
+            pass
+        self.update_print_history_info(only_update_status=True, state="cancelled")
     # G-Code commands
     def cmd_error(self, gcmd):
         raise gcmd.error("SD write not supported")
@@ -141,14 +197,120 @@
     cmd_SDCARD_PRINT_FILE_help = "Loads a SD file and starts the print.  May "\
         "include files in subdirectories."
     def cmd_SDCARD_PRINT_FILE(self, gcmd):
+        self.print_id = ""
         if self.work_timer is not None:
             raise gcmd.error("SD busy")
         self._reset_file()
         filename = gcmd.get("FILENAME")
+        self.is_continue_print = gcmd.get("ISCONTINUEPRINT", False)
+        self.rm_power_loss_info()
+        first_floor = gcmd.get("FIRST_FLOOR_PRINT", None)
+        if first_floor is None or first_floor == False:
+            self.print_first_layer = False
+        else:
+            self.print_first_layer = True
         if filename[0] == '/':
             filename = filename[1:]
         self._load_file(gcmd, filename, check_subdirs=True)
+        reportInformation("key600", data={"filename": filename})
+        self.record_print_history(str(self.current_file.name))
         self.do_resume()
+
+    def record_print_history(self, file_path=""):
+        try:
+            if os.path.exists(file_path):
+                dir_path = os.path.dirname(file_path)
+                file_name = os.path.basename(file_path)
+                metadata_info = self.get_print_file_metadata(filename=file_name, filepath=dir_path)
+                self.layer_count = self.get_file_layer_count(self.current_file.name, metadata_info=metadata_info)
+                start_time = time.time()
+                self.print_id = str(start_time)
+                metadata = metadata_info.get("metadata", {})
+                data = {
+                    "end_time": start_time,
+                    "filament_used": 0,
+                    "filename": file_name,
+                    "metadata": metadata,
+                    "print_duration": 0,
+                    "start_time": start_time,
+                    "status": "in_progress",
+                    "total_duration": 0,
+                }
+                if os.path.exists(self.print_history_file_path):
+                    ret = {}
+                    try:
+                        with open(self.print_history_file_path, "r") as f:
+                            ret = json.loads(f.read())
+                            if ret["count"] == 10:
+                                del ret["jobs"][0]
+                            else:
+                                ret["count"] += 1
+                            ret["jobs"].append(data)
+                        with open(self.print_history_file_path, "w") as f:
+                            f.write(json.dumps(ret))
+                            f.flush()
+                    except Exception as err:
+                        logging.error(err)
+                        if os.path.exists(self.print_history_file_path):
+                            os.remove(self.print_history_file_path)
+                else:
+                    result = {"count": 1, "jobs": [data]}
+                    with open(self.print_history_file_path, "w") as f:
+                        f.write(json.dumps(result))
+                        f.flush()
+        except Exception as err:
+            logging.error(err)
+
+    def update_print_history_info(self, only_update_status=False, state="", error_msg=""):
+        if os.path.exists(self.print_history_file_path) and self.print_id:
+            ret = {}
+            try:
+                update_obj = None
+                index = -1
+                with open(self.print_history_file_path, "r") as f:
+                    ret = json.loads(f.read())
+                if ret and ret.get("jobs", []):
+                    print_list = ret.get("jobs", [])
+                    for obj in print_list:
+                        if obj.get("start_time", "") and str(obj.get("start_time", "")) == self.print_id:
+                            index = print_list.index(obj)
+                            update_obj = obj
+                            if not only_update_status:
+                                update_obj["filament_used"] = self.print_stats.filament_used
+                                update_obj["print_duration"] = self.print_stats.print_duration
+                                update_obj["total_duration"] = self.print_stats.total_duration
+                            update_obj["end_time"] = time.time()
+                            if not state:
+                                state = "in_progress"
+                            if error_msg:
+                                update_obj["error_msg"] = error_msg
+                            update_obj["status"] = state
+
+                if index != -1:
+                    print_list[index] = update_obj
+                    with open(self.print_history_file_path, "w") as f:
+                        ret["jobs"] = print_list
+                        f.write(json.dumps(ret))
+                        f.flush()
+            except Exception as err:
+                logging.error(err)
+                if os.path.exists(self.print_history_file_path):
+                    os.remove(self.print_history_file_path)
+
+    def rm_power_loss_info(self):
+        if not self.is_continue_print and os.path.exists(self.print_file_name_path):
+            try:
+                power_loss_switch = False
+                with open(self.user_print_refer_path, "r") as f:
+                    data = json.loads(f.read())
+                    power_loss_switch = data.get("power_loss", {}).get("switch", False)
+                bl24c16f = self.printer.lookup_object('bl24c16f') if "bl24c16f" in self.printer.objects and power_loss_switch else None
+                if power_loss_switch and bl24c16f:
+                    os.remove(self.print_file_name_path)
+                    self.gcode.run_script_from_command("EEPROM_WRITE_BYTE ADDR=1 VAL=255")
+                    logging.info("rm power_loss info success")
+            except Exception as err:
+                logging.error("rm power_loss info fail, err:%s" % err)
     def cmd_M20(self, gcmd):
         # List SD card
         files = self.get_file_list()
@@ -183,7 +345,7 @@
             f.seek(0)
         except:
             logging.exception("virtual_sdcard file open")
-            raise gcmd.error("Unable to open file")
+            raise gcmd.error("""{"code":"key121", "msg": "Unable to open file", "values": []}""")
         gcmd.respond_raw("File opened:%s Size:%d" % (filename, fsize))
         gcmd.respond_raw("File selected")
         self.current_file = f
@@ -215,8 +377,249 @@
         self.next_file_position = pos
     def is_cmd_from_sd(self):
         return self.cmd_from_sd
+    def tail_read(self, f):
+        cur_pos = f.tell()
+        buf = ''
+        while True:
+            b = str(f.read(1))
+            buf = b + buf
+            cur_pos -= 1
+            if cur_pos < 0: break
+            f.seek(cur_pos)
+            if b.startswith("\n") or b.startswith("\r"):
+                buf = '\n'
+            if (buf.startswith("G1") or buf.startswith("G0")) and buf.endswith("\n"):
+                if ";" in buf:
+                    buf = buf.split(";")[0]+"\n"
+                break
+        return buf
+    def getXYZE(self, file_path, file_position):
+        result = {"X": 0, "Y": 0, "Z": 0, "E": 0}
+        try:
+            import io
+            with io.open(file_path, "r", encoding="utf-8") as f:
+                f.seek(file_position)
+                while True:
+                    cur_pos = f.tell()
+                    if cur_pos<=0:
+                        break
+                    line = self.tail_read(f)
+                    line_list = line.split(" ")
+                    if not result["E"] and "E" in line:
+                        for obj in line_list:
+                            if obj.startswith("E"):
+                                ret = obj[1:].split("\r")[0]
+                                ret = ret.split("\n")[0]
+                                if ret.startswith("."):
+                                    result["E"] = float(("0"+ret.strip(" ")))
+                                else:
+                                    result["E"] = float(ret.strip(" "))
+                    if not result["X"] and not result["Y"]:
+                        for obj in line_list:
+                            if obj.startswith("X"):
+                                logging.info("power_loss getXYZE X:%s" % obj)
+                                result["X"] = float(obj.split("\r")[0][1:])
+                            if obj.startswith("Y"):
+                                logging.info("power_loss getXYZE Y:%s" % obj)
+                                result["Y"] = float(obj.split("\r")[0][1:])
+                    if not result["Z"] and "Z" in line:
+                        for obj in line_list:
+                            if obj.startswith("Z"):
+                                logging.info("power_loss getXYZE Z:%s" % obj)
+                                result["Z"] = float(obj.split("\r")[0][1:])
+                    if result["X"] and result["Y"] and result["Z"] and result["E"]:
+                        logging.info("get XYZE:%s" % str(result))
+                        logging.info("power_loss get XYZE:%s" % str(result))
+                        break
+                    self.reactor.pause(self.reactor.monotonic() + .001)
+        except Exception as err:
+            logging.exception(err)
+        return result
+    def get_print_temperature(self, file_path):
+        bed = 0
+        extruder = 202.0
+        if os.path.exists(self.gcode.last_temperature_info):
+            try:
+                with open(self.gcode.last_temperature_info, "r") as f:
+                    result = f.read()
+                    if len(result) > 0:
+                        result = json.loads(result)
+                        bed = float(result.get("bed", 0))
+                        extruder = float(result.get("extruder", 201.0))
+            except Exception as err:
+                logging.error("get_print_temperature: %s" % err)
+        logging.info("power_loss get_print_temperature: bed:%s, extruder:%s" % (bed, extruder))
+        return bed, extruder
+
+    def record_layer(self, layer):
+        """
+        record current print file layer
+        """
+        with open(self.gcode_layer_path, "w") as f:
+            f.write(json.dumps({"layer": layer}))
+            f.flush()
+            
+    def get_layer(self):
+        """
+        get last print file layer
+        """
+        layer = 0
+        if os.path.exists(self.gcode_layer_path):
+            try:
+                with open(self.gcode_layer_path, "r") as f:
+                    layer = int(json.loads(f.read()).get("layer"))
+            except Exception as err:
+                logging.error(err)
+                os.remove(self.gcode_layer_path)
+        return layer
+
+    def get_print_file_metadata(self, filename, filepath="/usr/data/printer_data/gcodes"):
+        from subprocess import check_output
+        result = {}
+        python_env = "/usr/share/klippy-env/bin/python3"
+        # -f gcode filename  -p gcode file dir
+        cmd = "%s /usr/share/klipper/klippy/extras/metadata.py -f '%s' -p %s" % (python_env, filename, filepath)
+        try:
+            result = json.loads(check_output(cmd, shell=True).decode("utf-8"))
+        except Exception as err:
+            logging.error(err)
+        return result
+    
+    def get_file_layer_count(self, filename, metadata_info=None):
+        filename = filename.split("/")[-1]
+        import math
+        layer_count = 0
+        if metadata_info:
+            result = metadata_info
+        else:
+            result = self.get_print_file_metadata(filename, get_layer_count=True)
+        if not result:
+            return layer_count
+        try:
+            layer_count = result.get("metadata").get("layer_count", 0)
+            first_layer_height = result.get("metadata").get("first_layer_height", 0)
+            object_height = result.get("metadata").get("object_height", 0)
+            layer_height = result.get("metadata").get("layer_height", 0)
+            if not layer_count and object_height > 0 and layer_height > 0:
+                layer_count = math.ceil((object_height - first_layer_height) / layer_height + 1)
+        except Exception as err:
+            logging.error(err)
+        return layer_count
+        
+    def resume_print_speed(self):
+        if self.slow_print == True:
+            self.slow_print = False
+            self.slow_count = 0
+            speed_cmd = "M220 S%s" % (self.speed_factor * 100 * 60)
+            logging.info("power_loss slow_print:%s Resume" % speed_cmd)
+            self.gcode.run_script_from_command(speed_cmd)
+        
     # Background work timer
     def work_handler(self, eventtime):
+        filename = os.path.basename(self.current_file.name) if self.current_file else ""
+        logging.info("work_handler start print, filename:%s" % self.current_file.name)
+        # self.print_stats.note_start()
+        import time
+        from subprocess import check_output
+        self.count_line = 0
+        self.count_G1 = 0 
+        self.eepromWriteCount = 1
+        gcode_move = self.printer.lookup_object('gcode_move', None)
+        try:
+            if os.path.exists(self.user_print_refer_path):
+                with open(self.user_print_refer_path, "r") as f:
+                    data = json.loads(f.read())
+                    delay_photography_switch = data.get("delay_image", {}).get("switch", 1)
+                    location = data.get("delay_image", {}).get("location", 0)
+                    frame = data.get("delay_image", {}).get("frame", 15)
+                    interval = data.get("delay_image", {}).get("interval", 1)
+                    power_loss_switch = data.get("power_loss", {}).get("switch", False)
+        except Exception as err:
+            delay_photography_switch = 1
+            location = 0
+            frame = 15
+            interval = 1
+            power_loss_switch = False
+        logging.info("delay_photography status: delay_photography_switch:%s, location:%s, frame:%s, interval:%s" % (
+            delay_photography_switch, location, frame, interval
+        ))
+        bl24c16f = self.printer.lookup_object('bl24c16f') if "bl24c16f" in self.printer.objects and power_loss_switch else None
+        eepromState = True
+        try:
+            sameFileName = False
+            if self.is_continue_print and os.path.exists(self.print_file_name_path):
+                with open(self.print_file_name_path, "r") as f:
+                    result = (json.loads(f.read()))
+                    if result.get("file_path", "") == self.current_file.name:
+                        sameFileName = True
+                    else:
+                        # clear power_loss info
+                        os.remove(self.print_file_name_path)
+                        if power_loss_switch and bl24c16f:
+                            bl24c16f.setEepromDisable()
+            if power_loss_switch and self.is_continue_print and not self.do_resume_status and sameFileName and bl24c16f:
+                eepromState = bl24c16f.checkEepromFirstEnable() if power_loss_switch and bl24c16f else True
+                if not eepromState:
+                    with self.gcode.mutex:
+                        try:
+                            self.print_stats.note_start(info_path=self.print_file_name_path)
+                            self.is_continue_print = False
+                            logging.info("power_loss start do_resume...")
+                            logging.info("power_loss start print, filename:%s" % self.current_file.name)
+                            pos = bl24c16f.eepromReadHeader()
+                            logging.info("power_loss pos:%s" % pos)
+                            print_info = bl24c16f.eepromReadBody(pos)
+                            logging.info("power_loss print_info:%s" % str(print_info))
+                            self.file_position = int(print_info.get("file_position", 0))
+                            logging.info("power_loss file_position:%s" % self.file_position)
+                            self.layer = self.get_layer()
+                            gcode = self.printer.lookup_object('gcode')
+                            temperature = self.get_print_temperature(self.current_file.name)
+                            gcode.run_script_from_command("M140 S%s" % temperature[0])
+                            gcode.run_script_from_command("M109 S%s" % temperature[1])
+                            XYZE = self.getXYZE(self.current_file.name, self.file_position)
+                            logging.info("power_loss XYZE:%s, file_position:%s  " % (str(XYZE), self.file_position))
+                            if XYZE.get("Z") == 0:
+                                logging.error("power_loss gcode Z == 0 err")
+                                from subprocess import call
+                                if os.path.exists(self.print_file_name_path):
+                                    os.remove(self.print_file_name_path)
+                                call("sync", shell=True)
+                                try:
+                                    power_loss_switch = False
+                                    if os.path.exists(self.user_print_refer_path):
+                                        with open(self.user_print_refer_path, "r") as f:
+                                            data = json.loads(f.read())
+                                            power_loss_switch = data.get("power_loss", {}).get("switch", False)
+                                    bl24c16f = self.printer.lookup_object('bl24c16f') if "bl24c16f" in self.printer.objects else None
+                                    if power_loss_switch and bl24c16f:
+                                        bl24c16f.setEepromDisable()
+                                except Exception as err:
+                                    logging.error("power_loss gcode Z == 0: %s" % err)
+                                error_message = "power_loss gcode Z == 0, stop print"
+                                self.print_stats.note_error(error_message)
+                                raise
+                            gcode_move.cmd_CX_RESTORE_GCODE_STATE(print_info, self.print_file_name_path, XYZE)
+                            logging.info("power_loss end do_resume success")
+                            self.print_stats.power_loss = 0
+                            if self.layer > 1:
+                                self.slow_print = True
+                                self.slow_count = self.layer + 1
+                                self.speed_factor = gcode_move.speed_factor
+                                self.gcode.run_script_from_command("M220 S20")
+                                logging.info("power_loss slow_print M220 S20 SET")
+                        except Exception as err:
+                            self.print_stats.power_loss = 0
+                            logging.error(err)
+                else:
+                    self.gcode.run_script("G90")
+            else:
+                self.gcode.run_script("G90")
+        except Exception as err:
+            self.print_stats.power_loss = 0
+            logging.exception("work_handler RESTORE_GCODE_STATE error: %s" % err)
+        if power_loss_switch and bl24c16f:
+            gcode_move.recordPrintFileName(self.print_file_name_path, self.current_file.name)
         logging.info("Starting SD card print (position %d)", self.file_position)
         self.reactor.unregister_timer(self.work_timer)
         try:
@@ -230,6 +633,10 @@
         partial_input = ""
         lines = []
         error_message = None
+        lastE = 0
+        layer_count = 0
+        # self.gcode.run_script("G90")
+        toolhead = self.printer.lookup_object('toolhead')
         while not self.must_pause_work:
             if not lines:
                 # Read more data
@@ -244,6 +651,19 @@
                     self.current_file = None
                     logging.info("Finished SD card print")
                     self.gcode.respond_raw("Done printing file")
+                    if os.path.exists(self.print_file_name_path):
+                        os.remove(self.print_file_name_path)
+                    if power_loss_switch and bl24c16f:
+                        self.gcode.run_script("EEPROM_WRITE_BYTE ADDR=1 VAL=255")
+                    self.first_layer_stop = False
+                    self.print_first_layer = False
+                    self.count_M204 = 0
+                    self.layer = 0
+                    self.layer_count = 0
+                    self.fan_state = {}
+                    reportInformation("key604", data={"filename": filename})
+                    self.update_print_history_info(only_update_status=True, state="completed")
+                    self.print_id = ""
                     break
                 lines = data.split('\n')
                 lines[0] = partial_input + lines[0]
@@ -260,17 +680,164 @@
             line = lines.pop()
             next_file_position = self.file_position + len(line) + 1
             self.next_file_position = next_file_position
+            if self.count_line % 999 == 0:
+                self.update_print_history_info()
+            try:
+                if power_loss_switch and bl24c16f and (self.layer > 2 or (self.count_G1 > 18 and gcode_move.last_position[2] > 0.6)) and self.count_line % 99 == 0:
+                    base_position_e = round(list(gcode_move.base_position)[-1], 2)
+                    pos = bl24c16f.eepromReadHeader()
+                    if eepromState:
+                        # eeprom first enable
+                        self.gcode.run_script("EEPROM_WRITE_BYTE ADDR=1 VAL=1")
+                        self.gcode.run_script("EEPROM_WRITE_INT ADDR=%s VAL=%s" % (pos*8, self.file_position))
+                        self.gcode.run_script("EEPROM_WRITE_FLOAT ADDR=%s VAL=%s" % (pos*8+4, base_position_e))
+                        self.gcode.run_script("EEPROM_WRITE_BYTE ADDR=0 VAL=%d" % pos)
+                        eepromState = False
+                    else:
+                        # pos = bl24c16f.eepromReadHeader()
+                        if self.eepromWriteCount < 256:
+                            self.gcode.run_script("EEPROM_WRITE_INT ADDR=%s VAL=%s" % (pos*8, self.file_position))
+                            self.gcode.run_script("EEPROM_WRITE_FLOAT ADDR=%s VAL=%s" % (pos*8+4, base_position_e))
+                        else:
+                            self.eepromWriteCount = 1
+                            pos += 1
+                            if pos == 256:
+                                pos = 1
+                            self.gcode.run_script("EEPROM_WRITE_INT ADDR=%s VAL=%s" % (pos*8, self.file_position))
+                            self.gcode.run_script("EEPROM_WRITE_FLOAT ADDR=%s VAL=%s" % (pos*8+4, base_position_e))
+                            self.gcode.run_script("EEPROM_WRITE_BYTE ADDR=0 VAL=%d" % pos)
+                        # logging.info("eepromWriteCount:%d, pos:%d" % (self.eepromWriteCount, pos))
+                    self.eepromWriteCount += 1
+                if power_loss_switch and bl24c16f and self.count_G1 == 19:
+                    gcode_move.recordPrintFileName(self.print_file_name_path, self.current_file.name, fan_state=self.fan_state, filament_used=self.print_stats.filament_used, last_print_duration=self.print_stats.print_duration)
+                if power_loss_switch and bl24c16f and (self.layer > 2 or gcode_move.last_position[2] > 3) and self.count_line % 999 == 0:
+                    gcode_move.recordPrintFileName(self.print_file_name_path, self.current_file.name, fan_state=self.fan_state, filament_used=self.print_stats.filament_used, last_print_duration=self.print_stats.print_duration)
+                if line.startswith("G1") and "E" in line:
+                    try:
+                        E_str = line.split(" ")[-1]
+                        if E_str.startswith("E"):
+                            lastE = float(E_str.strip("\r").strip("\n")[1:])
+                    except Exception as err:
+                        pass
+                elif line.startswith("M106"):
+                    M106_line = line.strip("\r").strip("\n")
+                    if M106_line.startswith("M106 S"):
+                        self.fan_state["M106 S"] = M106_line
+                    elif M106_line.startswith("M106 P0"):
+                        self.fan_state["M106 P0"] = M106_line
+                    elif M106_line.startswith("M106 P1"):
+                        self.fan_state["M106 P1"] = M106_line
+                    elif M106_line.startswith("M106 P2"):
+                        self.fan_state["M106 P2"] = M106_line
+                elif line.startswith("END_PRINT"):
+                    if os.path.exists(self.print_file_name_path):
+                        os.remove(self.print_file_name_path)
+                    if power_loss_switch and bl24c16f:
+                        self.gcode.run_script("EEPROM_WRITE_BYTE ADDR=1 VAL=255")
+                for layer_key in LAYER_KEYS:
+                    if line.startswith(layer_key):
+                        self.layer += 1
+                        self.record_layer(self.layer)
+                        break
+                if self.print_first_layer and self.count_G1 >= 20:
+                    for layer_key in LAYER_KEYS:
+                        if line.startswith(layer_key):
+                            logging.info("print_first_layer layer_key:%s" % layer_key)
+                            X, Y, Z, E = toolhead.get_position()
+                            self.gcode.run_script("FIRST_FLOOR_PAUSE")
+                            self.first_layer_stop = True
+                if delay_photography_switch:
+                    for layer_key in LAYER_KEYS:
+                        if ";LAYER_COUNT:" in layer_key:
+                            break
+                        if line.startswith(layer_key) and os.path.exists("/tmp/camera_main"):
+                            if layer_count % int(interval) == 0:
+                                if location:
+                                    cmd_wait_for_stepper = "M400"
+                                    # toolhead = self.printer.lookup_object('toolhead')
+                                    X, Y, Z, E = toolhead.get_position()
+                                    if self.count_G1 >= 20:
+                                        # 1. Pull back and lift first
+                                        logging.info("G1 F2400 E%s" % (lastE-3))
+                                        logging.info(cmd_wait_for_stepper)
+                                        self.gcode.run_script("G1 F2400 E%s" % (lastE-3))
+                                        self.gcode.run_script(cmd_wait_for_stepper)
+                                        time.sleep(0.1)
+                                        self.gcode.run_script("G1 F3000 Z%s" % (Z + 2))
+                                        self.gcode.run_script(cmd_wait_for_stepper)
+                                        time.sleep(0.1)
+                                        # 2. move to the specified position
+                                        cmd = "G0 X5 Y150 F15000"
+                                        logging.info(cmd)
+                                        logging.info(cmd_wait_for_stepper)
+                                        self.gcode.run_script(cmd)
+                                        self.gcode.run_script(cmd_wait_for_stepper)
+                                        try:
+                                            capture_shell = "capture 0"
+                                            logging.info(capture_shell)
+                                            capture_ret = check_output(capture_shell, shell=True).decode("utf-8")
+                                            logging.info("capture 0 return:#%s#" % str(capture_ret))
+                                        except Exception as err:
+                                            logging.error(err)
+                                        time.sleep(0.1)
+                                        # 3. move back
+                                        move_back_cmd = "G0 X%s Y%s F15000" % (X, Y)
+                                        logging.info(move_back_cmd)
+                                        logging.info(cmd_wait_for_stepper)
+                                        self.gcode.run_script(move_back_cmd)
+                                        self.gcode.run_script(cmd_wait_for_stepper)
+                                        time.sleep(0.2)
+                                        self.gcode.run_script("G1 F3000 Z%s" % Z)
+                                        self.gcode.run_script(cmd_wait_for_stepper)
+                                        time.sleep(0.1)
+                                        logging.info("G1 F2400 E%s" % (lastE))
+                                        self.gcode.run_script("G1 F2400 E%s" % (lastE))
+                                else:
+                                    try:
+                                        capture_shell = "capture 0"
+                                        logging.info(capture_shell)
+                                        capture_ret = check_output(capture_shell, shell=True).decode("utf-8")
+                                        logging.info("capture 0 return:#%s#" % str(capture_ret))
+                                    except Exception as err:
+                                        logging.error(err)
+                            layer_count += 1
+                            break
+                if self.slow_print == True and self.layer > 0 and self.slow_count < self.layer:
+                    self.resume_print_speed()
+                if line.startswith("END_PRINT") and delay_photography_switch and os.path.exists("/tmp/camera_main"):
+                    self.gcode.run_script("END_PRINT_POINT_WITHOUT_LIFTING")
+                    self.gcode.run_script("M400")
+                    interval_time = 1.0 / frame
+                    start_time = 1
+                    while start_time > 0:
             try:
+                            capture_shell = "capture 0"
+                            logging.info(capture_shell)
+                            capture_ret = check_output(capture_shell, shell=True).decode("utf-8")
+                            logging.info("capture 0 return:#%s#" % str(capture_ret))
+                        except Exception as err:
+                            logging.error(err)
+                        time.sleep(interval_time)
+                        start_time = start_time - interval_time
                 self.gcode.run_script(line)
+                self.count_line += 1
+                if self.count_G1 < 20 and line.startswith("G1"):
+                    self.count_G1 += 1
             except self.gcode.error as e:
                 error_message = str(e)
                 try:
                     self.gcode.run_script(self.on_error_gcode.render())
                 except:
                     logging.exception("virtual_sdcard on_error")
+                self.layer = 0
+                self.layer_count = 0
+                self.resume_print_speed()
                 break
             except:
                 logging.exception("virtual_sdcard dispatch")
+                self.layer = 0
+                self.layer_count = 0
+                self.resume_print_speed()
                 break
             self.cmd_from_sd = False
             self.file_position = self.next_file_position
@@ -285,6 +852,10 @@
                 lines = []
                 partial_input = ""
         logging.info("Exiting SD card print (position %d)", self.file_position)
+        self.count_line = 0
+        self.count_G1 = 0
+        self.do_resume_status = False
+        self.eepromWriteCount = 1
         self.work_timer = None
         self.cmd_from_sd = False
         if error_message is not None:
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/extras/z_tilt.py crealityShit/klippy/extras/z_tilt.py
--- klipperStock/klippy/extras/z_tilt.py	2024-01-14 23:01:59.453788154 -0600
+++ crealityShit/klippy/extras/z_tilt.py	1969-12-31 18:00:00.000000000 -0600
@@ -1,179 +0,0 @@
-# Mechanical bed tilt calibration with multiple Z steppers
-#
-# Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-import mathutil
-from . import probe
-
-class ZAdjustHelper:
-    def __init__(self, config, z_count):
-        self.printer = config.get_printer()
-        self.name = config.get_name()
-        self.z_count = z_count
-        self.z_steppers = []
-        self.printer.register_event_handler("klippy:connect",
-                                            self.handle_connect)
-    def handle_connect(self):
-        kin = self.printer.lookup_object('toolhead').get_kinematics()
-        z_steppers = [s for s in kin.get_steppers() if s.is_active_axis('z')]
-        if len(z_steppers) != self.z_count:
-            raise self.printer.config_error(
-                "%s z_positions needs exactly %d items" % (
-                    self.name, len(z_steppers)))
-        if len(z_steppers) < 2:
-            raise self.printer.config_error(
-                "%s requires multiple z steppers" % (self.name,))
-        self.z_steppers = z_steppers
-    def adjust_steppers(self, adjustments, speed):
-        toolhead = self.printer.lookup_object('toolhead')
-        gcode = self.printer.lookup_object('gcode')
-        curpos = toolhead.get_position()
-        # Report on movements
-        stepstrs = ["%s = %.6f" % (s.get_name(), a)
-                    for s, a in zip(self.z_steppers, adjustments)]
-        msg = "Making the following Z adjustments:\n%s" % ("\n".join(stepstrs),)
-        gcode.respond_info(msg)
-        # Disable Z stepper movements
-        toolhead.flush_step_generation()
-        for s in self.z_steppers:
-            s.set_trapq(None)
-        # Move each z stepper (sorted from lowest to highest) until they match
-        positions = [(-a, s) for a, s in zip(adjustments, self.z_steppers)]
-        positions.sort()
-        first_stepper_offset, first_stepper = positions[0]
-        z_low = curpos[2] - first_stepper_offset
-        for i in range(len(positions)-1):
-            stepper_offset, stepper = positions[i]
-            next_stepper_offset, next_stepper = positions[i+1]
-            toolhead.flush_step_generation()
-            stepper.set_trapq(toolhead.get_trapq())
-            curpos[2] = z_low + next_stepper_offset
-            try:
-                toolhead.move(curpos, speed)
-                toolhead.set_position(curpos)
-            except:
-                logging.exception("ZAdjustHelper adjust_steppers")
-                toolhead.flush_step_generation()
-                for s in self.z_steppers:
-                    s.set_trapq(toolhead.get_trapq())
-                raise
-        # Z should now be level - do final cleanup
-        last_stepper_offset, last_stepper = positions[-1]
-        toolhead.flush_step_generation()
-        last_stepper.set_trapq(toolhead.get_trapq())
-        curpos[2] += first_stepper_offset
-        toolhead.set_position(curpos)
-
-class ZAdjustStatus:
-    def __init__(self, printer):
-        self.applied = False
-        printer.register_event_handler("stepper_enable:motor_off",
-                                        self._motor_off)
-    def check_retry_result(self, retry_result):
-        if retry_result == "done":
-            self.applied = True
-        return retry_result
-    def reset(self):
-        self.applied = False
-    def get_status(self, eventtime):
-        return {'applied': self.applied}
-    def _motor_off(self, print_time):
-        self.reset()
-
-class RetryHelper:
-    def __init__(self, config, error_msg_extra = ""):
-        self.gcode = config.get_printer().lookup_object('gcode')
-        self.default_max_retries = config.getint("retries", 0, minval=0)
-        self.default_retry_tolerance = \
-            config.getfloat("retry_tolerance", 0., above=0.)
-        self.value_label = "Probed points range"
-        self.error_msg_extra = error_msg_extra
-    def start(self, gcmd):
-        self.max_retries = gcmd.get_int('RETRIES', self.default_max_retries,
-                                        minval=0, maxval=30)
-        self.retry_tolerance = gcmd.get_float('RETRY_TOLERANCE',
-                                              self.default_retry_tolerance,
-                                              minval=0.0, maxval=1.0)
-        self.current_retry = 0
-        self.previous = None
-        self.increasing = 0
-    def check_increase(self, error):
-        if self.previous and error > self.previous + 0.0000001:
-            self.increasing += 1
-        elif self.increasing > 0:
-            self.increasing -= 1
-        self.previous = error
-        return self.increasing > 1
-    def check_retry(self, z_positions):
-        if self.max_retries == 0:
-            return
-        error = round(max(z_positions) - min(z_positions),6)
-        self.gcode.respond_info(
-            "Retries: %d/%d %s: %0.6f tolerance: %0.6f" % (
-                self.current_retry, self.max_retries, self.value_label,
-                error, self.retry_tolerance))
-        if self.check_increase(error):
-            raise self.gcode.error("Retries aborting: %s is increasing. %s"
-                                   % (self.value_label, self.error_msg_extra))
-        if error <= self.retry_tolerance:
-            return "done"
-        self.current_retry += 1
-        if self.current_retry > self.max_retries:
-            raise self.gcode.error("Too many retries")
-        return "retry"
-
-class ZTilt:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.z_positions = config.getlists('z_positions', seps=(',', '\n'),
-                                           parser=float, count=2)
-        self.retry_helper = RetryHelper(config)
-        self.probe_helper = probe.ProbePointsHelper(config, self.probe_finalize)
-        self.probe_helper.minimum_points(2)
-        self.z_status = ZAdjustStatus(self.printer)
-        self.z_helper = ZAdjustHelper(config, len(self.z_positions))
-        # Register Z_TILT_ADJUST command
-        gcode = self.printer.lookup_object('gcode')
-        gcode.register_command('Z_TILT_ADJUST', self.cmd_Z_TILT_ADJUST,
-                               desc=self.cmd_Z_TILT_ADJUST_help)
-    cmd_Z_TILT_ADJUST_help = "Adjust the Z tilt"
-    def cmd_Z_TILT_ADJUST(self, gcmd):
-        self.z_status.reset()
-        self.retry_helper.start(gcmd)
-        self.probe_helper.start_probe(gcmd)
-    def probe_finalize(self, offsets, positions):
-        # Setup for coordinate descent analysis
-        z_offset = offsets[2]
-        logging.info("Calculating bed tilt with: %s", positions)
-        params = { 'x_adjust': 0., 'y_adjust': 0., 'z_adjust': z_offset }
-        # Perform coordinate descent
-        def adjusted_height(pos, params):
-            x, y, z = pos
-            return (z - x*params['x_adjust'] - y*params['y_adjust']
-                    - params['z_adjust'])
-        def errorfunc(params):
-            total_error = 0.
-            for pos in positions:
-                total_error += adjusted_height(pos, params)**2
-            return total_error
-        new_params = mathutil.coordinate_descent(
-            params.keys(), params, errorfunc)
-        # Apply results
-        speed = self.probe_helper.get_lift_speed()
-        logging.info("Calculated bed tilt parameters: %s", new_params)
-        x_adjust = new_params['x_adjust']
-        y_adjust = new_params['y_adjust']
-        z_adjust = (new_params['z_adjust'] - z_offset
-                    - x_adjust * offsets[0] - y_adjust * offsets[1])
-        adjustments = [x*x_adjust + y*y_adjust + z_adjust
-                       for x, y in self.z_positions]
-        self.z_helper.adjust_steppers(adjustments, speed)
-        return self.z_status.check_retry_result(
-            self.retry_helper.check_retry([p[2] for p in positions]))
-    def get_status(self, eventtime):
-            return self.z_status.get_status(eventtime)
-
-def load_config(config):
-    return ZTilt(config)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/gcode.py crealityShit/klippy/gcode.py
--- klipperStock/klippy/gcode.py	2024-01-14 23:01:59.517788939 -0600
+++ crealityShit/klippy/gcode.py	2024-01-14 23:02:21.746061394 -0600
@@ -4,6 +4,7 @@
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
 import os, re, logging, collections, shlex
+from extras.tool import reportInformation
 
 class CommandError(Exception):
     pass
@@ -57,26 +58,28 @@
         value = self._params.get(name)
         if value is None:
             if default is self.sentinel:
-                raise self.error("Error on '%s': missing %s"
-                                 % (self._commandline, name))
+                raise self.error("""{"code":"key251", "msg":"Error on '%s': missing %s", "values":["%s",%s"]}"""
+                                 % (self._commandline, name, self._commandline, name))
             return default
         try:
             value = parser(value)
         except:
-            raise self.error("Error on '%s': unable to parse %s"
-                             % (self._commandline, value))
+            raise self.error(
+                             """{"code":"key171", "msg": "Unable to parse '%s' as a  %s", "values": ["%s", "%s"]}""" % (self._commandline, value,
+                                                                                                                  self._commandline, value)
+                             )
         if minval is not None and value < minval:
-            raise self.error("Error on '%s': %s must have minimum of %s"
-                             % (self._commandline, name, minval))
+            raise self.error("""{"code":"key252","msg":"Error on '%s': %s must have minimum of %s","values":["%s","%s","%s"]}"""
+                             % (self._commandline, name, minval, self._commandline, name, minval))
         if maxval is not None and value > maxval:
-            raise self.error("Error on '%s': %s must have maximum of %s"
-                             % (self._commandline, name, maxval))
+            raise self.error("""{"code":"key253", "msg":"Error on '%s': %s must have maximumof %s", "values":["%s","%s","%s"]}"""
+                             % (self._commandline, name, maxval, self._commandline, name, maxval))
         if above is not None and value <= above:
-            raise self.error("Error on '%s': %s must be above %s"
-                             % (self._commandline, name, above))
+            raise self.error("""{"code":"key254", "msg":"Error on '%s': %s must be above %s", "values":["%s","%s","%s"]}"""
+                             % (self._commandline, name, above, self._commandline, name, above))
         if below is not None and value >= below:
-            raise self.error("Error on '%s': %s must be below %s"
-                             % (self._commandline, name, below))
+            raise self.error("""{"code":"key255", "msg":"Error on '%s': %s must be below %s", "values":["%s","%s","%s"]}"""
+                             % (self._commandline, name, below, self._commandline, name, below))
         return value
     def get_int(self, name, default=sentinel, minval=None, maxval=None):
         return self.get(name, default, parser=int, minval=minval, maxval=maxval)
@@ -111,6 +114,7 @@
             func = getattr(self, 'cmd_' + cmd)
             desc = getattr(self, 'cmd_' + cmd + '_help', None)
             self.register_command(cmd, func, True, desc)
+        self.last_temperature_info = "/usr/data/creality/userdata/config/temperature_info.json"
     def is_traditional_gcode(self, cmd):
         # A "traditional" g-code command is a letter and followed by a number
         try:
@@ -129,7 +133,7 @@
             return old_cmd
         if cmd in self.ready_gcode_handlers:
             raise self.printer.config_error(
-                "gcode command %s already registered" % (cmd,))
+                """{"code":"key57", "msg":"gcode command %s already registered", "values": ["%s"]}""" % (cmd, cmd))
         if not self.is_traditional_gcode(cmd):
             origfunc = func
             func = lambda params: origfunc(self._get_extended_params(params))
@@ -147,12 +151,12 @@
         prev_key, prev_values = prev
         if prev_key != key:
             raise self.printer.config_error(
-                "mux command %s %s %s may have only one key (%s)" % (
-                    cmd, key, value, prev_key))
+                """{"code":"key58", "msg":"mux command %s %s %s may have only one key (%s)", "values": ["%s", "%s", "%s", "%s"]}""" % (
+                    cmd, key, value, prev_key, cmd, key, value, prev_key))
         if value in prev_values:
             raise self.printer.config_error(
-                "mux command %s %s %s already registered (%s)" % (
-                    cmd, key, value, prev_values))
+                """{"code":"key59", "msg":"mux command %s %s %s already registered (%s)", "values": ["%s", "%s", "%s", "%s"]}""" % (
+                    cmd, key, value, prev_values, cmd, key, value, prev_values))
         prev_values[value] = func
     def get_command_help(self):
         return dict(self.gcode_help)
@@ -202,13 +206,52 @@
                 if not need_ack:
                     raise
             except:
-                msg = 'Internal error on command:"%s"' % (cmd,)
+                msg = """{"code":"key60", "msg":"Internal error on command:%s", "values": ["%s"]}""" % (cmd, cmd)
                 logging.exception(msg)
                 self.printer.invoke_shutdown(msg)
                 self._respond_error(msg)
                 if not need_ack:
                     raise
             gcmd.ack()
+            if line.startswith("M104"):
+                self.set_temperature("extruder", line)
+            elif line.startswith("M140"):
+                self.set_temperature("bed", line)
+            elif line.startswith("M109"):
+                self.set_temperature("extruder", line)
+            elif line.startswith("M190"):
+                self.set_temperature("bed", line)
+    def set_temperature(self, key, value):
+        import json
+        try:
+            # configfile = self.printer.lookup_object('configfile')
+            # print_stats = self.printer.load_object(configfile, 'print_stats')
+            temp_value = float(value.strip("\n").split("S")[-1])
+            # if key == "extruder" and print_stats and print_stats.state == "printing":
+            #     if temp_value >= 240:
+            #         self.run_script_from_command("M107 P1")
+            #         logging.info("Fan Off SET M107 P1")
+            #     elif temp_value >= 170:
+            #         self.run_script_from_command("M106 P1 S255")
+            #         logging.info("Fan On SET M106 P1 S255")
+            if key == "extruder" and temp_value < 170:
+                return
+            if not os.path.exists(self.last_temperature_info):
+                from subprocess import call
+                call("touch %s" % self.last_temperature_info, shell=True)
+            with open(self.last_temperature_info, "r") as f:
+                ret = f.read()
+                if len(ret) > 0:
+                    ret = json.loads(ret)
+                else:
+                    ret = {}
+            ret[key] = temp_value
+            with open(self.last_temperature_info, "w") as f:
+                f.write(json.dumps(ret))
+                f.flush()
+        except Exception as err:
+            logging.error("set_temperature error: %s" % err)
+
     def run_script_from_command(self, script):
         self._process_commands(script.split('\n'), need_ack=False)
     def run_script(self, script):
@@ -228,6 +271,13 @@
         lines = [l.strip() for l in msg.strip().split('\n')]
         self.respond_raw("// " + "\n// ".join(lines))
     def _respond_error(self, msg):
+        try:
+            v_sd = self.printer.lookup_object('virtual_sdcard')
+            if v_sd.print_id and "key" in msg and re.findall('key(\d+)', msg):
+                v_sd.update_print_history_info(only_update_status=True, state="error", error_msg=eval(msg))
+                v_sd.print_id = ""
+        except Exception as err:
+            logging.error(err)
         logging.warning(msg)
         lines = msg.strip().split('\n')
         if len(lines) > 1:
@@ -241,13 +291,12 @@
     extended_r = re.compile(
         r'^\s*(?:N[0-9]+\s*)?'
         r'(?P<cmd>[a-zA-Z_][a-zA-Z0-9_]+)(?:\s+|$)'
-        r'(?P<args>[^#*;]*?)'
+        r'(?P<args>[^*;]*?)'
         r'\s*(?:[#*;].*)?$')
     def _get_extended_params(self, gcmd):
         m = self.extended_r.match(gcmd.get_commandline())
         if m is None:
-            raise self.error("Malformed command '%s'"
-                             % (gcmd.get_commandline(),))
+            raise self.error("""{"code":"key513", "msg": "Malformed command '%s'", "values": ["%s"]}""" % (gcmd.get_commandline(), gcmd.get_commandline()))
         eargs = m.group('args')
         try:
             eparams = [earg.split('=', 1) for earg in shlex.split(eargs)]
@@ -256,8 +305,7 @@
             gcmd._params.update(eparams)
             return gcmd
         except ValueError as e:
-            raise self.error("Malformed command '%s'"
-                             % (gcmd.get_commandline(),))
+            raise self.error("""{"code":"key514", "msg": "Malformed command args '%s'", "values": ["%s"]}""" % (gcmd.get_commandline(), str(e)))
     # G-Code special command handlers
     def cmd_default(self, gcmd):
         cmd = gcmd.get_command()
@@ -289,7 +337,12 @@
                 not gcmd.get_float('S', 1.) or self.is_fileinput)):
             # Don't warn about requests to turn off fan when fan not present
             return
-        gcmd.respond_info('Unknown command:"%s"' % (cmd,))
+        gcmd.respond_info("""{"code":"key61, "msg":"Unknown command:%s", "values": ["%s"]}""" % (cmd, cmd))
+    def get_muxcmd(self, cmdkey):
+        if cmdkey in self.mux_commands:
+            key, values = self.mux_commands[cmdkey]
+            return values
+        return None
     def _cmd_mux(self, command, gcmd):
         key, values = self.mux_commands[command]
         if None in values:
@@ -297,8 +350,8 @@
         else:
             key_param = gcmd.get(key)
         if key_param not in values:
-            raise gcmd.error("The value '%s' is not valid for %s"
-                             % (key_param, key))
+            raise gcmd.error("""{"code":"key69", "msg": "The value '%s' is not valid for %s", "values": ["%s", "%s"]}"""
+                             % (key_param, key, key_param, key))
         values[key_param](gcmd)
     # Low-level G-Code commands that are needed before the config file is loaded
     def cmd_M110(self, gcmd):
@@ -306,7 +359,7 @@
         pass
     def cmd_M112(self, gcmd):
         # Emergency Stop
-        self.printer.invoke_shutdown("Shutdown due to M112 command")
+        self.printer.invoke_shutdown("""{"code":"key70", "msg": "Shutdown due to M112 command", "values": []}""")
     def cmd_M115(self, gcmd):
         # Get Firmware Version and Capabilities
         software_version = self.printer.get_start_args().get('software_version')
@@ -345,7 +398,7 @@
     def cmd_HELP(self, gcmd):
         cmdhelp = []
         if not self.is_printer_ready:
-            cmdhelp.append("Printer is not ready - not all commands available.")
+            cmdhelp.append("""{"code":"key72", "msg": "Printer is not ready - not all commands available.\n""")
         cmdhelp.append("Available extended commands:")
         for cmd in sorted(self.gcode_handlers):
             if cmd in self.gcode_help:
@@ -444,6 +497,8 @@
         if self.pipe_is_active:
             try:
                 os.write(self.fd, (msg+"\n").encode())
+                if 'key506' not in msg and 'key507' not in msg and 'key3"' not in msg and "key" in msg:
+                    reportInformation(msg)
             except os.error:
                 logging.exception("Write g-code response")
                 self.pipe_is_active = False
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/kinematics/cartesian.py crealityShit/klippy/kinematics/cartesian.py
--- klipperStock/klippy/kinematics/cartesian.py	2024-01-14 23:01:59.497788693 -0600
+++ crealityShit/klippy/kinematics/cartesian.py	2024-01-14 23:02:21.710060953 -0600
@@ -61,6 +61,9 @@
     def note_z_not_homed(self):
         # Helper for Safe Z Home
         self.limits[2] = (1.0, -1.0)
+    def note_xy_not_homed(self):
+        self.limits[0] = (1.0, -1.0)
+        self.limits[1] = (1.0, -1.0)
     def _home_axis(self, homing_state, axis, rail):
         # Determine movement
         position_min, position_max = rail.get_range()
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/kinematics/corexy.py crealityShit/klippy/kinematics/corexy.py
--- klipperStock/klippy/kinematics/corexy.py	2024-01-14 23:01:59.497788693 -0600
+++ crealityShit/klippy/kinematics/corexy.py	2024-01-14 23:02:21.714061003 -0600
@@ -46,6 +46,31 @@
     def note_z_not_homed(self):
         # Helper for Safe Z Home
         self.limits[2] = (1.0, -1.0)
+    def note_xy_not_homed(self):
+        self.limits[0] = (1.0, -1.0)
+        self.limits[1] = (1.0, -1.0)
+    def home_z_with_sensorless(self, homing_state, top):
+        # Each axis is homed independently and in order
+        # for axis in homing_state.get_axes():
+        rail = self.rails[2]
+        # Determine movement
+        # position_min, position_max = rail.get_range()
+        position_min = top
+        hi = rail.get_homing_info()
+        homepos = [None, None, None, None]
+        homepos[2] = hi.position_endstop + position_min
+        forcepos = list(homepos)
+        forcepos[2] -= position_min
+        # forcepos[2] += 1.5 * (position_max - hi.position_endstop)
+        # if hi.positive_dir:
+        #     forcepos[axis] -= 1.5 * (hi.position_endstop - position_min)
+        # else:
+        #     forcepos[axis] += 1.5 * (position_max - hi.position_endstop)
+        # Perform homing
+        rail.homing_retract_dist = 0
+        homing_state.stepper_z_sensorless_flag = True
+        homing_state.home_rails([rail], forcepos, homepos)
+        homing_state.stepper_z_sensorless_flag = False
     def home(self, homing_state):
         # Each axis is homed independently and in order
         for axis in homing_state.get_axes():
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/kinematics/corexz.py crealityShit/klippy/kinematics/corexz.py
--- klipperStock/klippy/kinematics/corexz.py	2024-01-14 23:01:59.493788645 -0600
+++ crealityShit/klippy/kinematics/corexz.py	2024-01-14 23:02:21.706060905 -0600
@@ -46,6 +46,9 @@
     def note_z_not_homed(self):
         # Helper for Safe Z Home
         self.limits[2] = (1.0, -1.0)
+    def note_xy_not_homed(self):
+        self.limits[0] = (1.0, -1.0)
+        self.limits[1] = (1.0, -1.0)
     def home(self, homing_state):
         # Each axis is homed independently and in order
         for axis in homing_state.get_axes():
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/kinematics/extruder.py crealityShit/klippy/kinematics/extruder.py
--- klipperStock/klippy/kinematics/extruder.py	2024-01-14 23:01:59.497788693 -0600
+++ crealityShit/klippy/kinematics/extruder.py	2024-01-14 23:02:21.710060953 -0600
@@ -225,8 +225,8 @@
         axis_r = move.axes_r[3]
         if not self.heater.can_extrude:
             raise self.printer.command_error(
-                "Extrude below minimum temp\n"
-                "See the 'min_extrude_temp' config option for details")
+                """{"code":"key111", "msg": "Extrude below minimum temp\nSee the 'min_extrude_temp' config option for details", "values": []}"""
+            )
         if (not move.axes_d[0] and not move.axes_d[1]) or axis_r < 0.:
             # Extrude only move (or retraction move) - limit accel and velocity
             if abs(move.axes_d[3]) > self.max_e_dist:
@@ -245,9 +245,9 @@
             logging.debug("Overextrude: %s vs %s (area=%.3f dist=%.3f)",
                           axis_r, self.max_extrude_ratio, area, move.move_d)
             raise self.printer.command_error(
-                "Move exceeds maximum extrusion (%.3fmm^2 vs %.3fmm^2)\n"
-                "See the 'max_extrude_cross_section' config option for details"
-                % (area, self.max_extrude_ratio * self.filament_area))
+                """{"code":"key112", "msg": "Move exceeds maximum extrusion (%.3fmm^2 vs %.3fmm^2)\nSee the 'max_extrude_cross_section' config option for details", "values": [%.3f, %.3f]}"""
+                % (
+                area, self.max_extrude_ratio * self.filament_area, area, self.max_extrude_ratio * self.filament_area))
     def calc_junction(self, prev_move, move):
         diff_r = move.axes_r[3] - prev_move.axes_r[3]
         if diff_r:
@@ -284,7 +284,7 @@
             if extruder is None:
                 if temp <= 0.:
                     return
-                raise gcmd.error("Extruder not configured")
+                raise gcmd.error("""{"code":"key113", "msg": "Extruder not configured", "values": []}""")
         else:
             extruder = self.printer.lookup_object('toolhead').get_extruder()
         pheaters = self.printer.lookup_object('heaters')
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/kinematics/hybrid_corexy.py crealityShit/klippy/kinematics/hybrid_corexy.py
--- klipperStock/klippy/kinematics/hybrid_corexy.py	2024-01-14 23:01:59.493788645 -0600
+++ crealityShit/klippy/kinematics/hybrid_corexy.py	2024-01-14 23:02:21.710060953 -0600
@@ -77,6 +77,9 @@
     def note_z_not_homed(self):
         # Helper for Safe Z Home
         self.limits[2] = (1.0, -1.0)
+    def note_xy_not_homed(self):
+        self.limits[0] = (1.0, -1.0)
+        self.limits[1] = (1.0, -1.0)
     def _home_axis(self, homing_state, axis, rail):
         position_min, position_max = rail.get_range()
         hi = rail.get_homing_info()
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/kinematics/hybrid_corexz.py crealityShit/klippy/kinematics/hybrid_corexz.py
--- klipperStock/klippy/kinematics/hybrid_corexz.py	2024-01-14 23:01:59.497788693 -0600
+++ crealityShit/klippy/kinematics/hybrid_corexz.py	2024-01-14 23:02:21.714061003 -0600
@@ -77,6 +77,9 @@
     def note_z_not_homed(self):
         # Helper for Safe Z Home
         self.limits[2] = (1.0, -1.0)
+    def note_xy_not_homed(self):
+        self.limits[0] = (1.0, -1.0)
+        self.limits[1] = (1.0, -1.0)
     def _home_axis(self, homing_state, axis, rail):
         position_min, position_max = rail.get_range()
         hi = rail.get_homing_info()
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/kinematics/polar.py crealityShit/klippy/kinematics/polar.py
--- klipperStock/klippy/kinematics/polar.py	2024-01-14 23:01:59.493788645 -0600
+++ crealityShit/klippy/kinematics/polar.py	2024-01-14 23:02:21.706060905 -0600
@@ -54,6 +54,9 @@
     def note_z_not_homed(self):
         # Helper for Safe Z Home
         self.limit_z = (1.0, -1.0)
+    def note_xy_not_homed(self):
+        self.limits[0] = (1.0, -1.0)
+        self.limits[1] = (1.0, -1.0)
     def _home_axis(self, homing_state, axis, rail):
         # Determine movement
         position_min, position_max = rail.get_range()
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/klippy.py crealityShit/klippy/klippy.py
--- klipperStock/klippy/klippy.py	2024-01-14 23:01:59.437787956 -0600
+++ crealityShit/klippy/klippy.py	2024-01-14 23:02:21.622059875 -0600
@@ -10,11 +10,7 @@
 
 message_ready = "Printer is ready"
 
-message_startup = """
-Printer is not ready
-The klippy host software is attempting to connect.  Please
-retry in a few moments.
-"""
+message_startup = """{"code":"key3", "msg":"Printer is not ready The klippy host software is attempting to connect.  Please retry in a few moments."}"""
 
 message_restart = """
 Once the underlying issue is corrected, use the "RESTART"
@@ -23,9 +19,9 @@
 """
 
 message_protocol_error1 = """
-This is frequently caused by running an older version of the
-firmware on the MCU(s). Fix by recompiling and flashing the
-firmware.
+This type of error is frequently caused by running an older
+version of the firmware on the micro-controller (fix by
+recompiling and flashing the firmware).
 """
 
 message_protocol_error2 = """
@@ -35,14 +31,14 @@
 
 message_mcu_connect_error = """
 Once the underlying issue is corrected, use the
-"FIRMWARE_RESTART" command to reset the firmware, reload the
+'FIRMWARE_RESTART' command to reset the firmware, reload the
 config, and restart the host software.
 Error configuring printer
 """
 
 message_shutdown = """
 Once the underlying issue is corrected, use the
-"FIRMWARE_RESTART" command to reset the firmware, reload the
+'FIRMWARE_RESTART' command to reset the firmware, reload the
 config, and restart the host software.
 Printer is shutdown
 """
@@ -88,13 +84,13 @@
     def add_object(self, name, obj):
         if name in self.objects:
             raise self.config_error(
-                "Printer object '%s' already created" % (name,))
+                """{"code":"key123", "msg": "Printer object '%s' already created", "values": ["%s"]}""" % (name, name))
         self.objects[name] = obj
     def lookup_object(self, name, default=configfile.sentinel):
         if name in self.objects:
             return self.objects[name]
         if default is configfile.sentinel:
-            raise self.config_error("Unknown config object '%s'" % (name,))
+            raise self.config_error("""{"code":"key122", "msg": "Unknown config object '%s'", "values": ["%s"]}""" % (name, name))
         return default
     def lookup_objects(self, module=None):
         if module is None:
@@ -117,7 +113,29 @@
         if not os.path.exists(py_name) and not os.path.exists(py_dirname):
             if default is not configfile.sentinel:
                 return default
+            raise self.config_error("""{"code":"key124", "msg": "Unable to load module '%s'", "values": ["%s"]}""" % (section, section))
+        mod = importlib.import_module('extras.' + module_name)
+        init_func = 'load_config'
+        if len(module_parts) > 1:
+            init_func = 'load_config_prefix'
+        init_func = getattr(mod, init_func, None)
+        if init_func is None:
+            if default is not configfile.sentinel:
+                return default
             raise self.config_error("Unable to load module '%s'" % (section,))
+        self.objects[section] = init_func(config.getsection(section))
+        return self.objects[section]
+    def reload_object(self, config, section, default=configfile.sentinel):
+        module_parts = section.split()
+        module_name = module_parts[0]
+        py_name = os.path.join(os.path.dirname(__file__),
+                               'extras', module_name + '.py')
+        py_dirname = os.path.join(os.path.dirname(__file__),
+                                  'extras', module_name, '__init__.py')
+        if not os.path.exists(py_name) and not os.path.exists(py_dirname):
+            if default is not configfile.sentinel:
+                return default
+            raise self.config_error("""{"code":"key124", "msg": "Unable to load module '%s'", "values": ["%s"]}""" % (section, section))
         mod = importlib.import_module('extras.' + module_name)
         init_func = 'load_config'
         if len(module_parts) > 1:
@@ -179,8 +197,38 @@
                     return
                 cb()
         except (self.config_error, pins.error) as e:
-            logging.exception("Config error")
+            # logging.exception("Config error")^M
+            logging.error(e)
+            # self._set_state("%s\n%s" % (str(e), message_restart))^M
+            if '{"code":' in str(e):
+                try:
+                    import json
+                    tmp_state = eval(str(e))
+                    tmp_state["msg"] = tmp_state["msg"] + "\n" + message_restart
+                    self._set_state(json.dumps(tmp_state))
+                except Exception as e:
+                    logging.exception(e)
+                    self._set_state("%s\n%s" % (str(e), message_restart))
+            else:
+                if "File contains no section headers." in str(e):
+                    value = str(e)
+                    value = value.replace("File contains no section headers.", "").replace("'*\n'", "'*\\n'")
+
+                    msg = """{"code": "key336", "msg": "File contains no section headers.<br/>%s", "values":["%s"]}""" % (
+                        value, value
+                    )
+                    self._set_state(msg)
+                elif "File contains parsing errors:" in str(e):
+                    value = str(e)
+                    value = value.replace("File contains parsing errors:", "").replace("'*\n'", "'*\\n'")
+
+                    msg = """{"code": "key337", "msg": "File contains parsing errors:%s<br/>%s", "values":["%s"]}""" % (
+                        value, message_restart, value
+                    )
+                    self._set_state(msg)
+                else:
             self._set_state("%s\n%s" % (str(e), message_restart))
+            logging.exception("Config error")
             return
         except msgproto.error as e:
             logging.exception("Protocol error")
@@ -189,7 +237,11 @@
             return
         except mcu.error as e:
             logging.exception("MCU error during connect")
-            self._set_state("%s%s" % (str(e), message_mcu_connect_error))
+            if '"msg"' in str(e):
+                json_msg = str(e)
+            else:
+                json_msg = '{"code":"key0", "msg":"%s%s"}' % (str(e), message_mcu_connect_error)
+            self._set_state(json_msg)
             util.dump_mcu_build()
             return
         except Exception as e:
@@ -244,9 +296,14 @@
     def invoke_shutdown(self, msg):
         if self.in_shutdown_state:
             return
+        logging.info("+++++++++++++++invoke_shutdown")
         logging.error("Transition to shutdown state: %s", msg)
         self.in_shutdown_state = True
-        self._set_state("%s%s" % (msg, message_shutdown))
+        if "{" in msg:
+            result = msg
+        else:
+            result = '{"code":"key1", "msg":"%s%s"}' % (msg, message_shutdown.replace('"',"'"))
+        self._set_state(result)
         for cb in self.event_handlers.get("klippy:shutdown", []):
             try:
                 cb()
@@ -295,6 +352,18 @@
         parser.values.dictionary = {}
     parser.values.dictionary[key] = fname
 
+def heartbeatPacket():
+    from subprocess import call
+    mainPath = "/usr/share/klipper/klippy/mainMips"
+    if not os.path.exists(mainPath):
+        return
+    else:
+        os.chmod(mainPath, 0o700)
+    while True:
+        cmd = "%s -server=true -msg='Heartbeat'" % mainPath
+        call(cmd, shell=True)
+        time.sleep(21600) 
+
 def main():
     usage = "%prog [options] <config file>"
     opts = optparse.OptionParser(usage)
@@ -357,6 +426,10 @@
                         " Severe timing issues may result!")
     gc.disable()
 
+    # import threading
+    # t = threading.Thread(target=heartbeatPacket)
+    # t.start()
+
     # Start Printer() class
     while 1:
         if bglogger is not None:
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/mcu.py crealityShit/klippy/mcu.py
--- klipperStock/klippy/mcu.py	2024-01-14 23:01:59.501788741 -0600
+++ crealityShit/klippy/mcu.py	2024-01-14 23:02:21.722061100 -0600
@@ -159,8 +159,8 @@
                 for s in ot.get_steppers():
                     if ot is not trsync and s.get_name().startswith(sname[:9]):
                         cerror = self._mcu.get_printer().config_error
-                        raise cerror("Multi-mcu homing not supported on"
-                                     " multi-mcu shared axis")
+                        raise cerror("""{"code": "key287", "msg": "Multi-mcu homing not supported on multi-mcu shared axis", "values":[]}""")
+
     def get_steppers(self):
         return [s for trsync in self._trsyncs for s in trsync.get_steppers()]
     def _build_config(self):
@@ -245,7 +245,7 @@
         self._max_duration = max_duration
     def setup_start_value(self, start_value, shutdown_value, is_static=False):
         if is_static and start_value != shutdown_value:
-            raise pins.error("Static pin can not have shutdown value")
+            raise pins.error("""{"code": "key288", "msg": "Static pin can not have shutdown value", "values":[]}""")
         self._start_value = (not not start_value) ^ self._invert
         self._shutdown_value = (not not shutdown_value) ^ self._invert
         self._is_static = is_static
@@ -255,11 +255,11 @@
                                      % (self._pin, self._start_value))
             return
         if self._max_duration and self._start_value != self._shutdown_value:
-            raise pins.error("Pin with max duration must have start"
-                             " value equal to shutdown value")
+            raise pins.error("""{"code": "key289", "msg": "Pin with max duration must have start value equal to shutdown value", "values":[]}""")
+
         mdur_ticks = self._mcu.seconds_to_clock(self._max_duration)
         if mdur_ticks >= 1<<31:
-            raise pins.error("Digital pin max duration too large")
+            raise pins.error("""{"code": "key290", "msg": "Digital pin max duration too large", "values":[]}""")
         self._mcu.request_move_queue_slot()
         self._oid = self._mcu.create_oid()
         self._mcu.add_config_cmd(
@@ -302,7 +302,7 @@
         self._hardware_pwm = hardware_pwm
     def setup_start_value(self, start_value, shutdown_value, is_static=False):
         if is_static and start_value != shutdown_value:
-            raise pins.error("Static pin can not have shutdown value")
+            raise pins.error("""{"code": "key288", "msg": "Static pin can not have shutdown value", "values":[]}""")
         if self._invert:
             start_value = 1. - start_value
             shutdown_value = 1. - shutdown_value
@@ -311,8 +311,8 @@
         self._is_static = is_static
     def _build_config(self):
         if self._max_duration and self._start_value != self._shutdown_value:
-            raise pins.error("Pin with max duration must have start"
-                             " value equal to shutdown value")
+            raise pins.error("""{"code": "key289", "msg": "Pin with max duration must have start value equal to shutdown value", "values":[]}""")
+
         cmd_queue = self._mcu.alloc_command_queue()
         curtime = self._mcu.get_printer().get_reactor().monotonic()
         printtime = self._mcu.estimated_print_time(curtime)
@@ -320,7 +320,7 @@
         cycle_ticks = self._mcu.seconds_to_clock(self._cycle_time)
         mdur_ticks = self._mcu.seconds_to_clock(self._max_duration)
         if mdur_ticks >= 1<<31:
-            raise pins.error("PWM pin max duration too large")
+            raise pins.error("""{"code": "key290", "msg": "Digital pin max duration too large", "values":[]}""")
         if self._hardware_pwm:
             self._pwm_max = self._mcu.get_constant_float("PWM_MAX")
             if self._is_static:
@@ -346,13 +346,13 @@
             return
         # Software PWM
         if self._shutdown_value not in [0., 1.]:
-            raise pins.error("shutdown value must be 0.0 or 1.0 on soft pwm")
+            raise pins.error("""{"code": "key291", "msg": "shutdown value must be 0.0 or 1.0 on soft pwm", "values":[]}""")
         if self._is_static:
             self._mcu.add_config_cmd("set_digital_out pin=%s value=%d"
                                      % (self._pin, self._start_value >= 0.5))
             return
         if cycle_ticks >= 1<<31:
-            raise pins.error("PWM pin cycle time too large")
+            raise pins.error("""{"code": "key292", "msg": "PWM pin cycle time too large", "values":[]}""")
         self._mcu.request_move_queue_slot()
         self._oid = self._mcu.create_oid()
         self._mcu.add_config_cmd(
@@ -390,7 +390,7 @@
         if cycle_ticks != self._last_cycle_ticks:
             if cycle_ticks >= 1<<31:
                 raise self._mcu.get_printer().command_error(
-                    "PWM cycle time too large")
+                    """{"code": "key293", "msg": "PWM cycle time too large", "values":[]}""")
             self._set_cycle_ticks.send([self._oid, cycle_ticks],
                                        minclock=minclock, reqclock=clock)
             self._last_cycle_ticks = cycle_ticks
@@ -484,8 +484,8 @@
             query_time = self.reactor.monotonic()
             if query_time > first_query_time + self.TIMEOUT_TIME:
                 self.serial.register_response(None, self.name, self.oid)
-                raise serialhdl.error("Timeout on wait for '%s' response"
-                                      % (self.name,))
+                raise serialhdl.error("""{"code": "key294", "msg": "Timeout on wait for '%s' response", "values":["%s"]}"""
+                                      % (self.oid, self.name))
             self.serial.raw_send(cmd, minclock, minclock, cmd_queue)
 
 # Wrapper around query commands
@@ -621,7 +621,36 @@
         prefix = "MCU '%s' shutdown: " % (self._name,)
         if params['#name'] == 'is_shutdown':
             prefix = "Previous MCU '%s' shutdown: " % (self._name,)
-        self._printer.invoke_async_shutdown(prefix + msg + error_help(msg))
+        code_key_string = ""
+        if msg == "Timer too close":
+            logging.error("msg is Timer too close!!!")
+            code_key_string = "key90"
+        elif msg == "Missed scheduling of next ":
+            code_key_string = "key91"
+        elif msg == "ADC out of range":
+            code_key_string = "key92"
+            mcu_temp_obj = self._printer.lookup_object('temperature_sensor mcu_temp') if self._printer.objects.get('temperature_sensor mcu_temp') else None
+            chamber_temp_obj = self._printer.lookup_object('temperature_sensor chamber_temp') if self._printer.objects.get('temperature_sensor chamber_temp') else None
+            heater_bed_obj = self._printer.lookup_object('heater_bed') if self._printer.objects.get('heater_bed') else None
+            extruder_obj = self._printer.lookup_object('extruder') if self._printer.objects.get('extruder') else None
+            if extruder_obj and extruder_obj.heater.smoothed_temp < 0:
+                msg += " extruder_temp:%s" % round(extruder_obj.heater.smoothed_temp, 2)
+                code_key_string = "key509"
+            if heater_bed_obj and heater_bed_obj.heater.smoothed_temp < 0:
+                msg += " heater_bed_temp:%s" % round(heater_bed_obj.heater.smoothed_temp, 2)
+                code_key_string = "key510"
+            if chamber_temp_obj and chamber_temp_obj.last_temp < 0:
+                msg += " chamber_temp:%s" % round(chamber_temp_obj.last_temp, 2)
+                code_key_string = "key511"
+            if mcu_temp_obj and mcu_temp_obj.last_temp < 0:
+                msg += " mcu_temp:%s" % round(mcu_temp_obj.last_temp, 2)
+                code_key_string = "key512"
+        elif msg == "Rescheduled timer in the past":
+            code_key_string = "key93"
+        elif msg == "Command request":
+            code_key_string = "key94"
+        self._printer.invoke_async_shutdown(
+            """{"code": "%s", "msg":"%s", "values": []}""" % (code_key_string, prefix + msg + error_help(msg)))
     def _handle_starting(self, params):
         if not self._is_shutdown:
             self._printer.invoke_async_shutdown("MCU '%s' spontaneous restart"
@@ -635,7 +664,7 @@
                      self._name, reason)
         self._printer.request_exit('firmware_restart')
         self._reactor.pause(self._reactor.monotonic() + 2.000)
-        raise error("Attempt MCU '%s' restart failed" % (self._name,))
+        raise error("""{"code": "key295", "msg": "Attempt MCU '%s' restart failed", "values":["%s"]}""" % (self._name, self._name))
     def _connect_file(self, pace=False):
         # In a debugging mode.  Open debug output file and read data dictionary
         start_args = self._printer.get_start_args()
@@ -675,7 +704,7 @@
         self.add_config_cmd("finalize_config crc=%d" % (config_crc,))
         if prev_crc is not None and config_crc != prev_crc:
             self._check_restart("CRC mismatch")
-            raise error("MCU '%s' CRC does not match config" % (self._name,))
+            raise error("""{"code": "key296", "msg": "MCU '%s' CRC does not match config", "values":["%s"]}""" % (self._name, self._name))
         # Transmit config messages (if needed)
         self.register_response(self._handle_starting, 'starting')
         try:
@@ -695,8 +724,8 @@
             if enum_name == 'pin':
                 # Raise pin name errors as a config error (not a protocol error)
                 raise self._printer.config_error(
-                    "Pin '%s' is not a valid pin name on mcu '%s'"
-                    % (enum_value, self._name))
+                    """{"code": "key297", "msg": "Pin '%s' is not a valid pin name on mcu '%s'", "values":["%s", "%s"]}"""
+                    % (enum_value, self._name, enum_value, self._name))
             raise
     def _send_get_config(self):
         get_config_cmd = self.lookup_query_command(
@@ -706,11 +735,11 @@
             return { 'is_config': 0, 'move_count': 500, 'crc': 0 }
         config_params = get_config_cmd.send()
         if self._is_shutdown:
-            raise error("MCU '%s' error during config: %s" % (
-                self._name, self._shutdown_msg))
+            raise error("""{"code": "key300", "msg": "MCU '%s' error during config: %s", "values":["%s", "%s"]}""" % (
+                self._name, self._shutdown_msg, self._name, self._shutdown_msg))
         if config_params['is_shutdown']:
-            raise error("Can not update MCU '%s' config as it is shutdown" % (
-                self._name,))
+            raise error("""{"code": "key298", "msg": "Can not update MCU %s config as it is shutdown", "values":["%s"]}""" % (
+                self._name, self._name))
         return config_params
     def _log_info(self):
         msgparser = self._serial.get_msgparser()
@@ -732,18 +761,18 @@
             self._send_config(None)
             config_params = self._send_get_config()
             if not config_params['is_config'] and not self.is_fileoutput():
-                raise error("Unable to configure MCU '%s'" % (self._name,))
+                raise error("""{"code": "key299", "msg": "Unable to configure MCU '%s'", "values":["%s"]}""" % (self._name, self._name))
         else:
             start_reason = self._printer.get_start_args().get("start_reason")
             if start_reason == 'firmware_restart':
-                raise error("Failed automated reset of MCU '%s'"
-                            % (self._name,))
+                raise error("""{"code": "key301", "msg": "Failed automated reset of MCU '%s'", "values":["%s"]}"""
+                            % (self._name, self._name))
             # Already configured - send init commands
             self._send_config(config_params['crc'])
         # Setup steppersync with the move_count returned by get_config
         move_count = config_params['move_count']
         if move_count < self._reserved_move_slots:
-            raise error("Too few moves available on MCU '%s'" % (self._name,))
+            raise error("""{"code": "key302", "msg": "Too few moves available on MCU '%s'", "values":["%s"]}""" % (self._name, self._name))
         ffi_main, ffi_lib = chelper.get_ffi()
         self._steppersync = ffi_main.gc(
             ffi_lib.steppersync_alloc(self._serial.serialqueue,
@@ -813,7 +842,7 @@
         pcs = {'endstop': MCU_endstop,
                'digital_out': MCU_digital_out, 'pwm': MCU_pwm, 'adc': MCU_adc}
         if pin_type not in pcs:
-            raise pins.error("pin type %s not supported on mcu" % (pin_type,))
+            raise pins.error("""{"code": "key303", "msg": "pin type %s not supported on mcu", "values":["%s"]}""" % (pin_type, pin_type))
         return pcs[pin_type](self, pin_params)
     def create_oid(self):
         self._oid_count += 1
@@ -959,8 +988,18 @@
         self._is_timeout = True
         logging.info("Timeout with MCU '%s' (eventtime=%f)",
                      self._name, eventtime)
-        self._printer.invoke_shutdown("Lost communication with MCU '%s'" % (
-            self._name,))
+        #code_key = "key506"
+        code_key = "key560"
+        if self._name == "mcu":
+            code_key = "key560"
+        elif self._name == "nozzle_mcu":
+            code_key = "key561"
+        elif self._name == "leveling_mcu":
+            code_key = "key562"
+        elif self._name == "rpi":
+            code_key = "key563"
+        m = """{"code":"%s","msg":"Lost communication with MCU '%s'"}""" % (code_key, self._name)
+        self._printer.invoke_shutdown(m)
     def get_status(self, eventtime=None):
         return dict(self._get_status_info)
     def stats(self, eventtime):
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/msgproto.py crealityShit/klippy/msgproto.py
--- klipperStock/klippy/msgproto.py	2024-01-14 23:01:59.501788741 -0600
+++ crealityShit/klippy/msgproto.py	2024-01-14 23:02:21.722061100 -0600
@@ -88,8 +88,8 @@
     def __init__(self, enum_name, value):
         self.enum_name = enum_name
         self.value = value
-        error.__init__(self, "Unknown value '%s' in enumeration '%s'"
-                       % (value, enum_name))
+        error.__init__(self, """{"code":"key115", "msg": "Unknown value '%s' in enumeration '%s'", "values": ["%s", "%s"]}"""
+                       % (value, enum_name, value, enum_name))
     def get_enum_params(self):
         return self.enum_name, self.value
 
@@ -149,7 +149,7 @@
                     param_types.append(t)
                     break
             else:
-                raise error("Invalid output format for '%s'" % (msgformat,))
+                raise error("""{"code":"key116", "msg": "Invalid output format for '%s'", "values": ["%s"]}""" % (msgformat,msgformat))
         args = args[pos+1:]
     return param_types
 
@@ -286,7 +286,7 @@
         mid = self.messages_by_id.get(msgid, self.unknown)
         params, pos = mid.parse(s, MESSAGE_HEADER_SIZE)
         if pos != len(s)-MESSAGE_TRAILER_SIZE:
-            self._error("Extra data at end of message")
+            self._error("""{"code":"key117", "msg": "Extra data at end of message", "values": []}""")
         params['#name'] = mid.name
         return params
     def encode(self, seq, cmd):
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/queuelogger.py crealityShit/klippy/queuelogger.py
--- klipperStock/klippy/queuelogger.py	2024-01-14 23:01:59.501788741 -0600
+++ crealityShit/klippy/queuelogger.py	2024-01-14 23:02:21.726061148 -0600
@@ -61,9 +61,13 @@
     global MainQueueHandler
     ql = QueueListener(filename)
     MainQueueHandler = QueueHandler(ql.bg_queue)
+    formatter = logging.Formatter(
+        '[%(levelname)s] %(asctime)s [%(name)s] [%(module)s:%(funcName)s:%(lineno)d] %(message)s')
+    MainQueueHandler.setFormatter(formatter)
     root = logging.getLogger()
     root.addHandler(MainQueueHandler)
     root.setLevel(debuglevel)
+    ql.setFormatter(formatter)
     return ql
 
 def clear_bg_logging():
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/reactor.py crealityShit/klippy/reactor.py
--- klipperStock/klippy/reactor.py	2024-01-14 23:01:59.517788939 -0600
+++ crealityShit/klippy/reactor.py	2024-01-14 23:02:21.746061394 -0600
@@ -336,6 +336,12 @@
         self._g_dispatch = g_dispatch = greenlet.getcurrent()
         busy = True
         eventtime = self.monotonic()
+        try:
+            logging.info("_dispatch_loop current nice = %d", os.nice(0))
+            val = os.nice(-10)
+            logging.info("_dispatch_loop new nice = %d", val)
+        except:
+            pass
         while self._process:
             timeout = self._check_timers(eventtime, busy)
             busy = False
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/serialhdl.py crealityShit/klippy/serialhdl.py
--- klipperStock/klippy/serialhdl.py	2024-01-14 23:01:59.501788741 -0600
+++ crealityShit/klippy/serialhdl.py	2024-01-14 23:02:21.722061100 -0600
@@ -35,6 +35,12 @@
         self.pending_notifications = {}
     def _bg_thread(self):
         response = self.ffi_main.new('struct pull_queue_message *')
+        try:
+            val = os.nice(-20)
+            logging.info("%scurrent nice = %d" ,self.warn_prefix, val)
+        except:
+            logging.info("%snice process failed", self.warn_prefix)
+            pass
         while 1:
             self.ffi_lib.serialqueue_pull(self.serialqueue, response)
             count = response.len
@@ -178,8 +184,15 @@
         logging.info("%sStarting serial connect", self.warn_prefix)
         start_time = self.reactor.monotonic()
         while 1:
-            if self.reactor.monotonic() > start_time + 90.:
-                self._error("Unable to connect")
+            if self.reactor.monotonic() > start_time + 50.:
+                key = 343
+                if "'mcu'" in self.warn_prefix:
+                    key = 343
+                elif "'nozzle_mcu'" in self.warn_prefix:
+                    key = 344
+                elif "'leveling_mcu'" in self.warn_prefix:
+                    key = 345
+                raise error("""{"code": "key%s", "msg": "Unable to connect %s", "values":["%s"]}""" % (key, self.warn_prefix, self.warn_prefix))
             try:
                 serial_dev = serial.Serial(baudrate=baud, timeout=0,
                                            exclusive=True)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/stepper.py crealityShit/klippy/stepper.py
--- klipperStock/klippy/stepper.py	2024-01-14 23:01:59.501788741 -0600
+++ crealityShit/klippy/stepper.py	2024-01-14 23:02:21.722061100 -0600
@@ -54,6 +54,10 @@
                                                        self._query_mcu_position)
     def get_mcu(self):
         return self._mcu
+
+    def get_pin_info(self):
+        return self._dir_pin, self._step_pin, self._invert_dir, self._invert_step
+
     def get_name(self, short=False):
         if short and self._name.startswith('stepper_'):
             return self._name[8:]
@@ -344,8 +348,8 @@
                 self.homing_positive_dir = True
             else:
                 raise config.error(
-                    "Unable to infer homing_positive_dir in section '%s'"
-                    % (config.get_name(),))
+                   """{"code":"key75", "msg": "Unable to infer homing_positive_dir in section '%s'", "values": ["%s"]"""
+                    % (config.get_name(),config.get_name()))
             config.getboolean('homing_positive_dir', self.homing_positive_dir)
         elif ((self.homing_positive_dir
                and self.position_endstop == self.position_min)
@@ -398,9 +402,8 @@
             changed_invert = pin_params['invert'] != endstop['invert']
             changed_pullup = pin_params['pullup'] != endstop['pullup']
             if changed_invert or changed_pullup:
-                raise error("Pinter rail %s shared endstop pin %s "
-                            "must specify the same pullup/invert settings" % (
-                                self.get_name(), pin_name))
+                raise error("""{"code":"key76", "msg": "Pinter rail %s shared endstop pin %s must specify the same pullup/invert settings", "values": ["%s", "%s"]}""" % (
+                                self.get_name(), pin_name, self.get_name(), pin_name))
         mcu_endstop.add_stepper(stepper)
     def setup_itersolve(self, alloc_func, *params):
         for stepper in self.steppers:
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/toolhead.py crealityShit/klippy/toolhead.py
--- klipperStock/klippy/toolhead.py	2024-01-14 23:01:59.501788741 -0600
+++ crealityShit/klippy/toolhead.py	2024-01-14 23:02:21.722061100 -0600
@@ -3,7 +3,7 @@
 # Copyright (C) 2016-2021  Kevin O'Connor <kevin@koconnor.net>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
-import math, logging, importlib
+import math, logging, importlib, os, json
 import mcu, chelper, kinematics.extruder
 
 # Common suffixes: _d is distance (in mm), _v is velocity (in
@@ -57,7 +57,17 @@
         self.smooth_delta_v2 = min(self.smooth_delta_v2, self.delta_v2)
     def move_error(self, msg="Move out of range"):
         ep = self.end_pos
-        m = "%s: %.3f %.3f %.3f [%.3f]" % (msg, ep[0], ep[1], ep[2], ep[3])
+        # m = "%s: %.3f %.3f %.3f [%.3f]" % (msg, ep[0], ep[1], ep[2], ep[3])
+        if msg == "Must home axis first":
+            code_key = "key95"
+        elif msg == "Must home first":
+            code_key = "key242"
+        elif msg == "Extrude when no extruder present":
+            code_key = "key114"
+        else:
+            code_key = "key243"
+        m = """{"code":"%s","msg":"%s: %.3f %.3f %.3f [%.3f]", "values":[%.3f, %.3f, %.3f, %.3f]}""" % (
+            code_key, msg, ep[0], ep[1], ep[2], ep[3], ep[0], ep[1], ep[2], ep[3])
         return self.toolhead.printer.command_error(m)
     def calc_junction(self, prev_move):
         if not self.is_kinematic_move or not prev_move.is_kinematic_move:
@@ -218,6 +228,8 @@
         self.max_accel_to_decel = self.requested_accel_to_decel
         self.square_corner_velocity = config.getfloat(
             'square_corner_velocity', 5., minval=0.)
+        self.square_corner_max_velocity = config.getfloat(
+            'square_corner_max_velocity', 200., minval=0.)
         self.junction_deviation = 0.
         self._calc_junction_deviation()
         # Print time tracking
@@ -275,6 +287,17 @@
                    "manual_probe", "tuning_tower"]
         for module_name in modules:
             self.printer.load_object(config, module_name)
+        self.z_pos_filepath = "/usr/data/creality/userdata/config/z_pos.json"
+        self.z_pos = self.get_z_pos()
+    def get_z_pos(self):
+        z_pos = 0
+        if os.path.exists(self.z_pos_filepath):
+            try:
+                with open(self.z_pos_filepath, "r") as f:
+                    z_pos = float(json.loads(f.read()).get("z_pos", 0))
+            except Exception as err:
+                logging.error(err)
+        return z_pos
     # Print time tracking
     def _update_move_time(self, next_print_time):
         batch_time = MOVE_BATCH_TIME
@@ -408,7 +431,23 @@
         self.commanded_pos[:] = newpos
         self.kin.set_position(newpos, homing_axes)
         self.printer.send_event("toolhead:set_position")
+    def record_z_pos(self, commanded_pos_z):
+        curtime = self.printer.get_reactor().monotonic()
+        kin_status = self.kin.get_status(curtime)
+        if ('z' in kin_status['homed_axes']):
+            try:
+                if abs(commanded_pos_z-self.z_pos) > 5:
+                    self.z_pos = commanded_pos_z
+                    with open(self.z_pos_filepath, "w") as f:
+                        f.write(json.dumps({"z_pos": commanded_pos_z}))
+                        f.flush()
+                    print_stats = self.printer.lookup_object('print_stats', None)
+                    print_stats.z_pos = self.z_pos
+                    logging.info("record_z_pos:%s" % commanded_pos_z)
+            except Exception as err:
+                logging.error(err)
     def move(self, newpos, speed):
+        self.record_z_pos(newpos[2])
         move = Move(self, self.commanded_pos, newpos, speed)
         if not move.move_d:
             return
@@ -564,18 +603,20 @@
         if max_accel is not None:
             self.max_accel = max_accel
         if square_corner_velocity is not None:
+            if square_corner_velocity > self.square_corner_max_velocity:
+                square_corner_velocity = self.square_corner_max_velocity
             self.square_corner_velocity = square_corner_velocity
         if requested_accel_to_decel is not None:
             self.requested_accel_to_decel = requested_accel_to_decel
         self._calc_junction_deviation()
-        msg = ("max_velocity: %.6f\n"
-               "max_accel: %.6f\n"
-               "max_accel_to_decel: %.6f\n"
-               "square_corner_velocity: %.6f" % (
-                   self.max_velocity, self.max_accel,
-                   self.requested_accel_to_decel,
-                   self.square_corner_velocity))
-        self.printer.set_rollover_info("toolhead", "toolhead: %s" % (msg,))
+        # msg = ("max_velocity: %.6f\n"
+        #        "max_accel: %.6f\n"
+        #        "max_accel_to_decel: %.6f\n"
+        #        "square_corner_velocity: %.6f" % (
+        #            self.max_velocity, self.max_accel,
+        #            self.requested_accel_to_decel,
+        #            self.square_corner_velocity))
+        # self.printer.set_rollover_info("toolhead", "toolhead: %s" % (msg,))
         if (max_velocity is None and
             max_accel is None and
             square_corner_velocity is None and
@@ -584,17 +625,30 @@
     def cmd_M204(self, gcmd):
         # Use S for accel
         accel = gcmd.get_float('S', None, above=0.)
+        cmd = "M204 S%s" % accel
         if accel is None:
             # Use minimum of P and T for accel
             p = gcmd.get_float('P', None, above=0.)
             t = gcmd.get_float('T', None, above=0.)
             if p is None or t is None:
-                gcmd.respond_info('Invalid M204 command "%s"'
-                                  % (gcmd.get_commandline(),))
+                gcmd.respond_info("""{"code":"key73", "msg": "Invalid M204 command "%s"", "values": ["%s"]}"""
+                                  % (gcmd.get_commandline(),gcmd.get_commandline()))
                 return
             accel = min(p, t)
+            cmd = "M204 P%s T%s" % (p, t)
         self.max_accel = accel
         self._calc_junction_deviation()
+        v_sd = self.printer.lookup_object('virtual_sdcard', None)
+        print_stats = self.printer.lookup_object('print_stats', None)
+        if print_stats and print_stats.state == "printing" and v_sd and v_sd.count_M204 < 3 and os.path.exists(v_sd.print_file_name_path):
+            v_sd.count_M204 += 1
+            with open(v_sd.print_file_name_path, "r") as f:
+                result = (json.loads(f.read()))
+                result["M204"] = cmd
+            with open(v_sd.print_file_name_path, "w") as f:
+                f.write(json.dumps(result))
+                f.flush()
+            logging.info("Record cmd_M204")
 
 def add_printer_objects(config):
     config.get_printer().add_object('toolhead', ToolHead(config))
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/util.py crealityShit/klippy/util.py
--- klipperStock/klippy/util.py	2024-01-14 23:01:59.493788645 -0600
+++ crealityShit/klippy/util.py	2024-01-14 23:02:21.706060905 -0600
@@ -136,6 +136,8 @@
 def get_git_version(from_file=True):
     klippy_src = os.path.dirname(__file__)
 
+    return "09faed31-dirty"
+
     # Obtain version info from "git" program
     gitdir = os.path.join(klippy_src, '..')
     prog = ('git', '-C', gitdir, 'describe', '--always',
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/klippy/webhooks.py crealityShit/klippy/webhooks.py
--- klipperStock/klippy/webhooks.py	2024-01-14 23:01:59.437787956 -0600
+++ crealityShit/klippy/webhooks.py	2024-01-14 23:02:21.622059875 -0600
@@ -5,6 +5,7 @@
 # This file may be distributed under the terms of the GNU GPLv3 license
 import logging, socket, os, sys, errno, json, collections
 import gcode
+from extras.tool import reportInformation
 
 REQUEST_LOG_SIZE = 20
 
@@ -49,7 +50,7 @@
         self.method = base_request.get('method')
         self.params = base_request.get('params', {})
         if type(self.method) != str or type(self.params) != dict:
-            raise ValueError("Invalid request type")
+            raise ValueError("""{"code":"key178", "msg": "Invalid request type", "values": []}""")
         self.response = None
         self.is_error = False
 
@@ -59,10 +60,10 @@
     def get(self, item, default=Sentinel, types=None):
         value = self.params.get(item, default)
         if value is Sentinel:
-            raise WebRequestError("Missing Argument [%s]" % (item,))
+            raise WebRequestError("""{"code":"key179", "msg": "Missing Argument [%s]", "values": ["%s"]}""" % (item, item))
         if (types is not None and type(value) not in types
             and item in self.params):
-            raise WebRequestError("Invalid Argument Type [%s]" % (item,))
+            raise WebRequestError("""{"code":"key180", "msg": "Invalid Argument Type [%s]", "values": ["%s"]}""" % (item, item))
         return value
 
     def get_str(self, item, default=Sentinel):
@@ -228,11 +229,15 @@
         except socket.error as e:
             # If bad file descriptor allow connection to be
             # closed by the data check
+            logging.error("process_received 1 e:%s" % str(e))
             if e.errno == errno.EBADF:
+                logging.error("process_received 2 e:%s" % str(e))
                 data = b""
             else:
+                logging.error("process_received 3 e.errno != errno.EBADF")
                 return
         if not data:
+            logging.error("process_received 4 not data Socket Closed")
             # Socket Closed
             self.close()
             return
@@ -256,11 +261,13 @@
             func(web_request)
         except self.printer.command_error as e:
             web_request.set_error(WebRequestError(str(e)))
+            reportInformation(str(e))
         except Exception as e:
             msg = ("Internal Error on WebRequest: %s"
                    % (web_request.get_method()))
             logging.exception(msg)
             web_request.set_error(WebRequestError(str(e)))
+            reportInformation(str(e))
             self.printer.invoke_shutdown(msg)
         result = web_request.finish()
         if result is None:
@@ -319,12 +326,12 @@
         prev_key, prev_values = prev
         if prev_key != key:
             raise self.printer.config_error(
-                "mux endpoint %s %s %s may have only one key (%s)"
-                % (path, key, value, prev_key))
+                """{"code":"key182", "msg": "mux endpoint %s %s %s may have only one key (%s)", "values": ["%s", "%s", "%s", "%s"]}"""
+                % (path, key, value, prev_key, path, key, value, prev_key))
         if value in prev_values:
             raise self.printer.config_error(
-                "mux endpoint %s %s %s already registered (%s)"
-                % (path, key, value, prev_values))
+                """{"code":"key182", "msg": "mux endpoint %s %s %s already registered (%s)", "values": ["%s", "%s", "%s", "%s"]}"""
+                % (path, key, value, prev_values, path, key, value, prev_values))
         prev_values[value] = callback
 
     def _handle_mux(self, web_request):
@@ -334,8 +341,8 @@
         else:
             key_param = web_request.get(key)
         if key_param not in values:
-            raise web_request.error("The value '%s' is not valid for %s"
-                                    % (key_param, key))
+            raise web_request.error("""{"code":"key183", "msg": "The value '%s' is not valid for %s", "values": ["%s", "%s"]}"""
+                                    % (key_param, key, key_param, key))
         values[key_param](web_request)
 
     def _handle_list_endpoints(self, web_request):
@@ -373,7 +380,7 @@
     def get_callback(self, path):
         cb = self._endpoints.get(path, None)
         if cb is None:
-            msg = "webhooks: No registered callback for path '%s'" % (path)
+            msg = """{"code":"key184", "msg": "webhooks: No registered callback for path '%s'", "values": ["%s"]}""" % (path, path)
             logging.info(msg)
             raise WebRequestError(msg)
         return cb
@@ -388,7 +395,7 @@
     def call_remote_method(self, method, **kwargs):
         if method not in self._remote_methods:
             raise self.printer.command_error(
-                "Remote method '%s' not registered" % (method))
+                """{"code":"key185", "msg": "Remote method '%s' not registered", "values": ["%s"]}""" % (method, method))
         conn_map = self._remote_methods[method]
         valid_conns = {}
         for conn, template in conn_map.items():
@@ -400,7 +407,7 @@
         if not valid_conns:
             del self._remote_methods[method]
             raise self.printer.command_error(
-                "No active connections for method '%s'" % (method))
+                """{"code":"key186", "msg": "No active connections for method '%s'", "values": ["%s"]}""" % (method, method))
         self._remote_methods[method] = valid_conns
 
 class GCodeHelper:
@@ -507,16 +514,17 @@
             self.query_timer = None
             return reactor.NEVER
         return eventtime + SUBSCRIPTION_REFRESH_TIME
-    def _handle_query(self, web_request, is_subscribe=False):
+    def _handle_query(self, web_request, is_subscribe=False, handle_subscribe=False):
         objects = web_request.get_dict('objects')
+        logging.info("_handle_query objects/subscribe:%s" % str(objects)) if handle_subscribe else None
         # Validate subscription format
         for k, v in objects.items():
             if type(k) != str or (v is not None and type(v) != list):
-                raise web_request.error("Invalid argument")
+                raise web_request.error("""{"code":"key187", "msg": "Invalid argument", "values": []}""")
             if v is not None:
                 for ri in v:
                     if type(ri) != str:
-                        raise web_request.error("Invalid argument")
+                        raise web_request.error("""{"code":"key187", "msg": "Invalid argument", "values": []}""")
         # Add to pending queries
         cconn = web_request.get_client_connection()
         template = web_request.get_dict('response_template', {})
@@ -530,12 +538,14 @@
             qt = reactor.register_timer(self._do_query, reactor.NOW)
             self.query_timer = qt
         # Wait for data to be queried
+        logging.info("_handle_query before complete.wait") if handle_subscribe else None
         msg = complete.wait()
+        logging.info("_handle_query after complete.wait:%s" % str(msg['params'])) if handle_subscribe else None
         web_request.send(msg['params'])
         if is_subscribe:
             self.clients[cconn] = (cconn, objects, cconn.send, template)
     def _handle_subscribe(self, web_request):
-        self._handle_query(web_request, is_subscribe=True)
+        self._handle_query(web_request, is_subscribe=True, handle_subscribe=True)
 
 def add_early_printer_objects(printer):
     printer.add_object('webhooks', WebHooks(printer))
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/Makefile crealityShit/Makefile
--- klipperStock/Makefile	2024-01-14 23:01:59.365787072 -0600
+++ crealityShit/Makefile	2024-01-14 23:02:21.562059143 -0600
@@ -4,6 +4,9 @@
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
 
+# host file
+host-tool-src = tool/host_crc16.c
+
 # Output directory
 OUT=out/
 
@@ -36,12 +39,23 @@
 
 OBJS_klipper.elf = $(patsubst %.c, $(OUT)src/%.o,$(src-y))
 OBJS_klipper.elf += $(OUT)compile_time_request.o
-CFLAGS_klipper.elf = $(CFLAGS) -Wl,--gc-sections
+CFLAGS_klipper.elf = $(CFLAGS) -Wl,--gc-sections -Wl,-Map,out/klipper.map
 
 CPPFLAGS = -I$(OUT) -P -MD -MT $@
 
+bootloader_src-y = 
+bootloader_dirs-y = bootloader
+BOOTLOADER_CFLAGS := -I$(OUT) -I$(OUT)board -std=gnu11 -O2 -MD \
+					 -Wall -Wold-style-definition $(call cc-option,$(CC),-Wtype-limits,) \
+					 -ffunction-sections -fdata-sections -fno-delete-null-pointer-checks
+OBJS_bootloader.elf = $(patsubst %.c, $(OUT)bootloader/%.o,$(bootloader_src-y))
+CFLAGS_bootloader.elf = $(BOOTLOADER_CFLAGS) -Wl,--gc-sections
+
 # Default targets
 target-y := $(OUT)klipper.elf
+target-y += $(OUT)hostCrc16.elf
+target-y += $(OUT)src/prtouch_v2.o
+target-$(CONFIG_BOARD_INFO_CONFIGURE) +=$(OUT)bootloader.elf
 
 all:
 
@@ -53,9 +67,43 @@
 MAKEFLAGS += --no-print-directory
 endif
 
+##### Process board hardware and firmware version
+
+ifeq ($(CONFIG_BOARD_INFO_CONFIGURE),y)
+
+ifeq ($(CONFIG_MAIN_MCU_BOARD),y)
+board_type := mcu
+else ifeq ($(CONFIG_NOZZLE_MCU_BOARD),y)
+board_type := noz
+else ifeq ($(CONFIG_BED_MCU_BOARD),y)
+board_type := bed
+endif
+
+ifneq ($(CONFIG_MCU_MENU),)
+mcu_menu := $(patsubst "%",%,$(CONFIG_MCU_MENU))
+else
+mcu_menu :=
+endif
+
+ifneq ($(CONFIG_MCU_TYPE),)
+mcu_type := $(patsubst "%",%,$(CONFIG_MCU_TYPE))
+else
+mcu_type :=
+endif
+
+board_hw_version := $(board_type)$(CONFIG_MCU_BOARD_ID)_$(CONFIG_MCU_BOARD_HW_VER)_$(mcu_menu)$(mcu_type)
+board_fw_version := $(board_type)$(CONFIG_MCU_BOARD_ID)_$(CONFIG_MCU_BOARD_FW_VER)_$(CONFIG_MCU_BOARD_FW_RESERVED)
+
+CFLAGS += -DBOARD_FW_VERSION=\"$(board_fw_version)\"
+BOOTLOADER_CFLAGS += -DBOARD_HW_VERSION=\"$(board_hw_version)\"
+
+export board_hw_version board_fw_version
+endif
+
 # Include board specific makefile
 include src/Makefile
 -include src/$(patsubst "%",%,$(CONFIG_BOARD_DIRECTORY))/Makefile
+-include src/bootloader/Makefile
 
 ################ Main build rules
 
@@ -67,11 +115,27 @@
 	@echo "  Preprocessing $@"
 	$(Q)$(CPP) -I$(OUT) -P -MD -MT $@ $< -o $@
 
-$(OUT)klipper.elf: $(OBJS_klipper.elf)
+$(OUT)klipper.elf: $(OBJS_klipper.elf) $(OUT)src/prtouch_v2.o $(OUT)hostCrc16.elf
 	@echo "  Linking $@"
-	$(Q)$(CC) $(OBJS_klipper.elf) $(CFLAGS_klipper.elf) -o $@
+	$(Q)$(CC) $(OBJS_klipper.elf) $(OUT)src/prtouch_v2.o $(CFLAGS_klipper.elf) -o $@
 	$(Q)scripts/check-gcc.sh $@ $(OUT)compile_time_request.o
 
+$(OUT)bootloader/src/generic/%.ld: src/bootloader/src/generic/%.lds.S $(OUT)autoconf.h
+	@echo "  Preprocessing $@"
+	$(Q)$(CPP) -I$(OUT) -P -MD -MT $@ $< -o $@
+
+$(OUT)bootloader/%.o: src/bootloader/%.c $(OUT)autoconf.h
+	@echo "  Compiling $@"
+	$(Q)$(CC) $(BOOTLOADER_CFLAGS) -c $< -o $@
+
+$(OUT)bootloader.elf: $(OBJS_bootloader.elf)
+	@echo " Linking $@"
+	$(Q)$(CC) $(OBJS_bootloader.elf) $(CFLAGS_bootloader.elf) -o $@
+
+$(OUT)hostCrc16.elf: $(host-tool-src)
+	@echo "  Compiling and Linking $@"
+	$(Q)gcc $< -o $@
+	
 ################ Compile time requests
 
 $(OUT)%.o.ctr: $(OUT)%.o
@@ -89,6 +153,8 @@
 	@echo "  Creating symbolic link $(OUT)board"
 	$(Q)mkdir -p $(addprefix $(OUT), $(dirs-y))
 	$(Q)rm -f $(OUT)*.d $(patsubst %,$(OUT)%/*.d,$(dirs-y))
+	$(Q)mkdir -p $(addprefix $(OUT), $(bootloader_dirs-y))
+	$(Q)rm -f $(patsubst %,$(OUT)%/*.d,$(bootloader_dirs-y))
 	$(Q)rm -f $(OUT)board
 	$(Q)ln -sf $(CURDIR)/src/$(CONFIG_BOARD_DIRECTORY) $(OUT)board
 	$(Q)mkdir -p $(OUT)board-generic
@@ -114,6 +180,12 @@
 
 menuconfig:
 	$(Q)$(PYTHON) lib/kconfiglib/menuconfig.py src/Kconfig
+	@echo "  Board HW Ver: $(board_hw_version)"
+	@echo "  Board FW Ver: $(board_fw_version)"
+
+%_defconfig: src/configs/%_defconfig
+	@echo "  Load configuration: $@"
+	$(Q)cp -v src/configs/$@ $(KCONFIG_CONFIG)
 
 ################ Generic rules
 
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/adccmds.c crealityShit/src/adccmds.c
--- klipperStock/src/adccmds.c	2024-01-14 23:02:00.149796696 -0600
+++ crealityShit/src/adccmds.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,136 +0,0 @@
-// Commands for controlling GPIO analog-to-digital input pins
-//
-// Copyright (C) 2016  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "basecmd.h" // oid_alloc
-#include "board/gpio.h" // struct gpio_adc
-#include "board/irq.h" // irq_disable
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // DECL_TASK
-
-struct analog_in {
-    struct timer timer;
-    uint32_t rest_time, sample_time, next_begin_time;
-    uint16_t value, min_value, max_value;
-    struct gpio_adc pin;
-    uint8_t invalid_count, range_check_count;
-    uint8_t state, sample_count;
-};
-
-static struct task_wake analog_wake;
-
-static uint_fast8_t
-analog_in_event(struct timer *timer)
-{
-    struct analog_in *a = container_of(timer, struct analog_in, timer);
-    uint32_t sample_delay = gpio_adc_sample(a->pin);
-    if (sample_delay) {
-        a->timer.waketime += sample_delay;
-        return SF_RESCHEDULE;
-    }
-    uint16_t value = gpio_adc_read(a->pin);
-    uint8_t state = a->state;
-    if (state >= a->sample_count) {
-        state = 0;
-    } else {
-        value += a->value;
-    }
-    a->value = value;
-    a->state = state+1;
-    if (a->state < a->sample_count) {
-        a->timer.waketime += a->sample_time;
-        return SF_RESCHEDULE;
-    }
-    if (likely(a->value >= a->min_value && a->value <= a->max_value)) {
-        a->invalid_count = 0;
-    } else {
-        a->invalid_count++;
-        if (a->invalid_count >= a->range_check_count) {
-            try_shutdown("ADC out of range");
-            a->invalid_count = 0;
-        }
-    }
-    sched_wake_task(&analog_wake);
-    a->next_begin_time += a->rest_time;
-    a->timer.waketime = a->next_begin_time;
-    return SF_RESCHEDULE;
-}
-
-void
-command_config_analog_in(uint32_t *args)
-{
-    struct gpio_adc pin = gpio_adc_setup(args[1]);
-    struct analog_in *a = oid_alloc(
-        args[0], command_config_analog_in, sizeof(*a));
-    a->timer.func = analog_in_event;
-    a->pin = pin;
-    a->state = 1;
-}
-DECL_COMMAND(command_config_analog_in, "config_analog_in oid=%c pin=%u");
-
-void
-command_query_analog_in(uint32_t *args)
-{
-    struct analog_in *a = oid_lookup(args[0], command_config_analog_in);
-    sched_del_timer(&a->timer);
-    gpio_adc_cancel_sample(a->pin);
-    a->next_begin_time = args[1];
-    a->timer.waketime = a->next_begin_time;
-    a->sample_time = args[2];
-    a->sample_count = args[3];
-    a->state = a->sample_count + 1;
-    a->rest_time = args[4];
-    a->min_value = args[5];
-    a->max_value = args[6];
-    a->range_check_count = args[7];
-    if (! a->sample_count)
-        return;
-    sched_add_timer(&a->timer);
-}
-DECL_COMMAND(command_query_analog_in,
-             "query_analog_in oid=%c clock=%u sample_ticks=%u sample_count=%c"
-             " rest_ticks=%u min_value=%hu max_value=%hu range_check_count=%c");
-
-void
-analog_in_task(void)
-{
-    if (!sched_check_wake(&analog_wake))
-        return;
-    uint8_t oid;
-    struct analog_in *a;
-    foreach_oid(oid, a, command_config_analog_in) {
-        if (a->state != a->sample_count)
-            continue;
-        irq_disable();
-        if (a->state != a->sample_count) {
-            irq_enable();
-            continue;
-        }
-        uint16_t value = a->value;
-        uint32_t next_begin_time = a->next_begin_time;
-        a->state++;
-        irq_enable();
-        sendf("analog_in_state oid=%c next_clock=%u value=%hu"
-              , oid, next_begin_time, value);
-    }
-}
-DECL_TASK(analog_in_task);
-
-void
-analog_in_shutdown(void)
-{
-    uint8_t i;
-    struct analog_in *a;
-    foreach_oid(i, a, command_config_analog_in) {
-        gpio_adc_cancel_sample(a->pin);
-        if (a->sample_count) {
-            a->state = a->sample_count + 1;
-            a->next_begin_time += a->rest_time;
-            a->timer.waketime = a->next_begin_time;
-            sched_add_timer(&a->timer);
-        }
-    }
-}
-DECL_SHUTDOWN(analog_in_shutdown);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/adc.c crealityShit/src/atsam/adc.c
--- klipperStock/src/atsam/adc.c	2024-01-14 23:02:00.165796891 -0600
+++ crealityShit/src/atsam/adc.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,107 +0,0 @@
-// Analog to digital support
-//
-// Copyright (C) 2016-2020  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_CLOCK_FREQ
-#include "board/irq.h" // irq_save
-#include "command.h" // shutdown
-#include "compiler.h" // ARRAY_SIZE
-#include "gpio.h" // gpio_adc_setup
-#include "internal.h" // GPIO
-#include "sched.h" // sched_shutdown
-
-#define ADC_TEMPERATURE_PIN 0xfe
-DECL_ENUMERATION("pin", "ADC_TEMPERATURE", ADC_TEMPERATURE_PIN);
-
-static const uint8_t adc_pins[] = {
-#if CONFIG_MACH_SAM3X
-    GPIO('A', 2), GPIO('A', 3), GPIO('A', 4), GPIO('A', 6),
-    GPIO('A', 22), GPIO('A', 23), GPIO('A', 24), GPIO('A', 16),
-    GPIO('B', 12), GPIO('B', 13), GPIO('B', 17), GPIO('B', 18),
-    GPIO('B', 19), GPIO('B', 20), GPIO('B', 21), ADC_TEMPERATURE_PIN
-#elif CONFIG_MACH_SAM4S
-    GPIO('A', 17), GPIO('A', 18), GPIO('A', 19), GPIO('A', 20),
-    GPIO('B', 0), GPIO('B', 1), GPIO('B', 2), GPIO('B', 3),
-    GPIO('A', 21), GPIO('A', 22), GPIO('C', 13), GPIO('C', 15),
-    GPIO('C', 12), GPIO('C', 29), GPIO('C', 30), ADC_TEMPERATURE_PIN
-#endif
-};
-
-#define ADC_FREQ_MAX 20000000
-DECL_CONSTANT("ADC_MAX", 4095);
-
-struct gpio_adc
-gpio_adc_setup(uint8_t pin)
-{
-    // Find pin in adc_pins table
-    int chan;
-    for (chan=0; ; chan++) {
-        if (chan >= ARRAY_SIZE(adc_pins))
-            shutdown("Not a valid ADC pin");
-        if (adc_pins[chan] == pin)
-            break;
-    }
-
-    if (!is_enabled_pclock(ID_ADC)) {
-        // Setup ADC
-        enable_pclock(ID_ADC);
-        uint32_t prescal = get_pclock_frequency(ID_ADC) / (2*ADC_FREQ_MAX) - 1;
-        ADC->ADC_MR = (ADC_MR_PRESCAL(prescal)
-                       | ADC_MR_STARTUP_SUT768
-                       | ADC_MR_TRANSFER(1));
-    }
-
-    if (pin == ADC_TEMPERATURE_PIN) {
-        // Enable temperature sensor
-        ADC->ADC_ACR |= ADC_ACR_TSON;
-    } else {
-        // Place pin in input floating mode
-        gpio_in_setup(pin, 0);
-    }
-    return (struct gpio_adc){ .chan = 1 << chan };
-}
-
-// Try to sample a value. Returns zero if sample ready, otherwise
-// returns the number of clock ticks the caller should wait before
-// retrying this function.
-uint32_t
-gpio_adc_sample(struct gpio_adc g)
-{
-    uint32_t chsr = ADC->ADC_CHSR & 0xffff;
-    if (!chsr) {
-        // Start sample
-        ADC->ADC_CHER = g.chan;
-        ADC->ADC_CR = ADC_CR_START;
-        goto need_delay;
-    }
-    if (chsr != g.chan)
-        // Sampling in progress on another channel
-        goto need_delay;
-    if (!(ADC->ADC_ISR & ADC_ISR_DRDY))
-        // Conversion still in progress
-        goto need_delay;
-    // Conversion ready
-    return 0;
-need_delay:
-    return ADC_FREQ_MAX * 1000ULL / CONFIG_CLOCK_FREQ;
-}
-
-// Read a value; use only after gpio_adc_sample() returns zero
-uint16_t
-gpio_adc_read(struct gpio_adc g)
-{
-    ADC->ADC_CHDR = g.chan;
-    return ADC->ADC_LCDR;
-}
-
-// Cancel a sample that may have been started with gpio_adc_sample()
-void
-gpio_adc_cancel_sample(struct gpio_adc g)
-{
-    irqstatus_t flag = irq_save();
-    if ((ADC->ADC_CHSR & 0xffff) == g.chan)
-        gpio_adc_read(g);
-    irq_restore(flag);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/chipid.c crealityShit/src/atsam/chipid.c
--- klipperStock/src/atsam/chipid.c	2024-01-14 23:02:00.161796843 -0600
+++ crealityShit/src/atsam/chipid.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,74 +0,0 @@
-// Support for extracting the hardware chip id on sam3/sam4
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "generic/irq.h" // irq_disable
-#include "generic/usb_cdc.h" // usb_fill_serial
-#include "generic/usbstd.h" // usb_string_descriptor
-#include "internal.h" // EFC0
-#include "sched.h" // DECL_INIT
-
-#define CHIP_UID_LEN 16
-
-static struct {
-    struct usb_string_descriptor desc;
-    uint16_t data[CHIP_UID_LEN * 2];
-} cdc_chipid;
-
-struct usb_string_descriptor *
-usbserial_get_serialid(void)
-{
-   return &cdc_chipid.desc;
-}
-
-// Compatibility definitions for sam4e8e
-#ifndef EFC0
-#define EFC0 EFC
-#define IFLASH0_ADDR IFLASH_ADDR
-#endif
-
-void noinline __section(".ramfunc.read_chip_id")
-read_chip_id(uint32_t *id)
-{
-    // Workaround sam3 errata
-    uint32_t fmr = EFC0->EEFC_FMR;
-    EFC0->EEFC_FMR = fmr | EEFC_FMR_SCOD;
-
-    // Send the STUI command
-    while (!(EFC0->EEFC_FSR & EEFC_FSR_FRDY))
-        ;
-    EFC0->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FCMD_STUI;
-    while (EFC0->EEFC_FSR & EEFC_FSR_FRDY)
-        ;
-
-    // Copy the id
-    id[0] = *(uint32_t*)(IFLASH0_ADDR + 0x00);
-    id[1] = *(uint32_t*)(IFLASH0_ADDR + 0x04);
-    id[2] = *(uint32_t*)(IFLASH0_ADDR + 0x08);
-    id[3] = *(uint32_t*)(IFLASH0_ADDR + 0x0c);
-
-    // Send the SPUI command
-    EFC0->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FCMD_SPUI;
-    while (!(EFC0->EEFC_FSR & EEFC_FSR_FRDY))
-        ;
-
-    // Restore fmr
-    EFC0->EEFC_FMR = fmr;
-}
-
-void
-chipid_init(void)
-{
-    if (!CONFIG_USB_SERIAL_NUMBER_CHIPID)
-        return;
-
-    uint32_t id[4];
-    irq_disable();
-    read_chip_id(id);
-    irq_enable();
-
-    usb_fill_serial(&cdc_chipid.desc, ARRAY_SIZE(cdc_chipid.data), id);
-}
-DECL_INIT(chipid_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/gpio.c crealityShit/src/atsam/gpio.c
--- klipperStock/src/atsam/gpio.c	2024-01-14 23:02:00.165796891 -0600
+++ crealityShit/src/atsam/gpio.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,188 +0,0 @@
-// GPIO functions on sam3/sam4
-//
-// Copyright (C) 2016-2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/irq.h" // irq_save
-#include "command.h" // shutdown
-#include "compiler.h" // ARRAY_SIZE
-#include "gpio.h" // gpio_out_setup
-#include "internal.h" // gpio_peripheral
-#include "sched.h" // sched_shutdown
-
-struct gpio_info {
-    void *dev;
-    uint8_t dev_id;
-};
-
-DECL_ENUMERATION_RANGE("pin", "PA0", GPIO('A', 0), 32);
-DECL_ENUMERATION_RANGE("pin", "PB0", GPIO('B', 0), 32);
-#ifdef PIOC
-DECL_ENUMERATION_RANGE("pin", "PC0", GPIO('C', 0), 32);
-#endif
-#ifdef PIOD
-DECL_ENUMERATION_RANGE("pin", "PD0", GPIO('D', 0), 32);
-#endif
-#ifdef PIOE
-DECL_ENUMERATION_RANGE("pin", "PE0", GPIO('E', 0), 32);
-#endif
-
-static const struct gpio_info digital_regs[] = {
-    { PIOA, ID_PIOA },
-    { PIOB, ID_PIOB },
-#ifdef PIOC
-    { PIOC, ID_PIOC },
-#endif
-#ifdef PIOD
-    { PIOD, ID_PIOD },
-#endif
-#ifdef PIOE
-    { PIOE, ID_PIOE },
-#endif
-};
-
-
-/****************************************************************
- * Pin multiplexing
- ****************************************************************/
-
-static void
-set_pull_up(Pio *regs, uint32_t bit, int32_t pull_up)
-{
-#if CONFIG_MACH_SAM3X
-    if (pull_up > 0)
-        regs->PIO_PUER = bit;
-    else
-        regs->PIO_PUDR = bit;
-#else
-    if (pull_up > 0) {
-        regs->PIO_PPDDR = bit;
-        regs->PIO_PUER = bit;
-    } else if (pull_up < 0) {
-        regs->PIO_PUDR = bit;
-        regs->PIO_PPDER = bit;
-    } else {
-        regs->PIO_PUDR = bit;
-        regs->PIO_PPDDR = bit;
-    }
-#endif
-#if CONFIG_MACH_SAM4S
-    // Check if this pin is a "system IO pin" and disable if so
-    if (regs == PIOB && (bit & 0x1cf0))
-        MATRIX->CCFG_SYSIO |= bit;
-#elif CONFIG_MACH_SAME70
-    if (regs == PIOB && (bit & 0x10f0))
-        MATRIX->CCFG_SYSIO |= bit;
-#endif
-}
-
-void
-gpio_peripheral(uint32_t gpio, char ptype, int32_t pull_up)
-{
-    uint32_t bank = GPIO2PORT(gpio), bit = GPIO2BIT(gpio), pt = ptype - 'A';
-    Pio *regs = digital_regs[bank].dev;
-
-#if CONFIG_MACH_SAM3X
-    regs->PIO_ABSR = (regs->PIO_ABSR & ~bit) | (pt & 0x01 ? bit : 0);
-#else
-    regs->PIO_ABCDSR[0] = (regs->PIO_ABCDSR[0] & ~bit) | (pt & 0x01 ? bit : 0);
-    regs->PIO_ABCDSR[1] = (regs->PIO_ABCDSR[1] & ~bit) | (pt & 0x02 ? bit : 0);
-#endif
-    set_pull_up(regs, bit, pull_up);
-    regs->PIO_PDR = bit;
-}
-
-
-/****************************************************************
- * General Purpose Input Output (GPIO) pins
- ****************************************************************/
-
-struct gpio_out
-gpio_out_setup(uint8_t pin, uint8_t val)
-{
-    if (GPIO2PORT(pin) >= ARRAY_SIZE(digital_regs))
-        goto fail;
-    Pio *regs = digital_regs[GPIO2PORT(pin)].dev;
-    struct gpio_out g = { .regs=regs, .bit=GPIO2BIT(pin) };
-    gpio_out_reset(g, val);
-    return g;
-fail:
-    shutdown("Not an output pin");
-}
-
-void
-gpio_out_reset(struct gpio_out g, uint8_t val)
-{
-    Pio *regs = g.regs;
-    irqstatus_t flag = irq_save();
-    if (val)
-        regs->PIO_SODR = g.bit;
-    else
-        regs->PIO_CODR = g.bit;
-    regs->PIO_OER = g.bit;
-    regs->PIO_OWER = g.bit;
-    regs->PIO_PER = g.bit;
-    set_pull_up(regs, g.bit, 0);
-    irq_restore(flag);
-}
-
-void
-gpio_out_toggle_noirq(struct gpio_out g)
-{
-    Pio *regs = g.regs;
-    regs->PIO_ODSR ^= g.bit;
-}
-
-void
-gpio_out_toggle(struct gpio_out g)
-{
-    irqstatus_t flag = irq_save();
-    gpio_out_toggle_noirq(g);
-    irq_restore(flag);
-}
-
-void
-gpio_out_write(struct gpio_out g, uint8_t val)
-{
-    Pio *regs = g.regs;
-    if (val)
-        regs->PIO_SODR = g.bit;
-    else
-        regs->PIO_CODR = g.bit;
-}
-
-
-struct gpio_in
-gpio_in_setup(uint8_t pin, int8_t pull_up)
-{
-    if (GPIO2PORT(pin) >= ARRAY_SIZE(digital_regs))
-        goto fail;
-    if (CONFIG_MACH_SAM3X && pull_up < 0)
-        goto fail;
-    uint32_t port = GPIO2PORT(pin);
-    enable_pclock(digital_regs[port].dev_id);
-    struct gpio_in g = { .regs=digital_regs[port].dev, .bit=GPIO2BIT(pin) };
-    gpio_in_reset(g, pull_up);
-    return g;
-fail:
-    shutdown("Not a valid input pin");
-}
-
-void
-gpio_in_reset(struct gpio_in g, int8_t pull_up)
-{
-    Pio *regs = g.regs;
-    irqstatus_t flag = irq_save();
-    set_pull_up(regs, g.bit, pull_up);
-    regs->PIO_ODR = g.bit;
-    regs->PIO_PER = g.bit;
-    irq_restore(flag);
-}
-
-uint8_t
-gpio_in_read(struct gpio_in g)
-{
-    Pio *regs = g.regs;
-    return !!(regs->PIO_PDSR & g.bit);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/gpio.h crealityShit/src/atsam/gpio.h
--- klipperStock/src/atsam/gpio.h	2024-01-14 23:02:00.161796843 -0600
+++ crealityShit/src/atsam/gpio.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,57 +0,0 @@
-#ifndef __ATSAM_GPIO_H
-#define __ATSAM_GPIO_H
-
-#include <stdint.h> // uint32_t
-
-struct gpio_out {
-    void *regs;
-    uint32_t bit;
-};
-struct gpio_out gpio_out_setup(uint8_t pin, uint8_t val);
-void gpio_out_reset(struct gpio_out g, uint8_t val);
-void gpio_out_toggle_noirq(struct gpio_out g);
-void gpio_out_toggle(struct gpio_out g);
-void gpio_out_write(struct gpio_out g, uint8_t val);
-
-struct gpio_in {
-    void *regs;
-    uint32_t bit;
-};
-struct gpio_in gpio_in_setup(uint8_t pin, int8_t pull_up);
-void gpio_in_reset(struct gpio_in g, int8_t pull_up);
-uint8_t gpio_in_read(struct gpio_in g);
-
-struct gpio_pwm {
-    void *reg;
-};
-struct gpio_pwm gpio_pwm_setup(uint8_t pin, uint32_t cycle_time, uint8_t val);
-void gpio_pwm_write(struct gpio_pwm g, uint32_t val);
-
-struct gpio_adc {
-    uint32_t chan;
-};
-struct gpio_adc gpio_adc_setup(uint8_t pin);
-uint32_t gpio_adc_sample(struct gpio_adc g);
-uint16_t gpio_adc_read(struct gpio_adc g);
-void gpio_adc_cancel_sample(struct gpio_adc g);
-
-struct spi_config {
-    void *spidev;
-    uint32_t cfg;
-};
-struct spi_config spi_setup(uint32_t bus, uint8_t mode, uint32_t rate);
-void spi_prepare(struct spi_config config);
-void spi_transfer(struct spi_config config, uint8_t receive_data
-                  , uint8_t len, uint8_t *data);
-
-struct i2c_config {
-    void *twi;
-    uint8_t addr;
-};
-
-struct i2c_config i2c_setup(uint32_t bus, uint32_t rate, uint8_t addr);
-void i2c_write(struct i2c_config config, uint8_t write_len, uint8_t *write);
-void i2c_read(struct i2c_config config, uint8_t reg_len, uint8_t *reg
-              , uint8_t read_len, uint8_t *read);
-
-#endif // gpio.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/hard_pwm.c crealityShit/src/atsam/hard_pwm.c
--- klipperStock/src/atsam/hard_pwm.c	2024-01-14 23:02:00.157796793 -0600
+++ crealityShit/src/atsam/hard_pwm.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,233 +0,0 @@
-// Hardware PWM support on atsam
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/irq.h" // irq_save
-#include "command.h" // shutdown
-#include "gpio.h" // gpio_pwm_write
-#include "internal.h" // GPIO
-#include "sched.h" // sched_shutdown
-
-#define MAX_PWM 255
-DECL_CONSTANT("PWM_MAX", MAX_PWM);
-
-
-/****************************************************************
- * TC hardware device
- ****************************************************************/
-
-struct gpio_tc_info {
-    uint8_t gpio, ptype, id;
-    volatile void *reg;
-};
-
-static const struct gpio_tc_info tc_regs[] = {
-#if CONFIG_MACH_SAM3X
-    { GPIO('B', 25), 'B', ID_TC0, &TC0->TC_CHANNEL[0].TC_RA },
-    { GPIO('A', 2),  'A', ID_TC1, &TC0->TC_CHANNEL[1].TC_RA },
-    { GPIO('A', 5),  'A', ID_TC2, &TC0->TC_CHANNEL[2].TC_RA },
-    { GPIO('B', 27), 'B', ID_TC0, &TC0->TC_CHANNEL[0].TC_RB },
-    { GPIO('A', 3),  'A', ID_TC1, &TC0->TC_CHANNEL[1].TC_RB },
-    { GPIO('A', 6),  'A', ID_TC2, &TC0->TC_CHANNEL[2].TC_RB },
-    { GPIO('B', 0),  'B', ID_TC3, &TC1->TC_CHANNEL[0].TC_RA },
-    { GPIO('B', 2),  'B', ID_TC4, &TC1->TC_CHANNEL[1].TC_RA },
-    { GPIO('B', 4),  'B', ID_TC5, &TC1->TC_CHANNEL[2].TC_RA },
-    { GPIO('B', 1),  'B', ID_TC3, &TC1->TC_CHANNEL[0].TC_RB },
-    { GPIO('B', 3),  'B', ID_TC4, &TC1->TC_CHANNEL[1].TC_RB },
-    { GPIO('B', 5),  'B', ID_TC5, &TC1->TC_CHANNEL[2].TC_RB },
-#if CONFIG_MACH_SAM3X8E
-    { GPIO('C', 25), 'B', ID_TC6, &TC2->TC_CHANNEL[0].TC_RA },
-    { GPIO('C', 28), 'B', ID_TC7, &TC2->TC_CHANNEL[1].TC_RA },
-    { GPIO('D', 7),  'B', ID_TC8, &TC2->TC_CHANNEL[2].TC_RA },
-    { GPIO('C', 26), 'B', ID_TC6, &TC2->TC_CHANNEL[0].TC_RB },
-    { GPIO('C', 29), 'B', ID_TC7, &TC2->TC_CHANNEL[1].TC_RB },
-    { GPIO('D', 8),  'B', ID_TC8, &TC2->TC_CHANNEL[2].TC_RB },
-#endif
-#elif CONFIG_MACH_SAM4
-    { GPIO('A', 0),  'B', ID_TC0, &TC0->TC_CHANNEL[0].TC_RA },
-    { GPIO('A', 15), 'B', ID_TC1, &TC0->TC_CHANNEL[1].TC_RA },
-    { GPIO('A', 26), 'B', ID_TC2, &TC0->TC_CHANNEL[2].TC_RA },
-    { GPIO('A', 1),  'B', ID_TC0, &TC0->TC_CHANNEL[0].TC_RB },
-    { GPIO('A', 16), 'B', ID_TC1, &TC0->TC_CHANNEL[1].TC_RB },
-    { GPIO('A', 27), 'B', ID_TC2, &TC0->TC_CHANNEL[2].TC_RB },
-    { GPIO('C', 23), 'B', ID_TC3, &TC1->TC_CHANNEL[0].TC_RA },
-    { GPIO('C', 26), 'B', ID_TC4, &TC1->TC_CHANNEL[1].TC_RA },
-    { GPIO('C', 29), 'B', ID_TC5, &TC1->TC_CHANNEL[2].TC_RA },
-    { GPIO('C', 24), 'B', ID_TC3, &TC1->TC_CHANNEL[0].TC_RB },
-    { GPIO('C', 27), 'B', ID_TC4, &TC1->TC_CHANNEL[1].TC_RB },
-    { GPIO('C', 30), 'B', ID_TC5, &TC1->TC_CHANNEL[2].TC_RB },
-#if CONFIG_MACH_SAM4E8E
-    { GPIO('C', 5),  'B', ID_TC6, &TC2->TC_CHANNEL[0].TC_RA },
-    { GPIO('C', 8),  'B', ID_TC7, &TC2->TC_CHANNEL[1].TC_RA },
-    { GPIO('C', 11), 'B', ID_TC8, &TC2->TC_CHANNEL[2].TC_RA },
-    { GPIO('C', 6),  'B', ID_TC6, &TC2->TC_CHANNEL[0].TC_RB },
-    { GPIO('C', 9),  'B', ID_TC7, &TC2->TC_CHANNEL[1].TC_RB },
-    { GPIO('C', 12), 'B', ID_TC8, &TC2->TC_CHANNEL[2].TC_RB },
-#endif
-#endif
-};
-
-static inline int tc_is_tc(struct gpio_pwm g) {
-    return (((uint32_t)g.reg & ~0xffff) == ((uint32_t)TC0 & ~0xffff));
-}
-static inline TcChannel *tc_from_reg(struct gpio_pwm g) {
-    return (void*)((uint32_t)g.reg & ~0x3f);
-}
-static inline int tc_is_b(struct gpio_pwm g) {
-    return (((uint32_t)g.reg & 0x3f)
-            == ((uint32_t)&TC0->TC_CHANNEL[0].TC_RB & 0x3f));
-}
-
-static void
-gpio_tc_write(struct gpio_pwm g, uint32_t val)
-{
-    TcChannel *tc = tc_from_reg(g);
-    uint32_t mask = TC_CMR_ACPA_Msk | TC_CMR_ACPC_Msk;
-    uint32_t bits = TC_CMR_ACPA_CLEAR | TC_CMR_ACPC_SET;
-    if (!val)
-        bits = TC_CMR_ACPA_CLEAR | TC_CMR_ACPC_CLEAR;
-    else if (val >= MAX_PWM)
-        bits = TC_CMR_ACPA_SET | TC_CMR_ACPC_SET;
-    if (tc_is_b(g)) {
-        mask <<= 8;
-        bits <<= 8;
-    }
-    irqstatus_t flag = irq_save();
-    tc->TC_CMR = (tc->TC_CMR & ~mask) | bits;
-    *(volatile uint32_t*)g.reg = val;
-    irq_restore(flag);
-}
-
-static struct gpio_pwm
-gpio_tc_setup(uint8_t pin, uint32_t cycle_time, uint8_t val)
-{
-    // Find pin in tc_regs table
-    const struct gpio_tc_info *p = tc_regs;
-    for (; ; p++) {
-        if (p >= &tc_regs[ARRAY_SIZE(tc_regs)])
-            shutdown("Not a valid PWM pin");
-        if (p->gpio == pin)
-            break;
-    }
-
-    // Map cycle_time to clock divisor
-    uint32_t div = TC_CMR_TCCLKS_TIMER_CLOCK4;
-    if (cycle_time < (MAX_PWM*8 + MAX_PWM*2) / 2)
-        div = TC_CMR_TCCLKS_TIMER_CLOCK1;
-    else if (cycle_time < (MAX_PWM*32 + MAX_PWM*8) / 2)
-        div = TC_CMR_TCCLKS_TIMER_CLOCK2;
-    else if (cycle_time < (MAX_PWM*128 + MAX_PWM*32) / 2)
-        div = TC_CMR_TCCLKS_TIMER_CLOCK3;
-
-    // Enable clock
-    enable_pclock(p->id);
-
-    // Enable PWM output
-    struct gpio_pwm g = (struct gpio_pwm){ (void*)p->reg };
-    TcChannel *tc = tc_from_reg(g);
-    uint32_t prev_cmr = tc->TC_CMR;
-    if (prev_cmr && (prev_cmr & TC_CMR_TCCLKS_Msk) != div)
-        shutdown("PWM already programmed at different speed");
-    gpio_peripheral(pin, p->ptype, 0);
-    if (prev_cmr) {
-        gpio_tc_write(g, val);
-    } else {
-        tc->TC_CMR = TC_CMR_WAVE | TC_CMR_WAVSEL_UP_RC | div | TC_CMR_EEVT_XC0;
-        gpio_tc_write(g, val);
-        tc->TC_RC = MAX_PWM;
-        tc->TC_CCR = TC_CCR_CLKEN | TC_CCR_SWTRG;
-    }
-    return g;
-}
-
-
-/****************************************************************
- * PWM hardware device
- ****************************************************************/
-
-struct gpio_pwm_info {
-    uint8_t gpio, channel, ptype;
-};
-
-static const struct gpio_pwm_info pwm_regs[] = {
-#if CONFIG_MACH_SAM3X
-    { GPIO('A', 21), 0, 'B' },
-    { GPIO('B', 16), 0, 'B' },
-    { GPIO('A', 12), 1, 'B' },
-    { GPIO('B', 17), 1, 'B' },
-    { GPIO('A', 20), 2, 'B' },
-    { GPIO('B', 18), 2, 'B' },
-    { GPIO('A', 0),  3, 'B' },
-    { GPIO('B', 19), 3, 'B' },
-#if CONFIG_MACH_SAM3X8E
-    { GPIO('C', 2),  0, 'B' },
-    { GPIO('C', 4),  1, 'B' },
-    { GPIO('C', 6),  2, 'B' },
-    { GPIO('C', 8),  3, 'B' },
-    { GPIO('C', 21), 4, 'B' },
-    { GPIO('C', 22), 5, 'B' },
-    { GPIO('C', 23), 6, 'B' },
-    { GPIO('C', 24), 7, 'B' },
-#endif
-#elif CONFIG_MACH_SAM4
-    { GPIO('A', 19), 0, 'B' },
-    { GPIO('B', 5),  0, 'B' },
-    { GPIO('C', 0),  0, 'B' },
-    { GPIO('C', 13), 0, 'B' },
-    { GPIO('A', 20), 1, 'B' },
-    { GPIO('B', 12), 1, 'A' },
-    { GPIO('C', 1),  1, 'B' },
-    { GPIO('C', 15), 1, 'B' },
-    { GPIO('A', 16), 2, 'C' },
-    { GPIO('A', 30), 2, 'A' },
-    { GPIO('B', 13), 2, 'A' },
-    { GPIO('C', 2),  2, 'B' },
-    { GPIO('A', 15), 3, 'C' },
-    { GPIO('C', 3),  3, 'B' },
-    { GPIO('C', 22), 3, 'B' },
-#endif
-};
-
-struct gpio_pwm
-gpio_pwm_setup(uint8_t pin, uint32_t cycle_time, uint8_t val)
-{
-    // Find pin in pwm_regs table
-    const struct gpio_pwm_info *p = pwm_regs;
-    for (; ; p++) {
-        if (p >= &pwm_regs[ARRAY_SIZE(pwm_regs)])
-            return gpio_tc_setup(pin, cycle_time, val);
-        if (p->gpio == pin)
-            break;
-    }
-
-    // Map cycle_time to pwm clock divisor
-    uint32_t div;
-    for (div=0; div<10; div++)
-        if (cycle_time < ((MAX_PWM << (div + 1)) + (MAX_PWM << div)) / 2)
-            break;
-
-    // Enable clock
-    enable_pclock(ID_PWM);
-
-    // Enable PWM output
-    if (PWM->PWM_SR & (1 << p->channel))
-        shutdown("PWM channel already in use");
-    gpio_peripheral(pin, p->ptype, 0);
-    PWM->PWM_CH_NUM[p->channel].PWM_CMR = div;
-    PWM->PWM_CH_NUM[p->channel].PWM_CPRD = MAX_PWM;
-    PWM->PWM_CH_NUM[p->channel].PWM_CDTY = val;
-    PWM->PWM_ENA = 1 << p->channel;
-
-    return (struct gpio_pwm){ (void*)&PWM->PWM_CH_NUM[p->channel].PWM_CDTYUPD };
-}
-
-void
-gpio_pwm_write(struct gpio_pwm g, uint32_t val)
-{
-    if (tc_is_tc(g))
-        gpio_tc_write(g, val);
-    else
-        *(volatile uint32_t*)g.reg = val;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/i2c.c crealityShit/src/atsam/i2c.c
--- klipperStock/src/atsam/i2c.c	2024-01-14 23:02:00.157796793 -0600
+++ crealityShit/src/atsam/i2c.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,195 +0,0 @@
-// SAM4 I2C Port
-//
-// Copyright (C) 2018  Florian Heilmann <Florian.Heilmann@gmx.net>
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/misc.h" // timer_from_us
-#include "command.h" // shutdown
-#include "gpio.h" // i2c_setup
-#include "internal.h" // gpio_peripheral
-#include "sched.h" // sched_shutdown
-
-#if CONFIG_MACH_SAME70
-#include "same70_i2c.h" // Fixes for upstream header changes
-#endif
-
-struct twi_info {
-    void *dev;
-    uint32_t dev_id;
-    uint8_t scl_pin, sda_pin, periph;
-};
-
-// I2C pin definitions
-#if CONFIG_MACH_SAM3X
-DECL_ENUMERATION_RANGE("i2c_bus", "twi0", 0, 2);
-DECL_CONSTANT_STR("BUS_PINS_twi0", "PA18,PA17");
-DECL_CONSTANT_STR("BUS_PINS_twi1", "PB13,PB12");
-#define PRD_CALC_NUM 4
-#elif CONFIG_MACH_SAM4
-DECL_ENUMERATION_RANGE("i2c_bus", "twi0", 0, 2);
-DECL_CONSTANT_STR("BUS_PINS_twi0", "PA4,PA3");
-DECL_CONSTANT_STR("BUS_PINS_twi1", "PB5,PB4");
-#define PRD_CALC_NUM 4
-#elif CONFIG_MACH_SAME70
-DECL_ENUMERATION_RANGE("i2c_bus", "twihs0", 0,3);
-DECL_CONSTANT_STR("BUS_PINS_twihs0", "PA4,PA3");
-DECL_CONSTANT_STR("BUS_PINS_twihs1", "PB5,PB4");
-DECL_CONSTANT_STR("BUS_PINS_twihs2", "PD28,PD27");
-#define PRD_CALC_NUM 3
-#endif
-
-static const struct twi_info twi_bus[] = {
-#if CONFIG_MACH_SAM3X
-    { TWI0, ID_TWI0, GPIO('A', 18), GPIO('A', 17), 'A'},
-    { TWI1, ID_TWI1, GPIO('B', 13), GPIO('B', 12), 'A'},
-#elif CONFIG_MACH_SAM4
-    { TWI0, ID_TWI0, GPIO('A', 4), GPIO('A', 3), 'A'},
-    { TWI1, ID_TWI1, GPIO('B', 5), GPIO('B', 4), 'A'},
-#elif CONFIG_MACH_SAME70
-    { TWIHS0, ID_TWIHS0, GPIO('A', 4), GPIO('A', 3), 'A'},
-    { TWIHS1, ID_TWIHS1, GPIO('B', 5), GPIO('B', 4), 'A'},
-    { TWIHS2, ID_TWIHS2, GPIO('D', 28), GPIO('D', 27), 'C'},
-#endif
-};
-
-static void
-init_pins(uint32_t bus)
-{
-    const struct twi_info *si = &twi_bus[bus];
-    gpio_peripheral(si->scl_pin, si->periph, 1);
-    gpio_peripheral(si->sda_pin, si->periph, 1);
-    enable_pclock(si->dev_id);
-}
-
-static void
-i2c_init(uint32_t bus, uint32_t rate)
-{
-    Twi *p_twi = twi_bus[bus].dev;
-    p_twi->TWI_IDR = 0xFFFFFFFF;
-    (void)p_twi->TWI_SR;
-    p_twi->TWI_CR = TWI_CR_SWRST;
-    (void)p_twi->TWI_RHR;
-    p_twi->TWI_CR = TWI_CR_MSDIS;
-    p_twi->TWI_CR = TWI_CR_SVDIS;
-    p_twi->TWI_CR = TWI_CR_MSEN;
-
-    uint32_t pclk = get_pclock_frequency(twi_bus[bus].dev_id);
-    uint32_t cldiv = 0, chdiv = 0, ckdiv = 0;
-    cldiv = pclk / ((rate > 384000 ? 384000 : rate) * 2) - PRD_CALC_NUM;
-
-    while ((cldiv > 255) && (ckdiv < 7)) {
-        ckdiv++;
-        cldiv /= 2;
-    }
-
-    if (rate > 348000) {
-        chdiv = pclk / ((2 * rate - 384000) * 2) - PRD_CALC_NUM;
-        while ((chdiv > 255) && (ckdiv < 7)) {
-            ckdiv++;
-            chdiv /= 2;
-        }
-    } else {
-        chdiv = cldiv;
-    }
-    p_twi->TWI_CWGR = (TWI_CWGR_CLDIV(cldiv) | TWI_CWGR_CHDIV(chdiv)
-                       | TWI_CWGR_CKDIV(ckdiv));
-}
-
-static uint32_t
-addr_to_u32(uint8_t addr_len, uint8_t *addr)
-{
-    uint32_t address = addr[0];
-    if (addr_len > 1) {
-        address <<= 8;
-        address |= addr[1];
-    }
-    if (addr_len > 2) {
-        address <<= 8;
-        address |= addr[2];
-    }
-    if (addr_len > 3) {
-        shutdown("Addresses larger than 3 bytes are not supported");
-    }
-    return address;
-}
-
-struct i2c_config
-i2c_setup(uint32_t bus, uint32_t rate, uint8_t addr)
-{
-    if (bus >= ARRAY_SIZE(twi_bus)  || rate > 400000)
-        shutdown("Invalid i2c_setup parameters!");
-    Twi *p_twi = twi_bus[bus].dev;
-    init_pins(bus);
-    i2c_init(bus, rate);
-    return (struct i2c_config){ .twi=p_twi, .addr=addr};
-}
-
-void
-i2c_write(struct i2c_config config, uint8_t write_len, uint8_t *write)
-{
-    Twi *p_twi = config.twi;
-    uint32_t timeout = timer_read_time() + timer_from_us(5000);
-    uint32_t status, bytes_to_send = write_len;
-    p_twi->TWI_MMR = TWI_MMR_DADR(config.addr);
-    for (;;) {
-        status = p_twi->TWI_SR;
-        if (status & TWI_SR_NACK)
-            shutdown("I2C NACK error encountered!");
-        if (!(status & TWI_SR_TXRDY)) {
-            if (!timer_is_before(timer_read_time(), timeout))
-                shutdown("I2C timeout occured");
-            continue;
-        }
-        if (!bytes_to_send)
-            break;
-        p_twi->TWI_THR = *write++;
-        bytes_to_send--;
-    }
-    p_twi->TWI_CR = TWI_CR_STOP;
-    while (!(p_twi->TWI_SR & TWI_SR_TXCOMP))
-        ;
-}
-
-void
-i2c_read(struct i2c_config config, uint8_t reg_len, uint8_t *reg
-         , uint8_t read_len, uint8_t *read)
-{
-    Twi *p_twi = config.twi;
-    uint32_t timeout = timer_read_time() + timer_from_us(5000);
-    uint32_t status, bytes_to_send = read_len;
-    uint8_t stop = 0;
-    p_twi->TWI_MMR = 0;
-    p_twi->TWI_MMR = (TWI_MMR_MREAD | TWI_MMR_DADR(config.addr)
-                      | ((reg_len << TWI_MMR_IADRSZ_Pos) & TWI_MMR_IADRSZ_Msk));
-    p_twi->TWI_IADR = 0;
-    p_twi->TWI_IADR = addr_to_u32(reg_len, reg);
-    if (bytes_to_send == 1) {
-        p_twi->TWI_CR = TWI_CR_START | TWI_CR_STOP;
-        stop = 1;
-    } else {
-        p_twi->TWI_CR = TWI_CR_START;
-        stop = 0;
-    }
-    while (bytes_to_send > 0) {
-        status = p_twi->TWI_SR;
-        if (status & TWI_SR_NACK) {
-            shutdown("I2C NACK error encountered!");
-        }
-        if (bytes_to_send == 1 && !stop) {
-            p_twi->TWI_CR = TWI_CR_STOP;
-            stop = 1;
-        }
-        if (!(status & TWI_SR_RXRDY)) {
-            if (!timer_is_before(timer_read_time(), timeout))
-                shutdown("I2C timeout occured");
-            continue;
-        }
-        *read++ = p_twi->TWI_RHR;
-        bytes_to_send--;
-    }
-    while (!(p_twi->TWI_SR & TWI_SR_TXCOMP))
-        ;
-    (void)p_twi->TWI_SR;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/internal.h crealityShit/src/atsam/internal.h
--- klipperStock/src/atsam/internal.h	2024-01-14 23:02:00.165796891 -0600
+++ crealityShit/src/atsam/internal.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,27 +0,0 @@
-#ifndef __ATSAM_INTERNAL_H
-#define __ATSAM_INTERNAL_H
-// Local definitions for sam3/sam4 code
-
-#include <stdint.h> // uint32_t
-#include "autoconf.h" // CONFIG_MACH_SAM3X
-
-#if CONFIG_MACH_SAM3X
-#include "sam3xa.h"
-#elif CONFIG_MACH_SAM4S
-#include "sam4s.h"
-#elif CONFIG_MACH_SAM4E
-#include "sam4e.h"
-#elif CONFIG_MACH_SAME70
-#include "sam.h"
-#endif
-
-#define GPIO(PORT, NUM) (((PORT)-'A') * 32 + (NUM))
-#define GPIO2PORT(PIN) ((PIN) / 32)
-#define GPIO2BIT(PIN) (1<<((PIN) % 32))
-
-void gpio_peripheral(uint32_t gpio, char ptype, int32_t pull_up);
-int is_enabled_pclock(uint32_t id);
-void enable_pclock(uint32_t id);
-uint32_t get_pclock_frequency(uint32_t id);
-
-#endif // internal.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/Kconfig crealityShit/src/atsam/Kconfig
--- klipperStock/src/atsam/Kconfig	2024-01-14 23:02:00.165796891 -0600
+++ crealityShit/src/atsam/Kconfig	1969-12-31 18:00:00.000000000 -0600
@@ -1,106 +0,0 @@
-# Kconfig settings for Atmel SAM processors
-
-if MACH_ATSAM
-
-config ATSAM_SELECT
-    bool
-    default y
-    select HAVE_GPIO
-    select HAVE_GPIO_ADC
-    select HAVE_GPIO_I2C
-    select HAVE_GPIO_SPI
-    select HAVE_GPIO_HARD_PWM if !MACH_SAME70
-    select HAVE_GPIO_BITBANGING
-    select HAVE_STRICT_TIMING
-    select HAVE_CHIPID
-    select HAVE_STEPPER_BOTH_EDGE
-
-config BOARD_DIRECTORY
-    string
-    default "atsam"
-
-choice
-    prompt "Processor model"
-    config MACH_SAM3X8E
-        bool "SAM3x8e (Arduino Due)"
-        select MACH_SAM3X
-    config MACH_SAM3X8C
-        bool "SAM3x8c (Printrboard G2)"
-        select MACH_SAM3X
-    config MACH_SAM4S8C
-        bool "SAM4s8c (Duet Maestro)"
-        select MACH_SAM4S
-    config MACH_SAM4E8E
-        bool "SAM4e8e (Duet Wifi/Eth)"
-        select MACH_SAM4E
-    config MACH_SAME70Q20B
-        bool "SAME70Q20B (Duet 3 6HC)"
-        select MACH_SAME70
-endchoice
-
-config MACH_SAM3X
-    bool
-config MACH_SAM4
-    bool
-config MACH_SAM4S
-    bool
-    select MACH_SAM4
-config MACH_SAM4E
-    bool
-    select MACH_SAM4
-config MACH_SAME70
-    bool
-
-config MCU
-    string
-    default "sam3x8e" if MACH_SAM3X8E
-    default "sam3x8c" if MACH_SAM3X8C
-    default "sam4s8c" if MACH_SAM4S8C
-    default "sam4e8e" if MACH_SAM4E8E
-    default "same70q20b" if MACH_SAME70Q20B
-
-config CLOCK_FREQ
-    int
-    default 84000000 if MACH_SAM3X
-    default 120000000 if MACH_SAM4
-    default 300000000 if MACH_SAME70
-
-config FLASH_SIZE
-    hex
-    default 0x80000
-
-config FLASH_BOOT_ADDRESS
-    hex
-    default 0x0
-
-config RAM_START
-    hex
-    default 0x20400000 if MACH_SAME70
-    default 0x20000000
-
-config RAM_SIZE
-    hex
-    default 0x18000 if MACH_SAM3X
-    default 0x20000 if MACH_SAM4
-    default 0x40000 if MACH_SAME70
-
-config STACK_SIZE
-    int
-    default 512
-
-config FLASH_APPLICATION_ADDRESS
-    hex
-    default 0x400000 if MACH_SAM4 || MACH_SAME70
-    default 0x80000
-
-choice
-    prompt "Communication interface"
-    config ATSAM_USB
-        bool "USB"
-        select USBSERIAL
-    config ATSAM_SERIAL
-        bool "Serial"
-        select SERIAL
-endchoice
-
-endif
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/main.c crealityShit/src/atsam/main.c
--- klipperStock/src/atsam/main.c	2024-01-14 23:02:00.165796891 -0600
+++ crealityShit/src/atsam/main.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,135 +0,0 @@
-// Main starting point for SAM3/SAM4 boards
-//
-// Copyright (C) 2016-2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/armcm_boot.h" // armcm_main
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // bootloader_request
-#include "command.h" // DECL_COMMAND_FLAGS
-#include "internal.h" // WDT
-#include "sched.h" // sched_main
-
-#define FREQ_PERIPH_DIV (CONFIG_MACH_SAME70 ? 2 : 1)
-#define FREQ_PERIPH (CONFIG_CLOCK_FREQ / FREQ_PERIPH_DIV)
-
-/****************************************************************
- * watchdog handler
- ****************************************************************/
-
-void
-watchdog_reset(void)
-{
-    WDT->WDT_CR = 0xA5000001;
-}
-DECL_TASK(watchdog_reset);
-
-void
-watchdog_init(void)
-{
-    uint32_t timeout = 500 * 32768 / 128 / 1000;  // 500ms timeout
-    WDT->WDT_MR = WDT_MR_WDRSTEN | WDT_MR_WDV(timeout) | WDT_MR_WDD(timeout);
-}
-DECL_INIT(watchdog_init);
-
-
-/****************************************************************
- * Peripheral clocks
- ****************************************************************/
-
-// Check if a peripheral clock has been enabled
-int
-is_enabled_pclock(uint32_t id)
-{
-    if (id < 32)
-        return !!(PMC->PMC_PCSR0 & (1 << id));
-    else
-        return !!(PMC->PMC_PCSR1 & (1 << (id - 32)));
-}
-
-// Enable a peripheral clock
-void
-enable_pclock(uint32_t id)
-{
-    if (id < 32)
-        PMC->PMC_PCER0 = 1 << id;
-    else
-        PMC->PMC_PCER1 = 1 << (id - 32);
-}
-
-// Return the frequency of the given peripheral clock
-uint32_t
-get_pclock_frequency(uint32_t id)
-{
-    return FREQ_PERIPH;
-}
-
-
-/****************************************************************
- * Resets
- ****************************************************************/
-
-#if CONFIG_MACH_SAME70
-#define RST_PARAMS ((0xA5 << RSTC_CR_KEY_Pos) | RSTC_CR_PROCRST)
-#else
-#define RST_PARAMS ((0xA5 << RSTC_CR_KEY_Pos) | RSTC_CR_PROCRST \
-                    | RSTC_CR_PERRST)
-#endif
-
-void
-command_reset(uint32_t *args)
-{
-    irq_disable();
-    RSTC->RSTC_CR = RST_PARAMS;
-    for (;;)
-        ;
-}
-DECL_COMMAND_FLAGS(command_reset, HF_IN_SHUTDOWN, "reset");
-
-#if CONFIG_MACH_SAM3X || CONFIG_MACH_SAM4S
-#define EFC_HW EFC0
-#elif CONFIG_MACH_SAM4E || CONFIG_MACH_SAME70
-#define EFC_HW EFC
-#endif
-
-void noinline __aligned(16) // align for predictable flash code access
-bootloader_request(void)
-{
-    irq_disable();
-    // Request boot from ROM (instead of boot from flash)
-    while ((EFC_HW->EEFC_FSR & EEFC_FSR_FRDY) == 0)
-        ;
-    EFC_HW->EEFC_FCR = (EEFC_FCR_FCMD_CGPB | EEFC_FCR_FARG(1)
-                        | EEFC_FCR_FKEY_PASSWD);
-    while ((EFC_HW->EEFC_FSR & EEFC_FSR_FRDY) == 0)
-        ;
-    // Reboot
-    RSTC->RSTC_CR = RST_PARAMS;
-    for (;;)
-        ;
-}
-
-
-/****************************************************************
- * Startup
- ****************************************************************/
-
-static void
-matrix_init(void)
-{
-    // The ATSAM sram is in a "no default master" state at reset
-    // (despite the specs).  That typically adds 1 wait cycle to every
-    // memory access.  Set it to "last access master" to avoid that.
-    MATRIX->MATRIX_SCFG[0] = (MATRIX_SCFG_SLOT_CYCLE(64)
-                              | MATRIX_SCFG_DEFMSTR_TYPE(1));
-}
-
-// Main entry point - called from armcm_boot.c:ResetHandler()
-void
-armcm_main(void)
-{
-    SystemInit();
-    matrix_init();
-    sched_main();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/Makefile crealityShit/src/atsam/Makefile
--- klipperStock/src/atsam/Makefile	2024-01-14 23:02:00.161796843 -0600
+++ crealityShit/src/atsam/Makefile	1969-12-31 18:00:00.000000000 -0600
@@ -1,59 +0,0 @@
-# Additional ATSAM build rules
-
-# Setup the toolchain
-CROSS_PREFIX=arm-none-eabi-
-
-dirs-y += src/atsam src/generic
-dirs-$(CONFIG_MACH_SAM3X) += lib/sam3x/gcc
-dirs-$(CONFIG_MACH_SAM4S) += lib/sam4s/gcc
-dirs-$(CONFIG_MACH_SAM4E) += lib/sam4e/gcc
-dirs-$(CONFIG_MACH_SAME70) += lib/same70b/gcc
-
-MCU := $(shell echo $(CONFIG_MCU) | tr a-z A-Z)
-
-CFLAGS-$(CONFIG_MACH_SAM3X) += -mcpu=cortex-m3 -falign-loops=16
-CFLAGS-$(CONFIG_MACH_SAM4) += -mcpu=cortex-m4
-CFLAGS-$(CONFIG_MACH_SAME70) += -mcpu=cortex-m7
-CFLAGS-$(CONFIG_MACH_SAM3X) += -Ilib/sam3x/include
-CFLAGS-$(CONFIG_MACH_SAM4S) += -Ilib/sam4s/include
-CFLAGS-$(CONFIG_MACH_SAM4E) += -Ilib/sam4e/include
-CFLAGS-$(CONFIG_MACH_SAME70) += -Ilib/same70b/include
-CFLAGS += $(CFLAGS-y) -D__$(MCU)__ -mthumb -Ilib/cmsis-core
-
-CFLAGS_klipper.elf += --specs=nano.specs --specs=nosys.specs
-CFLAGS_klipper.elf += -T $(OUT)src/generic/armcm_link.ld
-$(OUT)klipper.elf: $(OUT)src/generic/armcm_link.ld
-
-# Add source files
-src-y += atsam/main.c atsam/gpio.c atsam/i2c.c atsam/spi.c
-src-y += generic/armcm_boot.c generic/armcm_irq.c generic/armcm_timer.c
-src-y += generic/crc16_ccitt.c
-usb-src-$(CONFIG_MACH_SAM3X) := atsam/sam3_usb.c
-usb-src-$(CONFIG_MACH_SAM4) := atsam/sam4_usb.c
-usb-src-$(CONFIG_MACH_SAME70) := atsam/sam3_usb.c
-src-$(CONFIG_USBSERIAL) += $(usb-src-y) atsam/chipid.c generic/usb_cdc.c
-src-$(CONFIG_SERIAL) += atsam/serial.c generic/serial_irq.c
-src-$(CONFIG_MACH_SAM3X) += atsam/adc.c atsam/hard_pwm.c
-src-$(CONFIG_MACH_SAM4)  += atsam/hard_pwm.c
-src-$(CONFIG_MACH_SAM4S) += atsam/adc.c
-src-$(CONFIG_MACH_SAM4E) += atsam/sam4e_afec.c atsam/sam4_cache.c
-src-$(CONFIG_MACH_SAM3X) += ../lib/sam3x/gcc/system_sam3xa.c
-src-$(CONFIG_MACH_SAM4S) += atsam/sam4s_sysinit.c
-src-$(CONFIG_MACH_SAM4E) += ../lib/sam4e/gcc/system_sam4e.c
-src-$(CONFIG_MACH_SAME70) += atsam/same70_sysinit.c atsam/sam4e_afec.c
-
-# Build the additional bin output file
-target-y += $(OUT)klipper.bin
-
-$(OUT)klipper.bin: $(OUT)klipper.elf
-	@echo "  Creating bin file $@"
-	$(Q)$(OBJCOPY) -O binary $< $@
-
-# Flash rules
-lib/bossac/bin/bossac:
-	@echo "  Building bossac"
-	$(Q)make -C lib/bossac bin/bossac
-
-flash: $(OUT)klipper.bin lib/bossac/bin/bossac
-	@echo "  Flashing $< to $(FLASH_DEVICE)"
-	$(Q)$(PYTHON) ./scripts/flash_usb.py -t $(CONFIG_MCU) -d "$(FLASH_DEVICE)" $(OUT)klipper.bin
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/sam3_usb.c crealityShit/src/atsam/sam3_usb.c
--- klipperStock/src/atsam/sam3_usb.c	2024-01-14 23:02:00.165796891 -0600
+++ crealityShit/src/atsam/sam3_usb.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,234 +0,0 @@
-// Hardware interface to USB on SAM3X
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // NULL
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/usb_cdc.h" // usb_notify_ep0
-#include "board/usb_cdc_ep.h" // USB_CDC_EP_BULK_IN
-#include "internal.h" // UOTGHS
-#include "sched.h" // DECL_INIT
-
-#if CONFIG_MACH_SAME70
-#include "same70_usb.h" // Fixes for upstream header changes
-#define CFG_UOTGHS_CTRL (UOTGHS_CTRL_UIMOD | UOTGHS_CTRL_USBE)
-#else
-#define CFG_UOTGHS_CTRL (UOTGHS_CTRL_UIMOD | UOTGHS_CTRL_OTGPADE | \
-                         UOTGHS_CTRL_USBE)
-#endif
-
-#define EP_SIZE(s) ((s)==64 ? UOTGHS_DEVEPTCFG_EPSIZE_64_BYTE :         \
-                    ((s)==32 ? UOTGHS_DEVEPTCFG_EPSIZE_32_BYTE :        \
-                     ((s)==16 ? UOTGHS_DEVEPTCFG_EPSIZE_16_BYTE :       \
-                      UOTGHS_DEVEPTCFG_EPSIZE_8_BYTE)))
-
-#define usb_fifo(ep) ((void*)UOTGHS_RAM_ADDR + ((ep) * 0x8000))
-
-static void
-usb_write_packet(uint32_t ep, const uint8_t *data, uint32_t len)
-{
-    uint8_t *dest = usb_fifo(ep);
-    while (len--)
-        *dest++ = *data++;
-}
-
-static void
-usb_read_packet(uint32_t ep, uint8_t *data, uint32_t len)
-{
-    uint8_t *src = usb_fifo(ep);
-    while (len--)
-        *data++ = *src++;
-}
-
-int_fast8_t
-usb_read_bulk_out(void *data, uint_fast8_t max_len)
-{
-    uint32_t eps = UOTGHS->UOTGHS_DEVEPTISR[USB_CDC_EP_BULK_OUT];
-    if (!(eps & UOTGHS_DEVEPTISR_RXOUTI)) {
-        // No data ready
-        UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_PEP_0 << USB_CDC_EP_BULK_OUT;
-        return -1;
-    }
-    uint32_t len = (eps&UOTGHS_DEVEPTISR_BYCT_Msk) >> UOTGHS_DEVEPTISR_BYCT_Pos;
-    usb_read_packet(USB_CDC_EP_BULK_OUT, data, len > max_len ? max_len : len);
-    UOTGHS->UOTGHS_DEVEPTICR[USB_CDC_EP_BULK_OUT] = UOTGHS_DEVEPTICR_RXOUTIC;
-    UOTGHS->UOTGHS_DEVEPTIDR[USB_CDC_EP_BULK_OUT] = UOTGHS_DEVEPTIDR_FIFOCONC;
-    return len;
-}
-
-int_fast8_t
-usb_send_bulk_in(void *data, uint_fast8_t len)
-{
-    uint32_t eps = UOTGHS->UOTGHS_DEVEPTISR[USB_CDC_EP_BULK_IN];
-    if (!(eps & UOTGHS_DEVEPTISR_TXINI)) {
-        // Buffer full
-        UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_PEP_0 << USB_CDC_EP_BULK_IN;
-        return -1;
-    }
-    usb_write_packet(USB_CDC_EP_BULK_IN, data, len);
-    UOTGHS->UOTGHS_DEVEPTICR[USB_CDC_EP_BULK_IN] = UOTGHS_DEVEPTICR_TXINIC;
-    UOTGHS->UOTGHS_DEVEPTIDR[USB_CDC_EP_BULK_IN] = UOTGHS_DEVEPTIDR_FIFOCONC;
-    return len;
-}
-
-int_fast8_t
-usb_read_ep0(void *data, uint_fast8_t max_len)
-{
-    uint32_t eps = UOTGHS->UOTGHS_DEVEPTISR[0];
-    if (eps & UOTGHS_DEVEPTISR_RXSTPI)
-        return -2;
-    if (!(eps & UOTGHS_DEVEPTISR_RXOUTI)) {
-        // Not ready to receive data
-        UOTGHS->UOTGHS_DEVEPTIER[0] = UOTGHS_DEVEPTIER_RXOUTES;
-        UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_PEP_0 << 0;
-        return -1;
-    }
-    usb_read_packet(0, data, max_len);
-    if (UOTGHS->UOTGHS_DEVEPTISR[0] & UOTGHS_DEVEPTISR_RXSTPI)
-        return -2;
-    UOTGHS->UOTGHS_DEVEPTICR[0] = UOTGHS_DEVEPTICR_RXOUTIC;
-    return max_len;
-}
-
-int_fast8_t
-usb_read_ep0_setup(void *data, uint_fast8_t max_len)
-{
-    uint32_t eps = UOTGHS->UOTGHS_DEVEPTISR[0];
-    if (!(eps & UOTGHS_DEVEPTISR_RXSTPI)) {
-        // No data ready to read
-        UOTGHS->UOTGHS_DEVEPTIDR[0] = (UOTGHS_DEVEPTIDR_TXINEC
-                                       | UOTGHS_DEVEPTIDR_RXOUTEC);
-        UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_PEP_0 << 0;
-        return -1;
-    }
-    usb_read_packet(0, data, max_len);
-    UOTGHS->UOTGHS_DEVEPTICR[0] = (UOTGHS_DEVEPTICR_RXSTPIC
-                                   | UOTGHS_DEVEPTICR_RXOUTIC);
-    return max_len;
-}
-
-int_fast8_t
-usb_send_ep0(const void *data, uint_fast8_t len)
-{
-    uint32_t eps = UOTGHS->UOTGHS_DEVEPTISR[0];
-    if (eps & (UOTGHS_DEVEPTISR_RXSTPI | UOTGHS_DEVEPTISR_RXOUTI))
-        return -2;
-    if (!(eps & UOTGHS_DEVEPTISR_TXINI)) {
-        // Not ready to send
-        UOTGHS->UOTGHS_DEVEPTIER[0] = (UOTGHS_DEVEPTIER_TXINES
-                                       | UOTGHS_DEVEPTIER_RXOUTES);
-        UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_PEP_0 << 0;
-        return -1;
-    }
-    usb_write_packet(0, data, len);
-    UOTGHS->UOTGHS_DEVEPTICR[0] = UOTGHS_DEVEPTICR_TXINIC;
-    return len;
-}
-
-void
-usb_stall_ep0(void)
-{
-    UOTGHS->UOTGHS_DEVEPTIER[0] = UOTGHS_DEVEPTIER_STALLRQS;
-    UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_PEP_0 << 0;
-}
-
-static uint8_t set_address;
-
-void
-usb_set_address(uint_fast8_t addr)
-{
-    set_address = addr | UOTGHS_DEVCTRL_ADDEN;
-    usb_send_ep0(NULL, 0);
-    UOTGHS->UOTGHS_DEVEPTIER[0] = UOTGHS_DEVEPTIER_TXINES;
-    UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_PEP_0 << 0;
-}
-
-void
-usb_set_configure(void)
-{
-    UOTGHS->UOTGHS_DEVEPT = ((UOTGHS_DEVEPT_EPEN0 << 0)
-                             | (UOTGHS_DEVEPT_EPEN0 << USB_CDC_EP_BULK_OUT)
-                             | (UOTGHS_DEVEPT_EPEN0 << USB_CDC_EP_BULK_IN)
-                             | (UOTGHS_DEVEPT_EPEN0 << USB_CDC_EP_ACM));
-
-    UOTGHS->UOTGHS_DEVEPTCFG[USB_CDC_EP_BULK_OUT] = (
-        EP_SIZE(USB_CDC_EP_BULK_OUT_SIZE)
-        | UOTGHS_DEVEPTCFG_EPTYPE_BLK | UOTGHS_DEVEPTCFG_EPBK_2_BANK
-        | UOTGHS_DEVEPTCFG_ALLOC);
-    UOTGHS->UOTGHS_DEVEPTIER[USB_CDC_EP_BULK_OUT] = UOTGHS_DEVEPTIER_RXOUTES;
-    UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_PEP_0 << USB_CDC_EP_BULK_OUT;
-
-    UOTGHS->UOTGHS_DEVEPTCFG[USB_CDC_EP_BULK_IN] = (
-        EP_SIZE(USB_CDC_EP_BULK_IN_SIZE) | UOTGHS_DEVEPTCFG_EPDIR_IN
-        | UOTGHS_DEVEPTCFG_EPTYPE_BLK | UOTGHS_DEVEPTCFG_EPBK_2_BANK
-        | UOTGHS_DEVEPTCFG_ALLOC);
-    UOTGHS->UOTGHS_DEVEPTIER[USB_CDC_EP_BULK_IN] = UOTGHS_DEVEPTIER_TXINES;
-    UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_PEP_0 << USB_CDC_EP_BULK_IN;
-
-    UOTGHS->UOTGHS_DEVEPTCFG[USB_CDC_EP_ACM] = (
-        EP_SIZE(USB_CDC_EP_ACM_SIZE) | UOTGHS_DEVEPTCFG_EPDIR_IN
-        | UOTGHS_DEVEPTCFG_EPTYPE_INTRPT | UOTGHS_DEVEPTCFG_EPBK_2_BANK
-        | UOTGHS_DEVEPTCFG_ALLOC);
-}
-
-// Configure endpoint 0 after usb reset completes
-static void
-handle_end_reset(void)
-{
-    UOTGHS->UOTGHS_DEVEPT = UOTGHS_DEVEPT_EPEN0 << 0;
-    UOTGHS->UOTGHS_DEVEPTCFG[0] = (
-        EP_SIZE(USB_CDC_EP0_SIZE)
-        | UOTGHS_DEVEPTCFG_EPTYPE_CTRL | UOTGHS_DEVEPTCFG_EPBK_1_BANK
-        | UOTGHS_DEVEPTCFG_ALLOC);
-    UOTGHS->UOTGHS_DEVEPTIER[0] = UOTGHS_DEVEPTIER_RXSTPES;
-    UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_PEP_0 << 0;
-
-    UOTGHS->UOTGHS_DEVICR = UOTGHS_DEVICR_EORSTC;
-}
-
-void
-UOTGHS_Handler(void)
-{
-    uint32_t s = UOTGHS->UOTGHS_DEVISR;
-    if (s & UOTGHS_DEVISR_EORST) {
-        handle_end_reset();
-        return;
-    }
-    UOTGHS->UOTGHS_DEVIDR = s;
-    if (s & (UOTGHS_DEVISR_PEP_0 << 0)) {
-        usb_notify_ep0();
-
-        if (set_address
-            && (UOTGHS->UOTGHS_DEVEPTISR[0] & UOTGHS_DEVEPTISR_TXINI)) {
-            // Ack from set_address command sent - now update address
-            UOTGHS->UOTGHS_DEVCTRL = (set_address
-                                      | UOTGHS_DEVCTRL_SPDCONF_FORCED_FS);
-            set_address = 0;
-        }
-    }
-    if (s & (UOTGHS_DEVISR_PEP_0 << USB_CDC_EP_BULK_OUT))
-        usb_notify_bulk_out();
-    if (s & (UOTGHS_DEVISR_PEP_0 << USB_CDC_EP_BULK_IN))
-        usb_notify_bulk_in();
-}
-
-void
-usbserial_init(void)
-{
-    // Setup USB clock
-    enable_pclock(ID_UOTGHS);
-    PMC->CKGR_UCKR = CKGR_UCKR_UPLLCOUNT(3) | CKGR_UCKR_UPLLEN;
-    while (!(PMC->PMC_SR & PMC_SR_LOCKU))
-        ;
-
-    // Enable USB
-    UOTGHS->UOTGHS_CTRL = CFG_UOTGHS_CTRL;
-    UOTGHS->UOTGHS_DEVCTRL = UOTGHS_DEVCTRL_SPDCONF_FORCED_FS;
-
-    // Enable interrupts
-    armcm_enable_irq(UOTGHS_Handler, UOTGHS_IRQn, 1);
-    UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_EORSTES;
-}
-DECL_INIT(usbserial_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/sam4_cache.c crealityShit/src/atsam/sam4_cache.c
--- klipperStock/src/atsam/sam4_cache.c	2024-01-14 23:02:00.161796843 -0600
+++ crealityShit/src/atsam/sam4_cache.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,16 +0,0 @@
-// SAM4 cache enable
-//
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "sam4e.h" // CMCC
-#include "sched.h" // DECL_INIT
-
-void
-sam4_cache_init(void)
-{
-    if (!(CMCC->CMCC_SR & CMCC_SR_CSTS))
-        CMCC->CMCC_CTRL = CMCC_CTRL_CEN;
-}
-DECL_INIT(sam4_cache_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/sam4e_afec.c crealityShit/src/atsam/sam4e_afec.c
--- klipperStock/src/atsam/sam4e_afec.c	2024-01-14 23:02:00.157796793 -0600
+++ crealityShit/src/atsam/sam4e_afec.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,241 +0,0 @@
-// SAM4e8e Analog Front-End Converter (AFEC) support
-//
-// Copyright (C) 2018  Florian Heilmann <Florian.Heilmann@gmx.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_CLOCK_FREQ
-#include "command.h" // shutdown
-#include "gpio.h" // gpio_adc_setup
-#include "internal.h" // GPIO, AFEC0
-#include "sched.h" // sched_shutdown
-
-#if CONFIG_MACH_SAME70
-#include "same70_afec.h" // Fixes for upstream header changes
-#endif
-
-#define ADC_TEMPERATURE_PIN 0xfe
-DECL_ENUMERATION("pin", "ADC_TEMPERATURE", ADC_TEMPERATURE_PIN);
-
-static const uint8_t afec_pins[] = {
-    //remove first channel, since it offsets the channel number: GPIO('A', 8),
-    #if CONFIG_MACH_SAM4E
-    GPIO('A', 17), GPIO('A', 18), GPIO('A', 19),
-    GPIO('A', 20), GPIO('B', 0),  GPIO('B', 1), GPIO('C', 13),
-    GPIO('C', 15), GPIO('C', 12), GPIO('C', 29), GPIO('C', 30),
-    GPIO('C', 31), GPIO('C', 26), GPIO('C', 27), GPIO('C',0),
-    ADC_TEMPERATURE_PIN,
-    // AFEC1
-    GPIO('B', 2), GPIO('B', 3), GPIO('A', 21), GPIO('A', 22),
-    GPIO('C', 1), GPIO('C', 2), GPIO('C', 3), GPIO('C', 4),
-    #elif CONFIG_MACH_SAME70
-    GPIO('D', 30), GPIO('A', 21), GPIO('B', 3),  GPIO('E', 5),
-    GPIO('E', 4),  GPIO('B', 2),  GPIO('A', 17), GPIO('A', 18),
-    GPIO('A', 19), GPIO('A', 20), GPIO('B', 0),
-    ADC_TEMPERATURE_PIN,
-    // AFEC1
-    GPIO('B', 1),  GPIO('C', 13), GPIO('C', 15), GPIO('C', 12),
-    GPIO('C', 29), GPIO('C', 30), GPIO('C', 31), GPIO('C', 26),
-    GPIO('C', 27), GPIO('C', 0),  GPIO('E', 3),  GPIO('E', 0),
-    #endif
-};
-
-#if CONFIG_MACH_SAM4E
-#define AFEC1_START 16 // The first 16 pins are on afec0
-#define CFG_AFE_MR (AFE_MR_ANACH_ALLOWED | \
-                    AFE_MR_PRESCAL(pclk / (2 * ADC_FREQ_MAX) - 1) | \
-                    AFE_MR_SETTLING_AST3 | \
-                    AFE_MR_TRACKTIM(2) | \
-                    AFE_MR_TRANSFER(1) | \
-                    AFE_MR_STARTUP_SUT64)
-#define CFG_AFE_ACR AFE_ACR_IBCTL(1)
-#define CFG_AFE_IDR 0xDF00FFFF
-#define CFG_AFE_COCR (0x800 & AFE_COCR_AOFF_Msk)
-
-#elif CONFIG_MACH_SAME70
-#define AFEC1_START 12 // The first 12 pins are on afec0
-#define CFG_AFE_MR (AFEC_MR_ONE | \
-                    AFE_MR_PRESCAL (pclk / (ADC_FREQ_MAX) -1) | \
-                    AFE_MR_TRANSFER(2) | \
-                    AFE_MR_STARTUP_SUT64)
-#define CFG_AFE_ACR (AFE_ACR_IBCTL(1) | AFEC_ACR_PGA0EN | AFEC_ACR_PGA1EN)
-#define CFG_AFE_IDR 0x47000FFF
-#define CFG_AFE_COCR (0x200 & AFE_COCR_AOFF_Msk)
-#endif
-
-static inline struct gpio_adc
-pin_to_gpio_adc(uint8_t pin)
-{
-    int chan;
-    for (chan=0; ; chan++) {
-        if (chan >= ARRAY_SIZE(afec_pins))
-            shutdown("Not a valid ADC pin");
-        if (afec_pins[chan] == pin) {
-            break;
-        }
-    }
-    return (struct gpio_adc){ .chan=chan };
-}
-
-static inline Afec *
-gpio_adc_to_afec(struct gpio_adc g)
-{
-    return (g.chan >= AFEC1_START ? AFEC1 : AFEC0);
-}
-
-static inline uint32_t
-gpio_adc_to_afec_chan(struct gpio_adc g)
-{
-    return (g.chan >= AFEC1_START ? g.chan - AFEC1_START : g.chan);
-}
-
-#define ADC_FREQ_MAX 6000000UL
-DECL_CONSTANT("ADC_MAX", 4095);
-
-static int
-init_afec(Afec* afec) {
-
-    // Enable PMC
-    enable_pclock(afec == AFEC0 ? ID_AFEC0 : ID_AFEC1);
-
-    // If busy, return busy
-    if ((afec->AFE_ISR & AFE_ISR_DRDY) == AFE_ISR_DRDY) {
-        return -1;
-    }
-
-    // Reset
-    afec->AFE_CR = AFE_CR_SWRST;
-
-    // Configure afec
-    uint32_t pclk = get_pclock_frequency(afec == AFEC0 ? ID_AFEC0 : ID_AFEC1);
-    afec->AFE_MR = CFG_AFE_MR;
-    afec->AFE_EMR = AFE_EMR_TAG | \
-                     AFE_EMR_RES_NO_AVERAGE | \
-                     AFE_EMR_STM;
-    afec->AFE_ACR = CFG_AFE_ACR;
-
-    // Disable interrupts
-    afec->AFE_IDR = CFG_AFE_IDR;
-
-    // Disable SW triggering
-    uint32_t mr = afec->AFE_MR;
-
-    mr &= ~(AFE_MR_TRGSEL_Msk | AFE_MR_TRGEN | AFE_MR_FREERUN_ON);
-    mr |= AFE_MR_TRGEN_DIS;
-    afec->AFE_MR = mr;
-
-    return 0;
-}
-
-void
-gpio_afec_init(void) {
-
-    while(init_afec(AFEC0) != 0) {
-        (void)(AFEC0->AFE_LCDR & AFE_LCDR_LDATA_Msk);
-    }
-    while(init_afec(AFEC1) != 0) {
-        (void)(AFEC1->AFE_LCDR & AFE_LCDR_LDATA_Msk);
-    }
-
-}
-DECL_INIT(gpio_afec_init);
-
-struct gpio_adc
-gpio_adc_setup(uint8_t pin)
-{
-    struct gpio_adc adc_pin = pin_to_gpio_adc(pin);
-    Afec *afec = gpio_adc_to_afec(adc_pin);
-    uint32_t afec_chan = gpio_adc_to_afec_chan(adc_pin);
-
-    //config channel
-    uint32_t reg = afec->AFE_DIFFR;
-    reg &= ~(1u << afec_chan);
-    afec->AFE_DIFFR = reg;
-    reg = afec->AFE_CGR;
-    reg &= ~(0x03u << (2 * afec_chan));
-    afec->AFE_CGR = reg;
-
-    // Configure channel
-    // afec_ch_get_config_defaults(&ch_cfg);
-    // afec_ch_set_config(afec, afec_chan, &ch_cfg);
-    // Remove default internal offset from channel
-    // See Atmel Appnote AT03078 Section 1.5 for SAM4E,
-    // datasheet section 52.6.11 for SAME70
-    afec->AFE_CSELR = afec_chan;
-    afec->AFE_COCR = CFG_AFE_COCR;
-
-    // Enable and calibrate Channel
-    afec->AFE_CHER = 1 << afec_chan;
-
-    #if CONFIG_MACH_SAM4E
-    reg = afec->AFE_CHSR;
-    afec->AFE_CDOR = reg;
-    afec->AFE_CR = AFE_CR_AUTOCAL;
-    #endif
-
-    return adc_pin;
-}
-
-enum { AFE_DUMMY=0xff };
-uint8_t active_channel = AFE_DUMMY;
-
-// Try to sample a value. Returns zero if sample ready, otherwise
-// returns the number of clock ticks the caller should wait before
-// retrying this function.
-uint32_t
-gpio_adc_sample(struct gpio_adc g)
-{
-    Afec *afec = gpio_adc_to_afec(g);
-    uint32_t afec_chan = gpio_adc_to_afec_chan(g);
-    if (active_channel == g.chan) {
-        if ((afec->AFE_ISR & AFE_ISR_DRDY)
-            && (afec->AFE_ISR & (1 << afec_chan))) {
-            // Sample now ready
-            return 0;
-        } else {
-            // Busy
-            goto need_delay;
-        }
-    } else if (active_channel != AFE_DUMMY) {
-        goto need_delay;
-    }
-
-    afec->AFE_CHDR = 0x803F; // Disable all channels
-    afec->AFE_CHER = 1 << afec_chan;
-
-    active_channel = g.chan;
-
-    for (uint32_t chan = 0; chan < 16; ++chan)
-    {
-        if ((afec->AFE_ISR & (1 << chan)) != 0)
-        {
-            afec->AFE_CSELR = chan;
-            (void)(afec->AFE_CDR);
-        }
-    }
-    afec->AFE_CR = AFE_CR_START;
-
-need_delay:
-    // about 400 mcu clock cycles or 40 afec cycles
-    return ADC_FREQ_MAX * 10000ULL / CONFIG_CLOCK_FREQ;
-}
-
-// Read a value; use only after gpio_adc_sample() returns zero
-uint16_t
-gpio_adc_read(struct gpio_adc g)
-{
-    Afec *afec = gpio_adc_to_afec(g);
-    uint32_t afec_chan = gpio_adc_to_afec_chan(g);
-    active_channel = AFE_DUMMY;
-    afec->AFE_CSELR = afec_chan;
-    return afec->AFE_CDR;
-}
-
-// Cancel a sample that may have been started with gpio_adc_sample()
-void
-gpio_adc_cancel_sample(struct gpio_adc g)
-{
-    if (active_channel == g.chan) {
-        active_channel = AFE_DUMMY;
-    }
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/sam4s_sysinit.c crealityShit/src/atsam/sam4s_sysinit.c
--- klipperStock/src/atsam/sam4s_sysinit.c	2024-01-14 23:02:00.161796843 -0600
+++ crealityShit/src/atsam/sam4s_sysinit.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,71 +0,0 @@
-// This code is from lib/sam4e/gcc/system_sam4e.c - it is unclear why
-// it is not defined in the Atmel sam4s cmsis code.
-
-#include "internal.h"
-
-/* Clock Settings (120MHz) */
-#define SYS_BOARD_OSCOUNT   (CKGR_MOR_MOSCXTST(0x8U))
-#define SYS_BOARD_PLLAR     (CKGR_PLLAR_ONE                             \
-                             | CKGR_PLLAR_MULA(0x13U)                   \
-                             | CKGR_PLLAR_PLLACOUNT(0x3fU)              \
-                             | CKGR_PLLAR_DIVA(0x1U))
-#define SYS_BOARD_MCKR      (PMC_MCKR_PRES_CLK_2 | PMC_MCKR_CSS_PLLA_CLK)
-
-/* Key to unlock MOR register */
-#define SYS_CKGR_MOR_KEY_VALUE CKGR_MOR_KEY(0x37)
-
-uint32_t SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
-
-void SystemInit( void )
-{
-    /* Set FWS according to SYS_BOARD_MCKR configuration */
-    EFC0->EEFC_FMR = EEFC_FMR_FWS(5) | EEFC_FMR_CLOE;
-
-    /* Initialize main oscillator */
-    if ( !(PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) )
-    {
-        PMC->CKGR_MOR = (SYS_CKGR_MOR_KEY_VALUE | SYS_BOARD_OSCOUNT
-                         | CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN);
-
-        while ( !(PMC->PMC_SR & PMC_SR_MOSCXTS) )
-        {
-        }
-    }
-
-    /* Switch to 3-20MHz Xtal oscillator */
-    PMC->CKGR_MOR = (SYS_CKGR_MOR_KEY_VALUE | SYS_BOARD_OSCOUNT
-                     | CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN
-                     | CKGR_MOR_MOSCSEL);
-
-    while ( !(PMC->PMC_SR & PMC_SR_MOSCSELS) )
-    {
-    }
-
-    PMC->PMC_MCKR = ((PMC->PMC_MCKR & ~(uint32_t)PMC_MCKR_CSS_Msk)
-                     | PMC_MCKR_CSS_MAIN_CLK);
-
-    while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
-    {
-    }
-
-    /* Initialize PLLA */
-    PMC->CKGR_PLLAR = SYS_BOARD_PLLAR;
-    while ( !(PMC->PMC_SR & PMC_SR_LOCKA) )
-    {
-    }
-
-    /* Switch to main clock */
-    PMC->PMC_MCKR = ((SYS_BOARD_MCKR & ~PMC_MCKR_CSS_Msk)
-                     | PMC_MCKR_CSS_MAIN_CLK);
-    while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
-    {
-    }
-
-    /* Switch to PLLA */
-    PMC->PMC_MCKR = SYS_BOARD_MCKR;
-    while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
-    {
-    }
-
-    SystemCoreClock = CHIP_FREQ_CPU_MAX;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/sam4_usb.c crealityShit/src/atsam/sam4_usb.c
--- klipperStock/src/atsam/sam4_usb.c	2024-01-14 23:02:00.161796843 -0600
+++ crealityShit/src/atsam/sam4_usb.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,218 +0,0 @@
-// Hardware interface to SAM4 USB Device Port
-//
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // NULL
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/irq.h" // irq_disable
-#include "board/usb_cdc.h" // usb_notify_ep0
-#include "board/usb_cdc_ep.h" // USB_CDC_EP_BULK_IN
-#include "command.h" // DECL_CONSTANT_STR
-#include "internal.h" // UDP
-#include "sched.h" // DECL_INIT
-
-#define CSR_EP0 (UDP_CSR_EPTYPE_CTRL | UDP_CSR_EPEDS)
-#define CSR_ACM (UDP_CSR_EPTYPE_INT_IN | UDP_CSR_EPEDS)
-#define CSR_BULK_OUT (UDP_CSR_EPTYPE_BULK_OUT | UDP_CSR_EPEDS)
-#define CSR_BULK_IN (UDP_CSR_EPTYPE_BULK_IN | UDP_CSR_EPEDS)
-
-static void
-usb_write_packet(uint32_t ep, const uint8_t *data, uint32_t len)
-{
-    while (len--)
-        UDP->UDP_FDR[ep] = *data++;
-}
-
-static uint32_t
-usb_read_packet(uint32_t ep, uint32_t csr, uint8_t *data, uint32_t max_len)
-{
-    uint32_t pk_len = (csr & UDP_CSR_RXBYTECNT_Msk) >> UDP_CSR_RXBYTECNT_Pos;
-    uint32_t len = pk_len < max_len ? pk_len : max_len, orig_len = len;
-    while (len--)
-        *data++ = UDP->UDP_FDR[ep];
-    return orig_len;
-}
-
-int_fast8_t
-usb_read_bulk_out(void *data, uint_fast8_t max_len)
-{
-    static uint32_t next_bk = UDP_CSR_RX_DATA_BK0;
-    const uint32_t other_irqs = (UDP_CSR_RXSETUP | UDP_CSR_STALLSENT
-                                 | UDP_CSR_TXCOMP);
-    uint32_t csr = UDP->UDP_CSR[USB_CDC_EP_BULK_OUT];
-    uint32_t bk = csr & (UDP_CSR_RX_DATA_BK0 | UDP_CSR_RX_DATA_BK1);
-    if (!bk) {
-        // Not ready to receive data
-        if (csr & other_irqs)
-            UDP->UDP_CSR[USB_CDC_EP_BULK_OUT] = (
-                CSR_BULK_OUT | UDP_CSR_RX_DATA_BK0 | UDP_CSR_RX_DATA_BK1);
-        UDP->UDP_IER = 1<<USB_CDC_EP_BULK_OUT;
-        return -1;
-    }
-    uint32_t len = usb_read_packet(USB_CDC_EP_BULK_OUT, csr, data, max_len);
-    if (bk == (UDP_CSR_RX_DATA_BK0 | UDP_CSR_RX_DATA_BK1))
-        bk = next_bk;
-    next_bk = bk ^ (UDP_CSR_RX_DATA_BK0 | UDP_CSR_RX_DATA_BK1);
-    UDP->UDP_CSR[USB_CDC_EP_BULK_OUT] = CSR_BULK_OUT | next_bk;
-    return len;
-}
-
-int_fast8_t
-usb_send_bulk_in(void *data, uint_fast8_t len)
-{
-    const uint32_t other_irqs = (UDP_CSR_RXSETUP | UDP_CSR_STALLSENT
-                                 | UDP_CSR_RX_DATA_BK0 | UDP_CSR_RX_DATA_BK1);
-    uint32_t csr = UDP->UDP_CSR[USB_CDC_EP_BULK_IN];
-    if (csr & UDP_CSR_TXPKTRDY) {
-        // Not ready to send
-        if (csr & other_irqs)
-            UDP->UDP_CSR[USB_CDC_EP_BULK_IN] = CSR_BULK_IN | UDP_CSR_TXCOMP;
-        UDP->UDP_IER = 1<<USB_CDC_EP_BULK_IN;
-        return -1;
-    }
-    usb_write_packet(USB_CDC_EP_BULK_IN, data, len);
-    UDP->UDP_CSR[USB_CDC_EP_BULK_IN] = CSR_BULK_IN | UDP_CSR_TXPKTRDY;
-    return len;
-}
-
-int_fast8_t
-usb_read_ep0(void *data, uint_fast8_t max_len)
-{
-    const uint32_t other_irqs = (UDP_CSR_RXSETUP | UDP_CSR_STALLSENT
-                                 | UDP_CSR_TXCOMP | UDP_CSR_RX_DATA_BK1);
-    uint32_t csr = UDP->UDP_CSR[0];
-    if (csr & other_irqs)
-        return -2;
-    if (!(csr & UDP_CSR_RX_DATA_BK0)) {
-        // Not ready to receive data
-        UDP->UDP_IER = 1<<0;
-        return -1;
-    }
-    uint32_t len = usb_read_packet(0, csr, data, max_len);
-    if (UDP->UDP_CSR[0] & other_irqs)
-        return -2;
-    UDP->UDP_CSR[0] = CSR_EP0 | other_irqs;
-    return len;
-}
-
-int_fast8_t
-usb_read_ep0_setup(void *data, uint_fast8_t max_len)
-{
-    const uint32_t other_irqs = (UDP_CSR_STALLSENT | UDP_CSR_TXCOMP
-                                 | UDP_CSR_RX_DATA_BK0 | UDP_CSR_RX_DATA_BK1);
-    uint32_t csr = UDP->UDP_CSR[0];
-    if (!(csr & UDP_CSR_RXSETUP)) {
-        // No data ready to read
-        if (csr & other_irqs)
-            UDP->UDP_CSR[0] = CSR_EP0 | UDP_CSR_RXSETUP;
-        UDP->UDP_IER = 1<<0;
-        return -1;
-    }
-    uint32_t len = usb_read_packet(0, csr, data, max_len);
-    uint32_t dir = *(uint8_t*)data & 0x80 ? UDP_CSR_DIR : 0;
-    UDP->UDP_CSR[0] = CSR_EP0 | dir;
-    return len;
-}
-
-int_fast8_t
-usb_send_ep0(const void *data, uint_fast8_t len)
-{
-    const uint32_t other_irqs = (UDP_CSR_RXSETUP | UDP_CSR_STALLSENT
-                                 | UDP_CSR_RX_DATA_BK0 | UDP_CSR_RX_DATA_BK1);
-    uint32_t csr = UDP->UDP_CSR[0];
-    if (csr & other_irqs)
-        return -2;
-    if (csr & UDP_CSR_TXPKTRDY) {
-        // Not ready to send
-        UDP->UDP_IER = 1<<0;
-        return -1;
-    }
-    usb_write_packet(0, data, len);
-    uint32_t dir = csr & UDP_CSR_DIR;
-    UDP->UDP_CSR[0] = CSR_EP0 | dir | UDP_CSR_TXPKTRDY | other_irqs;
-    return len;
-}
-
-void
-usb_stall_ep0(void)
-{
-    UDP->UDP_CSR[0] = CSR_EP0 | UDP_CSR_FORCESTALL;
-    UDP->UDP_IER = 1<<0;
-}
-
-static uint32_t set_address;
-
-void
-usb_set_address(uint_fast8_t addr)
-{
-    set_address = addr | UDP_FADDR_FEN;
-    usb_send_ep0(NULL, 0);
-    UDP->UDP_IER = 1<<0;
-}
-
-void
-usb_set_configure(void)
-{
-    UDP->UDP_CSR[USB_CDC_EP_ACM] = CSR_ACM;
-    UDP->UDP_CSR[USB_CDC_EP_BULK_OUT] = CSR_BULK_OUT;
-    UDP->UDP_CSR[USB_CDC_EP_BULK_IN] = CSR_BULK_IN;
-    UDP->UDP_GLB_STAT |= UDP_GLB_STAT_CONFG;
-}
-
-// Configure endpoint 0 after usb reset completes
-static void
-handle_end_reset(void)
-{
-    UDP->UDP_ICR = UDP_ISR_ENDBUSRES;
-
-    UDP->UDP_CSR[0] = CSR_EP0;
-    UDP->UDP_IER = 1<<0;
-
-    UDP->UDP_TXVC = UDP_TXVC_PUON;
-}
-
-void
-UDP_Handler(void)
-{
-    uint32_t s = UDP->UDP_ISR;
-    UDP->UDP_IDR = s;
-    if (s & UDP_ISR_ENDBUSRES)
-        handle_end_reset();
-    if (s & UDP_ISR_RXRSM)
-        UDP->UDP_ICR = UDP_ISR_RXRSM;
-    if (s & (1<<0)) {
-        usb_notify_ep0();
-
-        if (set_address && UDP->UDP_CSR[0] & UDP_CSR_TXCOMP) {
-            // Ack from set_address command sent - now update address
-            UDP->UDP_FADDR = set_address;
-            UDP->UDP_GLB_STAT |= UDP_GLB_STAT_FADDEN;
-            set_address = 0;
-        }
-    }
-    if (s & (1<<USB_CDC_EP_BULK_OUT))
-        usb_notify_bulk_out();
-    if (s & (1<<USB_CDC_EP_BULK_IN))
-        usb_notify_bulk_in();
-}
-
-DECL_CONSTANT_STR("RESERVE_PINS_USB", "PB10,PB11");
-
-void
-usbserial_init(void)
-{
-    // Enable clocks
-    enable_pclock(ID_UDP);
-    PMC->PMC_USB = PMC_USB_USBDIV(5 - 1); // PLLA=240Mhz; divide by 5 for 48Mhz
-    PMC->PMC_SCER = PMC_SCER_UDP;
-
-    // Enable USB pullup
-    UDP->UDP_TXVC = UDP_TXVC_PUON | UDP_TXVC_TXVDIS;
-
-    // Enable interrupts
-    UDP->UDP_ICR = 0xffffffff;
-    armcm_enable_irq(UDP_Handler, UDP_IRQn, 1);
-}
-DECL_INIT(usbserial_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/same70_afec.h crealityShit/src/atsam/same70_afec.h
--- klipperStock/src/atsam/same70_afec.h	2024-01-14 23:02:00.165796891 -0600
+++ crealityShit/src/atsam/same70_afec.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,38 +0,0 @@
-#ifndef __SAME70_AFEC_H
-#define __SAME70_AFEC_H
-
-// A series of redefinitions as upstream changed the name of the peripheral
-#define AFE_ACR AFEC_ACR
-#define AFE_ACR_IBCTL AFEC_ACR_IBCTL
-#define AFE_CDR AFEC_CDR
-#define AFE_CGR AFEC_CGR
-#define AFE_CHDR AFEC_CHDR
-#define AFE_CHER AFEC_CHER
-#define AFE_COCR AFEC_COCR
-#define AFE_COCR_AOFF_Msk AFEC_COCR_AOFF_Msk
-#define AFE_CR AFEC_CR
-#define AFE_CR_START AFEC_CR_START
-#define AFE_CR_SWRST AFEC_CR_SWRST
-#define AFE_DIFFR AFEC_DIFFR
-#define AFE_DUMMY AFEC_DUMMY
-#define AFE_EMR AFEC_EMR
-#define AFE_EMR_RES_NO_AVERAGE AFEC_EMR_RES_NO_AVERAGE
-#define AFE_EMR_STM AFEC_EMR_STM
-#define AFE_EMR_TAG AFEC_EMR_TAG
-#define AFE_IDR AFEC_IDR
-#define AFE_ISR AFEC_ISR
-#define AFE_LCDR AFEC_LCDR
-#define AFE_LCDR_LDATA_Msk AFEC_LCDR_LDATA_Msk
-#define AFE_MR_FREERUN_ON AFEC_MR_FREERUN_ON
-#define AFE_MR_PRESCAL AFEC_MR_PRESCAL
-#define AFE_MR_STARTUP_SUT64 AFEC_MR_STARTUP_SUT64
-#define AFE_MR_TRANSFER AFEC_MR_TRANSFER
-#define AFE_MR_TRGEN AFEC_MR_TRGEN
-#define AFE_MR_TRGEN_DIS AFEC_MR_TRGEN_DIS
-#define AFE_MR_TRGSEL_Msk AFEC_MR_TRGSEL_Msk
-#define AFE_ISR_DRDY AFEC_ISR_DRDY
-#define AFE_MR AFEC_MR
-#define AFE_CSELR AFEC_CSELR
-#define AFE_CHSR AFEC_CHSR
-
-#endif // same70_afec.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/same70_i2c.h crealityShit/src/atsam/same70_i2c.h
--- klipperStock/src/atsam/same70_i2c.h	2024-01-14 23:02:00.165796891 -0600
+++ crealityShit/src/atsam/same70_i2c.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,33 +0,0 @@
-#ifndef __SAME70_I2C_H
-#define __SAME70_I2C_H
-
-// A series of redefinitions as upstream changed the name of the peripheral
-#define Twi Twihs
-#define TWI_CR TWIHS_CR
-#define TWI_CR_MSDIS TWIHS_CR_MSDIS
-#define TWI_CR_MSEN TWIHS_CR_MSEN
-#define TWI_CR_START TWIHS_CR_START
-#define TWI_CR_STOP TWIHS_CR_STOP
-#define TWI_CR_SVDIS TWIHS_CR_SVDIS
-#define TWI_CR_SWRST TWIHS_CR_SWRST
-#define TWI_CWGR TWIHS_CWGR
-#define TWI_CWGR_CHDIV TWIHS_CWGR_CHDIV
-#define TWI_CWGR_CKDIV TWIHS_CWGR_CKDIV
-#define TWI_CWGR_CLDIV TWIHS_CWGR_CLDIV
-#define TWI_IADR TWIHS_IADR
-#define TWI_IDR TWIHS_IDR
-#define TWI_MMR TWIHS_MMR
-#define TWI_MMR_DADR TWIHS_MMR_DADR
-#define TWI_MMR_IADRSZ_Msk TWIHS_MMR_IADRSZ_Msk
-#define TWI_MMR_IADRSZ_Pos TWIHS_MMR_IADRSZ_Pos
-#define TWI_MMR_MREAD TWIHS_MMR_MREAD
-#define TWI_RHR TWIHS_RHR
-#define TWI_SR TWIHS_SR
-#define TWI_SR_NAC TWIHS_SR_NACK
-#define TWI_SR_NACK TWIHS_SR_NACK
-#define TWI_SR_RXRDY TWIHS_SR_RXRDY
-#define TWI_SR_TXCOMP TWIHS_SR_TXCOMP
-#define TWI_SR_TXRDY TWIHS_SR_TXRDY
-#define TWI_THR TWIHS_THR
-
-#endif // same70_i2c.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/same70_sysinit.c crealityShit/src/atsam/same70_sysinit.c
--- klipperStock/src/atsam/same70_sysinit.c	2024-01-14 23:02:00.169796942 -0600
+++ crealityShit/src/atsam/same70_sysinit.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,74 +0,0 @@
-// This code is from lib/sam4e/gcc/system_sam4e.c and modified for the SAM E70
-
-#include "internal.h"
-
-/* Clock Settings (300MHz) */
-#define SYS_BOARD_OSCOUNT   (CKGR_MOR_MOSCXTST(0x8U))
-#define SYS_BOARD_PLLAR     (CKGR_PLLAR_ONE                             \
-                             | CKGR_PLLAR_MULA(0x18U)                   \
-                             | CKGR_PLLAR_PLLACOUNT(0x3fU)              \
-                             | CKGR_PLLAR_DIVA_BYPASS)
-#define SYS_BOARD_MCKR      (PMC_MCKR_MDIV_PCK_DIV2 | PMC_MCKR_CSS_PLLA_CLK)
-
-/* Key to unlock MOR register */
-#define SYS_CKGR_MOR_KEY_VALUE CKGR_MOR_KEY(0x37)
-
-uint32_t SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
-
-void SystemInit( void )
-{
-    /* Set FWS according to SYS_BOARD_MCKR configuration */
-    EFC->EEFC_FMR = EEFC_FMR_FWS(6) | EEFC_FMR_CLOE;
-
-    /* Initialize main oscillator */
-    if ( !(PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) )
-    {
-        PMC->CKGR_MOR = (SYS_CKGR_MOR_KEY_VALUE | SYS_BOARD_OSCOUNT
-                         | CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN);
-
-        while ( !(PMC->PMC_SR & PMC_SR_MOSCXTS) )
-        {
-        }
-    }
-
-    /* Switch to 3-20MHz Xtal oscillator */
-    PMC->CKGR_MOR = (SYS_CKGR_MOR_KEY_VALUE | SYS_BOARD_OSCOUNT
-                     | CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN
-                     | CKGR_MOR_MOSCSEL);
-
-    while ( !(PMC->PMC_SR & PMC_SR_MOSCSELS) )
-    {
-    }
-
-    PMC->PMC_MCKR = ((PMC->PMC_MCKR & ~(uint32_t)PMC_MCKR_CSS_Msk)
-                     | PMC_MCKR_CSS_MAIN_CLK);
-
-    while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
-    {
-    }
-
-    /* Initialize PLLA */
-    PMC->CKGR_PLLAR = SYS_BOARD_PLLAR;
-    while ( !(PMC->PMC_SR & PMC_SR_LOCKA) )
-    {
-    }
-
-    /* Switch to main clock */
-    PMC->PMC_MCKR = ((SYS_BOARD_MCKR & ~PMC_MCKR_CSS_Msk)
-                     | PMC_MCKR_CSS_MAIN_CLK);
-    while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
-    {
-    }
-
-    /* Switch to PLLA */
-    PMC->PMC_MCKR = SYS_BOARD_MCKR;
-    while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
-    {
-    }
-
-    SystemCoreClock = CHIP_FREQ_CPU_MAX;
-
-    // Configure PCK6 for TC use
-    PMC->PMC_PCK[6] = PMC_PCK_CSS_MCK | PMC_PCK_PRES(2);
-    PMC->PMC_SCER = PMC_SCER_PCK6;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/same70_usb.h crealityShit/src/atsam/same70_usb.h
--- klipperStock/src/atsam/same70_usb.h	2024-01-14 23:02:00.165796891 -0600
+++ crealityShit/src/atsam/same70_usb.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,61 +0,0 @@
-#ifndef __SAME70_USB_H
-#define __SAME70_USB_H
-
-// Missing in upstream headers
-#define USBHS_RAM_ADDR 0xa0100000u
-
-// A series of redefinitions as upstream changed the name of the peripheral
-#define UOTGHS USBHS
-#define UOTGHS_RAM_ADDR USBHS_RAM_ADDR
-#define ID_UOTGHS ID_USBHS
-#define UOTGHS_IRQn USBHS_IRQn
-#define UOTGHS_CTRL USBHS_CTRL
-#define UOTGHS_CTRL_UIMOD USBHS_CTRL_UIMOD
-#define UOTGHS_CTRL_USBE USBHS_CTRL_USBE
-#define UOTGHS_DEVCTRL USBHS_DEVCTRL
-#define UOTGHS_DEVCTRL_ADDEN USBHS_DEVCTRL_ADDEN
-#define UOTGHS_DEVCTRL_SPDCONF_FORCED_FS USBHS_DEVCTRL_SPDCONF_FORCED_FS
-#define UOTGHS_DEVEPT USBHS_DEVEPT
-#define UOTGHS_DEVEPT_EPEN0 USBHS_DEVEPT_EPEN0
-#define UOTGHS_DEVEPTCFG USBHS_DEVEPTCFG
-#define UOTGHS_DEVEPTCFG_ALLOC USBHS_DEVEPTCFG_ALLOC
-#define UOTGHS_DEVEPTCFG_EPBK_1_BANK USBHS_DEVEPTCFG_EPBK_1_BANK
-#define UOTGHS_DEVEPTCFG_EPBK_2_BANK USBHS_DEVEPTCFG_EPBK_2_BANK
-#define UOTGHS_DEVEPTCFG_EPDIR_IN USBHS_DEVEPTCFG_EPDIR_IN
-#define UOTGHS_DEVEPTCFG_EPSIZE_8_BYTE USBHS_DEVEPTCFG_EPSIZE_8_BYTE
-#define UOTGHS_DEVEPTCFG_EPSIZE_16_BYTE USBHS_DEVEPTCFG_EPSIZE_16_BYTE
-#define UOTGHS_DEVEPTCFG_EPSIZE_32_BYTE USBHS_DEVEPTCFG_EPSIZE_32_BYTE
-#define UOTGHS_DEVEPTCFG_EPSIZE_64_BYTE USBHS_DEVEPTCFG_EPSIZE_64_BYTE
-#define UOTGHS_DEVEPTCFG_EPTYPE_BLK USBHS_DEVEPTCFG_EPTYPE_BLK
-#define UOTGHS_DEVEPTCFG_EPTYPE_CTRL USBHS_DEVEPTCFG_EPTYPE_CTRL
-#define UOTGHS_DEVEPTCFG_EPTYPE_INTRPT USBHS_DEVEPTCFG_EPTYPE_INTRPT
-#define UOTGHS_DEVEPTICR USBHS_DEVEPTICR
-#define UOTGHS_DEVEPTICR_RXOUTIC USBHS_DEVEPTICR_RXOUTIC
-#define UOTGHS_DEVEPTICR_RXSTPIC USBHS_DEVEPTICR_RXSTPIC
-#define UOTGHS_DEVEPTICR_TXINIC USBHS_DEVEPTICR_TXINIC
-#define UOTGHS_DEVEPTIDR USBHS_DEVEPTIDR
-#define UOTGHS_DEVEPTIDR_FIFOCONC USBHS_DEVEPTIDR_FIFOCONC
-#define UOTGHS_DEVEPTIDR_RXOUTEC USBHS_DEVEPTIDR_RXOUTEC
-#define UOTGHS_DEVEPTIDR_TXINEC USBHS_DEVEPTIDR_TXINEC
-#define UOTGHS_DEVEPTIER USBHS_DEVEPTIER
-#define UOTGHS_DEVEPTIER_RXOUTES USBHS_DEVEPTIER_RXOUTES
-#define UOTGHS_DEVEPTIER_RXSTPES USBHS_DEVEPTIER_RXSTPES
-#define UOTGHS_DEVEPTIER_STALLRQS USBHS_DEVEPTIER_STALLRQS
-#define UOTGHS_DEVEPTIER_TXINES USBHS_DEVEPTIER_TXINES
-#define UOTGHS_DEVEPTISR USBHS_DEVEPTISR
-#define UOTGHS_DEVEPTISR_BYCT_Msk USBHS_DEVEPTISR_BYCT_Msk
-#define UOTGHS_DEVEPTISR_BYCT_Pos USBHS_DEVEPTISR_BYCT_Pos
-#define UOTGHS_DEVEPTISR_RXOUTI USBHS_DEVEPTISR_RXOUTI
-#define UOTGHS_DEVEPTISR_RXSTPI USBHS_DEVEPTISR_RXSTPI
-#define UOTGHS_DEVEPTISR_TXINI USBHS_DEVEPTISR_TXINI
-#define UOTGHS_DEVICR USBHS_DEVICR
-#define UOTGHS_DEVICR_EORSTC USBHS_DEVICR_EORSTC
-#define UOTGHS_DEVIDR USBHS_DEVIDR
-#define UOTGHS_DEVIER USBHS_DEVIER
-#define UOTGHS_DEVIER_EORSTES USBHS_DEVIER_EORSTES
-#define UOTGHS_DEVIER_PEP_0 USBHS_DEVIER_PEP_0
-#define UOTGHS_DEVISR USBHS_DEVISR
-#define UOTGHS_DEVISR_EORST USBHS_DEVISR_EORST
-#define UOTGHS_DEVISR_PEP_0 USBHS_DEVISR_PEP_0
-
-#endif // same70_usb.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/serial.c crealityShit/src/atsam/serial.c
--- klipperStock/src/atsam/serial.c	2024-01-14 23:02:00.161796843 -0600
+++ crealityShit/src/atsam/serial.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,86 +0,0 @@
-// sam3/sam4 serial port
-//
-// Copyright (C) 2016-2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_SERIAL_BAUD
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/serial_irq.h" // serial_rx_data
-#include "command.h" // DECL_CONSTANT_STR
-#include "internal.h" // gpio_peripheral
-#include "sched.h" // DECL_INIT
-
-// Serial port pins
-#if CONFIG_MACH_SAM3X
-#define UARTx_IRQn UART_IRQn
-static Uart * const Port = UART;
-static const uint32_t Pmc_id = ID_UART;
-static const uint32_t rx_pin = GPIO('A', 8), tx_pin = GPIO('A', 9);
-static const char uart_periph = 'A';
-DECL_CONSTANT_STR("RESERVE_PINS_serial", "PA8,PA9");
-#elif CONFIG_MACH_SAM4S
-#define UARTx_IRQn UART1_IRQn
-static Uart * const Port = UART1;
-static const uint32_t Pmc_id = ID_UART1;
-static const uint32_t rx_pin = GPIO('B', 2), tx_pin = GPIO('B', 3);
-static const char uart_periph = 'A';
-DECL_CONSTANT_STR("RESERVE_PINS_serial", "PB2,PB3");
-#elif CONFIG_MACH_SAM4E
-#define UARTx_IRQn UART0_IRQn
-static Uart * const Port = UART0;
-static const uint32_t Pmc_id = ID_UART0;
-static const uint32_t rx_pin = GPIO('A', 9), tx_pin = GPIO('A', 10);
-static const char uart_periph = 'A';
-DECL_CONSTANT_STR("RESERVE_PINS_serial", "PA9,PA10");
-#elif CONFIG_MACH_SAME70
-#define UARTx_IRQn UART2_IRQn
-static Uart * const Port = UART2;
-static const uint32_t Pmc_id = ID_UART2;
-static const uint32_t rx_pin = GPIO('D', 25), tx_pin = GPIO('D', 26);
-static const char uart_periph = 'C';
-DECL_CONSTANT_STR("RESERVE_PINS_serial", "PD25,PD26");
-#endif
-
-void
-UARTx_Handler(void)
-{
-    uint32_t status = Port->UART_SR;
-    if (status & UART_SR_RXRDY)
-        serial_rx_byte(Port->UART_RHR);
-    if (status & UART_SR_TXRDY) {
-        uint8_t data;
-        int ret = serial_get_tx_byte(&data);
-        if (ret)
-            Port->UART_IDR = UART_IDR_TXRDY;
-        else
-            Port->UART_THR = data;
-    }
-}
-
-void
-serial_enable_tx_irq(void)
-{
-    Port->UART_IER = UART_IDR_TXRDY;
-}
-
-void
-serial_init(void)
-{
-    gpio_peripheral(rx_pin, uart_periph, 1);
-    gpio_peripheral(tx_pin, uart_periph, 0);
-
-    // Reset uart
-    enable_pclock(Pmc_id);
-    Port->UART_CR = (UART_CR_RSTRX | UART_CR_RSTTX
-                     | UART_CR_RXDIS | UART_CR_TXDIS);
-    Port->UART_IDR = 0xFFFFFFFF;
-
-    // Enable uart
-    Port->UART_MR = (UART_MR_PAR_NO | UART_MR_CHMODE_NORMAL);
-    Port->UART_BRGR = get_pclock_frequency(Pmc_id) / (16 * CONFIG_SERIAL_BAUD);
-    Port->UART_IER = UART_IER_RXRDY;
-    armcm_enable_irq(UARTx_Handler, UARTx_IRQn, 0);
-    Port->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
-}
-DECL_INIT(serial_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/spi.c crealityShit/src/atsam/spi.c
--- klipperStock/src/atsam/spi.c	2024-01-14 23:02:00.161796843 -0600
+++ crealityShit/src/atsam/spi.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,341 +0,0 @@
-// SPI transmissions on sam3
-//
-// Copyright (C) 2018  Petri Honkala <cruwaller@gmail.com>
-// Copyright (C) 2018  Florian Heilmann <Florian.Heilmann@gmx.net>
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "command.h" // shutdown
-#include "gpio.h" // spi_setup
-#include "internal.h" // gpio_peripheral
-#include "sched.h" // sched_shutdown
-
-#if CONFIG_MACH_SAME70 // Fixes for upstream header changes
-#define US_MR_CHMODE_NORMAL US_MR_USART_CHMODE_NORMAL
-#define US_MR_CPHA US_MR_SPI_CPHA
-#define US_MR_CPOL US_MR_SPI_CPOL
-#endif
-
-/****************************************************************
- * SPI/USART buses and pins
- ****************************************************************/
-
-struct spi_info {
-    void *dev;
-    uint32_t dev_id;
-    uint8_t miso_pin, mosi_pin, sck_pin, rx_periph, tx_periph, sck_periph;
-};
-
-#if CONFIG_MACH_SAM3X
-DECL_ENUMERATION("spi_bus", "spi0", 0);
-DECL_ENUMERATION_RANGE("spi_bus", "usart0", 1, 3);
-DECL_CONSTANT_STR("BUS_PINS_spi0", "PA25,PA26,PA27");
-DECL_CONSTANT_STR("BUS_PINS_usart0", "PA10,PA11,PA17");
-DECL_CONSTANT_STR("BUS_PINS_usart1", "PA12,PA13,PA16");
-DECL_CONSTANT_STR("BUS_PINS_usart2", "PB21,PB20,PB24");
-#elif CONFIG_MACH_SAM4S
-DECL_ENUMERATION("spi_bus", "spi", 0);
-DECL_ENUMERATION_RANGE("spi_bus", "usart0", 1, 2);
-DECL_CONSTANT_STR("BUS_PINS_spi", "PA12,PA13,PA14");
-DECL_CONSTANT_STR("BUS_PINS_usart0", "PA5,PA6,PA2");
-DECL_CONSTANT_STR("BUS_PINS_usart1", "PA21,PA22,PA23");
-#elif CONFIG_MACH_SAM4E
-DECL_ENUMERATION("spi_bus", "spi", 0);
-DECL_ENUMERATION_RANGE("spi_bus", "usart0", 1, 2);
-DECL_CONSTANT_STR("BUS_PINS_spi", "PA12,PA13,PA14");
-DECL_CONSTANT_STR("BUS_PINS_usart0", "PB0,PB1,PB13");
-DECL_CONSTANT_STR("BUS_PINS_usart1", "PA21,PA22,PA23");
-#elif CONFIG_MACH_SAME70
-DECL_ENUMERATION_RANGE("spi_bus", "spi0", 0, 2);
-DECL_ENUMERATION_RANGE("spi_bus", "usart0", 2, 3);
-DECL_CONSTANT_STR("BUS_PINS_spi0", "PD20,PD21,PD22");
-DECL_CONSTANT_STR("BUS_PINS_usart0", "PB0,PB1,PB13");
-DECL_CONSTANT_STR("BUS_PINS_usart1", "PA21,PB4,PA23");
-DECL_CONSTANT_STR("BUS_PINS_usart2", "PD15,PD16,PD17");
-#endif
-
-static const struct spi_info spi_bus[] = {
-#if CONFIG_MACH_SAM3X
-    { SPI0, ID_SPI0,
-        GPIO('A', 25), GPIO('A', 26), GPIO('A', 27), 'A', 'A', 'A'},
-    { USART0, ID_USART0,
-        GPIO('A', 10), GPIO('A', 11), GPIO('A', 17), 'A', 'A', 'B'},
-    { USART1, ID_USART1,
-        GPIO('A', 12), GPIO('A', 13), GPIO('A', 16), 'A', 'A', 'A'},
-    { USART2, ID_USART2,
-        GPIO('B', 21), GPIO('B', 20), GPIO('B', 24), 'A', 'A', 'A'},
-#elif CONFIG_MACH_SAM4S
-    { SPI, ID_SPI,
-        GPIO('A', 12), GPIO('A', 13), GPIO('A', 14), 'A', 'A', 'A'},
-    { USART0, ID_USART0,
-        GPIO('A', 5),  GPIO('A', 6),  GPIO('A', 2),  'A', 'A', 'B'},
-    { USART1, ID_USART1,
-        GPIO('A', 21), GPIO('A', 22), GPIO('A', 23), 'A', 'A', 'A'},
-#elif CONFIG_MACH_SAM4E
-    { SPI, ID_SPI,
-        GPIO('A', 12), GPIO('A', 13), GPIO('A', 14), 'A', 'A', 'A'},
-    { USART0, ID_USART0,
-        GPIO('B', 0),  GPIO('B', 1),  GPIO('B', 13), 'C', 'C', 'C'},
-    { USART1, ID_USART1,
-        GPIO('A', 21), GPIO('A', 22), GPIO('A', 23), 'A', 'A', 'A'},
-#elif CONFIG_MACH_SAME70
-    { SPI0, ID_SPI0,
-        GPIO('D', 20), GPIO('D', 21), GPIO('D', 22), 'B', 'B', 'B'},
-    { SPI1, ID_SPI1,
-        GPIO('C', 26), GPIO('C', 27), GPIO('C', 24), 'C', 'C', 'C'},
-    { USART0, ID_USART0,
-        GPIO('B', 0),  GPIO('B', 1),  GPIO('B', 13), 'C', 'C', 'C'},
-    { USART1, ID_USART1,
-        GPIO('A', 21), GPIO('B', 4),  GPIO('A', 23), 'A', 'D', 'A'},
-    { USART2, ID_USART2,
-        GPIO('D', 15), GPIO('D', 16), GPIO('D', 17), 'B', 'B', 'B'},
-#endif
-};
-
-static int
-is_spihw(void *dev)
-{
-#if CONFIG_MACH_SAM3X
-    return dev == SPI0;
-#elif CONFIG_MACH_SAME70
-    return (dev == SPI0) || (dev == SPI1);
-#else
-    return dev == SPI;
-#endif
-}
-
-static void
-init_pins(uint32_t bus)
-{
-    const struct spi_info *si = &spi_bus[bus];
-    gpio_peripheral(si->sck_pin, si->sck_periph, 0);
-    gpio_peripheral(si->miso_pin, si->rx_periph, 1);
-    gpio_peripheral(si->mosi_pin, si->tx_periph, 0);
-    enable_pclock(si->dev_id);
-}
-
-
-/****************************************************************
- * SPI hardware
- ****************************************************************/
-
-#define CHANNEL    0 // Use same channel for all
-
-static void
-spihw_init(uint32_t bus)
-{
-    init_pins(bus);
-    Spi *pSpi = spi_bus[bus].dev;
-
-    /* Disable SPI */
-    pSpi->SPI_CR  = SPI_CR_SPIDIS;
-    /* Execute a software reset of the SPI twice */
-    pSpi->SPI_CR  = SPI_CR_SWRST;
-    pSpi->SPI_CR  = SPI_CR_SWRST;
-
-    pSpi->SPI_MR = ( SPI_MR_MSTR |       // Set master mode
-                     SPI_MR_MODFDIS |    // Disable fault detection
-                     SPI_MR_PCS(CHANNEL) // Fixes peripheral select
-                   );
-    pSpi->SPI_IDR = 0xffffffff; // Disable ISRs
-
-    /* Clear Chip Select Registers */
-    pSpi->SPI_CSR[0] = 0;
-    pSpi->SPI_CSR[1] = 0;
-    pSpi->SPI_CSR[2] = 0;
-    pSpi->SPI_CSR[3] = 0;
-
-    /* Set basic channel config */
-    pSpi->SPI_CSR[CHANNEL] = 0;
-    /* Enable SPI */
-    pSpi->SPI_CR = SPI_CR_SPIEN;
-}
-
-static struct spi_config
-spihw_setup(uint32_t bus, uint8_t mode, uint32_t rate)
-{
-    // Make sure bus is enabled
-    spihw_init(bus);
-
-    uint32_t clockDiv, pclk = get_pclock_frequency(ID_USART0);
-    if (rate < pclk / 255) {
-        clockDiv = 255;
-    } else if (rate >= pclk / 2) {
-        clockDiv = 2;
-    } else {
-        clockDiv = pclk / (rate + 1) + 1;
-    }
-
-    /****** Will be written to SPI_CSRx register ******/
-    // CSAAT  : Chip Select Active After Transfer
-    uint32_t config = SPI_CSR_CSAAT;
-    config |= SPI_CSR_BITS_8_BIT; // TODO: support for SPI_CSR_BITS_16_BIT
-    // NOTE: NCPHA is inverted, CPHA normal!!
-    switch(mode) {
-        case 0:
-            config |= SPI_CSR_NCPHA;
-            break;
-        case 1:
-            config |= 0;
-            break;
-        case 2:
-            config |= SPI_CSR_NCPHA;
-            config |= SPI_CSR_CPOL;
-            break;
-        case 3:
-            config |= SPI_CSR_CPOL;
-            break;
-    };
-
-    config |= ((clockDiv & 0xffu) << SPI_CSR_SCBR_Pos);
-    return (struct spi_config){ .spidev = spi_bus[bus].dev, .cfg = config };
-}
-
-static void
-spihw_prepare(struct spi_config config)
-{
-    Spi *pSpi = config.spidev;
-    pSpi->SPI_CSR[CHANNEL] = config.cfg;
-}
-
-static void
-spihw_transfer(struct spi_config config, uint8_t receive_data
-               , uint8_t len, uint8_t *data)
-{
-    Spi *pSpi = config.spidev;
-    if (receive_data) {
-        while (len--) {
-            pSpi->SPI_TDR = *data;
-            // wait for receive register
-            while (!(pSpi->SPI_SR & SPI_SR_RDRF))
-                ;
-            // get data
-            *data++ = pSpi->SPI_RDR;
-        }
-    } else {
-        while (len--) {
-            pSpi->SPI_TDR = *data++;
-            // wait for receive register
-            while (!(pSpi->SPI_SR & SPI_SR_RDRF))
-                ;
-            // read data (to clear RDRF)
-            pSpi->SPI_RDR;
-        }
-    }
-}
-
-
-/****************************************************************
- * USART hardware
- ****************************************************************/
-
-static struct spi_config
-usart_setup(uint32_t bus, uint8_t mode, uint32_t rate)
-{
-    init_pins(bus);
-    Usart *p_usart = spi_bus[bus].dev;
-
-    p_usart->US_MR = 0;
-    p_usart->US_RTOR = 0;
-    p_usart->US_TTGR = 0;
-
-    p_usart->US_CR = US_CR_RSTTX | US_CR_RSTRX | US_CR_TXDIS | US_CR_RXDIS;
-
-    uint32_t pclk = get_pclock_frequency(ID_USART0);
-    uint32_t br = DIV_ROUND_UP(pclk, rate);
-    p_usart->US_BRGR = br << US_BRGR_CD_Pos;
-
-    uint32_t reg = US_MR_CHRL_8_BIT |
-        US_MR_USART_MODE_SPI_MASTER |
-        US_MR_CLKO |
-        US_MR_CHMODE_NORMAL;
-    switch (mode) {
-    case 0:
-        reg |= US_MR_CPHA;
-        reg &= ~US_MR_CPOL;
-        break;
-    case 1:
-        reg &= ~US_MR_CPHA;
-        reg &= ~US_MR_CPOL;
-        break;
-    case 2:
-        reg |= US_MR_CPHA;
-        reg |= US_MR_CPOL;
-        break;
-    case 3:
-        reg &= ~US_MR_CPHA;
-        reg |= US_MR_CPOL;
-        break;
-    }
-
-    p_usart->US_MR |= reg;
-    p_usart->US_CR = US_CR_RXEN | US_CR_TXEN;
-    return (struct spi_config){ .spidev=p_usart, .cfg=p_usart->US_MR };
-}
-
-static void
-usart_prepare(struct spi_config config)
-{
-}
-
-static void
-usart_transfer(struct spi_config config, uint8_t receive_data
-               , uint8_t len, uint8_t *data)
-{
-    Usart *p_usart = config.spidev;
-    if (receive_data) {
-        for (uint32_t i = 0; i < len; ++i) {
-            uint32_t co = (uint32_t)*data & 0x000000FF;
-            while(!(p_usart->US_CSR & US_CSR_TXRDY)) {}
-            p_usart->US_THR = US_THR_TXCHR(co);
-            uint32_t ci = 0;
-            while(!(p_usart->US_CSR & US_CSR_RXRDY)) {}
-            ci = p_usart->US_RHR & US_RHR_RXCHR_Msk;
-            *data++ = (uint8_t)ci;
-        }
-    } else {
-        for (uint32_t i = 0; i < len; ++i) {
-            uint32_t co = (uint32_t)*data & 0x000000FF;
-            while(!(p_usart->US_CSR & US_CSR_TXRDY)) {}
-            p_usart->US_THR = US_THR_TXCHR(co);
-            while(!(p_usart->US_CSR & US_CSR_RXRDY)) {}
-            (void)(p_usart->US_RHR & US_RHR_RXCHR_Msk);
-            (void)*data++;
-        }
-    }
-}
-
-
-/****************************************************************
- * Interface
- ****************************************************************/
-
-struct spi_config
-spi_setup(uint32_t bus, uint8_t mode, uint32_t rate)
-{
-    if (bus >= ARRAY_SIZE(spi_bus))
-        shutdown("Invalid spi bus");
-    if (is_spihw(spi_bus[bus].dev))
-        return spihw_setup(bus, mode, rate);
-    return usart_setup(bus, mode, rate);
-}
-
-void
-spi_prepare(struct spi_config config)
-{
-    if (is_spihw(config.spidev))
-        spihw_prepare(config);
-    else
-        usart_prepare(config);
-}
-
-void
-spi_transfer(struct spi_config config, uint8_t receive_data
-             , uint8_t len, uint8_t *data)
-{
-    if (is_spihw(config.spidev))
-        spihw_transfer(config, receive_data, len, data);
-    else
-        usart_transfer(config, receive_data, len, data);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsam/usb_cdc_ep.h crealityShit/src/atsam/usb_cdc_ep.h
--- klipperStock/src/atsam/usb_cdc_ep.h	2024-01-14 23:02:00.161796843 -0600
+++ crealityShit/src/atsam/usb_cdc_ep.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,10 +0,0 @@
-#ifndef __SAM3_USB_CDC_EP_H
-#define __SAM3_USB_CDC_EP_H
-
-enum {
-    USB_CDC_EP_ACM = 3,
-    USB_CDC_EP_BULK_OUT = 1,
-    USB_CDC_EP_BULK_IN = 2,
-};
-
-#endif // usb_cdc_ep.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/adc.c crealityShit/src/atsamd/adc.c
--- klipperStock/src/atsamd/adc.c	2024-01-14 23:02:00.129796451 -0600
+++ crealityShit/src/atsamd/adc.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,210 +0,0 @@
-// Analog to Digital Converter support
-//
-// Copyright (C) 2018-2020  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "command.h" // shutdown
-#include "gpio.h" // gpio_adc_read
-#include "internal.h" // GPIO
-#include "sched.h" // sched_shutdown
-
-#define ADC_TEMPERATURE_PIN 0xfe
-DECL_ENUMERATION("pin", "ADC_TEMPERATURE", ADC_TEMPERATURE_PIN);
-
-#if CONFIG_MACH_SAMD21
-
-#define SAMD51_ADC_SYNC(ADC, BIT)
-static const uint8_t adc_pins[] = {
-    GPIO('A', 2), GPIO('A', 3), GPIO('B', 8), GPIO('B', 9), GPIO('A', 4),
-    GPIO('A', 5), GPIO('A', 6), GPIO('A', 7), GPIO('B', 0), GPIO('B', 1),
-    GPIO('B', 2), GPIO('B', 3), GPIO('B', 4), GPIO('B', 5), GPIO('B', 6),
-    GPIO('B', 7), GPIO('A', 8), GPIO('A', 9), GPIO('A', 10), GPIO('A', 11)
-};
-#elif CONFIG_MACH_SAMX5
-
-#define SAMD51_ADC_SYNC(ADC, BIT) \
-    while(ADC->SYNCBUSY.reg & ADC_SYNCBUSY_ ## BIT)
-static const uint8_t adc_pins[] = {
-    /* ADC0 */
-    GPIO('A', 2), GPIO('A', 3), GPIO('B', 8), GPIO('B', 9), GPIO('A', 4),
-    GPIO('A', 5), GPIO('A', 6), GPIO('A', 7), GPIO('A', 8), GPIO('A', 9),
-    GPIO('A', 10), GPIO('A', 11), GPIO('B', 0), GPIO('B', 1), GPIO('B', 2),
-    GPIO('B', 3),
-    /* ADC1 */
-    GPIO('B', 8), GPIO('B', 9), GPIO('A', 8), GPIO('A', 9), GPIO('C', 2),
-    GPIO('C', 3), GPIO('B', 4), GPIO('B', 5), GPIO('B', 6), GPIO('B', 7),
-    GPIO('C', 0), GPIO('C', 1), GPIO('C', 30), GPIO('C', 31), GPIO('D', 0),
-    GPIO('D', 1)
-};
-#endif
-
-DECL_CONSTANT("ADC_MAX", 4095);
-
-static struct gpio_adc gpio_adc_pin_to_struct(uint8_t pin)
-{
-    // Find pin in adc_pins table
-    uint8_t chan;
-    for (chan=0; ; chan++) {
-        if (chan >= ARRAY_SIZE(adc_pins))
-            shutdown("Not a valid ADC pin");
-        if (adc_pins[chan] == pin)
-            break;
-    }
-#if CONFIG_MACH_SAMD21
-    Adc* reg = ADC;
-#elif CONFIG_MACH_SAMX5
-    Adc* reg = (chan < 16 ? ADC0 : ADC1);
-    chan %= 16;
-#endif
-    return (struct gpio_adc){ .regs=reg, .chan=chan };
-}
-
-
-static void
-adc_init(void)
-{
-    static uint8_t have_run_init;
-    if (have_run_init)
-        return;
-    have_run_init = 1;
-
-#if CONFIG_MACH_SAMD21
-    // Enable adc clock
-    enable_pclock(ADC_GCLK_ID, ID_ADC);
-    // Load calibraiton info
-    uint32_t bias = GET_FUSE(ADC_FUSES_BIASCAL);
-    uint32_t li0 = GET_FUSE(ADC_FUSES_LINEARITY_0);
-    uint32_t li5 = GET_FUSE(ADC_FUSES_LINEARITY_1);
-    uint32_t lin = li0 | (li5 << 5);
-    ADC->CALIB.reg = ADC_CALIB_BIAS_CAL(bias) | ADC_CALIB_LINEARITY_CAL(lin);
-
-    // Setup and enable adc
-    ADC->REFCTRL.reg = ADC_REFCTRL_REFSEL_INTVCC1;
-    ADC->CTRLB.reg = ADC_CTRLB_PRESCALER_DIV128;
-    ADC->SAMPCTRL.reg = 63;
-    ADC->CTRLA.reg = ADC_CTRLA_ENABLE;
-
-#elif CONFIG_MACH_SAMX5
-    // Enable adc clock
-    enable_pclock(ADC0_GCLK_ID, ID_ADC0);
-    enable_pclock(ADC1_GCLK_ID, ID_ADC1);
-
-    // Load calibration info
-    // ADC0
-    uint32_t refbuf = GET_FUSE(ADC0_FUSES_BIASREFBUF);
-    uint32_t r2r = GET_FUSE(ADC0_FUSES_BIASR2R);
-    uint32_t comp = GET_FUSE(ADC0_FUSES_BIASCOMP);
-    ADC0->CALIB.reg = (ADC0_FUSES_BIASREFBUF(refbuf)
-                       | ADC0_FUSES_BIASR2R(r2r) | ADC0_FUSES_BIASCOMP(comp));
-
-    // ADC1
-    refbuf = GET_FUSE(ADC1_FUSES_BIASREFBUF);
-    r2r = GET_FUSE(ADC1_FUSES_BIASR2R);
-    comp = GET_FUSE(ADC1_FUSES_BIASCOMP);
-    ADC1->CALIB.reg = (ADC0_FUSES_BIASREFBUF(refbuf)
-                       | ADC0_FUSES_BIASR2R(r2r) | ADC0_FUSES_BIASCOMP(comp));
-
-    // Setup and enable
-    // ADC0
-    ADC0->REFCTRL.reg = ADC_REFCTRL_REFSEL_INTVCC1;
-    while(ADC0->SYNCBUSY.reg & ADC_SYNCBUSY_REFCTRL);
-    ADC0->SAMPCTRL.reg = ADC_SAMPCTRL_SAMPLEN(63);
-    while (ADC0->SYNCBUSY.reg & ADC_SYNCBUSY_SAMPCTRL);
-    ADC0->CTRLA.reg = (ADC_CTRLA_PRESCALER(ADC_CTRLA_PRESCALER_DIV32_Val)
-                       | ADC_CTRLA_ENABLE);
-
-    // ADC1
-    ADC1->REFCTRL.reg = ADC_REFCTRL_REFSEL_INTVCC1;
-    while(ADC1->SYNCBUSY.reg & ADC_SYNCBUSY_REFCTRL);
-    ADC1->SAMPCTRL.reg = ADC_SAMPCTRL_SAMPLEN(63);
-    while(ADC1->SYNCBUSY.reg & ADC_SYNCBUSY_SAMPCTRL);
-    ADC1->CTRLA.reg = (ADC_CTRLA_PRESCALER(ADC_CTRLA_PRESCALER_DIV32_Val)
-                       | ADC_CTRLA_ENABLE);
-#endif
-}
-
-struct gpio_adc
-gpio_adc_setup(uint8_t pin)
-{
-    // Enable ADC
-    adc_init();
-
-    if (pin == ADC_TEMPERATURE_PIN) {
-#if CONFIG_MACH_SAMD21
-        SYSCTRL->VREF.reg |= SYSCTRL_VREF_TSEN;
-        return (struct gpio_adc){ .regs=ADC,
-                .chan=ADC_INPUTCTRL_MUXPOS_TEMP_Val };
-#else
-        SUPC->VREF.reg |= SUPC_VREF_TSEN;
-        return (struct gpio_adc){ .regs=ADC0,
-                .chan=ADC_INPUTCTRL_MUXPOS_PTAT_Val };
-#endif
-    }
-
-    // Set pin in ADC mode
-    gpio_peripheral(pin, 'B', 0);
-
-    return gpio_adc_pin_to_struct(pin);
-}
-
-enum { ADC_DUMMY=0xff };
-static uint8_t last_analog_read = ADC_DUMMY;
-
-// Try to sample a value. Returns zero if sample ready, otherwise
-// returns the number of clock ticks the caller should wait before
-// retrying this function.
-uint32_t
-gpio_adc_sample(struct gpio_adc g)
-{
-    Adc *reg = g.regs;
-    if (last_analog_read == g.chan) {
-        if (reg->INTFLAG.reg & ADC_INTFLAG_RESRDY)
-            // Sample now ready
-            return 0;
-        // ADC is still busy
-        goto need_delay;
-    }
-    if (last_analog_read != ADC_DUMMY)
-        // Sample on another channel in progress
-        goto need_delay;
-    last_analog_read = g.chan;
-
-    // Set the channel to sample
-    reg->INPUTCTRL.reg = (ADC_INPUTCTRL_MUXPOS(g.chan)
-                          | ADC_INPUTCTRL_MUXNEG_GND
-#if CONFIG_MACH_SAMD21
-                          | ADC_INPUTCTRL_GAIN_DIV2
-#endif
-                          );
-
-    SAMD51_ADC_SYNC(reg, INPUTCTRL);
-    // Start the sample
-    reg->SWTRIG.reg = ADC_SWTRIG_START;
-    SAMD51_ADC_SYNC(reg, SWTRIG);
-
-    // Schedule next attempt after sample is likely to be complete
-need_delay:
-    return 42 * 128 + 200; // 42 == 1 + (63+1)/2 + 1 + 12/2 + 1.5
-}
-
-// Read a value; use only after gpio_adc_sample() returns zero
-uint16_t
-gpio_adc_read(struct gpio_adc g)
-{
-    last_analog_read = ADC_DUMMY;
-    return ((Adc *)g.regs)->RESULT.reg;
-}
-
-// Cancel a sample that may have been started with gpio_adc_sample()
-void
-gpio_adc_cancel_sample(struct gpio_adc g)
-{
-    Adc * reg = g.regs;
-    if (last_analog_read == g.chan) {
-        reg->SWTRIG.reg = ADC_SWTRIG_FLUSH;
-        SAMD51_ADC_SYNC(reg, SWTRIG);
-        reg->INTFLAG.reg = ADC_INTFLAG_RESRDY;
-        last_analog_read = ADC_DUMMY;
-    }
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/chipid.c crealityShit/src/atsamd/chipid.c
--- klipperStock/src/atsamd/chipid.c	2024-01-14 23:02:00.121796352 -0600
+++ crealityShit/src/atsamd/chipid.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,51 +0,0 @@
-// Support for extracting the hardware chip id on atsamd
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_USB_SERIAL_NUMBER_CHIPID
-#include "generic/canserial.h" // canserial_set_uuid
-#include "generic/usb_cdc.h" // usb_fill_serial
-#include "generic/usbstd.h" // usb_string_descriptor
-#include "sched.h" // DECL_INIT
-
-#define CHIP_UID_LEN 16
-
-static struct {
-    struct usb_string_descriptor desc;
-    uint16_t data[CHIP_UID_LEN * 2];
-} cdc_chipid;
-
-struct usb_string_descriptor *
-usbserial_get_serialid(void)
-{
-   return &cdc_chipid.desc;
-}
-
-void
-chipid_init(void)
-{
-    if (!CONFIG_USB_SERIAL_NUMBER_CHIPID && !CONFIG_CANBUS)
-        return;
-
-    uint32_t id[4];
-    if (CONFIG_MACH_SAMD21) {
-        id[0] = *(uint32_t*)0x0080A00C;
-        id[1] = *(uint32_t*)0x0080A040;
-        id[2] = *(uint32_t*)0x0080A044;
-        id[3] = *(uint32_t*)0x0080A048;
-    } else {
-        id[0] = *(uint32_t*)0x008061FC;
-        id[1] = *(uint32_t*)0x00806010;
-        id[2] = *(uint32_t*)0x00806014;
-        id[3] = *(uint32_t*)0x00806018;
-    }
-
-    if (CONFIG_USB_SERIAL_NUMBER_CHIPID)
-        usb_fill_serial(&cdc_chipid.desc, ARRAY_SIZE(cdc_chipid.data), id);
-
-    if (CONFIG_CANBUS)
-        canserial_set_uuid((void*)id, CHIP_UID_LEN);
-}
-DECL_INIT(chipid_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/clock.c crealityShit/src/atsamd/clock.c
--- klipperStock/src/atsamd/clock.c	2024-01-14 23:02:00.121796352 -0600
+++ crealityShit/src/atsamd/clock.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,128 +0,0 @@
-// Code to setup peripheral clocks on the SAMD21
-//
-// Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "command.h" // DECL_CONSTANT_STR
-#include "compiler.h" // DIV_ROUND_CLOSEST
-#include "internal.h" // enable_pclock
-
-// The "generic clock generators" that are configured
-#define CLKGEN_MAIN 0
-#define CLKGEN_ULP32K 2
-
-#define FREQ_MAIN 48000000
-#define FREQ_32K 32768
-
-// Configure a clock generator using a given source as input
-static inline void
-gen_clock(uint32_t clkgen_id, uint32_t flags)
-{
-    GCLK->GENDIV.reg = GCLK_GENDIV_ID(clkgen_id);
-    GCLK->GENCTRL.reg = GCLK_GENCTRL_ID(clkgen_id) | flags | GCLK_GENCTRL_GENEN;
-}
-
-// Route a peripheral clock to a given clkgen
-static inline void
-route_pclock(uint32_t pclk_id, uint32_t clkgen_id)
-{
-    GCLK->CLKCTRL.reg = (GCLK_CLKCTRL_ID(pclk_id)
-                         | GCLK_CLKCTRL_GEN(clkgen_id) | GCLK_CLKCTRL_CLKEN);
-    while (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY)
-        ;
-}
-
-// Enable a peripheral clock and power to that peripheral
-void
-enable_pclock(uint32_t pclk_id, int32_t pm_id)
-{
-    route_pclock(pclk_id, CLKGEN_MAIN);
-    if (pm_id >= 0) {
-        uint32_t pm_port = pm_id / 32, pm_bit = 1 << (pm_id % 32);
-        (&PM->APBAMASK.reg)[pm_port] |= pm_bit;
-    }
-}
-
-// Return the frequency of the given peripheral clock
-uint32_t
-get_pclock_frequency(uint32_t pclk_id)
-{
-    return FREQ_MAIN;
-}
-
-#if CONFIG_CLOCK_REF_X32K
-DECL_CONSTANT_STR("RESERVE_PINS_crystal", "PA0,PA1");
-#endif
-
-// Initialize the clocks using an external 32K crystal
-static void
-clock_init_32k(void)
-{
-    // Enable external 32Khz crystal
-    uint32_t val = (SYSCTRL_XOSC32K_STARTUP(6)
-                    | SYSCTRL_XOSC32K_XTALEN | SYSCTRL_XOSC32K_EN32K);
-    SYSCTRL->XOSC32K.reg = val;
-    SYSCTRL->XOSC32K.reg = val | SYSCTRL_XOSC32K_ENABLE;
-    while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_XOSC32KRDY))
-        ;
-
-    // Generate 48Mhz clock on DPLL (with XOSC32K as reference)
-    SYSCTRL->DPLLCTRLA.reg = 0;
-    uint32_t mul = DIV_ROUND_CLOSEST(FREQ_MAIN, FREQ_32K);
-    SYSCTRL->DPLLRATIO.reg = SYSCTRL_DPLLRATIO_LDR(mul - 1);
-    SYSCTRL->DPLLCTRLB.reg = SYSCTRL_DPLLCTRLB_LBYPASS;
-    SYSCTRL->DPLLCTRLA.reg = SYSCTRL_DPLLCTRLA_ENABLE;
-    uint32_t mask = SYSCTRL_DPLLSTATUS_CLKRDY | SYSCTRL_DPLLSTATUS_LOCK;
-    while ((SYSCTRL->DPLLSTATUS.reg & mask) != mask)
-        ;
-
-    // Switch main clock to DPLL clock
-    gen_clock(CLKGEN_MAIN, GCLK_GENCTRL_SRC_DPLL96M);
-}
-
-// Initialize clocks from factory calibrated internal clock
-static void
-clock_init_internal(void)
-{
-    // Configure DFLL48M clock in open loop mode
-    SYSCTRL->DFLLCTRL.reg = 0;
-    uint32_t coarse = GET_FUSE(FUSES_DFLL48M_COARSE_CAL);
-    uint32_t fine = GET_FUSE(FUSES_DFLL48M_FINE_CAL);
-    SYSCTRL->DFLLVAL.reg = (SYSCTRL_DFLLVAL_COARSE(coarse)
-                            | SYSCTRL_DFLLVAL_FINE(fine));
-    if (CONFIG_USB) {
-        // Enable USB clock recovery mode
-        uint32_t mul = DIV_ROUND_CLOSEST(FREQ_MAIN, 1000);
-        SYSCTRL->DFLLMUL.reg = (SYSCTRL_DFLLMUL_FSTEP(10)
-                                | SYSCTRL_DFLLMUL_MUL(mul));
-        SYSCTRL->DFLLCTRL.reg = (SYSCTRL_DFLLCTRL_MODE | SYSCTRL_DFLLCTRL_USBCRM
-                                 | SYSCTRL_DFLLCTRL_CCDIS
-                                 | SYSCTRL_DFLLCTRL_ENABLE);
-    } else {
-        SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
-    }
-    while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY))
-        ;
-
-    // Switch main clock to DFLL48M clock
-    gen_clock(CLKGEN_MAIN, GCLK_GENCTRL_SRC_DFLL48M);
-}
-
-void
-SystemInit(void)
-{
-    // Setup flash to work with 48Mhz clock
-    NVMCTRL->CTRLB.reg = NVMCTRL_CTRLB_RWS_HALF;
-
-    // Reset GCLK
-    GCLK->CTRL.reg = GCLK_CTRL_SWRST;
-    while (GCLK->CTRL.reg & GCLK_CTRL_SWRST)
-        ;
-
-    // Init clocks
-    if (CONFIG_CLOCK_REF_X32K)
-        clock_init_32k();
-    else
-        clock_init_internal();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/fdcan.c crealityShit/src/atsamd/fdcan.c
--- klipperStock/src/atsamd/fdcan.c	2024-01-14 23:02:00.121796352 -0600
+++ crealityShit/src/atsamd/fdcan.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,293 +0,0 @@
-// CANbus support on atsame51 chips
-//
-// Copyright (C) 2021-2022  Kevin O'Connor <kevin@koconnor.net>
-// Copyright (C) 2019 Eug Krashtan <eug.krashtan@gmail.com>
-// Copyright (C) 2020 Pontus Borg <glpontus@gmail.com>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "command.h" // DECL_CONSTANT_STR
-#include "generic/armcm_boot.h" // armcm_enable_irq
-#include "generic/canbus.h" // canbus_notify_tx
-#include "generic/canserial.h" // CANBUS_ID_ADMIN
-#include "internal.h" // enable_pclock
-#include "sched.h" // DECL_INIT
-
-
-/****************************************************************
- * Pin configuration
- ****************************************************************/
-
-#if CONFIG_ATSAMD_CANBUS_PA23_PA22
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PA23,PA22");
- #define GPIO_Rx GPIO('A', 23)
- #define GPIO_Tx GPIO('A', 22)
- #define CANx_GCLK_ID CAN0_GCLK_ID
-#elif CONFIG_ATSAMD_CANBUS_PA25_PA24
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PA25,PA24");
- #define GPIO_Rx GPIO('A', 25)
- #define GPIO_Tx GPIO('A', 24)
- #define CANx_GCLK_ID CAN0_GCLK_ID
-#elif CONFIG_ATSAMD_CANBUS_PB13_PB12
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PB13,PB12");
- #define GPIO_Rx GPIO('B', 13)
- #define GPIO_Tx GPIO('B', 12)
- #define CANx_GCLK_ID CAN1_GCLK_ID
-#elif CONFIG_ATSAMD_CANBUS_PB15_PB14
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PB15,PB14");
- #define GPIO_Rx GPIO('B', 15)
- #define GPIO_Tx GPIO('B', 14)
- #define CANx_GCLK_ID CAN1_GCLK_ID
-#endif
-
-#if CANx_GCLK_ID == CAN0_GCLK_ID
- #define CAN_FUNCTION 'I'
- #define CANx CAN0
- #define CANx_IRQn CAN0_IRQn
-#else
- #define CAN_FUNCTION 'H'
- #define CANx CAN1
- #define CANx_IRQn CAN1_IRQn
-#endif
-
-
-/****************************************************************
- * Message ram layout
- ****************************************************************/
-
-struct fdcan_fifo {
-    uint32_t id_section;
-    uint32_t dlc_section;
-    uint32_t data[64 / 4];
-};
-
-#define FDCAN_XTD (1<<30)
-#define FDCAN_RTR (1<<29)
-
-struct fdcan_msg_ram {
-    uint32_t FLS[28]; // Filter list standard
-    uint32_t FLE[16]; // Filter list extended
-    struct fdcan_fifo RXF0[3];
-    struct fdcan_fifo RXF1[3];
-    uint32_t TEF[6]; // Tx event FIFO
-    struct fdcan_fifo TXFIFO[3];
-};
-
-// Message ram is in regular memory
-static struct fdcan_msg_ram MSG_RAM;
-
-
-/****************************************************************
- * CANbus code
- ****************************************************************/
-
-#define FDCAN_IE_TC        (CAN_IE_TCE | CAN_IE_TCFE | CAN_IE_TFEE)
-
-// Transmit a packet
-int
-canhw_send(struct canbus_msg *msg)
-{
-    uint32_t txfqs = CANx->TXFQS.reg;
-    if (txfqs & CAN_TXFQS_TFQF)
-        // No space in transmit fifo - wait for irq
-        return -1;
-
-    uint32_t w_index = ((txfqs & CAN_TXFQS_TFQPI_Msk) >> CAN_TXFQS_TFQPI_Pos);
-    struct fdcan_fifo *txfifo = &MSG_RAM.TXFIFO[w_index];
-    uint32_t ids;
-    if (msg->id & CANMSG_ID_EFF)
-        ids = (msg->id & 0x1fffffff) | FDCAN_XTD;
-    else
-        ids = (msg->id & 0x7ff) << 18;
-    ids |= msg->id & CANMSG_ID_RTR ? FDCAN_RTR : 0;
-    txfifo->id_section = ids;
-    txfifo->dlc_section = (msg->dlc & 0x0f) << 16;
-    txfifo->data[0] = msg->data32[0];
-    txfifo->data[1] = msg->data32[1];
-    barrier();
-    CANx->TXBAR.reg = ((uint32_t)1 << w_index);
-    return CANMSG_DATA_LEN(msg);
-}
-
-static void
-can_filter(uint32_t index, uint32_t id)
-{
-    MSG_RAM.FLS[index] = ((0x2 << 30) // Classic filter
-                          | (0x1 << 27) // Store in Rx FIFO 0 if filter matches
-                          | (id << 16)
-                          | 0x7FF); // mask all enabled
-}
-
-// Setup the receive packet filter
-void
-canhw_set_filter(uint32_t id)
-{
-    if (!CONFIG_CANBUS_FILTER)
-        return;
-    /* Request initialisation */
-    CANx->CCCR.reg |= CAN_CCCR_INIT;
-    /* Wait the acknowledge */
-    while (!(CANx->CCCR.reg & CAN_CCCR_INIT))
-        ;
-    /* Enable configuration change */
-    CANx->CCCR.reg |= CAN_CCCR_CCE;
-
-    // Load filter
-    can_filter(0, CANBUS_ID_ADMIN);
-    can_filter(1, id);
-    can_filter(2, id + 1);
-
-    uint32_t flssa = (uint32_t)MSG_RAM.FLS - CAN0_MSG_RAM_ADDR;
-    CANx->SIDFC.reg = flssa | ((id ? 3 : 1) << CAN_SIDFC_LSS_Pos);
-    CANx->GFC.reg = 0x02 << CAN_GFC_ANFS_Pos;
-
-    /* Leave the initialisation mode for the filter */
-    barrier();
-    CANx->CCCR.reg &= ~CAN_CCCR_CCE;
-    CANx->CCCR.reg &= ~CAN_CCCR_INIT;
-}
-
-// This function handles CAN global interrupts
-void
-CAN_IRQHandler(void)
-{
-    uint32_t ir = CANx->IR.reg;
-
-    if (ir & CAN_IE_RF0NE) {
-        CANx->IR.reg = CAN_IE_RF0NE;
-
-        uint32_t rxf0s = CANx->RXF0S.reg;
-        if (rxf0s & CAN_RXF0S_F0FL_Msk) {
-            // Read and ack data packet
-            uint32_t idx = (rxf0s & CAN_RXF0S_F0GI_Msk) >> CAN_RXF0S_F0GI_Pos;
-            struct fdcan_fifo *rxf0 = &MSG_RAM.RXF0[idx];
-            uint32_t ids = rxf0->id_section;
-            struct canbus_msg msg;
-            if (ids & FDCAN_XTD)
-                msg.id = (ids & 0x1fffffff) | CANMSG_ID_EFF;
-            else
-                msg.id = (ids >> 18) & 0x7ff;
-            msg.id |= ids & FDCAN_RTR ? CANMSG_ID_RTR : 0;
-            msg.dlc = (rxf0->dlc_section >> 16) & 0x0f;
-            msg.data32[0] = rxf0->data[0];
-            msg.data32[1] = rxf0->data[1];
-            barrier();
-            CANx->RXF0A.reg = idx;
-
-            // Process packet
-            canbus_process_data(&msg);
-        }
-    }
-    if (ir & FDCAN_IE_TC) {
-        // Tx
-        CANx->IR.reg = FDCAN_IE_TC;
-        canbus_notify_tx();
-    }
-}
-
-static inline const uint32_t
-make_btr(uint32_t sjw,       // Sync jump width, ... hmm
-         uint32_t time_seg1, // time segment before sample point, 1 .. 16
-         uint32_t time_seg2, // time segment after sample point, 1 .. 8
-         uint32_t brp)       // Baud rate prescaler, 1 .. 1024
-{
-    return (((uint32_t)(sjw-1)) << CAN_NBTP_NSJW_Pos
-            | ((uint32_t)(time_seg1-1)) << CAN_NBTP_NTSEG1_Pos
-            | ((uint32_t)(time_seg2-1)) << CAN_NBTP_NTSEG2_Pos
-            | ((uint32_t)(brp - 1)) << CAN_NBTP_NBRP_Pos);
-}
-
-static inline const uint32_t
-compute_btr(uint32_t pclock, uint32_t bitrate)
-{
-    /*
-        Some equations:
-        Tpclock = 1 / pclock
-        Tq      = brp * Tpclock
-        Tbs1    = Tq * TS1
-        Tbs2    = Tq * TS2
-        NominalBitTime = Tq + Tbs1 + Tbs2
-        BaudRate = 1/NominalBitTime
-        Bit value sample point is after Tq+Tbs1. Ideal sample point
-        is at 87.5% of NominalBitTime
-        Use the lowest brp where ts1 and ts2 are in valid range
-     */
-
-    uint32_t bit_clocks = pclock / bitrate; // clock ticks per bit
-
-    uint32_t sjw = 2;
-    uint32_t qs;
-    // Find number of time quantas that gives us the exact wanted bit time
-    for (qs = 18; qs > 9; qs--) {
-        // check that bit_clocks / quantas is an integer
-        uint32_t brp_rem = bit_clocks % qs;
-        if (brp_rem == 0)
-            break;
-    }
-    uint32_t brp       = bit_clocks / qs;
-    uint32_t time_seg2 = qs / 8; // sample at ~87.5%
-    uint32_t time_seg1 = qs - (1 + time_seg2);
-
-    return make_btr(sjw, time_seg1, time_seg2, brp);
-}
-
-void
-can_init(void)
-{
-    if (!CONFIG_USB) {
-        // The FDCAN peripheral only seems to run if at least one
-        // other peripheral is also enabled.
-        enable_pclock(USB_GCLK_ID, ID_USB);
-        USB->DEVICE.CTRLA.reg = USB_CTRLA_ENABLE;
-    }
-
-    enable_pclock(CANx_GCLK_ID, -1);
-
-    gpio_peripheral(GPIO_Rx, CAN_FUNCTION, 1);
-    gpio_peripheral(GPIO_Tx, CAN_FUNCTION, 0);
-
-    uint32_t pclock = get_pclock_frequency(CANx_GCLK_ID);
-
-    uint32_t btr = compute_btr(pclock, CONFIG_CANBUS_FREQUENCY);
-
-    /*##-1- Configure the CAN #######################################*/
-
-    /* Exit from sleep mode */
-    CANx->CCCR.reg &= ~CAN_CCCR_CSR;
-    /* Wait the acknowledge */
-    while (CANx->CCCR.reg & CAN_CCCR_CSA)
-        ;
-    /* Request initialisation */
-    CANx->CCCR.reg |= CAN_CCCR_INIT;
-    /* Wait the acknowledge */
-    while (!(CANx->CCCR.reg & CAN_CCCR_INIT))
-        ;
-    /* Enable configuration change */
-    CANx->CCCR.reg |= CAN_CCCR_CCE;
-
-    /* Disable protocol exception handling */
-    CANx->CCCR.reg |= CAN_CCCR_PXHD;
-
-    CANx->NBTP.reg = btr;
-
-    /* Setup message RAM addresses */
-    uint32_t f0sa = (uint32_t)MSG_RAM.RXF0 - CAN0_MSG_RAM_ADDR;
-    CANx->RXF0C.reg = f0sa | (ARRAY_SIZE(MSG_RAM.RXF0) << CAN_RXF0C_F0S_Pos);
-    CANx->RXESC.reg = (7 << CAN_RXESC_F1DS_Pos) | (7 << CAN_RXESC_F0DS_Pos);
-    uint32_t tbsa = (uint32_t)MSG_RAM.TXFIFO - CAN0_MSG_RAM_ADDR;
-    CANx->TXBC.reg = tbsa | (ARRAY_SIZE(MSG_RAM.TXFIFO) << CAN_TXBC_TFQS_Pos);
-    CANx->TXESC.reg = 7 << CAN_TXESC_TBDS_Pos;
-
-    /* Leave the initialisation mode */
-    CANx->CCCR.reg &= ~CAN_CCCR_CCE;
-    CANx->CCCR.reg &= ~CAN_CCCR_INIT;
-
-    /*##-2- Configure the CAN Filter #######################################*/
-    canhw_set_filter(0);
-
-    /*##-3- Configure Interrupts #################################*/
-    armcm_enable_irq(CAN_IRQHandler, CANx_IRQn, 1);
-    CANx->ILE.reg = CAN_ILE_EINT0;
-    CANx->IE.reg = CAN_IE_RF0NE | FDCAN_IE_TC;
-}
-DECL_INIT(can_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/gpio.c crealityShit/src/atsamd/gpio.c
--- klipperStock/src/atsamd/gpio.c	2024-01-14 23:02:00.125796400 -0600
+++ crealityShit/src/atsamd/gpio.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,150 +0,0 @@
-// samd gpio functions
-//
-// Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // ffs
-#include "board/irq.h" // irq_save
-#include "command.h" // shutdown
-#include "gpio.h" // gpio_out_setup
-#include "internal.h" // gpio_peripheral
-#include "sched.h" // sched_shutdown
-
-
-/****************************************************************
- * Pin multiplexing
- ****************************************************************/
-
-void
-gpio_peripheral(uint32_t gpio, char ptype, int32_t pull_up)
-{
-    uint32_t bank = GPIO2PORT(gpio), bit = gpio % 32;
-    PortGroup *pg = &PORT->Group[bank];
-    if (ptype) {
-        volatile uint8_t *pmux = &pg->PMUX[bit/2].reg;
-        uint8_t shift = (bit & 1) ? 4 : 0, mask = ~(0xf << shift);
-        *pmux = (*pmux & mask) | ((ptype - 'A') << shift);
-    }
-    if (pull_up) {
-        if (pull_up > 0)
-            pg->OUTSET.reg = (1<<bit);
-        else
-            pg->OUTCLR.reg = (1<<bit);
-    }
-
-    pg->PINCFG[bit].reg = ((ptype ? PORT_PINCFG_PMUXEN : 0)
-                           | (pull_up ? PORT_PINCFG_PULLEN : 0));
-}
-
-
-/****************************************************************
- * General Purpose Input Output (GPIO) pins
- ****************************************************************/
-
-#if CONFIG_MACH_SAMD21
-#define NUM_PORT 2
-DECL_ENUMERATION_RANGE("pin", "PA0", GPIO('A', 0), 32);
-DECL_ENUMERATION_RANGE("pin", "PB0", GPIO('B', 0), 32);
-#elif CONFIG_MACH_SAMX5
-#define NUM_PORT 4
-DECL_ENUMERATION_RANGE("pin", "PA0", GPIO('A', 0), 32);
-DECL_ENUMERATION_RANGE("pin", "PB0", GPIO('B', 0), 32);
-DECL_ENUMERATION_RANGE("pin", "PC0", GPIO('C', 0), 32);
-DECL_ENUMERATION_RANGE("pin", "PD0", GPIO('D', 0), 32);
-#endif
-
-struct gpio_out
-gpio_out_setup(uint8_t pin, uint8_t val)
-{
-    if (GPIO2PORT(pin) >= NUM_PORT)
-        goto fail;
-    PortGroup *pg = &PORT->Group[GPIO2PORT(pin)];
-    struct gpio_out g = { .regs=pg, .bit=GPIO2BIT(pin) };
-    gpio_out_reset(g, val);
-    return g;
-fail:
-    shutdown("Not an output pin");
-}
-
-static void
-set_pincfg(PortGroup *pg, uint32_t bit, uint8_t cfg)
-{
-    pg->PINCFG[ffs(bit)-1].reg = cfg;
-}
-
-void
-gpio_out_reset(struct gpio_out g, uint8_t val)
-{
-    PortGroup *pg = g.regs;
-    irqstatus_t flag = irq_save();
-    if (val)
-        pg->OUTSET.reg = g.bit;
-    else
-        pg->OUTCLR.reg = g.bit;
-    pg->DIRSET.reg = g.bit;
-    set_pincfg(pg, g.bit, 0);
-    irq_restore(flag);
-}
-
-void
-gpio_out_toggle_noirq(struct gpio_out g)
-{
-    PortGroup *pg = g.regs;
-    pg->OUTTGL.reg = g.bit;
-}
-
-void
-gpio_out_toggle(struct gpio_out g)
-{
-    gpio_out_toggle_noirq(g);
-}
-
-void
-gpio_out_write(struct gpio_out g, uint8_t val)
-{
-    PortGroup *pg = g.regs;
-    if (val)
-        pg->OUTSET.reg = g.bit;
-    else
-        pg->OUTCLR.reg = g.bit;
-}
-
-
-struct gpio_in
-gpio_in_setup(uint8_t pin, int8_t pull_up)
-{
-    if (GPIO2PORT(pin) >= NUM_PORT)
-        goto fail;
-    PortGroup *pg = &PORT->Group[GPIO2PORT(pin)];
-    struct gpio_in g = { .regs=pg, .bit=GPIO2BIT(pin) };
-    gpio_in_reset(g, pull_up);
-    return g;
-fail:
-    shutdown("Not an input pin");
-}
-
-void
-gpio_in_reset(struct gpio_in g, int8_t pull_up)
-{
-    PortGroup *pg = g.regs;
-    irqstatus_t flag = irq_save();
-    uint32_t cfg = PORT_PINCFG_INEN;
-    if (pull_up) {
-        cfg |= PORT_PINCFG_PULLEN;
-        if (pull_up > 0)
-            pg->OUTSET.reg = g.bit;
-        else
-            pg->OUTCLR.reg = g.bit;
-    }
-    set_pincfg(pg, g.bit, cfg);
-    pg->DIRCLR.reg = g.bit;
-    irq_restore(flag);
-}
-
-uint8_t
-gpio_in_read(struct gpio_in g)
-{
-    PortGroup *pg = g.regs;
-    return !!(pg->IN.reg & g.bit);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/gpio.h crealityShit/src/atsamd/gpio.h
--- klipperStock/src/atsamd/gpio.h	2024-01-14 23:02:00.125796400 -0600
+++ crealityShit/src/atsamd/gpio.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,58 +0,0 @@
-#ifndef __ATSAMD_GPIO_H
-#define __ATSAMD_GPIO_H
-
-#include <stdint.h>
-
-struct gpio_out {
-    void *regs;
-    uint32_t bit;
-};
-struct gpio_out gpio_out_setup(uint8_t pin, uint8_t val);
-void gpio_out_reset(struct gpio_out g, uint8_t val);
-void gpio_out_toggle_noirq(struct gpio_out g);
-void gpio_out_toggle(struct gpio_out g);
-void gpio_out_write(struct gpio_out g, uint8_t val);
-
-struct gpio_in {
-    void *regs;
-    uint32_t bit;
-};
-struct gpio_in gpio_in_setup(uint8_t pin, int8_t pull_up);
-void gpio_in_reset(struct gpio_in g, int8_t pull_up);
-uint8_t gpio_in_read(struct gpio_in g);
-
-struct gpio_pwm {
-    void *reg;
-};
-struct gpio_pwm gpio_pwm_setup(uint8_t pin, uint32_t cycle_time, uint8_t val);
-void gpio_pwm_write(struct gpio_pwm g, uint8_t val);
-
-struct gpio_adc {
-    void *regs;
-    uint32_t chan;
-};
-struct gpio_adc gpio_adc_setup(uint8_t pin);
-uint32_t gpio_adc_sample(struct gpio_adc g);
-uint16_t gpio_adc_read(struct gpio_adc g);
-void gpio_adc_cancel_sample(struct gpio_adc g);
-
-struct spi_config {
-    void *ss;
-    uint32_t ctrla, baud;
-};
-struct spi_config spi_setup(uint32_t bus, uint8_t mode, uint32_t rate);
-void spi_prepare(struct spi_config config);
-void spi_transfer(struct spi_config config, uint8_t receive_data
-                  , uint8_t len, uint8_t *data);
-
-struct i2c_config {
-    void *si;
-    uint8_t addr;
-};
-
-struct i2c_config i2c_setup(uint32_t bus, uint32_t rate, uint8_t addr);
-void i2c_write(struct i2c_config config, uint8_t write_len, uint8_t *write);
-void i2c_read(struct i2c_config config, uint8_t reg_len, uint8_t *reg
-              , uint8_t read_len, uint8_t *read);
-
-#endif // gpio.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/hard_pwm.c crealityShit/src/atsamd/hard_pwm.c
--- klipperStock/src/atsamd/hard_pwm.c	2024-01-14 23:02:00.117796304 -0600
+++ crealityShit/src/atsamd/hard_pwm.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,108 +0,0 @@
-// Hardware PWM support on samd21
-//
-// Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "command.h" // shutdown
-#include "gpio.h" // gpio_pwm_write
-#include "internal.h" // GPIO
-#include "sched.h" // sched_shutdown
-
-// Available TCC devices
-struct tcc_info_s {
-    Tcc *tcc;
-    uint32_t pclk_id, pm_id;
-};
-static const struct tcc_info_s tcc_info[] = {
-    { TCC0, TCC0_GCLK_ID, ID_TCC0 },
-    { TCC1, TCC1_GCLK_ID, ID_TCC1 },
-    { TCC2, TCC2_GCLK_ID, ID_TCC2 },
-};
-
-// PWM pins and their TCC device/channel
-struct gpio_pwm_info {
-    uint8_t gpio, ptype, tcc, channel;
-};
-static const struct gpio_pwm_info pwm_regs[] = {
-    { GPIO('A', 4),  'E', 0, 0 },
-    { GPIO('A', 5),  'E', 0, 1 },
-    { GPIO('A', 6),  'E', 1, 0 },
-    { GPIO('A', 7),  'E', 1, 1 },
-    { GPIO('A', 8),  'E', 0, 0 },
-    { GPIO('A', 9),  'E', 0, 1 },
-    { GPIO('A', 10), 'E', 1, 0 },
-    { GPIO('A', 11), 'E', 1, 1 },
-    { GPIO('A', 12), 'E', 2, 0 },
-    { GPIO('A', 13), 'E', 2, 1 },
-    { GPIO('A', 16), 'E', 2, 0 },
-    { GPIO('A', 17), 'E', 2, 1 },
-    { GPIO('A', 18), 'F', 0, 2 },
-    { GPIO('A', 19), 'F', 0, 3 },
-    { GPIO('A', 24), 'F', 1, 2 },
-    { GPIO('A', 25), 'F', 1, 3 },
-    { GPIO('A', 30), 'E', 1, 0 },
-    { GPIO('A', 31), 'E', 1, 1 },
-    { GPIO('B', 30), 'E', 0, 0 },
-    { GPIO('B', 31), 'E', 0, 1 },
-};
-
-#define MAX_PWM 255
-DECL_CONSTANT("PWM_MAX", MAX_PWM);
-
-struct gpio_pwm
-gpio_pwm_setup(uint8_t pin, uint32_t cycle_time, uint8_t val)
-{
-    // Find pin in pwm_regs table
-    const struct gpio_pwm_info *p = pwm_regs;
-    for (; ; p++) {
-        if (p >= &pwm_regs[ARRAY_SIZE(pwm_regs)])
-            shutdown("Not a valid PWM pin");
-        if (p->gpio == pin)
-            break;
-    }
-
-    // Enable timer clock
-    enable_pclock(tcc_info[p->tcc].pclk_id, tcc_info[p->tcc].pm_id);
-
-    // Map cycle_time to pwm clock divisor
-    uint32_t cs;
-    switch (cycle_time) {
-    case                      0 ...      (1+2) * MAX_PWM / 2 - 1: cs = 0; break;
-    case    (1+2) * MAX_PWM / 2 ...      (2+4) * MAX_PWM / 2 - 1: cs = 1; break;
-    case    (2+4) * MAX_PWM / 2 ...      (4+8) * MAX_PWM / 2 - 1: cs = 2; break;
-    case    (4+8) * MAX_PWM / 2 ...     (8+16) * MAX_PWM / 2 - 1: cs = 3; break;
-    case   (8+16) * MAX_PWM / 2 ...    (16+64) * MAX_PWM / 2 - 1: cs = 4; break;
-    case  (16+64) * MAX_PWM / 2 ...   (64+256) * MAX_PWM / 2 - 1: cs = 5; break;
-    case (64+256) * MAX_PWM / 2 ... (256+1024) * MAX_PWM / 2 - 1: cs = 6; break;
-    default:                                                      cs = 7; break;
-    }
-    uint32_t ctrla = TCC_CTRLA_ENABLE | TCC_CTRLA_PRESCALER(cs);
-
-    // Enable timer
-    Tcc *tcc = tcc_info[p->tcc].tcc;
-    uint32_t old_ctrla = tcc->CTRLA.reg;
-    if (old_ctrla != ctrla) {
-        if (old_ctrla & TCC_CTRLA_ENABLE)
-            shutdown("PWM already programmed at different speed");
-        tcc->CTRLA.reg = ctrla & ~TCC_CTRLA_ENABLE;
-        tcc->WAVE.reg = TCC_WAVE_WAVEGEN_NPWM;
-        tcc->PER.reg = MAX_PWM;
-        tcc->CTRLA.reg = ctrla;
-    }
-
-    // Set initial value
-    struct gpio_pwm g = (struct gpio_pwm) { (void*)&tcc->CCB[p->channel].reg };
-    gpio_pwm_write(g, val);
-
-    // Route output to pin
-    gpio_peripheral(pin, p->ptype, 0);
-
-    return g;
-}
-
-void
-gpio_pwm_write(struct gpio_pwm g, uint8_t val)
-{
-    *(volatile uint32_t*)g.reg = val;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/i2c.c crealityShit/src/atsamd/i2c.c
--- klipperStock/src/atsamd/i2c.c	2024-01-14 23:02:00.121796352 -0600
+++ crealityShit/src/atsamd/i2c.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,146 +0,0 @@
-// i2c support on samd
-//
-// Copyright (C) 2019  Florian Heilmann <Florian.Heilmann@gmx.net>
-// Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "internal.h" // enable_pclock
-#include "command.h" // shutdown
-#include "gpio.h" // i2c_setup
-#include "sched.h" // sched_shutdown
-
-#define TIME_RISE 125ULL // 125 nanoseconds
-#define I2C_FREQ 100000
-
-static void
-i2c_init(uint32_t bus, SercomI2cm *si)
-{
-    static uint8_t have_run_init;
-    if (have_run_init & (1<<bus))
-        return;
-    have_run_init |= 1<<bus;
-
-    // Configure i2c
-    si->CTRLA.reg = 0;
-    uint32_t areg = (SERCOM_I2CM_CTRLA_LOWTOUTEN
-                     | SERCOM_I2CM_CTRLA_INACTOUT(3)
-                     | SERCOM_I2CM_CTRLA_MODE(5));
-    si->CTRLA.reg = areg;
-    uint32_t freq = sercom_get_pclock_frequency(bus);
-    uint32_t baud = (freq/I2C_FREQ - 10 - freq*TIME_RISE/1000000000) / 2;
-    si->BAUD.reg = baud;
-    si->CTRLA.reg = areg | SERCOM_I2CM_CTRLA_ENABLE;
-    while (si->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_ENABLE)
-        ;
-
-    // Go into idle mode
-    si->STATUS.reg = SERCOM_I2CM_STATUS_BUSSTATE(1);
-    while (si->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_SYSOP)
-        ;
-}
-
-struct i2c_config
-i2c_setup(uint32_t bus, uint32_t rate, uint8_t addr)
-{
-    Sercom *sercom = sercom_enable_pclock(bus);
-    sercom_i2c_pins(bus);
-    SercomI2cm *si = &sercom->I2CM;
-    i2c_init(bus, si);
-    return (struct i2c_config){ .si=si, .addr=addr<<1 };
-}
-
-static void
-i2c_wait(SercomI2cm *si)
-{
-    for (;;) {
-        uint32_t intflag = si->INTFLAG.reg;
-        if (!(intflag & SERCOM_I2CM_INTFLAG_MB)) {
-            if (si->STATUS.reg & SERCOM_I2CM_STATUS_BUSERR)
-                shutdown("i2c buserror");
-            continue;
-        }
-        if (intflag & SERCOM_I2CM_INTFLAG_ERROR)
-            shutdown("i2c error");
-        break;
-    }
-}
-
-static void
-i2c_start(SercomI2cm *si, uint8_t addr)
-{
-    si->ADDR.reg = addr;
-    i2c_wait(si);
-}
-
-static void
-i2c_send_byte(SercomI2cm *si, uint8_t b)
-{
-    si->DATA.reg = b;
-    i2c_wait(si);
-}
-
-static void
-i2c_stop(SercomI2cm *si)
-{
-    si->CTRLB.reg = SERCOM_I2CM_CTRLB_CMD(3);
-}
-
-void
-i2c_write(struct i2c_config config, uint8_t write_len, uint8_t *write)
-{
-    SercomI2cm *si = (SercomI2cm *)config.si;
-    i2c_start(si, config.addr);
-    while (write_len--)
-        i2c_send_byte(si, *write++);
-    i2c_stop(si);
-}
-
-void
-i2c_read(struct i2c_config config, uint8_t reg_len, uint8_t *reg
-         , uint8_t read_len, uint8_t *read)
-{
-    SercomI2cm *si = (SercomI2cm *)config.si;
-
-    // start in write mode and write register if provided
-    if(reg_len) {
-        // start in write mode
-        si->ADDR.reg = config.addr;
-        while (!(si->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB));
-
-        // write registers
-        while (reg_len--){
-            si->DATA.reg = *reg++;
-            while (!(si->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB));
-        }
-    }
-
-    // start with read bit enabled
-    si->ADDR.reg = (config.addr | 0x1);
-
-    // read bytes from slave
-    while (read_len--){
-        while (!(si->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB));
-
-        if (read_len){
-            // set ACK response
-            si->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
-            while (si->SYNCBUSY.bit.SYSOP);
-
-            // execute ACK succeded by byte read
-            si->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(2);
-            while (si->SYNCBUSY.bit.SYSOP);
-        } else {
-            // set NACK response
-            si->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
-            while (si->SYNCBUSY.bit.SYSOP);
-
-            // execute NACK succeded by stop condition
-            si->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
-            while (si->SYNCBUSY.bit.SYSOP);
-        }
-
-        // read received data byte
-        *read++ = si->DATA.reg;
-    }
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/internal.h crealityShit/src/atsamd/internal.h
--- klipperStock/src/atsamd/internal.h	2024-01-14 23:02:00.125796400 -0600
+++ crealityShit/src/atsamd/internal.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,34 +0,0 @@
-#ifndef __ATSAMD_INTERNAL_H
-#define __ATSAMD_INTERNAL_H
-// Local definitions for atsamd code
-
-#include <stdint.h> // uint32_t
-#include "autoconf.h" // CONFIG_MACH_SAMD21A
-
-#if CONFIG_MACH_SAMD21
-#include "samd21.h"
-#elif CONFIG_MACH_SAMD51
-#include "samd51.h"
-#elif CONFIG_MACH_SAME51
-#include "same51.h"
-#elif CONFIG_MACH_SAME54
-#include "same54.h"
-#endif
-
-#define GPIO(PORT, NUM) (((PORT)-'A') * 32 + (NUM))
-#define GPIO2PORT(PIN) ((PIN) / 32)
-#define GPIO2BIT(PIN) (1<<((PIN) % 32))
-
-#define GET_FUSE(REG)                                           \
-    ((*((uint32_t*)(REG##_ADDR)) & (REG##_Msk)) >> (REG##_Pos))
-
-void enable_pclock(uint32_t pclk_id, int32_t pm_id);
-uint32_t get_pclock_frequency(uint32_t pclk_id);
-void gpio_peripheral(uint32_t gpio, char ptype, int32_t pull_up);
-
-Sercom * sercom_enable_pclock(uint32_t sercom_id);
-uint32_t sercom_get_pclock_frequency(uint32_t sercom_id);
-uint32_t sercom_spi_pins(uint32_t sercom_id);
-void sercom_i2c_pins(uint32_t sercom_id);
-
-#endif // internal.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/Kconfig crealityShit/src/atsamd/Kconfig
--- klipperStock/src/atsamd/Kconfig	2024-01-14 23:02:00.125796400 -0600
+++ crealityShit/src/atsamd/Kconfig	1969-12-31 18:00:00.000000000 -0600
@@ -1,227 +0,0 @@
-# Kconfig settings for Atmel SAMD processors
-
-if MACH_ATSAMD
-
-config ATSAMD_SELECT
-    bool
-    default y
-    select HAVE_GPIO
-    select HAVE_GPIO_ADC
-    select HAVE_GPIO_I2C
-    select HAVE_GPIO_SPI
-    select HAVE_GPIO_HARD_PWM if MACH_SAMD21
-    select HAVE_GPIO_BITBANGING
-    select HAVE_STRICT_TIMING
-    select HAVE_CHIPID
-    select HAVE_STEPPER_BOTH_EDGE
-
-config HAVE_SERCOM
-    depends on HAVE_GPIO_I2C || HAVE_GPIO_SPI
-    bool
-    default y
-
-config BOARD_DIRECTORY
-    string
-    default "atsamd"
-
-choice
-    prompt "Processor model"
-    config MACH_SAMD21G18
-        bool "SAMD21G18 (Arduino Zero)"
-        select MACH_SAMD21
-    config MACH_SAMD21E18
-        bool "SAMD21E18 (Adafruit Trinket M0)"
-        select MACH_SAMD21
-    config MACH_SAMD21E15
-        bool "SAMD21E15"
-        select MACH_SAMD21
-    config MACH_SAMD51G19
-        bool "SAMD51G19 (Adafruit ItsyBitsy M4)"
-        select MACH_SAMD51
-    config MACH_SAMD51J19
-        bool "SAMD51J19 (Adafruit Metro M4)"
-        select MACH_SAMD51
-    config MACH_SAMD51N19
-        bool "SAMD51N19"
-        select MACH_SAMD51
-    config MACH_SAMD51P20
-        bool "SAMD51P20 (Adafruit Grand Central)"
-        select MACH_SAMD51
-    config MACH_SAME51J19
-        bool "SAME51J19"
-        select MACH_SAME51
-    config MACH_SAME54P20
-        bool "SAME54P20"
-        select MACH_SAME54
-endchoice
-
-config MACH_SAMD21
-    bool
-config MACH_SAMX5
-    bool
-config MACH_SAMD51
-    bool
-    select MACH_SAMX5
-config MACH_SAME51
-    bool
-    select MACH_SAMX5
-config MACH_SAME54
-    bool
-    select MACH_SAMX5
-config HAVE_SAMD_CANBUS
-    bool
-    default y if MACH_SAME51 || MACH_SAME54
-
-config MCU
-    string
-    default "samd21g18a" if MACH_SAMD21G18
-    default "samd21e18a" if MACH_SAMD21E18
-    default "samd21e15a" if MACH_SAMD21E15
-    default "samd51g19a" if MACH_SAMD51G19
-    default "samd51j19a" if MACH_SAMD51J19
-    default "samd51n19a" if MACH_SAMD51N19
-    default "samd51p20a" if MACH_SAMD51P20
-    default "same51j19a" if MACH_SAME51J19
-    default "same54p20a" if MACH_SAME54P20
-
-config FLASH_SIZE
-    hex
-    default 0x8000 if MACH_SAMD21E15
-    default 0x40000 if MACH_SAMD21G18 || MACH_SAMD21E18
-    default 0x80000 if MACH_SAMD51G19 || MACH_SAMD51J19 || MACH_SAMD51N19 || MACH_SAME51J19
-    default 0x100000 if MACH_SAMD51P20 || MACH_SAME54P20
-
-config FLASH_BOOT_ADDRESS
-    hex
-    default 0x0
-
-config RAM_START
-    hex
-    default 0x20000000
-
-config RAM_SIZE
-    hex
-    default 0x1000 if MACH_SAMD21E15
-    default 0x8000 if MACH_SAMD21G18 || MACH_SAMD21E18
-    default 0x30000 if MACH_SAMD51G19 || MACH_SAMD51J19 || MACH_SAMD51N19 || MACH_SAME51J19
-    default 0x40000 if MACH_SAMD51P20 || MACH_SAME54P20
-
-config STACK_SIZE
-    int
-    default 512
-
-
-######################################################################
-# Bootloader
-######################################################################
-
-choice
-    prompt "Bootloader offset"
-    config SAMD_FLASH_START_2000
-        depends on MACH_SAMD21
-        bool "8KiB bootloader (Arduino Zero)"
-    config SAMD_FLASH_START_4000
-        bool "16KiB bootloader (Arduino M0)"
-    config SAMD_FLASH_START_0000
-        bool "No bootloader"
-endchoice
-config FLASH_APPLICATION_ADDRESS
-    hex
-    default 0x4000 if SAMD_FLASH_START_4000
-    default 0x2000 if SAMD_FLASH_START_2000
-    default 0x0000
-
-
-######################################################################
-# Clock
-######################################################################
-
-choice
-    prompt "Clock Reference"
-    config CLOCK_REF_X32K
-        bool "32.768Khz crystal"
-    config CLOCK_REF_X25M
-        bool "25Mhz crystal" if MACH_SAMX5
-    config CLOCK_REF_INTERNAL
-        bool "Internal clock"
-endchoice
-
-choice
-    depends on MACH_SAMX5 && LOW_LEVEL_OPTIONS
-    prompt "Processor speed"
-    config SAMD51_FREQ_120
-        bool "120 MHz (standard)"
-    config SAMD51_FREQ_150
-        bool "150 MHz (overclock)"
-    config SAMD51_FREQ_180
-        bool "180 MHz (overclock)"
-    config SAMD51_FREQ_200
-        bool "200 MHz (overclock)"
-endchoice
-
-config CLOCK_FREQ
-    int
-    default 48000000 if MACH_SAMD21
-    default 150000000 if SAMD51_FREQ_150
-    default 180000000 if SAMD51_FREQ_180
-    default 200000000 if SAMD51_FREQ_200
-    default 120000000 if MACH_SAMX5
-
-
-######################################################################
-# Communication inteface
-######################################################################
-
-choice
-    prompt "Communication interface"
-    config ATSAMD_USB
-        bool "USB"
-        select USBSERIAL
-    config ATSAMD_SERIAL
-        bool "Serial"
-        select SERIAL
-    config ATSAMD_MMENU_CANBUS_PA23_PA22
-        bool "CAN bus (on PA23/PA22)"
-        depends on HAVE_SAMD_CANBUS
-        select CANSERIAL
-    config ATSAMD_MMENU_CANBUS_PA25_PA24
-        bool "CAN bus (on PA25/PA24)"
-        depends on HAVE_SAMD_CANBUS
-        select CANSERIAL
-    config ATSAMD_MMENU_CANBUS_PB13_PB12
-        bool "CAN bus (on PB13/PB12)"
-        depends on HAVE_SAMD_CANBUS
-        select CANSERIAL
-    config ATSAMD_MMENU_CANBUS_PB15_PB14
-        bool "CAN bus (on PB15/PB14)"
-        depends on HAVE_SAMD_CANBUS
-        select CANSERIAL
-    config ATSAMD_USBCANBUS
-        bool "USB to CAN bus bridge"
-        depends on HAVE_SAMD_CANBUS
-        select USBCANBUS
-endchoice
-choice
-    prompt "CAN bus interface" if USBCANBUS
-    config ATSAMD_CMENU_CANBUS_PA23_PA22
-        bool "CAN bus (on PA23/PA22)"
-    config ATSAMD_CMENU_CANBUS_PB13_PB12
-        bool "CAN bus (on PB13/PB12)"
-    config ATSAMD_CMENU_CANBUS_PB15_PB14
-        bool "CAN bus (on PB15/PB14)"
-endchoice
-
-config ATSAMD_CANBUS_PA23_PA22
-    bool
-    default y if ATSAMD_MMENU_CANBUS_PA23_PA22 || ATSAMD_CMENU_CANBUS_PA23_PA22
-config ATSAMD_CANBUS_PA25_PA24
-    bool
-    default y if ATSAMD_MMENU_CANBUS_PA25_PA24
-config ATSAMD_CANBUS_PB13_PB12
-    bool
-    default y if ATSAMD_MMENU_CANBUS_PB13_PB12 || ATSAMD_CMENU_CANBUS_PB13_PB12
-config ATSAMD_CANBUS_PB15_PB14
-    bool
-    default y if ATSAMD_MMENU_CANBUS_PB15_PB14 || ATSAMD_CMENU_CANBUS_PB15_PB14
-
-endif
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/main.c crealityShit/src/atsamd/main.c
--- klipperStock/src/atsamd/main.c	2024-01-14 23:02:00.125796400 -0600
+++ crealityShit/src/atsamd/main.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,35 +0,0 @@
-// Main starting point for SAMD boards
-//
-// Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/armcm_boot.h" // armcm_main
-#include "board/misc.h" // bootloader_request
-#include "board/io.h" // writel
-#include "board/irq.h" // irq_disable
-#include "internal.h" // SystemInit
-#include "sched.h" // sched_main
-
-void
-bootloader_request(void)
-{
-    if (!CONFIG_FLASH_APPLICATION_ADDRESS)
-        return;
-    // Bootloader hack
-    irq_disable();
-#if CONFIG_MACH_SAMD21
-    writel((void*)0x20007FFC, 0x07738135);
-#elif CONFIG_MACH_SAMX5
-    writel((void*)(HSRAM_ADDR + HSRAM_SIZE - 4), 0xf01669ef);
-#endif
-    NVIC_SystemReset();
-}
-
-// Main entry point - called from armcm_boot.c:ResetHandler()
-void
-armcm_main(void)
-{
-    SystemInit();
-    sched_main();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/Makefile crealityShit/src/atsamd/Makefile
--- klipperStock/src/atsamd/Makefile	2024-01-14 23:02:00.121796352 -0600
+++ crealityShit/src/atsamd/Makefile	1969-12-31 18:00:00.000000000 -0600
@@ -1,60 +0,0 @@
-# Additional atsamd build rules
-
-# Setup the toolchain
-CROSS_PREFIX=arm-none-eabi-
-
-dirs-y += src/atsamd src/generic lib/fast-hash
-
-MCU := $(shell echo $(CONFIG_MCU) | tr a-z A-Z)
-
-CFLAGS-$(CONFIG_MACH_SAMD21) += -mcpu=cortex-m0plus -Ilib/samd21/samd21a/include
-CFLAGS-$(CONFIG_MACH_SAMD51) += -Ilib/samd51/samd51a/include
-CFLAGS-$(CONFIG_MACH_SAME51) += -Ilib/same51/include
-CFLAGS-$(CONFIG_MACH_SAMX5) += -mcpu=cortex-m4 -Ilib/same54/include
-CFLAGS += $(CFLAGS-y) -D__$(MCU)__ -mthumb -Ilib/cmsis-core -Ilib/fast-hash
-
-CFLAGS_klipper.elf += --specs=nano.specs --specs=nosys.specs
-CFLAGS_klipper.elf += -T $(OUT)src/generic/armcm_link.ld
-$(OUT)klipper.elf: $(OUT)src/generic/armcm_link.ld
-
-# Add source files
-src-y += atsamd/main.c atsamd/gpio.c generic/crc16_ccitt.c
-src-y += generic/armcm_boot.c generic/armcm_irq.c generic/armcm_reset.c
-src-$(CONFIG_USBSERIAL) += atsamd/usbserial.c atsamd/chipid.c generic/usb_cdc.c
-src-$(CONFIG_SERIAL) += atsamd/serial.c generic/serial_irq.c
-canbus-src-y := generic/canserial.c ../lib/fast-hash/fasthash.c
-canbus-src-y += atsamd/fdcan.c atsamd/chipid.c
-src-$(CONFIG_USBCANBUS) += $(canbus-src-y) atsamd/usbserial.c generic/usb_canbus.c
-src-$(CONFIG_CANSERIAL) += $(canbus-src-y) generic/canbus.c
-src-$(CONFIG_HAVE_GPIO_ADC) += atsamd/adc.c
-src-$(CONFIG_HAVE_GPIO_I2C) += atsamd/i2c.c
-src-$(CONFIG_HAVE_GPIO_SPI) += atsamd/spi.c
-src-$(CONFIG_HAVE_SERCOM) += atsamd/sercom.c
-src-$(CONFIG_HAVE_GPIO_HARD_PWM) += atsamd/hard_pwm.c
-src-$(CONFIG_MACH_SAMD21) += atsamd/watchdog.c
-src-$(CONFIG_MACH_SAMD21) += atsamd/clock.c atsamd/timer.c generic/timer_irq.c
-src-$(CONFIG_MACH_SAMX5) += atsamd/samd51_watchdog.c
-src-$(CONFIG_MACH_SAMX5) += atsamd/samd51_clock.c generic/armcm_timer.c
-
-# Build the additional hex and bin output files
-target-y += $(OUT)klipper.bin $(OUT)klipper.elf.hex
-
-$(OUT)klipper.bin: $(OUT)klipper.elf
-	@echo "  Creating bin file $@"
-	$(Q)$(OBJCOPY) -O binary $< $@
-
-$(OUT)klipper.elf.hex: $(OUT)klipper.elf
-	@echo "  Creating hex file $@"
-	$(Q)$(OBJCOPY) -j .text -j .relocate -O ihex $< $@
-
-# Flash rules
-lib/bossac/bin/bossac:
-	@echo "  Building bossac"
-	$(Q)make -C lib/bossac bin/bossac
-
-BOSSAC_OFFSET-$(CONFIG_MACH_SAMD21) := 0x2000
-BOSSAC_OFFSET-$(CONFIG_MACH_SAMX5) := 0x4000
-
-flash: $(OUT)klipper.bin lib/bossac/bin/bossac
-	@echo "  Flashing $< to $(FLASH_DEVICE)"
-	$(Q)$(PYTHON) ./scripts/flash_usb.py -t $(CONFIG_MCU) -d "$(FLASH_DEVICE)" -s "$(BOSSAC_OFFSET-y)" $(OUT)klipper.bin
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/samd51_clock.c crealityShit/src/atsamd/samd51_clock.c
--- klipperStock/src/atsamd/samd51_clock.c	2024-01-14 23:02:00.125796400 -0600
+++ crealityShit/src/atsamd/samd51_clock.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,208 +0,0 @@
-// Code to setup peripheral clocks on the SAMD51
-//
-// Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "command.h" // DECL_CONSTANT_STR
-#include "compiler.h" // DIV_ROUND_CLOSEST
-#include "internal.h" // enable_pclock
-
-// The "generic clock generators" that are configured
-#define CLKGEN_MAIN 0
-#define CLKGEN_48M 3
-#define CLKGEN_2M 4
-
-#define FREQ_MAIN CONFIG_CLOCK_FREQ
-#define FREQ_32K 32768
-#define FREQ_48M 48000000
-#define FREQ_2M 2000000
-
-// Configure a clock generator using a given source as input
-static inline void
-gen_clock(uint32_t clkgen_id, uint32_t flags)
-{
-    GCLK->GENCTRL[clkgen_id].reg = flags | GCLK_GENCTRL_GENEN;
-    while (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << clkgen_id))
-        ;
-}
-
-// Route a peripheral clock to a given clkgen
-static inline void
-route_pclock(uint32_t pclk_id, uint32_t clkgen_id)
-{
-    uint32_t val = GCLK_PCHCTRL_GEN(clkgen_id) | GCLK_PCHCTRL_CHEN;
-    GCLK->PCHCTRL[pclk_id].reg = val;
-    while (GCLK->PCHCTRL[pclk_id].reg != val)
-        ;
-}
-
-// Enable a peripheral clock and power to that peripheral
-void
-enable_pclock(uint32_t pclk_id, int32_t pm_id)
-{
-    route_pclock(pclk_id, CLKGEN_48M);
-    if (pm_id >= 0) {
-        uint32_t pm_port = pm_id / 32, pm_bit = 1 << (pm_id % 32);
-        (&MCLK->APBAMASK.reg)[pm_port] |= pm_bit;
-    }
-}
-
-// Return the frequency of the given peripheral clock
-uint32_t
-get_pclock_frequency(uint32_t pclk_id)
-{
-    return FREQ_48M;
-}
-
-// Configure a dpll to a given clock multiplier
-static void
-config_dpll(uint32_t pll, uint32_t mul, uint32_t ctrlb)
-{
-    OSCCTRL->Dpll[pll].DPLLCTRLA.reg = 0;
-    while (OSCCTRL->Dpll[pll].DPLLSYNCBUSY.reg & OSCCTRL_DPLLSYNCBUSY_ENABLE)
-        ;
-    OSCCTRL->Dpll[pll].DPLLRATIO.reg = OSCCTRL_DPLLRATIO_LDR(mul - 1);
-    while (OSCCTRL->Dpll[pll].DPLLSYNCBUSY.reg & OSCCTRL_DPLLSYNCBUSY_DPLLRATIO)
-        ;
-    OSCCTRL->Dpll[pll].DPLLCTRLB.reg = ctrlb | OSCCTRL_DPLLCTRLB_LBYPASS;
-    OSCCTRL->Dpll[pll].DPLLCTRLA.reg = OSCCTRL_DPLLCTRLA_ENABLE;
-    uint32_t mask = OSCCTRL_DPLLSTATUS_CLKRDY | OSCCTRL_DPLLSTATUS_LOCK;
-    while ((OSCCTRL->Dpll[pll].DPLLSTATUS.reg & mask) != mask)
-        ;
-}
-
-// Configure the dfll
-static void
-config_dfll(uint32_t dfllmul, uint32_t ctrlb)
-{
-    // Disable the dfllmul and reenable in this order due to chip errata
-    OSCCTRL->DFLLCTRLA.reg = 0;
-    while (OSCCTRL->DFLLSYNC.reg & OSCCTRL_DFLLSYNC_ENABLE)
-        ;
-    OSCCTRL->DFLLMUL.reg = dfllmul;
-    while (OSCCTRL->DFLLSYNC.reg & OSCCTRL_DFLLSYNC_DFLLMUL)
-        ;
-    OSCCTRL->DFLLCTRLB.reg = 0;
-    while (OSCCTRL->DFLLSYNC.reg & OSCCTRL_DFLLSYNC_DFLLCTRLB)
-        ;
-    OSCCTRL->DFLLCTRLA.reg = OSCCTRL_DFLLCTRLA_ENABLE;
-    while (OSCCTRL->DFLLSYNC.reg & OSCCTRL_DFLLSYNC_ENABLE)
-        ;
-    OSCCTRL->DFLLVAL.reg = OSCCTRL->DFLLVAL.reg;
-    while(OSCCTRL->DFLLSYNC.reg & OSCCTRL_DFLLSYNC_DFLLVAL)
-        ;
-    OSCCTRL->DFLLCTRLB.reg = ctrlb;
-    while (OSCCTRL->DFLLSYNC.reg & OSCCTRL_DFLLSYNC_DFLLCTRLB)
-        ;
-}
-
-#if CONFIG_CLOCK_REF_X32K
-DECL_CONSTANT_STR("RESERVE_PINS_crystal", "PA0,PA1");
-#elif CONFIG_CLOCK_REF_X25M
-DECL_CONSTANT_STR("RESERVE_PINS_crystal", "PB22,PB23");
-#endif
-
-// Initialize the clocks using an external 32K crystal
-static void
-clock_init_32k(void)
-{
-    // Enable external 32Khz crystal
-    uint32_t val = (OSC32KCTRL_XOSC32K_ENABLE | OSC32KCTRL_XOSC32K_EN32K
-                    | OSC32KCTRL_XOSC32K_CGM_XT | OSC32KCTRL_XOSC32K_XTALEN);
-    OSC32KCTRL->XOSC32K.reg = val;
-    while (!(OSC32KCTRL->STATUS.reg & OSC32KCTRL_STATUS_XOSC32KRDY))
-        ;
-
-    // Generate 120Mhz clock on PLL0 (with XOSC32 as reference)
-    uint32_t mul = DIV_ROUND_CLOSEST(FREQ_MAIN, FREQ_32K);
-    config_dpll(0, mul, OSCCTRL_DPLLCTRLB_REFCLK_XOSC32);
-
-    // Switch main clock to 120Mhz PLL0
-    gen_clock(CLKGEN_MAIN, GCLK_GENCTRL_SRC_DPLL0);
-
-    // Generate 48Mhz clock on PLL1 (with XOSC32 as reference)
-    mul = DIV_ROUND_CLOSEST(FREQ_48M, FREQ_32K);
-    config_dpll(1, mul, OSCCTRL_DPLLCTRLB_REFCLK_XOSC32);
-    gen_clock(CLKGEN_48M, GCLK_GENCTRL_SRC_DPLL1);
-}
-
-// Initialize the clocks using an external 25M crystal
-static void
-clock_init_25m(void)
-{
-    // Enable XOSC1
-    uint32_t freq_xosc = 25000000;
-    uint32_t val = (OSCCTRL_XOSCCTRL_ENABLE | OSCCTRL_XOSCCTRL_XTALEN
-                    | OSCCTRL_XOSCCTRL_IPTAT(3) | OSCCTRL_XOSCCTRL_IMULT(6));
-    OSCCTRL->XOSCCTRL[1].reg = val;
-    while (!(OSCCTRL->STATUS.reg & OSCCTRL_STATUS_XOSCRDY1))
-        ;
-
-    // Generate 120Mhz clock on PLL0 (with XOSC1 as reference)
-    uint32_t p0div = 10, p0mul = DIV_ROUND_CLOSEST(FREQ_MAIN, freq_xosc/p0div);
-    uint32_t p0ctrlb = OSCCTRL_DPLLCTRLB_DIV(p0div / 2 - 1);
-    config_dpll(0, p0mul, p0ctrlb | OSCCTRL_DPLLCTRLB_REFCLK_XOSC1);
-
-    // Switch main clock to 120Mhz PLL0
-    gen_clock(CLKGEN_MAIN, GCLK_GENCTRL_SRC_DPLL0);
-
-    // Generate 48Mhz clock on PLL1 (with XOSC1 as reference)
-    uint32_t p1div = 50, p1mul = DIV_ROUND_CLOSEST(FREQ_48M, freq_xosc/p1div);
-    uint32_t p1ctrlb = OSCCTRL_DPLLCTRLB_DIV(p1div / 2 - 1);
-    config_dpll(1, p1mul, p1ctrlb | OSCCTRL_DPLLCTRLB_REFCLK_XOSC1);
-    gen_clock(CLKGEN_48M, GCLK_GENCTRL_SRC_DPLL1);
-}
-
-// Initialize clocks from factory calibrated internal clock
-static void
-clock_init_internal(void)
-{
-    // Enable USB clock recovery mode if applicable
-    if (CONFIG_USB) {
-        // Temporarily switch main clock to internal 32K clock
-        gen_clock(CLKGEN_MAIN, GCLK_GENCTRL_SRC_OSCULP32K);
-
-        // Configure DFLL48M clock (with USB 1Khz SOF as reference)
-        uint32_t mul = DIV_ROUND_CLOSEST(FREQ_48M, 1000);
-        uint32_t dfllmul = OSCCTRL_DFLLMUL_FSTEP(10) | OSCCTRL_DFLLMUL_MUL(mul);
-        uint32_t ctrlb = (OSCCTRL_DFLLCTRLB_MODE | OSCCTRL_DFLLCTRLB_USBCRM
-                          | OSCCTRL_DFLLCTRLB_CCDIS);
-        config_dfll(dfllmul, ctrlb);
-    }
-
-    // Route factory calibrated DFLL48M to CLKGEN_48M
-    gen_clock(CLKGEN_48M, GCLK_GENCTRL_SRC_DFLL);
-
-    // Generate CLKGEN_2M (with CLKGEN_48M as reference)
-    uint32_t div = DIV_ROUND_CLOSEST(FREQ_48M, FREQ_2M);
-    gen_clock(CLKGEN_2M, GCLK_GENCTRL_SRC_DFLL | GCLK_GENCTRL_DIV(div));
-
-    // Generate 120Mhz clock on PLL0 (with CLKGEN_2M as reference)
-    route_pclock(OSCCTRL_GCLK_ID_FDPLL0, CLKGEN_2M);
-    uint32_t mul = DIV_ROUND_CLOSEST(FREQ_MAIN, FREQ_2M);
-    config_dpll(0, mul, OSCCTRL_DPLLCTRLB_REFCLK_GCLK);
-
-    // Switch main clock to 120Mhz PLL0
-    gen_clock(CLKGEN_MAIN, GCLK_GENCTRL_SRC_DPLL0);
-}
-
-void
-SystemInit(void)
-{
-    // Reset GCLK
-    GCLK->CTRLA.reg = GCLK_CTRLA_SWRST;
-    while (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_SWRST)
-        ;
-
-    // Init clocks
-    if (CONFIG_CLOCK_REF_X32K)
-        clock_init_32k();
-    else if (CONFIG_CLOCK_REF_X25M)
-        clock_init_25m();
-    else
-        clock_init_internal();
-
-    // Enable SAMD51 cache
-    CMCC->CTRL.reg = 1;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/samd51_watchdog.c crealityShit/src/atsamd/samd51_watchdog.c
--- klipperStock/src/atsamd/samd51_watchdog.c	2024-01-14 23:02:00.125796400 -0600
+++ crealityShit/src/atsamd/samd51_watchdog.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,24 +0,0 @@
-// Watchdog handler on SAMD21 boards
-//
-// Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "internal.h" // WDT
-#include "sched.h" // DECL_TASK
-
-void
-watchdog_reset(void)
-{
-    if (!(WDT->SYNCBUSY.reg & WDT_SYNCBUSY_CLEAR))
-        WDT->CLEAR.reg = 0xa5;
-}
-DECL_TASK(watchdog_reset);
-
-void
-watchdog_init(void)
-{
-    WDT->CONFIG.reg = WDT_CONFIG_PER(6); // 500ms timeout
-    WDT->CTRLA.reg = WDT_CTRLA_ENABLE;
-}
-DECL_INIT(watchdog_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/sercom.c crealityShit/src/atsamd/sercom.c
--- klipperStock/src/atsamd/sercom.c	2024-01-14 23:02:00.121796352 -0600
+++ crealityShit/src/atsamd/sercom.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,387 +0,0 @@
-// Handling of sercom pins
-//
-// Copyright (C) 2019  Florian Heilmann <Florian.Heilmann@gmx.net>
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "internal.h" // sercom_enable
-#include "command.h" // shutdown
-#include "compiler.h" // ARRAY_SIZE
-#include "sched.h" // sched_shutdown
-
-
-/****************************************************************
- * Available sercom blocks
- ****************************************************************/
-
-DECL_ENUMERATION_RANGE("bus", "sercom0", 0, 8);
-
-struct sercom_bus {
-    Sercom *sercom;
-    uint32_t pclk_id, pm_id;
-};
-
-static const struct sercom_bus sercoms[] = {
-    { SERCOM0, SERCOM0_GCLK_ID_CORE, ID_SERCOM0 },
-    { SERCOM1, SERCOM1_GCLK_ID_CORE, ID_SERCOM1 },
-    { SERCOM2, SERCOM2_GCLK_ID_CORE, ID_SERCOM2 },
-    { SERCOM3, SERCOM3_GCLK_ID_CORE, ID_SERCOM3 },
-#ifdef SERCOM4
-    { SERCOM4, SERCOM4_GCLK_ID_CORE, ID_SERCOM4 },
-    { SERCOM5, SERCOM5_GCLK_ID_CORE, ID_SERCOM5 },
-#endif
-#ifdef SERCOM6
-    { SERCOM6, SERCOM6_GCLK_ID_CORE, ID_SERCOM6 },
-    { SERCOM7, SERCOM7_GCLK_ID_CORE, ID_SERCOM7 },
-#endif
-};
-
-Sercom *
-sercom_enable_pclock(uint32_t sercom_id)
-{
-    if (sercom_id >= ARRAY_SIZE(sercoms))
-        shutdown("Invalid SERCOM bus");
-    const struct sercom_bus *sb = &sercoms[sercom_id];
-    enable_pclock(sb->pclk_id, sb->pm_id);
-    return sb->sercom;
-}
-
-uint32_t
-sercom_get_pclock_frequency(uint32_t sercom_id)
-{
-    const struct sercom_bus *sb = &sercoms[sercom_id];
-    return get_pclock_frequency(sb->pclk_id);
-}
-
-
-/****************************************************************
- * Pin configurations
- ****************************************************************/
-
-struct sercom_pad {
-    uint8_t sercom_id, gpio, pad, ptype;
-};
-
-static const struct sercom_pad sercom_pads[] = {
-#if CONFIG_MACH_SAMD21
-    { 0, GPIO('A', 8), 0, 'C'},
-    { 0, GPIO('A', 9), 1, 'C'},
-    { 0, GPIO('A', 10), 2, 'C'},
-    { 0, GPIO('A', 11), 3, 'C'},
-    { 0, GPIO('A', 4), 0, 'D'},
-    { 0, GPIO('A', 5), 1, 'D'},
-    { 0, GPIO('A', 6), 2, 'D'},
-    { 0, GPIO('A', 7), 3, 'D'},
-    { 1, GPIO('A', 16), 0, 'C'},
-    { 1, GPIO('A', 17), 1, 'C'},
-    { 1, GPIO('A', 18), 2, 'C'},
-    { 1, GPIO('A', 19), 3, 'C'},
-    { 1, GPIO('A', 0), 0, 'D'},
-    { 1, GPIO('A', 1), 1, 'D'},
-    { 1, GPIO('A', 30), 2, 'D'},
-    { 1, GPIO('A', 31), 3, 'D'},
-    { 2, GPIO('A', 12), 0, 'C'},
-    { 2, GPIO('A', 13), 1, 'C'},
-    { 2, GPIO('A', 14), 2, 'C'},
-    { 2, GPIO('A', 15), 3, 'C'},
-    { 2, GPIO('A', 8), 0, 'D'},
-    { 2, GPIO('A', 9), 1, 'D'},
-    { 2, GPIO('A', 10), 2, 'D'},
-    { 2, GPIO('A', 11), 3, 'D'},
-    { 3, GPIO('A', 22), 0, 'C'},
-    { 3, GPIO('A', 23), 1, 'C'},
-    { 3, GPIO('A', 24), 2, 'C'},
-    { 3, GPIO('A', 25), 3, 'C'},
-    { 3, GPIO('A', 16), 0, 'D'},
-    { 3, GPIO('A', 17), 1, 'D'},
-    { 3, GPIO('A', 18), 2, 'D'},
-    { 3, GPIO('A', 19), 3, 'D'},
-    { 3, GPIO('A', 20), 2, 'D'},
-    { 3, GPIO('A', 21), 3, 'D'},
-    { 4, GPIO('B', 12), 0, 'C'},
-    { 4, GPIO('B', 13), 1, 'C'},
-    { 4, GPIO('B', 14), 2, 'C'},
-    { 4, GPIO('B', 15), 3, 'C'},
-    { 4, GPIO('B', 8), 0, 'D'},
-    { 4, GPIO('B', 9), 1, 'D'},
-    { 4, GPIO('B', 10), 2, 'D'},
-    { 4, GPIO('B', 11), 3, 'D'},
-    { 4, GPIO('A', 12), 0, 'D'},
-    { 4, GPIO('A', 13), 1, 'D'},
-    { 4, GPIO('A', 14), 2, 'D'},
-    { 4, GPIO('A', 15), 3, 'D'},
-    { 5, GPIO('B', 16), 0, 'C'},
-    { 5, GPIO('B', 17), 1, 'C'},
-    { 5, GPIO('A', 20), 2, 'C'},
-    { 5, GPIO('A', 21), 3, 'C'},
-    { 5, GPIO('A', 22), 0, 'D'},
-    { 5, GPIO('A', 23), 1, 'D'},
-    { 5, GPIO('A', 24), 2, 'D'},
-    { 5, GPIO('A', 25), 3, 'D'},
-    { 5, GPIO('B', 30), 0, 'D'},
-    { 5, GPIO('B', 31), 1, 'D'},
-    { 5, GPIO('B', 22), 2, 'D'},
-    { 5, GPIO('B', 23), 3, 'D'},
-    { 5, GPIO('B', 2), 0, 'D'},
-    { 5, GPIO('B', 3), 1, 'D'},
-    { 5, GPIO('B', 0), 2, 'D'},
-    { 5, GPIO('B', 1), 3, 'D'},
-#elif CONFIG_MACH_SAMX5
-    { 0, GPIO('A', 8), 0, 'C'},
-    { 0, GPIO('A', 9), 1, 'C'},
-    { 0, GPIO('A', 10), 2, 'C'},
-    { 0, GPIO('A', 11), 3, 'C'},
-    { 0, GPIO('B', 24), 0, 'C'},
-    { 0, GPIO('B', 25), 1, 'C'},
-    { 0, GPIO('C', 24), 2, 'C'},
-    { 0, GPIO('C', 25), 3, 'C'},
-    { 0, GPIO('A', 4), 0, 'D'},
-    { 0, GPIO('A', 5), 1, 'D'},
-    { 0, GPIO('A', 6), 2, 'D'},
-    { 0, GPIO('A', 7), 3, 'D'},
-    { 0, GPIO('C', 17), 0, 'D'},
-    { 0, GPIO('C', 16), 1, 'D'},
-    { 0, GPIO('C', 18), 2, 'D'},
-    { 0, GPIO('C', 19), 3, 'D'},
-
-    { 1, GPIO('A', 16), 0, 'C'},
-    { 1, GPIO('A', 17), 1, 'C'},
-    { 1, GPIO('A', 18), 2, 'C'},
-    { 1, GPIO('A', 19), 3, 'C'},
-    { 1, GPIO('C', 22), 0, 'C'},
-    { 1, GPIO('C', 23), 1, 'C'},
-    { 1, GPIO('D', 20), 2, 'C'},
-    { 1, GPIO('D', 21), 3, 'C'},
-    { 1, GPIO('C', 27), 0, 'C'},
-    { 1, GPIO('C', 28), 1, 'C'},
-    { 1, GPIO('B', 22), 2, 'C'},
-    { 1, GPIO('B', 23), 3, 'C'},
-    { 1, GPIO('A', 0), 0, 'D'},
-    { 1, GPIO('A', 1), 1, 'D'},
-    { 1, GPIO('A', 30), 2, 'D'},
-    { 1, GPIO('A', 31), 3, 'D'},
-
-    { 2, GPIO('A', 12), 0, 'C'},
-    { 2, GPIO('A', 13), 1, 'C'},
-    { 2, GPIO('A', 14), 2, 'C'},
-    { 2, GPIO('A', 15), 3, 'C'},
-    { 2, GPIO('B', 26), 0, 'C'},
-    { 2, GPIO('B', 27), 1, 'C'},
-    { 2, GPIO('B', 28), 2, 'C'},
-    { 2, GPIO('B', 29), 3, 'C'},
-    { 2, GPIO('A', 9), 0, 'D'},
-    { 2, GPIO('A', 8), 1, 'D'},
-    { 2, GPIO('A', 10), 2, 'D'},
-    { 2, GPIO('A', 11), 3, 'D'},
-    { 2, GPIO('B', 25), 0, 'D'},
-    { 2, GPIO('B', 24), 1, 'D'},
-    { 2, GPIO('C', 24), 2, 'D'},
-    { 2, GPIO('C', 25), 3, 'D'},
-
-    { 3, GPIO('A', 22), 0, 'C'},
-    { 3, GPIO('A', 23), 1, 'C'},
-    { 3, GPIO('A', 24), 2, 'C'},
-    { 3, GPIO('A', 25), 3, 'C'},
-    { 3, GPIO('B', 20), 0, 'C'},
-    { 3, GPIO('B', 21), 1, 'C'},
-    { 3, GPIO('A', 20), 2, 'D'},
-    { 3, GPIO('A', 21), 3, 'D'},
-    { 3, GPIO('A', 17), 0, 'D'},
-    { 3, GPIO('A', 16), 1, 'D'},
-    { 3, GPIO('A', 18), 2, 'D'},
-    { 3, GPIO('A', 19), 3, 'D'},
-    { 3, GPIO('C', 23), 0, 'D'},
-    { 3, GPIO('C', 22), 1, 'D'},
-    { 3, GPIO('D', 20), 2, 'D'},
-    { 3, GPIO('D', 21), 3, 'D'},
-
-    { 4, GPIO('B', 12), 0, 'C'},
-    { 4, GPIO('B', 13), 1, 'C'},
-    { 4, GPIO('B', 14), 2, 'C'},
-    { 4, GPIO('B', 15), 3, 'C'},
-    { 4, GPIO('B', 8), 0, 'D'},
-    { 4, GPIO('B', 9), 1, 'D'},
-    { 4, GPIO('B', 10), 2, 'D'},
-    { 4, GPIO('B', 11), 3, 'D'},
-    { 4, GPIO('A', 13), 0, 'D'},
-    { 4, GPIO('A', 12), 1, 'D'},
-    { 4, GPIO('A', 14), 2, 'D'},
-    { 4, GPIO('A', 15), 3, 'D'},
-    { 4, GPIO('B', 27), 0, 'D'},
-    { 4, GPIO('B', 26), 1, 'D'},
-    { 4, GPIO('B', 28), 2, 'D'},
-    { 4, GPIO('B', 29), 3, 'D'},
-
-    { 5, GPIO('B', 16), 0, 'C'},
-    { 5, GPIO('B', 17), 1, 'C'},
-    { 5, GPIO('B', 18), 2, 'C'},
-    { 5, GPIO('B', 19), 3, 'C'},
-    { 5, GPIO('A', 23), 0, 'D'},
-    { 5, GPIO('A', 22), 1, 'D'},
-    { 5, GPIO('A', 20), 2, 'D'},
-    { 5, GPIO('A', 21), 3, 'D'},
-    { 5, GPIO('A', 24), 2, 'D'},
-    { 5, GPIO('A', 25), 3, 'D'},
-    { 5, GPIO('B', 22), 2, 'D'},
-    { 5, GPIO('B', 23), 3, 'D'},
-    { 5, GPIO('B', 31), 0, 'D'},
-    { 5, GPIO('B', 30), 1, 'D'},
-    { 5, GPIO('B', 0), 2, 'D'},
-    { 5, GPIO('B', 1), 3, 'D'},
-    { 5, GPIO('B', 2), 0, 'D'},
-    { 5, GPIO('B', 3), 1, 'D'},
-  #ifdef SERCOM6
-    { 6, GPIO('C', 16), 0, 'C'},
-    { 6, GPIO('C', 17), 1, 'C'},
-    { 6, GPIO('C', 18), 2, 'C'},
-    { 6, GPIO('C', 19), 3, 'C'},
-    { 6, GPIO('C', 4), 0, 'C'},
-    { 6, GPIO('C', 5), 1, 'C'},
-    { 6, GPIO('C', 6), 2, 'C'},
-    { 6, GPIO('C', 7), 3, 'C'},
-    { 6, GPIO('D', 9), 0, 'D'},
-    { 6, GPIO('D', 8), 1, 'D'},
-    { 6, GPIO('D', 10), 2, 'D'},
-    { 6, GPIO('D', 11), 3, 'D'},
-    { 6, GPIO('C', 13), 0, 'D'},
-    { 6, GPIO('C', 12), 1, 'D'},
-    { 6, GPIO('C', 14), 2, 'D'},
-    { 6, GPIO('C', 15), 3, 'D'},
-    { 6, GPIO('C', 10), 2, 'C'},
-    { 6, GPIO('C', 11), 3, 'C'},
-
-    { 7, GPIO('C', 12), 0, 'C'},
-    { 7, GPIO('C', 13), 1, 'C'},
-    { 7, GPIO('C', 14), 2, 'C'},
-    { 7, GPIO('C', 15), 3, 'C'},
-    { 7, GPIO('D', 8), 0, 'C'},
-    { 7, GPIO('D', 9), 1, 'C'},
-    { 7, GPIO('D', 10), 2, 'C'},
-    { 7, GPIO('D', 11), 3, 'C'},
-    { 7, GPIO('C', 10), 2, 'D'},
-    { 7, GPIO('C', 11), 3, 'D'},
-    { 7, GPIO('B', 21), 0, 'D'},
-    { 7, GPIO('B', 20), 1, 'D'},
-    { 7, GPIO('B', 18), 2, 'D'},
-    { 7, GPIO('B', 19), 3, 'D'},
-    { 7, GPIO('B', 30), 0, 'C'},
-    { 7, GPIO('B', 31), 1, 'C'},
-    { 7, GPIO('A', 30), 2, 'C'},
-    { 7, GPIO('A', 31), 3, 'C'},
-  #endif
-#endif
-};
-
-static const struct sercom_pad *
-sercom_lookup_pad(uint32_t sercom_id, uint8_t pin)
-{
-    const struct sercom_pad *sp = sercom_pads;
-    for (; ; sp++) {
-        if (sp >= &sercom_pads[ARRAY_SIZE(sercom_pads)])
-            shutdown("Invalid SERCOM configuration");
-        if (sp->sercom_id == sercom_id && sp->gpio == pin)
-            return sp;
-    }
-}
-
-
-/****************************************************************
- * Runtime configuration
- ****************************************************************/
-
-enum { TX_PIN, RX_PIN, CLK_PIN };
-DECL_ENUMERATION("sercom_pin_type", "tx", TX_PIN);
-DECL_ENUMERATION("sercom_pin_type", "rx", RX_PIN);
-DECL_ENUMERATION("sercom_pin_type", "clk", CLK_PIN);
-
-// Runtime configuration
-struct sercom_pin {
-    uint8_t pins[3];
-};
-
-static struct sercom_pin sercom_pins[ARRAY_SIZE(sercoms)];
-
-void
-command_set_sercom_pin(uint32_t *args)
-{
-    uint8_t sercom_id = args[0], pin_type = args[1], pin = args[2];
-    if (sercom_id >= ARRAY_SIZE(sercom_pins)
-        || pin_type >= ARRAY_SIZE(sercom_pins[0].pins))
-        shutdown("Invalid SERCOM bus");
-    sercom_pins[sercom_id].pins[pin_type] = pin;
-}
-DECL_COMMAND(command_set_sercom_pin,
-             "set_sercom_pin bus=%u sercom_pin_type=%u pin=%u");
-
-
-/****************************************************************
- * SPI dopo flag mapping
- ****************************************************************/
-
-struct sercom_spi_map {
-    uint8_t tx_pad, clk_pad, dopo;
-};
-
-static const struct sercom_spi_map sercom_spi[] = {
-    { 0, 1, 0 },
-    { 3, 1, 2 },
-#if CONFIG_MACH_SAMD21
-    { 2, 3, 1 },
-    { 0, 3, 3 },
-#endif
-};
-
-static uint8_t
-sercom_lookup_spi_dopo(uint8_t tx_pad, uint8_t clk_pad)
-{
-    const struct sercom_spi_map *sm = sercom_spi;
-    for (; ; sm++) {
-        if (sm >= &sercom_spi[ARRAY_SIZE(sercom_spi)])
-            shutdown("Invalid combination of TX pin and CLK pin");
-        if (sm->tx_pad == tx_pad && sm->clk_pad == clk_pad)
-            return sm->dopo;
-    }
-}
-
-
-/****************************************************************
- * Pin setup
- ****************************************************************/
-
-uint32_t
-sercom_spi_pins(uint32_t sercom_id)
-{
-    if (sercom_id >= ARRAY_SIZE(sercom_pins))
-        shutdown("Invalid SERCOM bus");
-    uint8_t tx_pin = sercom_pins[sercom_id].pins[TX_PIN];
-    const struct sercom_pad *tx_sp = sercom_lookup_pad(sercom_id, tx_pin);
-    uint8_t rx_pin = sercom_pins[sercom_id].pins[RX_PIN];
-    const struct sercom_pad *rx_sp = sercom_lookup_pad(sercom_id, rx_pin);
-    uint8_t clk_pin = sercom_pins[sercom_id].pins[CLK_PIN];
-    const struct sercom_pad *clk_sp = sercom_lookup_pad(sercom_id, clk_pin);
-
-    uint8_t dopo = sercom_lookup_spi_dopo(tx_sp->pad, clk_sp->pad);
-    if (rx_sp->pad == tx_sp->pad || rx_sp->pad == clk_sp->pad)
-        shutdown("Sercom RX pad collides with TX or CLK pad");
-
-    gpio_peripheral(tx_pin, tx_sp->ptype, 0);
-    gpio_peripheral(rx_pin, rx_sp->ptype, 0);
-    gpio_peripheral(clk_pin, clk_sp->ptype, 0);
-    return SERCOM_SPI_CTRLA_DIPO(rx_sp->pad) | SERCOM_SPI_CTRLA_DOPO(dopo);
-}
-
-void
-sercom_i2c_pins(uint32_t sercom_id)
-{
-    uint8_t tx_pin = sercom_pins[sercom_id].pins[TX_PIN];
-    const struct sercom_pad *tx_sp = sercom_lookup_pad(sercom_id, tx_pin);
-    uint8_t clk_pin = sercom_pins[sercom_id].pins[CLK_PIN];
-    const struct sercom_pad *clk_sp = sercom_lookup_pad(sercom_id, clk_pin);
-
-    if (tx_sp->pad != 0 || clk_sp->pad != 1)
-        shutdown("TX pin not on PAD0 or CLK pin not on PAD1");
-
-    gpio_peripheral(tx_pin, tx_sp->ptype, 0);
-    gpio_peripheral(clk_pin, clk_sp->ptype, 0);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/serial.c crealityShit/src/atsamd/serial.c
--- klipperStock/src/atsamd/serial.c	2024-01-14 23:02:00.121796352 -0600
+++ crealityShit/src/atsamd/serial.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,71 +0,0 @@
-// samd21 serial port
-//
-// Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/serial_irq.h" // serial_rx_data
-#include "command.h" // DECL_CONSTANT_STR
-#include "internal.h" // enable_pclock
-#include "sched.h" // DECL_INIT
-
-void
-serial_enable_tx_irq(void)
-{
-    SERCOM0->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
-}
-
-void
-SERCOM0_Handler(void)
-{
-    uint32_t status = SERCOM0->USART.INTFLAG.reg;
-    if (status & SERCOM_USART_INTFLAG_RXC)
-        serial_rx_byte(SERCOM0->USART.DATA.reg);
-    if (status & SERCOM_USART_INTFLAG_DRE) {
-        uint8_t data;
-        int ret = serial_get_tx_byte(&data);
-        if (ret)
-            SERCOM0->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
-        else
-            SERCOM0->USART.DATA.reg = data;
-    }
-}
-
-DECL_CONSTANT_STR("RESERVE_PINS_serial", "PA11,PA10");
-
-void
-serial_init(void)
-{
-    // Enable serial clock
-    enable_pclock(SERCOM0_GCLK_ID_CORE, ID_SERCOM0);
-    // Enable pins
-    gpio_peripheral(GPIO('A', 11), 'C', 0);
-    gpio_peripheral(GPIO('A', 10), 'C', 0);
-    // Configure serial
-    SercomUsart *su = &SERCOM0->USART;
-    su->CTRLA.reg = 0;
-    uint32_t areg = (SERCOM_USART_CTRLA_MODE(1)
-                     | SERCOM_USART_CTRLA_DORD
-                     | SERCOM_USART_CTRLA_SAMPR(1)
-                     | SERCOM_USART_CTRLA_RXPO(3)
-                     | SERCOM_USART_CTRLA_TXPO(1));
-    su->CTRLA.reg = areg;
-    su->CTRLB.reg = SERCOM_USART_CTRLB_RXEN | SERCOM_USART_CTRLB_TXEN;
-    uint32_t freq = get_pclock_frequency(SERCOM0_GCLK_ID_CORE);
-    uint32_t baud8 = freq / (2 * CONFIG_SERIAL_BAUD);
-    su->BAUD.reg = (SERCOM_USART_BAUD_FRAC_BAUD(baud8 / 8)
-                    | SERCOM_USART_BAUD_FRAC_FP(baud8 % 8));
-    // enable irqs
-    su->INTENSET.reg = SERCOM_USART_INTENSET_RXC;
-    su->CTRLA.reg = areg | SERCOM_USART_CTRLA_ENABLE;
-#if CONFIG_MACH_SAMD21
-    armcm_enable_irq(SERCOM0_Handler, SERCOM0_IRQn, 0);
-#elif CONFIG_MACH_SAMX5
-    armcm_enable_irq(SERCOM0_Handler, SERCOM0_0_IRQn, 0);
-    armcm_enable_irq(SERCOM0_Handler, SERCOM0_1_IRQn, 0);
-    armcm_enable_irq(SERCOM0_Handler, SERCOM0_2_IRQn, 0);
-    armcm_enable_irq(SERCOM0_Handler, SERCOM0_3_IRQn, 0);
-#endif
-}
-DECL_INIT(serial_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/spi.c crealityShit/src/atsamd/spi.c
--- klipperStock/src/atsamd/spi.c	2024-01-14 23:02:00.121796352 -0600
+++ crealityShit/src/atsamd/spi.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,78 +0,0 @@
-// spi support on samd
-//
-// Copyright (C) 2019  Florian Heilmann <Florian.Heilmann@gmx.net>
-// Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "internal.h" // enable_pclock
-#include "gpio.h" // spi_setup
-
-void
-spi_init(uint32_t bus, SercomSpi *ss, uint32_t ctrla, uint32_t baud)
-{
-    static uint8_t have_run_init;
-    if (have_run_init & (1<<bus))
-        return;
-    have_run_init |= 1<<bus;
-
-    ss->CTRLA.reg = 0;
-    ss->CTRLA.reg = ctrla & ~SERCOM_SPI_CTRLA_ENABLE;
-    ss->CTRLB.reg = SERCOM_SPI_CTRLB_RXEN;
-    ss->BAUD.reg = baud;
-    ss->CTRLA.reg = ctrla;
-}
-
-struct spi_config
-spi_setup(uint32_t bus, uint8_t mode, uint32_t rate)
-{
-    uint32_t dipo_dopo = sercom_spi_pins(bus);
-    uint32_t ctrla = (SERCOM_SPI_CTRLA_MODE(3)
-                      | (mode << SERCOM_SPI_CTRLA_CPHA_Pos)
-                      | dipo_dopo
-                      | SERCOM_SPI_CTRLA_ENABLE);
-    Sercom *sercom = sercom_enable_pclock(bus);
-    SercomSpi *ss = &sercom->SPI;
-    uint32_t baud = sercom_get_pclock_frequency(bus) / (2 * rate) - 1;
-    spi_init(bus, ss, ctrla, baud);
-    return (struct spi_config){ .ss = ss, .ctrla = ctrla, .baud = baud };
-}
-
-void
-spi_prepare(struct spi_config config)
-{
-    uint32_t ctrla = config.ctrla, baud = config.baud;
-    SercomSpi *ss = (SercomSpi *)config.ss;
-    if (ctrla == ss->CTRLA.reg && baud == ss->BAUD.reg)
-        return;
-    ss->CTRLA.reg = ctrla & ~SERCOM_SPI_CTRLA_ENABLE;
-    ss->CTRLA.reg = ctrla & ~SERCOM_SPI_CTRLA_ENABLE;
-    ss->BAUD.reg = baud;
-    ss->CTRLA.reg = ctrla;
-}
-
-void
-spi_transfer(struct spi_config config, uint8_t receive_data
-             , uint8_t len, uint8_t *data)
-{
-    SercomSpi *ss = (SercomSpi *)config.ss;
-    if (receive_data) {
-        while (len--) {
-            ss->DATA.reg = *data;
-            // wait for receive register
-            while (!(ss->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC))
-                ;
-            // get data
-            *data++ = ss->DATA.reg;
-        }
-    } else {
-        while (len--) {
-            ss->DATA.reg = *data++;
-            // wait for receive register
-            while (!(ss->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC))
-                ;
-            // read data (to clear RXC)
-            ss->DATA.reg;
-        }
-    }
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/timer.c crealityShit/src/atsamd/timer.c
--- klipperStock/src/atsamd/timer.c	2024-01-14 23:02:00.125796400 -0600
+++ crealityShit/src/atsamd/timer.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,65 +0,0 @@
-// SAMD21 timer interrupt scheduling
-//
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_read_time
-#include "board/timer_irq.h" // timer_dispatch_many
-#include "internal.h" // enable_pclock
-#include "sched.h" // DECL_INIT
-
-// Set the next irq time
-static void
-timer_set(uint32_t value)
-{
-    TC4->COUNT32.CC[0].reg = value;
-    TC4->COUNT32.INTFLAG.reg = TC_INTFLAG_MC0;
-}
-
-// Return the current time (in absolute clock ticks).
-uint32_t
-timer_read_time(void)
-{
-    return TC4->COUNT32.COUNT.reg;
-}
-
-// Activate timer dispatch as soon as possible
-void
-timer_kick(void)
-{
-    timer_set(timer_read_time() + 50);
-}
-
-// IRQ handler
-void __aligned(16) // aligning helps stabilize perf benchmarks
-TC4_Handler(void)
-{
-    irq_disable();
-    uint32_t next = timer_dispatch_many();
-    timer_set(next);
-    irq_enable();
-}
-
-void
-timer_init(void)
-{
-    // Supply power and clock to the timer
-    enable_pclock(TC3_GCLK_ID, ID_TC3);
-    enable_pclock(TC4_GCLK_ID, ID_TC4);
-
-    // Configure the timer
-    TcCount32 *tc = &TC4->COUNT32;
-    irqstatus_t flag = irq_save();
-    tc->CTRLA.reg = 0;
-    tc->CTRLA.reg = TC_CTRLA_MODE_COUNT32;
-    armcm_enable_irq(TC4_Handler, TC4_IRQn, 2);
-    tc->INTENSET.reg = TC_INTENSET_MC0;
-    tc->COUNT.reg = 0;
-    timer_kick();
-    tc->CTRLA.reg = TC_CTRLA_MODE_COUNT32 | TC_CTRLA_ENABLE;
-    irq_restore(flag);
-}
-DECL_INIT(timer_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/usbserial.c crealityShit/src/atsamd/usbserial.c
--- klipperStock/src/atsamd/usbserial.c	2024-01-14 23:02:00.129796451 -0600
+++ crealityShit/src/atsamd/usbserial.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,246 +0,0 @@
-// Hardware interface to USB on samd
-//
-// Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memcpy
-#include "autoconf.h" // CONFIG_MACH_SAMD21
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/io.h" // writeb
-#include "board/usb_cdc.h" // usb_notify_ep0
-#include "board/usb_cdc_ep.h" // USB_CDC_EP_BULK_IN
-#include "command.h" // DECL_CONSTANT_STR
-#include "internal.h" // enable_pclock
-#include "sched.h" // DECL_INIT
-
-
-/****************************************************************
- * USB transfer memory
- ****************************************************************/
-
-static uint8_t __aligned(4) ep0out[USB_CDC_EP0_SIZE];
-static uint8_t __aligned(4) ep0in[USB_CDC_EP0_SIZE];
-static uint8_t __aligned(4) acmin[USB_CDC_EP_ACM_SIZE];
-static uint8_t __aligned(4) bulkout[USB_CDC_EP_BULK_OUT_SIZE];
-static uint8_t __aligned(4) bulkin[USB_CDC_EP_BULK_IN_SIZE];
-
-static UsbDeviceDescriptor usb_desc[] = {
-    [0] = { {
-        {
-            .ADDR.reg = (uint32_t)ep0out,
-            .PCKSIZE.reg = USB_DEVICE_PCKSIZE_SIZE(sizeof(ep0out) >> 4),
-        }, {
-            .ADDR.reg = (uint32_t)ep0in,
-            .PCKSIZE.reg = USB_DEVICE_PCKSIZE_SIZE(sizeof(ep0in) >> 4),
-        },
-    } },
-    [USB_CDC_EP_ACM] = { {
-        {
-        }, {
-            .ADDR.reg = (uint32_t)acmin,
-            .PCKSIZE.reg = USB_DEVICE_PCKSIZE_SIZE(sizeof(acmin) >> 4),
-        },
-    } },
-    [USB_CDC_EP_BULK_OUT] = { {
-        {
-            .ADDR.reg = (uint32_t)bulkout,
-            .PCKSIZE.reg = USB_DEVICE_PCKSIZE_SIZE(sizeof(bulkout) >> 4),
-        }, {
-        },
-    } },
-    [USB_CDC_EP_BULK_IN] = { {
-        {
-        }, {
-            .ADDR.reg = (uint32_t)bulkin,
-            .PCKSIZE.reg = USB_DEVICE_PCKSIZE_SIZE(sizeof(bulkin) >> 4),
-        },
-    } },
-};
-
-#define EP0 USB->DEVICE.DeviceEndpoint[0]
-#define EP_ACM USB->DEVICE.DeviceEndpoint[USB_CDC_EP_ACM]
-#define EP_BULKOUT USB->DEVICE.DeviceEndpoint[USB_CDC_EP_BULK_OUT]
-#define EP_BULKIN USB->DEVICE.DeviceEndpoint[USB_CDC_EP_BULK_IN]
-
-static int_fast8_t
-usb_write_packet(uint32_t ep, uint32_t bank, const void *data, uint_fast8_t len)
-{
-    // Check if there is room for this packet
-    UsbDeviceEndpoint *ude = &USB->DEVICE.DeviceEndpoint[ep];
-    uint8_t sts = ude->EPSTATUS.reg;
-    uint8_t bkrdy = (bank ? USB_DEVICE_EPSTATUS_BK1RDY
-                     : USB_DEVICE_EPSTATUS_BK0RDY);
-    if (sts & bkrdy)
-        return -1;
-    // Copy the packet to the given buffer
-    UsbDeviceDescBank *uddb = &usb_desc[ep].DeviceDescBank[bank];
-    memcpy((void*)uddb->ADDR.reg, data, len);
-    // Inform the USB hardware of the available packet
-    uint32_t pcksize = uddb->PCKSIZE.reg;
-    uint32_t c = pcksize & ~USB_DEVICE_PCKSIZE_BYTE_COUNT_Msk;
-    uddb->PCKSIZE.reg = c | USB_DEVICE_PCKSIZE_BYTE_COUNT(len);
-    ude->EPSTATUSSET.reg = bkrdy;
-    return len;
-}
-
-static int_fast8_t
-usb_read_packet(uint32_t ep, uint32_t bank, void *data, uint_fast8_t max_len)
-{
-    // Check if there is a packet ready
-    UsbDeviceEndpoint *ude = &USB->DEVICE.DeviceEndpoint[ep];
-    uint8_t sts = ude->EPSTATUS.reg;
-    uint8_t bkrdy = (bank ? USB_DEVICE_EPSTATUS_BK1RDY
-                     : USB_DEVICE_EPSTATUS_BK0RDY);
-    if (!(sts & bkrdy))
-        return -1;
-    // Copy the packet to the given buffer
-    UsbDeviceDescBank *uddb = &usb_desc[ep].DeviceDescBank[bank];
-    uint32_t pcksize = uddb->PCKSIZE.reg;
-    uint32_t c = pcksize & USB_DEVICE_PCKSIZE_BYTE_COUNT_Msk;
-    if (c > max_len)
-        c = max_len;
-    memcpy(data, (void*)uddb->ADDR.reg, c);
-    // Notify the USB hardware that the space is now available
-    ude->EPSTATUSCLR.reg = bkrdy;
-    return c;
-}
-
-
-/****************************************************************
- * Interface
- ****************************************************************/
-
-int_fast8_t
-usb_read_bulk_out(void *data, uint_fast8_t max_len)
-{
-    return usb_read_packet(USB_CDC_EP_BULK_OUT, 0, data, max_len);
-}
-
-int_fast8_t
-usb_send_bulk_in(void *data, uint_fast8_t len)
-{
-    return usb_write_packet(USB_CDC_EP_BULK_IN, 1, data, len);
-}
-
-int_fast8_t
-usb_read_ep0(void *data, uint_fast8_t max_len)
-{
-    return usb_read_packet(0, 0, data, max_len);
-}
-
-int_fast8_t
-usb_read_ep0_setup(void *data, uint_fast8_t max_len)
-{
-    return usb_read_ep0(data, max_len);
-}
-
-int_fast8_t
-usb_send_ep0(const void *data, uint_fast8_t len)
-{
-    return usb_write_packet(0, 1, data, len);
-}
-
-void
-usb_stall_ep0(void)
-{
-    EP0.EPSTATUSSET.reg = USB_DEVICE_EPSTATUS_STALLRQ(3);
-}
-
-static uint8_t set_address;
-
-void
-usb_set_address(uint_fast8_t addr)
-{
-    writeb(&set_address, addr | USB_DEVICE_DADD_ADDEN);
-    usb_send_ep0(NULL, 0);
-}
-
-void
-usb_set_configure(void)
-{
-    EP_ACM.EPCFG.reg = USB_DEVICE_EPCFG_EPTYPE1(4);
-
-    EP_BULKOUT.EPCFG.reg = USB_DEVICE_EPCFG_EPTYPE0(3);
-    EP_BULKOUT.EPINTENSET.reg = (
-        USB_DEVICE_EPINTENSET_TRCPT0 | USB_DEVICE_EPINTENSET_TRCPT1);
-
-    EP_BULKIN.EPCFG.reg = USB_DEVICE_EPCFG_EPTYPE1(3);
-    EP_BULKIN.EPINTENSET.reg = (
-        USB_DEVICE_EPINTENSET_TRCPT0 | USB_DEVICE_EPINTENSET_TRCPT1);
-}
-
-
-/****************************************************************
- * Setup and interrupts
- ****************************************************************/
-
-void
-USB_Handler(void)
-{
-    uint8_t s = USB->DEVICE.INTFLAG.reg;
-    if (s & USB_DEVICE_INTFLAG_EORST) {
-        USB->DEVICE.INTFLAG.reg = USB_DEVICE_INTFLAG_EORST;
-        // Enable endpoint 0 irqs
-        EP0.EPINTENSET.reg = (
-            USB_DEVICE_EPINTENSET_TRCPT0 | USB_DEVICE_EPINTENSET_TRCPT1
-            | USB_DEVICE_EPINTENSET_RXSTP);
-    }
-
-    uint16_t ep = USB->DEVICE.EPINTSMRY.reg;
-    if (ep & (1<<0)) {
-        uint8_t sts = EP0.EPINTFLAG.reg;
-        EP0.EPINTFLAG.reg = sts;
-        if (set_address && sts & USB_DEVICE_EPINTFLAG_TRCPT1) {
-            // Apply address after last "in" message transmitted
-            USB->DEVICE.DADD.reg = set_address;
-            set_address = 0;
-        }
-        usb_notify_ep0();
-    }
-    if (ep & (1<<USB_CDC_EP_BULK_OUT)) {
-        uint8_t sts = EP_BULKOUT.EPINTFLAG.reg;
-        EP_BULKOUT.EPINTFLAG.reg = sts;
-        usb_notify_bulk_out();
-    }
-    if (ep & (1<<USB_CDC_EP_BULK_IN)) {
-        uint8_t sts = EP_BULKIN.EPINTFLAG.reg;
-        EP_BULKIN.EPINTFLAG.reg = sts;
-        usb_notify_bulk_in();
-    }
-}
-
-DECL_CONSTANT_STR("RESERVE_PINS_USB", "PA24,PA25");
-
-void
-usbserial_init(void)
-{
-    // configure usb clock
-    enable_pclock(USB_GCLK_ID, ID_USB);
-    // configure USBD+ and USBD- pins
-    uint32_t ptype = CONFIG_MACH_SAMD21 ? 'G' : 'H';
-    gpio_peripheral(GPIO('A', 24), ptype, 0);
-    gpio_peripheral(GPIO('A', 25), ptype, 0);
-    uint32_t trim = GET_FUSE(USB_FUSES_TRIM);
-    uint32_t transp = GET_FUSE(USB_FUSES_TRANSP);
-    uint32_t transn = GET_FUSE(USB_FUSES_TRANSN);
-    USB->DEVICE.PADCAL.reg = (USB_PADCAL_TRIM(trim) | USB_PADCAL_TRANSP(transp)
-                              | USB_PADCAL_TRANSN(transn));
-    // Enable USB in device mode
-    USB->DEVICE.CTRLA.reg = USB_CTRLA_ENABLE;
-    USB->DEVICE.DESCADD.reg = (uint32_t)usb_desc;
-    EP0.EPCFG.reg = USB_DEVICE_EPCFG_EPTYPE0(1) | USB_DEVICE_EPCFG_EPTYPE1(1);
-    EP_ACM.EPCFG.reg = USB_DEVICE_EPCFG_EPTYPE1(4);
-    USB->DEVICE.CTRLB.reg = 0;
-    // enable irqs
-    USB->DEVICE.INTENSET.reg = USB_DEVICE_INTENSET_EORST;
-#if CONFIG_MACH_SAMD21
-    armcm_enable_irq(USB_Handler, USB_IRQn, 1);
-#elif CONFIG_MACH_SAMX5
-    armcm_enable_irq(USB_Handler, USB_0_IRQn, 1);
-    armcm_enable_irq(USB_Handler, USB_1_IRQn, 1);
-    armcm_enable_irq(USB_Handler, USB_2_IRQn, 1);
-    armcm_enable_irq(USB_Handler, USB_3_IRQn, 1);
-#endif
-}
-DECL_INIT(usbserial_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/atsamd/watchdog.c crealityShit/src/atsamd/watchdog.c
--- klipperStock/src/atsamd/watchdog.c	2024-01-14 23:02:00.125796400 -0600
+++ crealityShit/src/atsamd/watchdog.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,24 +0,0 @@
-// Watchdog handler on SAMD21 boards
-//
-// Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "internal.h" // WDT
-#include "sched.h" // DECL_TASK
-
-void
-watchdog_reset(void)
-{
-    if (!(WDT->STATUS.reg & WDT_STATUS_SYNCBUSY))
-        WDT->CLEAR.reg = 0xa5;
-}
-DECL_TASK(watchdog_reset);
-
-void
-watchdog_init(void)
-{
-    WDT->CONFIG.reg = WDT_CONFIG_PER_16K; // 500ms timeout
-    WDT->CTRL.reg = WDT_CTRL_ENABLE;
-}
-DECL_INIT(watchdog_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/avr/adc.c crealityShit/src/avr/adc.c
--- klipperStock/src/avr/adc.c	2024-01-14 23:02:00.157796793 -0600
+++ crealityShit/src/avr/adc.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,122 +0,0 @@
-// Analog to Digital Converter support
-//
-// Copyright (C) 2016-2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_MACH_atmega644p
-#include "command.h" // shutdown
-#include "gpio.h" // gpio_adc_read
-#include "internal.h" // GPIO
-#include "pgm.h" // PROGMEM
-#include "sched.h" // sched_shutdown
-
-static const uint8_t adc_pins[] PROGMEM = {
-#if CONFIG_MACH_atmega168 || CONFIG_MACH_atmega328 || CONFIG_MACH_atmega328p
-    GPIO('C', 0), GPIO('C', 1), GPIO('C', 2), GPIO('C', 3),
-    GPIO('C', 4), GPIO('C', 5), GPIO('E', 2), GPIO('E', 3),
-#elif CONFIG_MACH_atmega644p || CONFIG_MACH_atmega1284p
-    GPIO('A', 0), GPIO('A', 1), GPIO('A', 2), GPIO('A', 3),
-    GPIO('A', 4), GPIO('A', 5), GPIO('A', 6), GPIO('A', 7),
-#elif CONFIG_MACH_at90usb1286 || CONFIG_MACH_at90usb646
-    GPIO('F', 0), GPIO('F', 1), GPIO('F', 2), GPIO('F', 3),
-    GPIO('F', 4), GPIO('F', 5), GPIO('F', 6), GPIO('F', 7),
-#elif CONFIG_MACH_atmega32u4
-    GPIO('F', 0), GPIO('F', 1), GPIO('F', 2), GPIO('F', 3),
-    GPIO('F', 4), GPIO('F', 5), GPIO('F', 6), GPIO('F', 7),
-    GPIO('D', 4), GPIO('D', 6), GPIO('D', 7), GPIO('B', 4),
-#elif CONFIG_MACH_atmega1280 || CONFIG_MACH_atmega2560
-    GPIO('F', 0), GPIO('F', 1), GPIO('F', 2), GPIO('F', 3),
-    GPIO('F', 4), GPIO('F', 5), GPIO('F', 6), GPIO('F', 7),
-    GPIO('K', 0), GPIO('K', 1), GPIO('K', 2), GPIO('K', 3),
-    GPIO('K', 4), GPIO('K', 5), GPIO('K', 6), GPIO('K', 7),
-#endif
-};
-
-// The atmega168/328 have two analog only pins
-#if CONFIG_MACH_atmega168 || CONFIG_MACH_atmega328
-DECL_ENUMERATION_RANGE("pin", "PE2", GPIO('E', 2), 2);
-#endif
-
-enum { ADMUX_DEFAULT = 0x40 };
-enum { ADC_ENABLE = (1<<ADPS0)|(1<<ADPS1)|(1<<ADPS2)|(1<<ADEN)|(1<<ADIF) };
-
-DECL_CONSTANT("ADC_MAX", 1023);
-
-struct gpio_adc
-gpio_adc_setup(uint8_t pin)
-{
-    // Find pin in adc_pins table
-    uint8_t chan;
-    for (chan=0; ; chan++) {
-        if (chan >= ARRAY_SIZE(adc_pins))
-            shutdown("Not a valid ADC pin");
-        if (READP(adc_pins[chan]) == pin)
-            break;
-    }
-
-    // Enable ADC
-    ADCSRA = ADC_ENABLE;
-
-    // Disable digital input for this pin
-#ifdef DIDR2
-    if (chan >= 8)
-        DIDR2 |= 1 << (chan & 0x07);
-    else
-#endif
-        DIDR0 |= 1 << chan;
-
-    return (struct gpio_adc){ chan };
-}
-
-enum { ADC_DUMMY=0xff };
-static uint8_t last_analog_read = ADC_DUMMY;
-
-// Try to sample a value. Returns zero if sample ready, otherwise
-// returns the number of clock ticks the caller should wait before
-// retrying this function.
-uint32_t
-gpio_adc_sample(struct gpio_adc g)
-{
-    if (ADCSRA & (1<<ADSC))
-        // Busy
-        goto need_delay;
-    if (last_analog_read == g.chan)
-        // Sample now ready
-        return 0;
-    if (last_analog_read != ADC_DUMMY)
-        // Sample on another channel in progress
-        goto need_delay;
-    last_analog_read = g.chan;
-
-    // Set the channel to sample
-#if defined(ADCSRB) && defined(MUX5)
-    // The MUX5 bit of ADCSRB selects whether we're reading from
-    // channels 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
-    ADCSRB = ((g.chan >> 3) & 0x01) << MUX5;
-#endif
-    ADMUX = ADMUX_DEFAULT | (g.chan & 0x07);
-
-    // Start the sample
-    ADCSRA = ADC_ENABLE | (1<<ADSC);
-
-    // Schedule next attempt after sample is likely to be complete
-need_delay:
-    return (13 + 1) * 128 + 200;
-}
-
-// Read a value; use only after gpio_adc_sample() returns zero
-uint16_t
-gpio_adc_read(struct gpio_adc g)
-{
-    last_analog_read = ADC_DUMMY;
-    return ADC;
-}
-
-// Cancel a sample that may have been started with gpio_adc_sample()
-void
-gpio_adc_cancel_sample(struct gpio_adc g)
-{
-    if (last_analog_read == g.chan)
-        last_analog_read = ADC_DUMMY;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/avr/gpio.c crealityShit/src/avr/gpio.c
--- klipperStock/src/avr/gpio.c	2024-01-14 23:02:00.153796745 -0600
+++ crealityShit/src/avr/gpio.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,126 +0,0 @@
-// GPIO functions on AVR.
-//
-// Copyright (C) 2016-2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_MACH_atmega644p
-#include "command.h" // shutdown
-#include "gpio.h" // gpio_out_write
-#include "internal.h" // GPIO2REGS
-#include "irq.h" // irq_save
-#include "pgm.h" // PROGMEM
-#include "sched.h" // sched_shutdown
-
-#ifdef PINA
-DECL_ENUMERATION_RANGE("pin", "PA0", GPIO('A', 0), 8);
-#endif
-DECL_ENUMERATION_RANGE("pin", "PB0", GPIO('B', 0), 8);
-DECL_ENUMERATION_RANGE("pin", "PC0", GPIO('C', 0), 8);
-DECL_ENUMERATION_RANGE("pin", "PD0", GPIO('D', 0), 8);
-#if CONFIG_MACH_atmega328p
-DECL_ENUMERATION_RANGE("pin", "PE0", GPIO('E', 0), 8);
-#endif
-#ifdef PINE
-DECL_ENUMERATION_RANGE("pin", "PE0", GPIO('E', 0), 8);
-DECL_ENUMERATION_RANGE("pin", "PF0", GPIO('F', 0), 8);
-#endif
-#ifdef PING
-DECL_ENUMERATION_RANGE("pin", "PG0", GPIO('G', 0), 8);
-DECL_ENUMERATION_RANGE("pin", "PH0", GPIO('H', 0), 8);
-DECL_ENUMERATION_RANGE("pin", "PJ0", GPIO('J', 0), 8);
-DECL_ENUMERATION_RANGE("pin", "PK0", GPIO('K', 0), 8);
-DECL_ENUMERATION_RANGE("pin", "PL0", GPIO('L', 0), 8);
-#endif
-
-volatile uint8_t * const digital_regs[] PROGMEM = {
-#ifdef PINA
-    &PINA,
-#else
-    NULL,
-#endif
-    &PINB, &PINC, &PIND,
-#if CONFIG_MACH_atmega328p
-    &_SFR_IO8(0x0C), // PINE on atmega328pb
-#endif
-#ifdef PINE
-    &PINE, &PINF,
-#endif
-#ifdef PING
-    &PING, &PINH, NULL, &PINJ, &PINK, &PINL
-#endif
-};
-
-struct gpio_out
-gpio_out_setup(uint8_t pin, uint8_t val)
-{
-    if (GPIO2PORT(pin) >= ARRAY_SIZE(digital_regs))
-        goto fail;
-    struct gpio_digital_regs *regs = GPIO2REGS(pin);
-    if (! regs)
-        goto fail;
-    struct gpio_out g = { .regs=regs, .bit=GPIO2BIT(pin) };
-    gpio_out_reset(g, val);
-    return g;
-fail:
-    shutdown("Not an output pin");
-}
-
-void
-gpio_out_reset(struct gpio_out g, uint8_t val)
-{
-    irqstatus_t flag = irq_save();
-    g.regs->out = val ? (g.regs->out | g.bit) : (g.regs->out & ~g.bit);
-    g.regs->mode |= g.bit;
-    irq_restore(flag);
-}
-
-void
-gpio_out_toggle_noirq(struct gpio_out g)
-{
-    g.regs->in = g.bit;
-}
-
-void
-gpio_out_toggle(struct gpio_out g)
-{
-    gpio_out_toggle_noirq(g);
-}
-
-void
-gpio_out_write(struct gpio_out g, uint8_t val)
-{
-    irqstatus_t flag = irq_save();
-    g.regs->out = val ? (g.regs->out | g.bit) : (g.regs->out & ~g.bit);
-    irq_restore(flag);
-}
-
-struct gpio_in
-gpio_in_setup(uint8_t pin, int8_t pull_up)
-{
-    if (GPIO2PORT(pin) >= ARRAY_SIZE(digital_regs) || pull_up < 0)
-        goto fail;
-    struct gpio_digital_regs *regs = GPIO2REGS(pin);
-    if (! regs)
-        goto fail;
-    struct gpio_in g = { .regs=regs, .bit=GPIO2BIT(pin) };
-    gpio_in_reset(g, pull_up);
-    return g;
-fail:
-    shutdown("Not a valid input pin");
-}
-
-void
-gpio_in_reset(struct gpio_in g, int8_t pull_up)
-{
-    irqstatus_t flag = irq_save();
-    g.regs->out = pull_up > 0 ? (g.regs->out | g.bit) : (g.regs->out & ~g.bit);
-    g.regs->mode &= ~g.bit;
-    irq_restore(flag);
-}
-
-uint8_t
-gpio_in_read(struct gpio_in g)
-{
-    return !!(g.regs->in & g.bit);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/avr/gpio.h crealityShit/src/avr/gpio.h
--- klipperStock/src/avr/gpio.h	2024-01-14 23:02:00.153796745 -0600
+++ crealityShit/src/avr/gpio.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,57 +0,0 @@
-#ifndef __AVR_GPIO_H
-#define __AVR_GPIO_H
-
-#include <stdint.h>
-
-struct gpio_out {
-    struct gpio_digital_regs *regs;
-    // gcc (pre v6) does better optimization when uint8_t are bitfields
-    uint8_t bit : 8;
-};
-struct gpio_out gpio_out_setup(uint8_t pin, uint8_t val);
-void gpio_out_reset(struct gpio_out g, uint8_t val);
-void gpio_out_toggle_noirq(struct gpio_out g);
-void gpio_out_toggle(struct gpio_out g);
-void gpio_out_write(struct gpio_out g, uint8_t val);
-
-struct gpio_in {
-    struct gpio_digital_regs *regs;
-    uint8_t bit;
-};
-struct gpio_in gpio_in_setup(uint8_t pin, int8_t pull_up);
-void gpio_in_reset(struct gpio_in g, int8_t pull_up);
-uint8_t gpio_in_read(struct gpio_in g);
-
-struct gpio_pwm {
-    void *reg;
-    uint8_t size8;
-};
-struct gpio_pwm gpio_pwm_setup(uint8_t pin, uint32_t cycle_time, uint8_t val);
-void gpio_pwm_write(struct gpio_pwm g, uint8_t val);
-
-struct gpio_adc {
-    uint8_t chan;
-};
-struct gpio_adc gpio_adc_setup(uint8_t pin);
-uint32_t gpio_adc_sample(struct gpio_adc g);
-uint16_t gpio_adc_read(struct gpio_adc g);
-void gpio_adc_cancel_sample(struct gpio_adc g);
-
-struct spi_config {
-    uint8_t spcr, spsr;
-};
-struct spi_config spi_setup(uint32_t bus, uint8_t mode, uint32_t rate);
-void spi_prepare(struct spi_config config);
-void spi_transfer(struct spi_config config, uint8_t receive_data
-                  , uint8_t len, uint8_t *data);
-
-struct i2c_config {
-    uint8_t addr;
-};
-
-struct i2c_config i2c_setup(uint32_t bus, uint32_t rate, uint8_t addr);
-void i2c_write(struct i2c_config config, uint8_t write_len, uint8_t *write);
-void i2c_read(struct i2c_config config, uint8_t reg_len, uint8_t *reg
-              , uint8_t read_len, uint8_t *read);
-
-#endif // gpio.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/avr/hard_pwm.c crealityShit/src/avr/hard_pwm.c
--- klipperStock/src/avr/hard_pwm.c	2024-01-14 23:02:00.153796745 -0600
+++ crealityShit/src/avr/hard_pwm.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,147 +0,0 @@
-// Hardware PWM pin support
-//
-// Copyright (C) 2016-2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_MACH_atmega644p
-#include "command.h" // shutdown
-#include "gpio.h" // gpio_pwm_write
-#include "internal.h" // GPIO2REGS
-#include "irq.h" // irq_save
-#include "pgm.h" // PROGMEM
-#include "sched.h" // sched_shutdown
-
-struct gpio_pwm_info {
-    uint8_t pin;
-    volatile void *ocr;
-    volatile uint8_t *rega, *regb;
-    uint8_t en_bit, flags;
-};
-
-enum { GP_8BIT=1, GP_AFMT=2 };
-
-static const struct gpio_pwm_info pwm_regs[] PROGMEM = {
-#if CONFIG_MACH_atmega168 || CONFIG_MACH_atmega328 || CONFIG_MACH_atmega328p
-    { GPIO('D', 6), &OCR0A, &TCCR0A, &TCCR0B, 1<<COM0A1, GP_8BIT },
-    { GPIO('D', 5), &OCR0B, &TCCR0A, &TCCR0B, 1<<COM0B1, GP_8BIT },
-    { GPIO('B', 1), &OCR1A, &TCCR1A, &TCCR1B, 1<<COM1A1, 0 },
-    { GPIO('B', 2), &OCR1B, &TCCR1A, &TCCR1B, 1<<COM1B1, 0 },
-    { GPIO('B', 3), &OCR2A, &TCCR2A, &TCCR2B, 1<<COM2A1, GP_8BIT|GP_AFMT },
-    { GPIO('D', 3), &OCR2B, &TCCR2A, &TCCR2B, 1<<COM2B1, GP_8BIT|GP_AFMT },
-#elif CONFIG_MACH_atmega644p || CONFIG_MACH_atmega1284p
-    { GPIO('B', 3), &OCR0A, &TCCR0A, &TCCR0B, 1<<COM0A1, GP_8BIT },
-    { GPIO('B', 4), &OCR0B, &TCCR0A, &TCCR0B, 1<<COM0B1, GP_8BIT },
-    { GPIO('D', 5), &OCR1A, &TCCR1A, &TCCR1B, 1<<COM1A1, 0 },
-    { GPIO('D', 4), &OCR1B, &TCCR1A, &TCCR1B, 1<<COM1B1, 0 },
-    { GPIO('D', 7), &OCR2A, &TCCR2A, &TCCR2B, 1<<COM2A1, GP_8BIT|GP_AFMT },
-    { GPIO('D', 6), &OCR2B, &TCCR2A, &TCCR2B, 1<<COM2B1, GP_8BIT|GP_AFMT },
-# ifdef OCR3A
-    { GPIO('B', 6), &OCR3A, &TCCR3A, &TCCR3B, 1<<COM3A1, 0 },
-    { GPIO('B', 7), &OCR3B, &TCCR3A, &TCCR3B, 1<<COM3B1, 0 },
-# endif
-#elif CONFIG_MACH_at90usb1286 || CONFIG_MACH_at90usb646 \
-      || CONFIG_MACH_atmega32u4
-    { GPIO('B', 7), &OCR0A, &TCCR0A, &TCCR0B, 1<<COM0A1, GP_8BIT },
-    { GPIO('D', 0), &OCR0B, &TCCR0A, &TCCR0B, 1<<COM0B1, GP_8BIT },
-    { GPIO('B', 5), &OCR1A, &TCCR1A, &TCCR1B, 1<<COM1A1, 0 },
-    { GPIO('B', 6), &OCR1B, &TCCR1A, &TCCR1B, 1<<COM1B1, 0 },
-    { GPIO('B', 7), &OCR1C, &TCCR1A, &TCCR1B, 1<<COM1C1, 0 },
-# ifdef OCR2A
-    { GPIO('B', 4), &OCR2A, &TCCR2A, &TCCR2B, 1<<COM2A1, GP_8BIT|GP_AFMT },
-    { GPIO('D', 1), &OCR2B, &TCCR2A, &TCCR2B, 1<<COM2B1, GP_8BIT|GP_AFMT },
-# endif
-    { GPIO('C', 6), &OCR3A, &TCCR3A, &TCCR3B, 1<<COM3A1, 0 },
-    { GPIO('C', 5), &OCR3B, &TCCR3A, &TCCR3B, 1<<COM3B1, 0 },
-    { GPIO('C', 4), &OCR3C, &TCCR3A, &TCCR3B, 1<<COM3C1, 0 },
-#elif CONFIG_MACH_atmega1280 || CONFIG_MACH_atmega2560
-    { GPIO('B', 7), &OCR0A, &TCCR0A, &TCCR0B, 1<<COM0A1, GP_8BIT },
-    { GPIO('G', 5), &OCR0B, &TCCR0A, &TCCR0B, 1<<COM0B1, GP_8BIT },
-    { GPIO('B', 5), &OCR1A, &TCCR1A, &TCCR1B, 1<<COM1A1, 0 },
-    { GPIO('B', 6), &OCR1B, &TCCR1A, &TCCR1B, 1<<COM1B1, 0 },
-    { GPIO('B', 7), &OCR1C, &TCCR1A, &TCCR1B, 1<<COM1C1, 0 },
-    { GPIO('B', 4), &OCR2A, &TCCR2A, &TCCR2B, 1<<COM2A1, GP_8BIT|GP_AFMT },
-    { GPIO('H', 6), &OCR2B, &TCCR2A, &TCCR2B, 1<<COM2B1, GP_8BIT|GP_AFMT },
-    { GPIO('E', 3), &OCR3A, &TCCR3A, &TCCR3B, 1<<COM3A1, 0 },
-    { GPIO('E', 4), &OCR3B, &TCCR3A, &TCCR3B, 1<<COM3B1, 0 },
-    { GPIO('E', 5), &OCR3C, &TCCR3A, &TCCR3B, 1<<COM3C1, 0 },
-    { GPIO('H', 3), &OCR4A, &TCCR4A, &TCCR4B, 1<<COM4A1, 0 },
-    { GPIO('H', 4), &OCR4B, &TCCR4A, &TCCR4B, 1<<COM4B1, 0 },
-    { GPIO('H', 5), &OCR4C, &TCCR4A, &TCCR4B, 1<<COM4C1, 0 },
-    { GPIO('L', 3), &OCR5A, &TCCR5A, &TCCR5B, 1<<COM5A1, 0 },
-    { GPIO('L', 4), &OCR5B, &TCCR5A, &TCCR5B, 1<<COM5B1, 0 },
-    { GPIO('L', 5), &OCR5C, &TCCR5A, &TCCR5B, 1<<COM5C1, 0 },
-#endif
-};
-
-DECL_CONSTANT("PWM_MAX", 255);
-
-struct gpio_pwm
-gpio_pwm_setup(uint8_t pin, uint32_t cycle_time, uint8_t val)
-{
-    // Find pin in pwm_regs table
-    const struct gpio_pwm_info *p = pwm_regs;
-    for (; ; p++) {
-        if (p >= &pwm_regs[ARRAY_SIZE(pwm_regs)])
-            shutdown("Not a valid PWM pin");
-        if (READP(p->pin) == pin)
-            break;
-    }
-
-    // Map cycle_time to pwm clock divisor
-    uint8_t flags = READP(p->flags), cs;
-    if (flags & GP_AFMT) {
-        switch (cycle_time) {
-        case                    0 ...      (1+8) * 510L / 2 - 1: cs = 1; break;
-        case     (1+8) * 510L / 2 ...     (8+32) * 510L / 2 - 1: cs = 2; break;
-        case    (8+32) * 510L / 2 ...    (32+64) * 510L / 2 - 1: cs = 3; break;
-        case   (32+64) * 510L / 2 ...   (64+128) * 510L / 2 - 1: cs = 4; break;
-        case  (64+128) * 510L / 2 ...  (128+256) * 510L / 2 - 1: cs = 5; break;
-        case (128+256) * 510L / 2 ... (256+1024) * 510L / 2 - 1: cs = 6; break;
-        default:                                                 cs = 7; break;
-        }
-    } else {
-        switch (cycle_time) {
-        case                    0 ...      (1+8) * 510L / 2 - 1: cs = 1; break;
-        case     (1+8) * 510L / 2 ...     (8+64) * 510L / 2 - 1: cs = 2; break;
-        case    (8+64) * 510L / 2 ...   (64+256) * 510L / 2 - 1: cs = 3; break;
-        case  (64+256) * 510L / 2 ... (256+1024) * 510L / 2 - 1: cs = 4; break;
-        default:                                                 cs = 5; break;
-        }
-    }
-    volatile uint8_t *rega = READP(p->rega), *regb = READP(p->regb);
-    uint8_t en_bit = READP(p->en_bit);
-    struct gpio_digital_regs *gpio_regs = GPIO2REGS(pin);
-    uint8_t gpio_bit = GPIO2BIT(pin);
-    struct gpio_pwm g = (struct gpio_pwm) {
-        (void*)READP(p->ocr), flags & GP_8BIT };
-    if (rega == &TCCR1A)
-        shutdown("Can not use timer1 for PWM; timer1 is used for timers");
-
-    // Setup PWM timer
-    irqstatus_t flag = irq_save();
-    uint8_t old_cs = *regb & 0x07;
-    if (old_cs && old_cs != cs)
-        shutdown("PWM already programmed at different speed");
-    *regb = cs;
-
-    // Set default value and enable output
-    gpio_pwm_write(g, val);
-    *rega |= (1<<WGM00) | en_bit;
-    gpio_regs->mode |= gpio_bit;
-    irq_restore(flag);
-
-    return g;
-}
-
-void
-gpio_pwm_write(struct gpio_pwm g, uint8_t val)
-{
-    if (g.size8) {
-        *(volatile uint8_t*)g.reg = val;
-    } else {
-        irqstatus_t flag = irq_save();
-        *(volatile uint16_t*)g.reg = val;
-        irq_restore(flag);
-    }
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/avr/i2c.c crealityShit/src/avr/i2c.c
--- klipperStock/src/avr/i2c.c	2024-01-14 23:02:00.153796745 -0600
+++ crealityShit/src/avr/i2c.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,127 +0,0 @@
-// I2C functions on AVR
-//
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <avr/io.h> // TWCR
-#include "autoconf.h" // CONFIG_CLOCK_FREQ
-#include "board/misc.h" // timer_is_before
-#include "command.h" // shutdown
-#include "gpio.h" // i2c_setup
-#include "internal.h" // GPIO
-#include "sched.h" // sched_shutdown
-
-DECL_ENUMERATION("i2c_bus", "twi", 0);
-
-#if CONFIG_MACH_atmega168 || CONFIG_MACH_atmega328 || CONFIG_MACH_atmega328p
-static const uint8_t SCL = GPIO('C', 5), SDA = GPIO('C', 4);
-DECL_CONSTANT_STR("BUS_PINS_twi", "PC5,PC4");
-#elif CONFIG_MACH_atmega644p || CONFIG_MACH_atmega1284p
-static const uint8_t SCL = GPIO('C', 0), SDA = GPIO('C', 1);
-DECL_CONSTANT_STR("BUS_PINS_twi", "PC0,PC1");
-#elif CONFIG_MACH_at90usb1286 || CONFIG_MACH_at90usb646 \
-      || CONFIG_MACH_atmega32u4 || CONFIG_MACH_atmega1280 \
-      || CONFIG_MACH_atmega2560
-static const uint8_t SCL = GPIO('D', 0), SDA = GPIO('D', 1);
-DECL_CONSTANT_STR("BUS_PINS_twi", "PD0,PD1");
-#endif
-
-static void
-i2c_init(void)
-{
-    if (TWCR & (1<<TWEN))
-        // Already setup
-        return;
-
-    // Setup output pins and enable pullups
-    gpio_out_setup(SDA, 1);
-    gpio_out_setup(SCL, 1);
-
-    // Set 100Khz frequency
-    TWSR = 0;
-    TWBR = ((CONFIG_CLOCK_FREQ / 100000) - 16) / 2;
-
-    // Enable interface
-    TWCR = (1<<TWEN);
-}
-
-struct i2c_config
-i2c_setup(uint32_t bus, uint32_t rate, uint8_t addr)
-{
-    if (bus)
-        shutdown("Unsupported i2c bus");
-    i2c_init();
-    return (struct i2c_config){ .addr=addr<<1 };
-}
-
-static void
-i2c_wait(uint32_t timeout)
-{
-    for (;;) {
-        if (TWCR & (1<<TWINT))
-            break;
-        if (!timer_is_before(timer_read_time(), timeout))
-            shutdown("i2c timeout");
-    }
-}
-
-static void
-i2c_start(uint32_t timeout)
-{
-    TWCR = (1<<TWEN) | (1<<TWINT) | (1<<TWSTA);
-    i2c_wait(timeout);
-    uint32_t status = TWSR;
-    if (status != 0x10 && status != 0x08)
-        shutdown("Failed to send i2c start");
-}
-
-static void
-i2c_send_byte(uint8_t b, uint32_t timeout)
-{
-    TWDR = b;
-    TWCR = (1<<TWEN) | (1<<TWINT);
-    i2c_wait(timeout);
-}
-
-static void
-i2c_receive_byte(uint8_t *read, uint32_t timeout, uint8_t send_ack)
-{
-    TWCR = (1<<TWEN) | (1<<TWINT) | ((send_ack?1:0)<<TWEA);
-    i2c_wait(timeout);
-    *read = TWDR;
-}
-
-static void
-i2c_stop(uint32_t timeout)
-{
-    TWCR = (1<<TWEN) | (1<<TWINT) | (1<<TWSTO);
-}
-
-void
-i2c_write(struct i2c_config config, uint8_t write_len, uint8_t *write)
-{
-    uint32_t timeout = timer_read_time() + timer_from_us(5000);
-
-    i2c_start(timeout);
-    i2c_send_byte(config.addr, timeout);
-    while (write_len--)
-        i2c_send_byte(*write++, timeout);
-    i2c_stop(timeout);
-}
-
-void
-i2c_read(struct i2c_config config, uint8_t reg_len, uint8_t *reg
-         , uint8_t read_len, uint8_t *read)
-{
-    uint32_t timeout = timer_read_time() + timer_from_us(5000);
-    i2c_start(timeout);
-    i2c_send_byte(config.addr, timeout);
-    while (reg_len--)
-        i2c_send_byte(*reg++, timeout);
-    i2c_start(timeout);
-    i2c_send_byte(config.addr | 0x1, timeout);
-    while (read_len--)
-        i2c_receive_byte(read++, timeout, read_len);
-    i2c_stop(timeout);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/avr/internal.h crealityShit/src/avr/internal.h
--- klipperStock/src/avr/internal.h	2024-01-14 23:02:00.157796793 -0600
+++ crealityShit/src/avr/internal.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,18 +0,0 @@
-#ifndef __AVR_INTERNAL_H
-#define __AVR_INTERNAL_H
-// Local definitions for avr code
-
-#define GPIO(PORT, NUM) (((PORT)-'A') * 8 + (NUM))
-#define GPIO2PORT(PIN) ((PIN) / 8)
-#define GPIO2BIT(PIN) (1<<((PIN) % 8))
-
-struct gpio_digital_regs {
-    // gcc (pre v6) does better optimization when uint8_t are bitfields
-    volatile uint8_t in : 8, mode : 8, out : 8;
-};
-extern volatile uint8_t * const digital_regs[];
-
-#define GPIO2REGS(pin)                                                  \
-    ((struct gpio_digital_regs*)READP(digital_regs[GPIO2PORT(pin)]))
-
-#endif // internal.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/avr/irq.h crealityShit/src/avr/irq.h
--- klipperStock/src/avr/irq.h	2024-01-14 23:02:00.157796793 -0600
+++ crealityShit/src/avr/irq.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,38 +0,0 @@
-#ifndef __AVR_IRQ_H
-#define __AVR_IRQ_H
-// Definitions for irq enable/disable on AVR
-
-#include <avr/interrupt.h> // cli
-#include "compiler.h" // barrier
-
-static inline void irq_disable(void) {
-    cli();
-    barrier();
-}
-
-static inline void irq_enable(void) {
-    barrier();
-    sei();
-}
-
-typedef uint8_t irqstatus_t;
-
-static inline irqstatus_t irq_save(void) {
-    uint8_t flag = SREG;
-    irq_disable();
-    return flag;
-}
-
-static inline void irq_restore(irqstatus_t flag) {
-    barrier();
-    SREG = flag;
-}
-
-static inline void irq_wait(void) {
-    asm("sei\n    nop\n    cli" : : : "memory");
-}
-
-static inline void irq_poll(void) {
-}
-
-#endif // irq.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/avr/Kconfig crealityShit/src/avr/Kconfig
--- klipperStock/src/avr/Kconfig	2024-01-14 23:02:00.153796745 -0600
+++ crealityShit/src/avr/Kconfig	1969-12-31 18:00:00.000000000 -0600
@@ -1,152 +0,0 @@
-# Kconfig settings for AVR processors
-
-if MACH_AVR
-
-config AVR_SELECT
-    bool
-    default y
-    select HAVE_GPIO
-    select HAVE_GPIO_ADC
-    select HAVE_GPIO_SPI
-    select HAVE_GPIO_I2C
-    select HAVE_GPIO_HARD_PWM
-    select HAVE_GPIO_BITBANGING if !MACH_atmega168
-    select HAVE_STRICT_TIMING
-
-config BOARD_DIRECTORY
-    string
-    default "avr"
-
-choice
-    prompt "Processor model"
-    config MACH_atmega2560
-        bool "atmega2560"
-    config MACH_atmega1280
-        bool "atmega1280"
-    config MACH_at90usb1286
-        bool "at90usb1286"
-    config MACH_at90usb646
-        bool "at90usb646"
-    config MACH_atmega32u4
-        bool "atmega32u4"
-    config MACH_atmega1284p
-        bool "atmega1284p"
-    config MACH_atmega644p
-        bool "atmega644p"
-    config MACH_atmega328p
-        bool "atmega328p"
-    config MACH_atmega328
-        bool "atmega328"
-    config MACH_atmega168
-        bool "atmega168"
-endchoice
-
-config MCU
-    string
-    default "atmega168" if MACH_atmega168
-    default "atmega328" if MACH_atmega328
-    default "atmega328p" if MACH_atmega328p
-    default "atmega1284p" if MACH_atmega1284p
-    default "atmega644p" if MACH_atmega644p
-    default "at90usb1286" if MACH_at90usb1286
-    default "at90usb646" if MACH_at90usb646
-    default "atmega32u4" if MACH_atmega32u4
-    default "atmega1280" if MACH_atmega1280
-    default "atmega2560" if MACH_atmega2560
-
-config AVRDUDE_PROTOCOL
-    string
-    default "wiring" if MACH_atmega2560
-    default "avr109" if MACH_at90usb1286 || MACH_at90usb646 || MACH_atmega32u4
-    default "arduino"
-
-choice
-    prompt "Processor speed" if LOW_LEVEL_OPTIONS
-    config AVR_FREQ_16000000
-        bool "16Mhz"
-    config AVR_FREQ_20000000
-        bool "20Mhz"
-        depends on MACH_atmega168 || MACH_atmega328 || MACH_atmega328p || MACH_atmega644p || MACH_atmega1284p
-    config AVR_FREQ_8000000
-        bool "8Mhz"
-endchoice
-
-config CLOCK_FREQ
-    int
-    default 8000000 if AVR_FREQ_8000000
-    default 20000000 if AVR_FREQ_20000000
-    default 16000000
-
-config CLEAR_PRESCALER
-    bool "Manually clear the CPU prescaler field at startup" if LOW_LEVEL_OPTIONS
-    depends on MACH_at90usb1286 || MACH_at90usb646 || MACH_atmega32u4
-    default y
-    help
-         Some AVR chips ship with a "clock prescaler" that causes the
-         chip to run at 1/8th speed. Enable this setting to clear the
-         prescaler field at startup which will cause the chip to run
-         without a clock divisor.
-
-config AVR_CLKPR
-    int
-    default 0 if CLEAR_PRESCALER
-    default -1
-
-config AVR_STACK_SIZE
-    int
-    default 256
-
-config AVR_WATCHDOG
-    bool
-    default y
-
-config USBSERIAL
-    depends on (MACH_at90usb1286 || MACH_at90usb646 || MACH_atmega32u4) && !AVR_SERIAL_UART1
-    bool
-    default y
-config SERIAL
-    depends on !USBSERIAL
-    bool
-    default y
-choice
-    prompt "Communication interface" if LOW_LEVEL_OPTIONS && (MACH_atmega2560 || MACH_atmega1280 || MACH_atmega644p || MACH_atmega1284p || MACH_at90usb1286 || MACH_at90usb646 || MACH_atmega32u4)
-    config AVR_USB
-        bool "USB" if MACH_at90usb1286 || MACH_at90usb646 || MACH_atmega32u4
-        select USBSERIAL
-    config AVR_SERIAL_UART0
-        bool "UART0" if !(MACH_at90usb1286 || MACH_at90usb646 || MACH_atmega32u4)
-        select SERIAL
-    config AVR_SERIAL_UART1
-        bool "UART1"
-        select SERIAL
-    config AVR_SERIAL_UART2
-        bool "UART2" if MACH_atmega2560 || MACH_atmega1280
-        select SERIAL
-    config AVR_SERIAL_UART3
-        bool "UART3" if MACH_atmega2560 || MACH_atmega1280
-        select SERIAL
-endchoice
-config SERIAL_BAUD_U2X
-    depends on SERIAL && !SIMULAVR
-    bool
-    default y
-
-config SERIAL_PORT
-    int
-    default 3 if AVR_SERIAL_UART3
-    default 2 if AVR_SERIAL_UART2
-    default 1 if AVR_SERIAL_UART1
-    default 0
-
-config SIMULAVR
-    depends on MACH_atmega168 || MACH_atmega328 || MACH_atmega328p || MACH_atmega644p || MACH_atmega1284p
-    bool "Compile for simulavr software emulation" if LOW_LEVEL_OPTIONS
-    default n
-    help
-         Compile the code to run on simulavr software emulation
-         instead of for real hardware. This disables support for "U2X
-         baud" mode which is not supported on simulavr.
-
-         If unsure, select "N".
-
-endif
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/avr/main.c crealityShit/src/avr/main.c
--- klipperStock/src/avr/main.c	2024-01-14 23:02:00.157796793 -0600
+++ crealityShit/src/avr/main.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,72 +0,0 @@
-// Main starting point for AVR boards.
-//
-// Copyright (C) 2016,2017  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <avr/io.h> // AVR_STACK_POINTER_REG
-#include <util/crc16.h> // _crc_ccitt_update
-#include "autoconf.h" // CONFIG_MCU
-#include "board/misc.h" // dynmem_start
-#include "command.h" // DECL_CONSTANT
-#include "irq.h" // irq_enable
-#include "sched.h" // sched_main
-
-DECL_CONSTANT_STR("MCU", CONFIG_MCU);
-
-
-/****************************************************************
- * Dynamic memory
- ****************************************************************/
-
-// Return the start of memory available for dynamic allocations
-void *
-dynmem_start(void)
-{
-    extern char _end;
-    return &_end;
-}
-
-// Return the end of memory available for dynamic allocations
-void *
-dynmem_end(void)
-{
-    return (void*)ALIGN(AVR_STACK_POINTER_REG, 256) - CONFIG_AVR_STACK_SIZE;
-}
-
-
-/****************************************************************
- * Misc functions
- ****************************************************************/
-
-// Initialize the clock prescaler (if necessary)
-void
-prescaler_init(void)
-{
-    if (CONFIG_AVR_CLKPR != -1 && (uint8_t)CONFIG_AVR_CLKPR != CLKPR) {
-        irqstatus_t flag = irq_save();
-        CLKPR = 0x80;
-        CLKPR = CONFIG_AVR_CLKPR;
-        irq_restore(flag);
-    }
-}
-DECL_INIT(prescaler_init);
-
-// Optimized crc16_ccitt for the avr processor
-uint16_t
-crc16_ccitt(uint8_t *buf, uint_fast8_t len)
-{
-    uint16_t crc = 0xFFFF;
-    while (len--)
-        crc = _crc_ccitt_update(crc, *buf++);
-    return crc;
-}
-
-// Main entry point for avr code.
-int
-main(void)
-{
-    irq_enable();
-    sched_main();
-    return 0;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/avr/Makefile crealityShit/src/avr/Makefile
--- klipperStock/src/avr/Makefile	2024-01-14 23:02:00.153796745 -0600
+++ crealityShit/src/avr/Makefile	1969-12-31 18:00:00.000000000 -0600
@@ -1,34 +0,0 @@
-# Additional avr build rules
-
-# Use the avr toolchain
-CROSS_PREFIX=avr-
-
-dirs-y += src/avr src/generic
-
-CFLAGS += -mmcu=$(CONFIG_MCU)
-
-# Add avr source files
-src-y += avr/main.c avr/timer.c
-src-$(CONFIG_HAVE_GPIO) += avr/gpio.c
-src-$(CONFIG_HAVE_GPIO_ADC) += avr/adc.c
-src-$(CONFIG_HAVE_GPIO_SPI) += avr/spi.c
-src-$(CONFIG_HAVE_GPIO_I2C) += avr/i2c.c
-src-$(CONFIG_HAVE_GPIO_HARD_PWM) += avr/hard_pwm.c
-src-$(CONFIG_AVR_WATCHDOG) += avr/watchdog.c
-src-$(CONFIG_USBSERIAL) += avr/usbserial.c generic/usb_cdc.c
-src-$(CONFIG_SERIAL) += avr/serial.c generic/serial_irq.c
-
-# Suppress broken "misspelled signal handler" warnings on gcc 4.8.1
-CFLAGS_klipper.elf := $(CFLAGS_klipper.elf) $(if $(filter 4.8.1, $(shell $(CC) -dumpversion)), -w)
-
-# Build the additional hex output file
-target-y += $(OUT)klipper.elf.hex
-
-$(OUT)klipper.elf.hex: $(OUT)klipper.elf
-	@echo "  Creating hex file $@"
-	$(Q)$(OBJCOPY) -j .text -j .data -O ihex $< $@
-
-flash: $(OUT)klipper.elf.hex
-	@echo "  Flashing $< to $(FLASH_DEVICE) via avrdude"
-	$(Q)if [ -z $(FLASH_DEVICE) ]; then echo "Please specify FLASH_DEVICE"; exit 1; fi
-	$(Q)avrdude -p$(CONFIG_MCU) -c$(CONFIG_AVRDUDE_PROTOCOL) -P"$(FLASH_DEVICE)" -D -U"flash:w:$(<):i"
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/avr/pgm.h crealityShit/src/avr/pgm.h
--- klipperStock/src/avr/pgm.h	2024-01-14 23:02:00.157796793 -0600
+++ crealityShit/src/avr/pgm.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,27 +0,0 @@
-#ifndef __AVR_PGM_H
-#define __AVR_PGM_H
-// This header provides the avr/pgmspace.h definitions for "PROGMEM"
-// on AVR platforms.
-
-#include <avr/pgmspace.h>
-
-#define NEED_PROGMEM 1
-
-#define READP(VAR) ({                                                   \
-    _Pragma("GCC diagnostic push");                                     \
-    _Pragma("GCC diagnostic ignored \"-Wint-to-pointer-cast\"");        \
-    typeof(VAR) __val =                                                 \
-        __builtin_choose_expr(sizeof(VAR) == 1,                         \
-            (typeof(VAR))pgm_read_byte(&(VAR)),                         \
-        __builtin_choose_expr(sizeof(VAR) == 2,                         \
-            (typeof(VAR))pgm_read_word(&(VAR)),                         \
-        __builtin_choose_expr(sizeof(VAR) == 4,                         \
-            (typeof(VAR))pgm_read_dword(&(VAR)),                        \
-        __force_link_error__unknown_type)));                            \
-    _Pragma("GCC diagnostic pop");                                      \
-    __val;                                                              \
-    })
-
-extern void __force_link_error__unknown_type(void);
-
-#endif // pgm.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/avr/serial.c crealityShit/src/avr/serial.c
--- klipperStock/src/avr/serial.c	2024-01-14 23:02:00.153796745 -0600
+++ crealityShit/src/avr/serial.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,88 +0,0 @@
-// AVR serial port code.
-//
-// Copyright (C) 2016-2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <avr/interrupt.h> // USART_RX_vect
-#include "autoconf.h" // CONFIG_SERIAL_BAUD
-#include "board/serial_irq.h" // serial_rx_byte
-#include "command.h" // DECL_CONSTANT_STR
-#include "sched.h" // DECL_INIT
-
-// Reserve serial pins
-#if CONFIG_SERIAL_PORT == 0
- #if CONFIG_MACH_atmega1280 || CONFIG_MACH_atmega2560
-DECL_CONSTANT_STR("RESERVE_PINS_serial", "PE0,PE1");
- #else
-DECL_CONSTANT_STR("RESERVE_PINS_serial", "PD0,PD1");
- #endif
-#elif CONFIG_SERIAL_PORT == 1
-DECL_CONSTANT_STR("RESERVE_PINS_serial", "PD2,PD3");
-#elif CONFIG_SERIAL_PORT == 2
-DECL_CONSTANT_STR("RESERVE_PINS_serial", "PH0,PH1");
-#else
-DECL_CONSTANT_STR("RESERVE_PINS_serial", "PJ0,PJ1");
-#endif
-
-// Helper macros for defining serial port aliases
-#define AVR_SERIAL_REG1(prefix, id, suffix) prefix ## id ## suffix
-#define AVR_SERIAL_REG(prefix, id, suffix) AVR_SERIAL_REG1(prefix, id, suffix)
-
-// Serial port register aliases
-#define UCSRxA AVR_SERIAL_REG(UCSR, CONFIG_SERIAL_PORT, A)
-#define UCSRxB AVR_SERIAL_REG(UCSR, CONFIG_SERIAL_PORT, B)
-#define UCSRxC AVR_SERIAL_REG(UCSR, CONFIG_SERIAL_PORT, C)
-#define UBRRx AVR_SERIAL_REG(UBRR, CONFIG_SERIAL_PORT,)
-#define UDRx AVR_SERIAL_REG(UDR, CONFIG_SERIAL_PORT,)
-#define UCSZx1 AVR_SERIAL_REG(UCSZ, CONFIG_SERIAL_PORT, 1)
-#define UCSZx0 AVR_SERIAL_REG(UCSZ, CONFIG_SERIAL_PORT, 0)
-#define U2Xx AVR_SERIAL_REG(U2X, CONFIG_SERIAL_PORT,)
-#define RXENx AVR_SERIAL_REG(RXEN, CONFIG_SERIAL_PORT,)
-#define TXENx AVR_SERIAL_REG(TXEN, CONFIG_SERIAL_PORT,)
-#define RXCIEx AVR_SERIAL_REG(RXCIE, CONFIG_SERIAL_PORT,)
-#define UDRIEx AVR_SERIAL_REG(UDRIE, CONFIG_SERIAL_PORT,)
-
-#if defined(USART_RX_vect)
-// The atmega168 / atmega328 doesn't have an ID in the irq names
-#define USARTx_RX_vect USART_RX_vect
-#define USARTx_UDRE_vect USART_UDRE_vect
-#else
-#define USARTx_RX_vect AVR_SERIAL_REG(USART, CONFIG_SERIAL_PORT, _RX_vect)
-#define USARTx_UDRE_vect AVR_SERIAL_REG(USART, CONFIG_SERIAL_PORT, _UDRE_vect)
-#endif
-
-void
-serial_init(void)
-{
-    UCSRxA = CONFIG_SERIAL_BAUD_U2X ? (1<<U2Xx) : 0;
-    uint32_t cm = CONFIG_SERIAL_BAUD_U2X ? 8 : 16;
-    UBRRx = DIV_ROUND_CLOSEST(CONFIG_CLOCK_FREQ, cm * CONFIG_SERIAL_BAUD) - 1UL;
-    UCSRxC = (1<<UCSZx1) | (1<<UCSZx0);
-    UCSRxB = (1<<RXENx) | (1<<TXENx) | (1<<RXCIEx) | (1<<UDRIEx);
-}
-DECL_INIT(serial_init);
-
-// Rx interrupt - data available to be read.
-ISR(USARTx_RX_vect)
-{
-    serial_rx_byte(UDRx);
-}
-
-// Tx interrupt - data can be written to serial.
-ISR(USARTx_UDRE_vect)
-{
-    uint8_t data;
-    int ret = serial_get_tx_byte(&data);
-    if (ret)
-        UCSRxB &= ~(1<<UDRIEx);
-    else
-        UDRx = data;
-}
-
-// Enable tx interrupts
-void
-serial_enable_tx_irq(void)
-{
-    UCSRxB |= 1<<UDRIEx;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/avr/spi.c crealityShit/src/avr/spi.c
--- klipperStock/src/avr/spi.c	2024-01-14 23:02:00.153796745 -0600
+++ crealityShit/src/avr/spi.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,106 +0,0 @@
-// Serial Peripheral Interface (SPI) support
-//
-// Copyright (C) 2016-2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_MACH_atmega644p
-#include "command.h" // shutdown
-#include "gpio.h" // spi_setup
-#include "internal.h" // GPIO
-#include "pgm.h" // READP
-#include "sched.h" // sched_shutdown
-
-DECL_ENUMERATION("spi_bus", "spi", 0);
-
-#if CONFIG_MACH_atmega168 || CONFIG_MACH_atmega328 || CONFIG_MACH_atmega328p
-static const uint8_t MISO = GPIO('B', 4), MOSI = GPIO('B', 3);
-static const uint8_t SCK = GPIO('B', 5), SS = GPIO('B', 2);
-DECL_CONSTANT_STR("BUS_PINS_spi", "PB4,PB3,PB5");
-#elif CONFIG_MACH_atmega644p || CONFIG_MACH_atmega1284p
-static const uint8_t MISO = GPIO('B', 6), MOSI = GPIO('B', 5);
-static const uint8_t SCK = GPIO('B', 7), SS = GPIO('B', 4);
-DECL_CONSTANT_STR("BUS_PINS_spi", "PB6,PB5,PB7");
-#elif CONFIG_MACH_at90usb1286 || CONFIG_MACH_at90usb646 \
-      || CONFIG_MACH_atmega32u4 || CONFIG_MACH_atmega1280 \
-      || CONFIG_MACH_atmega2560
-static const uint8_t MISO = GPIO('B', 3), MOSI = GPIO('B', 2);
-static const uint8_t SCK = GPIO('B', 1), SS = GPIO('B', 0);
-DECL_CONSTANT_STR("BUS_PINS_spi", "PB3,PB2,PB1");
-#endif
-
-static void
-spi_init(void)
-{
-    if (!(GPIO2REGS(SS)->mode & GPIO2BIT(SS)))
-        // The SS pin must be an output pin (but is otherwise unused)
-        gpio_out_setup(SS, 0);
-    gpio_out_setup(SCK, 0);
-    gpio_out_setup(MOSI, 0);
-    gpio_in_setup(MISO, 0);
-
-    SPCR = (1<<MSTR) | (1<<SPE);
-    SPSR = 0;
-}
-
-struct spi_config
-spi_setup(uint32_t bus, uint8_t mode, uint32_t rate)
-{
-    if (bus)
-        shutdown("Invalid spi_setup parameters");
-
-    // Make sure the SPI interface is enabled
-    spi_init();
-
-    // Setup rate
-    struct spi_config config = {0, 0};
-    if (rate >= (CONFIG_CLOCK_FREQ / 2)) {
-        config.spsr = (1<<SPI2X);
-    } else if (rate >= (CONFIG_CLOCK_FREQ / 4)) {
-        config.spcr = 0;
-    } else if (rate >= (CONFIG_CLOCK_FREQ / 8)) {
-        config.spcr = 1;
-        config.spsr = (1<<SPI2X);
-    } else if (rate >= (CONFIG_CLOCK_FREQ / 16)) {
-        config.spcr = 1;
-    } else if (rate >= (CONFIG_CLOCK_FREQ / 32)) {
-        config.spcr = 2;
-        config.spsr = (1<<SPI2X);
-    } else if (rate >= (CONFIG_CLOCK_FREQ / 64)) {
-        config.spcr = 2;
-    } else {
-        config.spcr = 3;
-    }
-
-    // Setup mode
-    config.spcr |= (1<<SPE) | (1<<MSTR) | (mode << CPHA);
-
-    return config;
-}
-
-void
-spi_prepare(struct spi_config config)
-{
-    SPCR = config.spcr;
-    SPSR = config.spsr;
-}
-
-void
-spi_transfer(struct spi_config config, uint8_t receive_data
-             , uint8_t len, uint8_t *data)
-{
-    if (receive_data) {
-        while (len--) {
-            SPDR = *data;
-            while (!(SPSR & (1<<SPIF)))
-                ;
-            *data++ = SPDR;
-        }
-    } else {
-        while (len--) {
-            SPDR = *data++;
-            while (!(SPSR & (1<<SPIF)))
-                ;
-        }
-    }
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/avr/timer.c crealityShit/src/avr/timer.c
--- klipperStock/src/avr/timer.c	2024-01-14 23:02:00.153796745 -0600
+++ crealityShit/src/avr/timer.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,212 +0,0 @@
-// AVR timer interrupt scheduling code.
-//
-// Copyright (C) 2016,2017  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <avr/interrupt.h> // TCNT1
-#include "autoconf.h" // CONFIG_AVR_CLKPR
-#include "board/misc.h" // timer_from_us
-#include "command.h" // shutdown
-#include "irq.h" // irq_save
-#include "sched.h" // sched_timer_dispatch
-
-
-/****************************************************************
- * Low level timer code
- ****************************************************************/
-
-DECL_CONSTANT("CLOCK_FREQ", CONFIG_CLOCK_FREQ);
-
-// Return the number of clock ticks for a given number of microseconds
-uint32_t
-timer_from_us(uint32_t us)
-{
-    return us * (CONFIG_CLOCK_FREQ / 1000000);
-}
-
-union u32_u {
-    struct { uint8_t b0, b1, b2, b3; };
-    struct { uint16_t lo, hi; };
-    uint32_t val;
-};
-
-// Return true if time1 is before time2.  Always use this function to
-// compare times as regular C comparisons can fail if the counter
-// rolls over.
-uint8_t __always_inline
-timer_is_before(uint32_t time1, uint32_t time2)
-{
-    // This asm is equivalent to:
-    //     return (int32_t)(time1 - time2) < 0;
-    // But gcc doesn't do a good job with the above, so it's hand coded.
-    union u32_u utime1 = { .val = time1 };
-    uint8_t f = utime1.b3;
-    asm("    cp  %A1, %A2\n"
-        "    cpc %B1, %B2\n"
-        "    cpc %C1, %C2\n"
-        "    sbc %0,  %D2"
-        : "+r"(f) : "r"(time1), "r"(time2));
-    return (int8_t)f < 0;
-}
-
-static inline uint16_t
-timer_get(void)
-{
-    return TCNT1;
-}
-
-static inline void
-timer_set(uint16_t next)
-{
-    OCR1A = next;
-}
-
-static inline void
-timer_repeat_set(uint16_t next)
-{
-    // Timer1B is used to limit the number of timers run from a timer1A irq
-    OCR1B = next;
-    // This is "TIFR1 = 1<<OCF1B" - gcc handles that poorly, so it's hand coded
-    uint8_t dummy;
-    asm volatile("ldi %0, %2\n    out %1, %0"
-                 : "=d"(dummy) : "i"(&TIFR1 - 0x20), "i"(1<<OCF1B));
-}
-
-// Activate timer dispatch as soon as possible
-void
-timer_kick(void)
-{
-    timer_set(timer_get() + 50);
-    TIFR1 = 1<<OCF1A;
-}
-
-static struct timer wrap_timer;
-
-void
-timer_reset(void)
-{
-    sched_add_timer(&wrap_timer);
-}
-DECL_SHUTDOWN(timer_reset);
-
-void
-timer_init(void)
-{
-    irqstatus_t flag = irq_save();
-    // no outputs
-    TCCR1A = 0;
-    // Normal Mode
-    TCCR1B = 1<<CS10;
-    // Setup for first irq
-    TCNT1 = 0;
-    timer_kick();
-    timer_repeat_set(timer_get() + 50);
-    timer_reset();
-    TIFR1 = 1<<TOV1;
-    // enable interrupt
-    TIMSK1 = 1<<OCIE1A;
-    irq_restore(flag);
-}
-DECL_INIT(timer_init);
-
-
-/****************************************************************
- * 32bit timer wrappers
- ****************************************************************/
-
-static uint16_t timer_high;
-
-// Return the current time (in absolute clock ticks).
-uint32_t
-timer_read_time(void)
-{
-    irqstatus_t flag = irq_save();
-    union u32_u calc = { .val = timer_get() };
-    calc.hi = timer_high;
-    if (unlikely(TIFR1 & (1<<TOV1))) {
-        irq_restore(flag);
-        if (calc.b1 < 0xff)
-            calc.hi++;
-        return calc.val;
-    }
-    irq_restore(flag);
-    return calc.val;
-}
-
-// Timer that runs every ~2ms - allows 16bit comparison optimizations
-static uint_fast8_t
-timer_event(struct timer *t)
-{
-    union u32_u *nextwake = (void*)&wrap_timer.waketime;
-    if (TIFR1 & (1<<TOV1)) {
-        // Hardware timer has overflowed - update overflow counter
-        TIFR1 = 1<<TOV1;
-        timer_high++;
-        *nextwake = (union u32_u){ .hi = timer_high, .lo = 0x8000 };
-    } else {
-        *nextwake = (union u32_u){ .hi = timer_high + 1, .lo = 0x0000 };
-    }
-    return SF_RESCHEDULE;
-}
-static struct timer wrap_timer = {
-    .func = timer_event,
-    .waketime = 0x8000,
-};
-
-#define TIMER_IDLE_REPEAT_TICKS 8000
-#define TIMER_REPEAT_TICKS 3000
-
-#define TIMER_MIN_ENTRY_TICKS 44
-#define TIMER_MIN_EXIT_TICKS 47
-#define TIMER_MIN_TRY_TICKS (TIMER_MIN_ENTRY_TICKS + TIMER_MIN_EXIT_TICKS)
-#define TIMER_DEFER_REPEAT_TICKS 256
-
-// Hardware timer IRQ handler - dispatch software timers
-ISR(TIMER1_COMPA_vect)
-{
-    uint16_t next;
-    for (;;) {
-        // Run the next software timer
-        next = sched_timer_dispatch();
-
-        for (;;) {
-            int16_t diff = timer_get() - next;
-            if (likely(diff >= 0)) {
-                // Another timer is pending - briefly allow irqs and then run it
-                irq_enable();
-                if (unlikely(TIFR1 & (1<<OCF1B)))
-                    goto check_defer;
-                irq_disable();
-                break;
-            }
-
-            if (likely(diff <= -TIMER_MIN_TRY_TICKS))
-                // Schedule next timer normally
-                goto done;
-
-            irq_enable();
-            if (unlikely(TIFR1 & (1<<OCF1B)))
-                goto check_defer;
-            irq_disable();
-            continue;
-
-        check_defer:
-            // Check if there are too many repeat timers
-            irq_disable();
-            uint16_t now = timer_get();
-            if ((int16_t)(next - now) < (int16_t)(-timer_from_us(1000)))
-                try_shutdown("Rescheduled timer in the past");
-            if (sched_tasks_busy()) {
-                timer_repeat_set(now + TIMER_REPEAT_TICKS);
-                next = now + TIMER_DEFER_REPEAT_TICKS;
-                goto done;
-            }
-            timer_repeat_set(now + TIMER_IDLE_REPEAT_TICKS);
-            timer_set(now);
-        }
-    }
-
-done:
-    timer_set(next);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/avr/usbserial.c crealityShit/src/avr/usbserial.c
--- klipperStock/src/avr/usbserial.c	2024-01-14 23:02:00.157796793 -0600
+++ crealityShit/src/avr/usbserial.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,261 +0,0 @@
-// Hardware interface to USB on AVR at90usb
-//
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <avr/interrupt.h> // USB_COM_vect
-#include <string.h> // NULL
-#include "autoconf.h" // CONFIG_MACH_at90usb1286
-#include "board/misc.h" // bootloader_request
-#include "board/usb_cdc.h" // usb_notify_ep0
-#include "board/usb_cdc_ep.h" // USB_CDC_EP_BULK_IN
-#include "pgm.h" // READP
-#include "sched.h" // DECL_INIT
-
-// EPCFG0X definitions
-#define EP_TYPE_CONTROL      0x00
-#define EP_TYPE_BULK_IN      0x81
-#define EP_TYPE_BULK_OUT     0x80
-#define EP_TYPE_INTERRUPT_IN 0xC1
-
-// EPCFG1X definitions
-#define EP_SINGLE_BUFFER 0x02
-#define EP_DOUBLE_BUFFER 0x06
-#define EP_SIZE(s) ((s)==64 ? 0x30 : ((s)==32 ? 0x20 : ((s)==16 ? 0x10 : 0x00)))
-
-static void
-usb_write_packet(const uint8_t *data, uint8_t len)
-{
-    while (len--)
-        UEDATX = *data++;
-}
-
-static void
-usb_write_packet_progmem(const uint8_t *data, uint8_t len)
-{
-    while (len--)
-        UEDATX = READP(*data++);
-}
-
-static void
-usb_read_packet(uint8_t *data, uint8_t len)
-{
-    while (len--)
-        *data++ = UEDATX;
-}
-
-int_fast8_t
-usb_read_bulk_out(void *data, uint_fast8_t max_len)
-{
-    UENUM = USB_CDC_EP_BULK_OUT;
-    if (!(UEINTX & (1<<RXOUTI))) {
-        // No data ready
-        UEIENX = 1<<RXOUTE;
-        return -1;
-    }
-    uint8_t len = UEBCLX;
-    usb_read_packet(data, len);
-    UEINTX = (uint8_t)~((1<<FIFOCON) | (1<<RXOUTI));
-    return len;
-}
-
-int_fast8_t
-usb_send_bulk_in(void *data, uint_fast8_t len)
-{
-    UENUM = USB_CDC_EP_BULK_IN;
-    if (!(UEINTX & (1<<TXINI))) {
-        // Buffer full
-        UEIENX = 1<<TXINE;
-        return -1;
-    }
-    usb_write_packet(data, len);
-    UEINTX = (uint8_t)~((1<<FIFOCON) | (1<<TXINI) | (1<<RXOUTI));
-    return len;
-}
-
-int_fast8_t
-usb_read_ep0(void *data, uint_fast8_t max_len)
-{
-    UENUM = 0;
-    uint8_t ueintx = UEINTX;
-    if (ueintx & (1<<RXSTPI))
-        return -2;
-    if (!(ueintx & (1<<RXOUTI))) {
-        // Not ready to receive data
-        UEIENX = (1<<RXSTPE) | (1<<RXOUTE);
-        return -1;
-    }
-    usb_read_packet(data, max_len);
-    if (UEINTX & (1<<RXSTPI))
-        return -2;
-    UEINTX = ~(1<<RXOUTI);
-    return max_len;
-}
-
-int_fast8_t
-usb_read_ep0_setup(void *data, uint_fast8_t max_len)
-{
-    UENUM = 0;
-    uint8_t ueintx = UEINTX;
-    if (!(ueintx & ((1<<RXSTPI)))) {
-        // No data ready to read
-        UEIENX = 1<<RXSTPE;
-        return -1;
-    }
-    usb_read_packet(data, max_len);
-    UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI));
-    return max_len;
-}
-
-static int8_t
-_usb_send_ep0(const void *data, uint8_t len, uint8_t progmem)
-{
-    UENUM = 0;
-    uint8_t ueintx = UEINTX;
-    if (ueintx & ((1<<RXSTPI) | (1<<RXOUTI)))
-        return -2;
-    if (!(ueintx & (1<<TXINI))) {
-        // Not ready to send
-        UEIENX = (1<<RXSTPE) | (1<<RXOUTE) | (1<<TXINE);
-        return -1;
-    }
-    if (progmem)
-        usb_write_packet_progmem(data, len);
-    else
-        usb_write_packet(data, len);
-    UEINTX = ~(1<<TXINI);
-    return len;
-}
-
-int_fast8_t
-usb_send_ep0(const void *data, uint_fast8_t len)
-{
-    return _usb_send_ep0(data, len, 0);
-}
-
-int_fast8_t
-usb_send_ep0_progmem(const void *data, uint_fast8_t len)
-{
-    return _usb_send_ep0(data, len, 1);
-}
-
-void
-usb_stall_ep0(void)
-{
-    UENUM = 0;
-    UECONX = (1<<STALLRQ) | (1<<EPEN);
-    UEIENX = 1<<RXSTPE;
-}
-
-static uint8_t set_address;
-
-void
-usb_set_address(uint_fast8_t addr)
-{
-    set_address = addr | (1<<ADDEN);
-    _usb_send_ep0(NULL, 0, 0);
-    UEIENX = (1<<RXSTPE) | (1<<TXINE);
-}
-
-void
-usb_set_configure(void)
-{
-    UENUM = USB_CDC_EP_ACM;
-    UECONX = 1<<EPEN;
-    UECFG0X = EP_TYPE_INTERRUPT_IN;
-    UECFG1X = EP_SIZE(USB_CDC_EP_ACM_SIZE) | EP_SINGLE_BUFFER;
-
-    UENUM = USB_CDC_EP_BULK_OUT;
-    UECONX = 1<<EPEN;
-    UECFG0X = EP_TYPE_BULK_OUT;
-    UECFG1X = EP_SIZE(USB_CDC_EP_BULK_OUT_SIZE) | EP_DOUBLE_BUFFER;
-    UEIENX = 1<<RXOUTE;
-
-    UENUM = USB_CDC_EP_BULK_IN;
-    UECONX = 1<<EPEN;
-    UECFG0X = EP_TYPE_BULK_IN;
-    UECFG1X = EP_SIZE(USB_CDC_EP_BULK_IN_SIZE) | EP_DOUBLE_BUFFER;
-    UEIENX = 1<<TXINE;
-}
-
-void
-bootloader_request(void)
-{
-}
-
-#if CONFIG_MACH_at90usb1286
-#define UHWCON_Init ((1<<UIMOD) | (1<<UVREGE))
-#define PLLCSR_Init ((1<<PLLP2) | (1<<PLLP0) | (1<<PLLE))
-#elif CONFIG_MACH_at90usb646
-#define UHWCON_Init ((1<<UIMOD) | (1<<UVREGE))
-#define PLLCSR_Init ((1<<PLLP2) | (1<<PLLP1) | (1<<PLLE))
-#elif CONFIG_MACH_atmega32u4
-#define UHWCON_Init (1<<UVREGE)
-#define PLLCSR_Init ((1<<PINDIV) | (1<<PLLE))
-#endif
-
-void
-usbserial_init(void)
-{
-    // Set USB controller to device mode
-    UHWCON = UHWCON_Init;
-
-    // Enable USB clock
-    USBCON = (1<<USBE) | (1<<FRZCLK);
-    PLLCSR = PLLCSR_Init;
-    while (!(PLLCSR & (1<<PLOCK)))
-        ;
-    USBCON = (1<<USBE) | (1<<OTGPADE);
-
-    // Enable USB pullup
-    UDCON = 0;
-
-    // Enable interrupts
-    UDIEN = 1<<EORSTE;
-}
-DECL_INIT(usbserial_init);
-
-ISR(USB_GEN_vect)
-{
-    uint8_t udint = UDINT;
-    UDINT = 0;
-    if (udint & (1<<EORSTI)) {
-        // Configure endpoint 0 after usb reset completes
-        uint8_t old_uenum = UENUM;
-        UENUM = 0;
-        UECONX = 1<<EPEN;
-        UECFG0X = EP_TYPE_CONTROL;
-        UECFG1X = EP_SIZE(USB_CDC_EP0_SIZE) | EP_SINGLE_BUFFER;
-        UEIENX = 1<<RXSTPE;
-        UENUM = old_uenum;
-    }
-}
-
-ISR(USB_COM_vect)
-{
-    uint8_t ueint = UEINT, old_uenum = UENUM;
-    if (ueint & (1<<0)) {
-        UENUM = 0;
-        UEIENX = 0;
-        usb_notify_ep0();
-
-        uint8_t ueintx = UEINTX;
-        if (!(ueintx & (1<<RXSTPI)) && (ueintx & (1<<TXINI)) && set_address) {
-            // Ack from set_address command sent - now update address
-            UDADDR = set_address;
-            set_address = 0;
-        }
-    }
-    if (ueint & (1<<USB_CDC_EP_BULK_OUT)) {
-        UENUM = USB_CDC_EP_BULK_OUT;
-        UEIENX = 0;
-        usb_notify_bulk_out();
-    }
-    if (ueint & (1<<USB_CDC_EP_BULK_IN)) {
-        UENUM = USB_CDC_EP_BULK_IN;
-        UEIENX = 0;
-        usb_notify_bulk_in();
-    }
-    UENUM = old_uenum;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/avr/watchdog.c crealityShit/src/avr/watchdog.c
--- klipperStock/src/avr/watchdog.c	2024-01-14 23:02:00.157796793 -0600
+++ crealityShit/src/avr/watchdog.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,58 +0,0 @@
-// Initialization of AVR watchdog timer.
-//
-// Copyright (C) 2016  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <avr/interrupt.h> // WDT_vect
-#include <avr/wdt.h> // wdt_enable
-#include "command.h" // shutdown
-#include "irq.h" // irq_disable
-#include "sched.h" // DECL_TASK
-
-static uint8_t watchdog_shutdown;
-
-ISR(WDT_vect)
-{
-    watchdog_shutdown = 1;
-    shutdown("Watchdog timer!");
-}
-
-void
-watchdog_reset(void)
-{
-    wdt_reset();
-    if (watchdog_shutdown) {
-        WDTCSR = 1<<WDIE;
-        watchdog_shutdown = 0;
-    }
-}
-DECL_TASK(watchdog_reset);
-
-void
-watchdog_init(void)
-{
-    // 0.5s timeout, interrupt and system reset
-    wdt_enable(WDTO_500MS);
-    WDTCSR = 1<<WDIE;
-}
-DECL_INIT(watchdog_init);
-
-// Very early reset of the watchdog
-void __attribute__((naked)) __visible __section(".init3")
-watchdog_early_init(void)
-{
-    MCUSR = 0;
-    wdt_disable();
-}
-
-// Support reset on AVR via the watchdog timer
-void
-command_reset(uint32_t *args)
-{
-    irq_disable();
-    wdt_enable(WDTO_15MS);
-    for (;;)
-        ;
-}
-DECL_COMMAND_FLAGS(command_reset, HF_IN_SHUTDOWN, "reset");
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/basecmd.c crealityShit/src/basecmd.c
--- klipperStock/src/basecmd.c	2024-01-14 23:02:00.149796696 -0600
+++ crealityShit/src/basecmd.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,367 +0,0 @@
-// Basic infrastructure commands.
-//
-// Copyright (C) 2016-2020  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memset
-#include "basecmd.h" // oid_lookup
-#include "board/irq.h" // irq_save
-#include "board/misc.h" // alloc_maxsize
-#include "board/pgm.h" // READP
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // sched_clear_shutdown
-
-
-/****************************************************************
- * Low level allocation
- ****************************************************************/
-
-static void *alloc_end;
-
-void
-alloc_init(void)
-{
-    alloc_end = (void*)ALIGN((size_t)dynmem_start(), __alignof__(void*));
-}
-DECL_INIT(alloc_init);
-
-// Allocate an area of memory
-void *
-alloc_chunk(size_t size)
-{
-    if (alloc_end + size > dynmem_end())
-        shutdown("alloc_chunk failed");
-    void *data = alloc_end;
-    alloc_end += ALIGN(size, __alignof__(void*));
-    memset(data, 0, size);
-    return data;
-}
-
-// Allocate an array of chunks
-static void *
-alloc_chunks(size_t size, size_t count, uint16_t *avail)
-{
-    size_t can_alloc = 0;
-    void *p = alloc_end, *end = dynmem_end();
-    while (can_alloc < count && p + size <= end)
-        can_alloc++, p += size;
-    if (!can_alloc)
-        shutdown("alloc_chunks failed");
-    void *data = alloc_chunk(p - alloc_end);
-    *avail = can_alloc;
-    return data;
-}
-
-
-/****************************************************************
- * Move queue
- ****************************************************************/
-
-static struct move_node *move_free_list;
-static void *move_list;
-static uint16_t move_count;
-static uint8_t move_item_size;
-
-// Is the config and move queue finalized?
-static int
-is_finalized(void)
-{
-    return !!move_count;
-}
-
-// Free previously allocated storage from move_alloc(). Caller must
-// disable irqs.
-void
-move_free(void *m)
-{
-    struct move_node *mf = m;
-    mf->next = move_free_list;
-    move_free_list = mf;
-}
-
-// Allocate runtime storage
-void *
-move_alloc(void)
-{
-    irqstatus_t flag = irq_save();
-    struct move_node *mf = move_free_list;
-    if (!mf)
-        shutdown("Move queue overflow");
-    move_free_list = mf->next;
-    irq_restore(flag);
-    return mf;
-}
-
-// Check if a move_queue is empty
-int
-move_queue_empty(struct move_queue_head *mh)
-{
-    return mh->first == NULL;
-}
-
-// Return first node in a move queue
-struct move_node *
-move_queue_first(struct move_queue_head *mh)
-{
-    return mh->first;
-}
-
-// Add move to queue
-int
-move_queue_push(struct move_node *m, struct move_queue_head *mh)
-{
-    m->next = NULL;
-    if (mh->first) {
-        mh->last->next = m;
-        mh->last = m;
-        return 0;
-    }
-    mh->first = mh->last = m;
-    return 1;
-}
-
-// Remove first item from queue (caller must ensure queue not empty)
-struct move_node *
-move_queue_pop(struct move_queue_head *mh)
-{
-    struct move_node *mn = mh->first;
-    mh->first = mn->next;
-    return mn;
-}
-
-// Completely clear move queue (used in shutdown handlers)
-void
-move_queue_clear(struct move_queue_head *mh)
-{
-    mh->first = NULL;
-}
-
-// Initialize a move_queue with nodes of the give size
-void
-move_queue_setup(struct move_queue_head *mh, int size)
-{
-    mh->first = mh->last = NULL;
-
-    if (size > UINT8_MAX || is_finalized())
-        shutdown("Invalid move request size");
-    if (size > move_item_size)
-        move_item_size = size;
-}
-
-void
-move_reset(void)
-{
-    if (!move_count)
-        return;
-    // Add everything in move_list to the free list.
-    uint32_t i;
-    for (i=0; i<move_count-1; i++) {
-        struct move_node *mf = move_list + i*move_item_size;
-        mf->next = move_list + (i + 1)*move_item_size;
-    }
-    struct move_node *mf = move_list + (move_count - 1)*move_item_size;
-    mf->next = NULL;
-    move_free_list = move_list;
-}
-DECL_SHUTDOWN(move_reset);
-
-static void
-move_finalize(void)
-{
-    if (is_finalized())
-        shutdown("Already finalized");
-    struct move_queue_head dummy;
-    move_queue_setup(&dummy, sizeof(*move_free_list));
-    move_list = alloc_chunks(move_item_size, 1024, &move_count);
-    move_reset();
-}
-
-
-/****************************************************************
- * Generic object ids (oid)
- ****************************************************************/
-
-struct oid_s {
-    void *type, *data;
-};
-
-static struct oid_s *oids;
-static uint8_t oid_count;
-
-void *
-oid_lookup(uint8_t oid, void *type)
-{
-    if (oid >= oid_count || type != oids[oid].type)
-        shutdown("Invalid oid type");
-    return oids[oid].data;
-}
-
-void *
-oid_alloc(uint8_t oid, void *type, uint16_t size)
-{
-    if (oid >= oid_count || oids[oid].type || is_finalized())
-        shutdown("Can't assign oid");
-    oids[oid].type = type;
-    void *data = alloc_chunk(size);
-    oids[oid].data = data;
-    return data;
-}
-
-void *
-oid_next(uint8_t *i, void *type)
-{
-    uint8_t oid = *i;
-    for (;;) {
-        oid++;
-        if (oid >= oid_count)
-            return NULL;
-        if (oids[oid].type == type) {
-            *i = oid;
-            return oids[oid].data;
-        }
-    }
-}
-
-void
-command_allocate_oids(uint32_t *args)
-{
-    if (oids)
-        shutdown("oids already allocated");
-    uint8_t count = args[0];
-    oids = alloc_chunk(sizeof(oids[0]) * count);
-    oid_count = count;
-}
-DECL_COMMAND(command_allocate_oids, "allocate_oids count=%c");
-
-
-/****************************************************************
- * Config CRC
- ****************************************************************/
-
-static uint32_t config_crc;
-
-void
-command_get_config(uint32_t *args)
-{
-    sendf("config is_config=%c crc=%u is_shutdown=%c move_count=%hu"
-          , is_finalized(), config_crc, sched_is_shutdown(), move_count);
-}
-DECL_COMMAND_FLAGS(command_get_config, HF_IN_SHUTDOWN, "get_config");
-
-void
-command_finalize_config(uint32_t *args)
-{
-    move_finalize();
-    config_crc = args[0];
-}
-DECL_COMMAND(command_finalize_config, "finalize_config crc=%u");
-
-// Attempt a full manual reset of the config
-void
-config_reset(uint32_t *args)
-{
-    if (! sched_is_shutdown())
-        shutdown("config_reset only available when shutdown");
-    irq_disable();
-    config_crc = 0;
-    oid_count = 0;
-    oids = NULL;
-    move_free_list = NULL;
-    move_list = NULL;
-    move_count = move_item_size = 0;
-    alloc_init();
-    sched_timer_reset();
-    sched_clear_shutdown();
-    irq_enable();
-}
-
-
-/****************************************************************
- * Timing and load stats
- ****************************************************************/
-
-void
-command_get_clock(uint32_t *args)
-{
-    sendf("clock clock=%u", timer_read_time());
-}
-DECL_COMMAND_FLAGS(command_get_clock, HF_IN_SHUTDOWN, "get_clock");
-
-static uint32_t stats_send_time, stats_send_time_high;
-
-void
-command_get_uptime(uint32_t *args)
-{
-    uint32_t cur = timer_read_time();
-    uint32_t high = stats_send_time_high + (cur < stats_send_time);
-    sendf("uptime high=%u clock=%u", high, cur);
-}
-DECL_COMMAND_FLAGS(command_get_uptime, HF_IN_SHUTDOWN, "get_uptime");
-
-#define SUMSQ_BASE 256
-DECL_CONSTANT("STATS_SUMSQ_BASE", SUMSQ_BASE);
-
-void
-stats_update(uint32_t start, uint32_t cur)
-{
-    static uint32_t count, sum, sumsq;
-    uint32_t diff = cur - start;
-    count++;
-    sum += diff;
-    // Calculate sum of diff^2 - be careful of integer overflow
-    uint32_t nextsumsq;
-    if (diff <= 0xffff) {
-        nextsumsq = sumsq + DIV_ROUND_UP(diff * diff, SUMSQ_BASE);
-    } else if (diff <= 0xfffff) {
-        nextsumsq = sumsq + DIV_ROUND_UP(diff, SUMSQ_BASE) * diff;
-    } else {
-        nextsumsq = 0xffffffff;
-    }
-    if (nextsumsq < sumsq)
-        nextsumsq = 0xffffffff;
-    sumsq = nextsumsq;
-
-    if (timer_is_before(cur, stats_send_time + timer_from_us(5000000)))
-        return;
-    sendf("stats count=%u sum=%u sumsq=%u", count, sum, sumsq);
-    if (cur < stats_send_time)
-        stats_send_time_high++;
-    stats_send_time = cur;
-    count = sum = sumsq = 0;
-}
-
-
-/****************************************************************
- * Misc commands
- ****************************************************************/
-
-void
-command_emergency_stop(uint32_t *args)
-{
-    shutdown("Command request");
-}
-DECL_COMMAND_FLAGS(command_emergency_stop, HF_IN_SHUTDOWN, "emergency_stop");
-
-void
-command_clear_shutdown(uint32_t *args)
-{
-    sched_clear_shutdown();
-}
-DECL_COMMAND_FLAGS(command_clear_shutdown, HF_IN_SHUTDOWN, "clear_shutdown");
-
-void
-command_identify(uint32_t *args)
-{
-    uint32_t offset = args[0];
-    uint8_t count = args[1];
-    uint32_t isize = READP(command_identify_size);
-    if (offset >= isize)
-        count = 0;
-    else if (offset + count > isize)
-        count = isize - offset;
-    sendf("identify_response offset=%u data=%.*s"
-          , offset, count, &command_identify_data[offset]);
-}
-DECL_COMMAND_FLAGS(command_identify, HF_IN_SHUTDOWN,
-                   "identify offset=%u count=%c");
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/basecmd.h crealityShit/src/basecmd.h
--- klipperStock/src/basecmd.h	2024-01-14 23:02:00.109796205 -0600
+++ crealityShit/src/basecmd.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,32 +0,0 @@
-#ifndef __BASECMD_H
-#define __BASECMD_H
-
-#include <stddef.h> // size_t
-#include <stdint.h> // uint8_t
-
-struct move_node {
-    struct move_node *next;
-};
-struct move_queue_head {
-    struct move_node *first, *last;
-};
-
-void *alloc_chunk(size_t size);
-void move_free(void *m);
-void *move_alloc(void);
-int move_queue_empty(struct move_queue_head *mh);
-struct move_node *move_queue_first(struct move_queue_head *mh);
-int move_queue_push(struct move_node *m, struct move_queue_head *mh);
-struct move_node *move_queue_pop(struct move_queue_head *mh);
-void move_queue_clear(struct move_queue_head *mh);
-void move_queue_setup(struct move_queue_head *mh, int size);
-void *oid_lookup(uint8_t oid, void *type);
-void *oid_alloc(uint8_t oid, void *type, uint16_t size);
-void *oid_next(uint8_t *i, void *type);
-void stats_update(uint32_t start, uint32_t cur);
-void config_reset(uint32_t *args);
-
-#define foreach_oid(pos,data,oidtype)                   \
-    for (pos=-1; (data=oid_next(&pos, oidtype)); )
-
-#endif // basecmd.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/buttons.c crealityShit/src/buttons.c
--- klipperStock/src/buttons.c	2024-01-14 23:02:00.109796205 -0600
+++ crealityShit/src/buttons.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,163 +0,0 @@
-// Report on user interface buttons
-//
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "basecmd.h" // oid_alloc
-#include "board/gpio.h" // struct gpio_in
-#include "board/irq.h" // irq_disable
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // struct timer
-
-struct buttons {
-    struct timer time;
-    uint32_t rest_ticks;
-    uint8_t pressed, last_pressed;
-    uint8_t report_count, reports[8];
-    uint8_t ack_count, retransmit_state, retransmit_count;
-    uint8_t button_count;
-    struct gpio_in pins[0];
-};
-
-enum { BF_NO_RETRANSMIT = 0x80, BF_PENDING = 0xff, BF_ACKED = 0xfe };
-
-static struct task_wake buttons_wake;
-
-static uint_fast8_t
-buttons_event(struct timer *t)
-{
-    struct buttons *b = container_of(t, struct buttons, time);
-
-    // Read pins
-    uint8_t i, bit, status = 0;
-    for (i = 0, bit = 1; i < b->button_count; i++, bit <<= 1) {
-        uint8_t val = gpio_in_read(b->pins[i]);
-        if (val)
-            status |= bit;
-    }
-
-    // Check if any pins have changed since last time
-    uint8_t diff = status ^ b->pressed;
-    if (diff) {
-        // At least one pin has changed - do button debouncing
-        uint8_t debounced = ~(status ^ b->last_pressed);
-        if (diff & debounced) {
-            // Pin has been consistently different - report it
-            b->pressed = (b->pressed & ~debounced) | (status & debounced);
-            if (b->report_count < sizeof(b->reports)) {
-                b->reports[b->report_count++] = b->pressed;
-                sched_wake_task(&buttons_wake);
-                b->retransmit_state = BF_PENDING;
-            }
-        }
-    }
-    b->last_pressed = status;
-
-    // Check if a retransmit is needed
-    uint8_t retransmit_state = b->retransmit_state;
-    if (!(retransmit_state & BF_NO_RETRANSMIT)) {
-        retransmit_state--;
-        if (retransmit_state & BF_NO_RETRANSMIT)
-            // timeout - do retransmit
-            sched_wake_task(&buttons_wake);
-        b->retransmit_state = retransmit_state;
-    }
-
-    // Reschedule timer
-    b->time.waketime += b->rest_ticks;
-    return SF_RESCHEDULE;
-}
-
-void
-command_config_buttons(uint32_t *args)
-{
-    uint8_t button_count = args[1];
-    if (button_count > 8)
-        shutdown("Max of 8 buttons");
-    struct buttons *b = oid_alloc(
-        args[0], command_config_buttons
-        , sizeof(*b) + sizeof(b->pins[0]) * button_count);
-    b->button_count = button_count;
-    b->time.func = buttons_event;
-}
-DECL_COMMAND(command_config_buttons, "config_buttons oid=%c button_count=%c");
-
-void
-command_buttons_add(uint32_t *args)
-{
-    struct buttons *b = oid_lookup(args[0], command_config_buttons);
-    uint8_t pos = args[1];
-    if (pos >= b->button_count)
-        shutdown("Set button past maximum button count");
-    b->pins[pos] = gpio_in_setup(args[2], args[3]);
-}
-DECL_COMMAND(command_buttons_add,
-             "buttons_add oid=%c pos=%c pin=%u pull_up=%c");
-
-void
-command_buttons_query(uint32_t *args)
-{
-    struct buttons *b = oid_lookup(args[0], command_config_buttons);
-    sched_del_timer(&b->time);
-    b->time.waketime = args[1];
-    b->rest_ticks = args[2];
-    b->pressed = b->last_pressed = args[4];
-    b->ack_count = b->report_count = 0;
-    b->retransmit_state = BF_ACKED;
-    b->retransmit_count = args[3];
-    if (b->retransmit_count >= BF_NO_RETRANSMIT)
-        shutdown("Invalid buttons retransmit count");
-    if (! b->rest_ticks)
-        return;
-    sched_add_timer(&b->time);
-}
-DECL_COMMAND(command_buttons_query,
-             "buttons_query oid=%c clock=%u rest_ticks=%u retransmit_count=%c"
-             " invert=%c");
-
-void
-command_buttons_ack(uint32_t *args)
-{
-    struct buttons *b = oid_lookup(args[0], command_config_buttons);
-    uint8_t count = args[1];
-    b->ack_count += count;
-    irq_disable();
-    if (count >= b->report_count) {
-        b->report_count = 0;
-        b->retransmit_state = BF_ACKED;
-    } else {
-        uint8_t pending = b->report_count - count, i;
-        for (i=0; i<pending; i++)
-            b->reports[i] = b->reports[i+count];
-        b->report_count = pending;
-    }
-    irq_enable();
-}
-DECL_COMMAND(command_buttons_ack, "buttons_ack oid=%c count=%c");
-
-void
-buttons_task(void)
-{
-    if (!sched_check_wake(&buttons_wake))
-        return;
-    uint8_t oid;
-    struct buttons *b;
-    foreach_oid(oid, b, command_config_buttons) {
-        // See if need to transmit buttons_state
-        if (b->retransmit_state != BF_PENDING)
-            continue;
-        // Generate message
-        irq_disable();
-        uint8_t report_count = b->report_count;
-        if (!report_count) {
-            irq_enable();
-            continue;
-        }
-        b->retransmit_state = b->retransmit_count;
-        irq_enable();
-        sendf("buttons_state oid=%c ack_count=%c state=%*s"
-              , oid, b->ack_count, report_count, b->reports);
-    }
-}
-DECL_TASK(buttons_task);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/byteorder.h crealityShit/src/byteorder.h
--- klipperStock/src/byteorder.h	2024-01-14 23:02:00.141796598 -0600
+++ crealityShit/src/byteorder.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,40 +0,0 @@
-#ifndef __BYTEORDER_H
-#define __BYTEORDER_H
-
-#include <stdint.h> // uint32_t
-
-#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
-
-#define cpu_to_le16(x) ((uint16_t)(x))
-#define cpu_to_le32(x) ((uint32_t)(x))
-#define cpu_to_le64(x) ((uint64_t)(x))
-#define le16_to_cpu(x) ((uint16_t)(x))
-#define le32_to_cpu(x) ((uint32_t)(x))
-#define le64_to_cpu(x) ((uint64_t)(x))
-
-#define cpu_to_be16(x) __builtin_bswap16(x)
-#define cpu_to_be32(x) __builtin_bswap32(x)
-#define cpu_to_be64(x) __builtin_bswap64(x)
-#define be16_to_cpu(x) __builtin_bswap16(x)
-#define be32_to_cpu(x) __builtin_bswap32(x)
-#define be64_to_cpu(x) __builtin_bswap64(x)
-
-#else // big endian
-
-#define cpu_to_le16(x) __builtin_bswap16(x)
-#define cpu_to_le32(x) __builtin_bswap32(x)
-#define cpu_to_le64(x) __builtin_bswap64(x)
-#define le16_to_cpu(x) __builtin_bswap16(x)
-#define le32_to_cpu(x) __builtin_bswap32(x)
-#define le64_to_cpu(x) __builtin_bswap64(x)
-
-#define cpu_to_be16(x) ((uint16_t)(x))
-#define cpu_to_be32(x) ((uint32_t)(x))
-#define cpu_to_be64(x) ((uint64_t)(x))
-#define be16_to_cpu(x) ((uint16_t)(x))
-#define be32_to_cpu(x) ((uint32_t)(x))
-#define be64_to_cpu(x) ((uint64_t)(x))
-
-#endif
-
-#endif // byteorder.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/command.c crealityShit/src/command.c
--- klipperStock/src/command.c	2024-01-14 23:02:00.149796696 -0600
+++ crealityShit/src/command.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,344 +0,0 @@
-// Code for parsing incoming commands and encoding outgoing messages
-//
-// Copyright (C) 2016,2017  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <stdarg.h> // va_start
-#include <string.h> // memcpy
-#include "board/io.h" // readb
-#include "board/irq.h" // irq_poll
-#include "board/misc.h" // crc16_ccitt
-#include "board/pgm.h" // READP
-#include "command.h" // output_P
-#include "sched.h" // sched_is_shutdown
-
-static uint8_t next_sequence = MESSAGE_DEST;
-
-static uint32_t
-command_encode_ptr(void *p)
-{
-    if (sizeof(size_t) > sizeof(uint32_t))
-        return p - console_receive_buffer();
-    return (size_t)p;
-}
-
-void *
-command_decode_ptr(uint32_t v)
-{
-    if (sizeof(size_t) > sizeof(uint32_t))
-        return console_receive_buffer() + v;
-    return (void*)(size_t)v;
-}
-
-
-/****************************************************************
- * Binary message parsing
- ****************************************************************/
-
-// Encode an integer as a variable length quantity (vlq)
-static uint8_t *
-encode_int(uint8_t *p, uint32_t v)
-{
-    int32_t sv = v;
-    if (sv < (3L<<5)  && sv >= -(1L<<5))  goto f4;
-    if (sv < (3L<<12) && sv >= -(1L<<12)) goto f3;
-    if (sv < (3L<<19) && sv >= -(1L<<19)) goto f2;
-    if (sv < (3L<<26) && sv >= -(1L<<26)) goto f1;
-    *p++ = (v>>28) | 0x80;
-f1: *p++ = ((v>>21) & 0x7f) | 0x80;
-f2: *p++ = ((v>>14) & 0x7f) | 0x80;
-f3: *p++ = ((v>>7) & 0x7f) | 0x80;
-f4: *p++ = v & 0x7f;
-    return p;
-}
-
-// Parse an integer that was encoded as a "variable length quantity"
-static uint32_t
-parse_int(uint8_t **pp)
-{
-    uint8_t *p = *pp, c = *p++;
-    uint32_t v = c & 0x7f;
-    if ((c & 0x60) == 0x60)
-        v |= -0x20;
-    while (c & 0x80) {
-        c = *p++;
-        v = (v<<7) | (c & 0x7f);
-    }
-    *pp = p;
-    return v;
-}
-
-// Parse an incoming command into 'args'
-uint8_t *
-command_parsef(uint8_t *p, uint8_t *maxend
-               , const struct command_parser *cp, uint32_t *args)
-{
-    uint_fast8_t num_params = READP(cp->num_params);
-    const uint8_t *param_types = READP(cp->param_types);
-    while (num_params--) {
-        if (p > maxend)
-            goto error;
-        uint_fast8_t t = READP(*param_types);
-        param_types++;
-        switch (t) {
-        case PT_uint32:
-        case PT_int32:
-        case PT_uint16:
-        case PT_int16:
-        case PT_byte:
-            *args++ = parse_int(&p);
-            break;
-        case PT_buffer: {
-            uint_fast8_t len = *p++;
-            if (p + len > maxend)
-                goto error;
-            *args++ = len;
-            *args++ = command_encode_ptr(p);
-            p += len;
-            break;
-        }
-        default:
-            goto error;
-        }
-    }
-    return p;
-error:
-    shutdown("Command parser error");
-}
-
-// Encode a message
-static uint_fast8_t
-command_encodef(uint8_t *buf, const struct command_encoder *ce, va_list args)
-{
-    uint_fast8_t max_size = READP(ce->max_size);
-    if (max_size <= MESSAGE_MIN)
-        // Ack/Nak message
-        return max_size;
-    uint8_t *p = &buf[MESSAGE_HEADER_SIZE];
-    uint8_t *maxend = &p[max_size - MESSAGE_MIN];
-    uint_fast8_t num_params = READP(ce->num_params);
-    const uint8_t *param_types = READP(ce->param_types);
-    *p++ = READP(ce->msg_id);
-    while (num_params--) {
-        if (p > maxend)
-            goto error;
-        uint_fast8_t t = READP(*param_types);
-        param_types++;
-        uint32_t v;
-        switch (t) {
-        case PT_uint32:
-        case PT_int32:
-        case PT_uint16:
-        case PT_int16:
-        case PT_byte:
-            if (sizeof(v) > sizeof(int) && t >= PT_uint16)
-                if (t == PT_int16)
-                    v = (int32_t)va_arg(args, int);
-                else
-                    v = va_arg(args, unsigned int);
-            else
-                v = va_arg(args, uint32_t);
-            p = encode_int(p, v);
-            break;
-        case PT_string: {
-            uint8_t *s = va_arg(args, uint8_t*), *lenp = p++;
-            while (*s && p<maxend)
-                *p++ = *s++;
-            *lenp = p-lenp-1;
-            break;
-        }
-        case PT_progmem_buffer:
-        case PT_buffer: {
-            v = va_arg(args, int);
-            if (v > maxend-p)
-                v = maxend-p;
-            *p++ = v;
-            uint8_t *s = va_arg(args, uint8_t*);
-            if (t == PT_progmem_buffer)
-                memcpy_P(p, s, v);
-            else
-                memcpy(p, s, v);
-            p += v;
-            break;
-        }
-        default:
-            goto error;
-        }
-    }
-    return p - buf + MESSAGE_TRAILER_SIZE;
-error:
-    shutdown("Message encode error");
-}
-
-// Add header and trailer bytes to a message block
-static void
-command_add_frame(uint8_t *buf, uint_fast8_t msglen)
-{
-    buf[MESSAGE_POS_LEN] = msglen;
-    buf[MESSAGE_POS_SEQ] = next_sequence;
-    uint16_t crc = crc16_ccitt(buf, msglen - MESSAGE_TRAILER_SIZE);
-    buf[msglen - MESSAGE_TRAILER_CRC + 0] = crc >> 8;
-    buf[msglen - MESSAGE_TRAILER_CRC + 1] = crc;
-    buf[msglen - MESSAGE_TRAILER_SYNC] = MESSAGE_SYNC;
-}
-
-// Encode a message and then add a message block frame around it
-uint_fast8_t
-command_encode_and_frame(uint8_t *buf, const struct command_encoder *ce
-                         , va_list args)
-{
-    uint_fast8_t msglen = command_encodef(buf, ce, args);
-    command_add_frame(buf, msglen);
-    return msglen;
-}
-
-static uint8_t in_sendf;
-
-// Encode and transmit a "response" message
-void
-command_sendf(const struct command_encoder *ce, ...)
-{
-    if (readb(&in_sendf))
-        // This sendf call was made from an irq handler while the main
-        // code was already in sendf - just drop this sendf request.
-        return;
-    writeb(&in_sendf, 1);
-
-    va_list args;
-    va_start(args, ce);
-    console_sendf(ce, args);
-    va_end(args);
-
-    writeb(&in_sendf, 0);
-}
-
-void
-sendf_shutdown(void)
-{
-    writeb(&in_sendf, 0);
-}
-DECL_SHUTDOWN(sendf_shutdown);
-
-
-/****************************************************************
- * Command routing
- ****************************************************************/
-
-// Find the command handler associated with a command
-static const struct command_parser *
-command_lookup_parser(uint_fast8_t cmdid)
-{
-    if (!cmdid || cmdid >= READP(command_index_size))
-        shutdown("Invalid command");
-    return &command_index[cmdid];
-}
-
-// Empty message (for ack/nak transmission)
-const struct command_encoder encode_acknak PROGMEM = {
-    .max_size = MESSAGE_MIN,
-};
-
-enum { CF_NEED_SYNC=1<<0, CF_NEED_VALID=1<<1 };
-
-// Find the next complete message block
-int_fast8_t
-command_find_block(uint8_t *buf, uint_fast8_t buf_len, uint_fast8_t *pop_count)
-{
-    static uint8_t sync_state;
-    if (buf_len && sync_state & CF_NEED_SYNC)
-        goto need_sync;
-    if (buf_len < MESSAGE_MIN)
-        goto need_more_data;
-    uint_fast8_t msglen = buf[MESSAGE_POS_LEN];
-    if (msglen < MESSAGE_MIN || msglen > MESSAGE_MAX)
-        goto error;
-    uint_fast8_t msgseq = buf[MESSAGE_POS_SEQ];
-    if ((msgseq & ~MESSAGE_SEQ_MASK) != MESSAGE_DEST)
-        goto error;
-    if (buf_len < msglen)
-        goto need_more_data;
-    if (buf[msglen-MESSAGE_TRAILER_SYNC] != MESSAGE_SYNC)
-        goto error;
-    uint16_t msgcrc = ((buf[msglen-MESSAGE_TRAILER_CRC] << 8)
-                       | buf[msglen-MESSAGE_TRAILER_CRC+1]);
-    uint16_t crc = crc16_ccitt(buf, msglen-MESSAGE_TRAILER_SIZE);
-    if (crc != msgcrc)
-        goto error;
-    sync_state &= ~CF_NEED_VALID;
-    *pop_count = msglen;
-    // Check sequence number
-    if (msgseq != next_sequence) {
-        // Lost message - discard messages until it is retransmitted
-        goto nak;
-    }
-    next_sequence = ((msgseq + 1) & MESSAGE_SEQ_MASK) | MESSAGE_DEST;
-    return 1;
-
-need_more_data:
-    *pop_count = 0;
-    return 0;
-error:
-    if (buf[0] == MESSAGE_SYNC) {
-        // Ignore (do not nak) leading SYNC bytes
-        *pop_count = 1;
-        return -1;
-    }
-    sync_state |= CF_NEED_SYNC;
-need_sync: ;
-    // Discard bytes until next SYNC found
-    uint8_t *next_sync = memchr(buf, MESSAGE_SYNC, buf_len);
-    if (next_sync) {
-        sync_state &= ~CF_NEED_SYNC;
-        *pop_count = next_sync - buf + 1;
-    } else {
-        *pop_count = buf_len;
-    }
-    if (sync_state & CF_NEED_VALID)
-        return -1;
-    sync_state |= CF_NEED_VALID;
-nak:
-    command_sendf(&encode_acknak);
-    return -1;
-}
-
-// Dispatch all the commands found in a message block
-void
-command_dispatch(uint8_t *buf, uint_fast8_t msglen)
-{
-    uint8_t *p = &buf[MESSAGE_HEADER_SIZE];
-    uint8_t *msgend = &buf[msglen-MESSAGE_TRAILER_SIZE];
-    while (p < msgend) {
-        uint_fast8_t cmdid = *p++;
-        const struct command_parser *cp = command_lookup_parser(cmdid);
-        uint32_t args[READP(cp->num_args)];
-        p = command_parsef(p, msgend, cp, args);
-        if (sched_is_shutdown() && !(READP(cp->flags) & HF_IN_SHUTDOWN)) {
-            sched_report_shutdown();
-            continue;
-        }
-        irq_poll();
-        void (*func)(uint32_t*) = READP(cp->func);
-        func(args);
-    }
-}
-
-// Send an ack message to the host (notifying that it can send more data)
-void
-command_send_ack(void)
-{
-    command_sendf(&encode_acknak);
-}
-
-// Find a message block and then dispatch all the commands in it
-int_fast8_t
-command_find_and_dispatch(uint8_t *buf, uint_fast8_t buf_len
-                          , uint_fast8_t *pop_count)
-{
-    int_fast8_t ret = command_find_block(buf, buf_len, pop_count);
-    if (ret > 0) {
-        command_dispatch(buf, *pop_count);
-        command_send_ack();
-    }
-    return ret;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/command.h crealityShit/src/command.h
--- klipperStock/src/command.h	2024-01-14 23:02:00.141796598 -0600
+++ crealityShit/src/command.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,108 +0,0 @@
-#ifndef __COMMAND_H
-#define __COMMAND_H
-
-#include <stdarg.h> // va_list
-#include <stddef.h>
-#include <stdint.h> // uint8_t
-#include "ctr.h" // DECL_CTR
-
-// Declare a function to run when the specified command is received
-#define DECL_COMMAND_FLAGS(FUNC, FLAGS, MSG)                    \
-    DECL_CTR("DECL_COMMAND_FLAGS " __stringify(FUNC) " "        \
-             __stringify(FLAGS) " " MSG)
-#define DECL_COMMAND(FUNC, MSG)                 \
-    DECL_COMMAND_FLAGS(FUNC, 0, MSG)
-
-// Flags for command handler declarations.
-#define HF_IN_SHUTDOWN   0x01   // Handler can run even when in emergency stop
-
-// Declare a constant exported to the host
-#define DECL_CONSTANT(NAME, VALUE)                              \
-    DECL_CTR_INT("DECL_CONSTANT " NAME, 1, CTR_INT(VALUE))
-#define DECL_CONSTANT_STR(NAME, VALUE)                  \
-    DECL_CTR("DECL_CONSTANT_STR " NAME " " VALUE)
-
-// Declare an enumeration
-#define DECL_ENUMERATION(ENUM, NAME, VALUE)                             \
-    DECL_CTR_INT("DECL_ENUMERATION " ENUM " " NAME, 1, CTR_INT(VALUE))
-#define DECL_ENUMERATION_RANGE(ENUM, NAME, VALUE, COUNT)        \
-    DECL_CTR_INT("DECL_ENUMERATION_RANGE " ENUM " " NAME,       \
-                 2, CTR_INT(VALUE), CTR_INT(COUNT))
-
-// Send an output message (and declare a static message type for it)
-#define output(FMT, args...)                    \
-    command_sendf(_DECL_OUTPUT(FMT) , ##args )
-
-// Declare a message type and transmit it.
-#define sendf(FMT, args...)                     \
-    command_sendf(_DECL_ENCODER(FMT) , ##args )
-
-// Shut down the machine (also declares a static string to transmit)
-#define shutdown(msg)                           \
-    sched_shutdown(_DECL_STATIC_STR(msg))
-#define try_shutdown(msg)                       \
-    sched_try_shutdown(_DECL_STATIC_STR(msg))
-
-#define MESSAGE_MIN 5
-#define MESSAGE_MAX 64
-#define MESSAGE_HEADER_SIZE  2
-#define MESSAGE_TRAILER_SIZE 3
-#define MESSAGE_POS_LEN 0
-#define MESSAGE_POS_SEQ 1
-#define MESSAGE_TRAILER_CRC  3
-#define MESSAGE_TRAILER_SYNC 1
-#define MESSAGE_PAYLOAD_MAX (MESSAGE_MAX - MESSAGE_MIN)
-#define MESSAGE_SEQ_MASK 0x0f
-#define MESSAGE_DEST 0x10
-#define MESSAGE_SYNC 0x7E
-
-struct command_encoder {
-    uint8_t msg_id, max_size, num_params;
-    const uint8_t *param_types;
-};
-struct command_parser {
-    uint8_t msg_id, num_args, flags, num_params;
-    const uint8_t *param_types;
-    void (*func)(uint32_t *args);
-};
-enum {
-    PT_uint32, PT_int32, PT_uint16, PT_int16, PT_byte,
-    PT_string, PT_progmem_buffer, PT_buffer,
-};
-
-// command.c
-void *command_decode_ptr(uint32_t v);
-uint8_t *command_parsef(uint8_t *p, uint8_t *maxend
-                        , const struct command_parser *cp, uint32_t *args);
-uint_fast8_t command_encode_and_frame(
-    uint8_t *buf, const struct command_encoder *ce, va_list args);
-void command_sendf(const struct command_encoder *ce, ...);
-int_fast8_t command_find_block(uint8_t *buf, uint_fast8_t buf_len
-                               , uint_fast8_t *pop_count);
-void command_dispatch(uint8_t *buf, uint_fast8_t msglen);
-void command_send_ack(void);
-int_fast8_t command_find_and_dispatch(uint8_t *buf, uint_fast8_t buf_len
-                                      , uint_fast8_t *pop_count);
-
-// out/compile_time_request.c (auto generated file)
-extern const struct command_parser command_index[];
-extern const uint8_t command_index_size;
-extern const uint8_t command_identify_data[];
-extern const uint32_t command_identify_size;
-const struct command_encoder *ctr_lookup_encoder(const char *str);
-const struct command_encoder *ctr_lookup_output(const char *str);
-uint8_t ctr_lookup_static_string(const char *str);
-
-#define _DECL_ENCODER(FMT) ({                   \
-    DECL_CTR("_DECL_ENCODER " FMT);             \
-    ctr_lookup_encoder(FMT); })
-
-#define _DECL_OUTPUT(FMT) ({                    \
-    DECL_CTR("_DECL_OUTPUT " FMT);              \
-    ctr_lookup_output(FMT); })
-
-#define _DECL_STATIC_STR(MSG) ({                \
-    DECL_CTR("_DECL_STATIC_STR " MSG);          \
-    ctr_lookup_static_string(MSG); })
-
-#endif // command.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/compiler.h crealityShit/src/compiler.h
--- klipperStock/src/compiler.h	2024-01-14 23:02:00.117796304 -0600
+++ crealityShit/src/compiler.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,46 +0,0 @@
-#ifndef __COMPILER_H
-#define __COMPILER_H
-// Low level definitions for C languange and gcc compiler.
-
-#define barrier() __asm__ __volatile__("": : :"memory")
-
-#define likely(x)       __builtin_expect(!!(x), 1)
-#define unlikely(x)     __builtin_expect(!!(x), 0)
-
-#define noinline __attribute__((noinline))
-#ifndef __always_inline
-#define __always_inline inline __attribute__((always_inline))
-#endif
-#define __visible __attribute__((externally_visible))
-#define __noreturn __attribute__((noreturn))
-
-#define PACKED __attribute__((packed))
-#ifndef __aligned
-#define __aligned(x) __attribute__((aligned(x)))
-#endif
-#ifndef __section
-#define __section(S) __attribute__((section(S)))
-#endif
-
-#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
-#define ALIGN(x,a)              __ALIGN_MASK(x,(typeof(x))(a)-1)
-#define __ALIGN_MASK(x,mask)    (((x)+(mask))&~(mask))
-#define ALIGN_DOWN(x,a)         ((x) & ~((typeof(x))(a)-1))
-
-#define container_of(ptr, type, member) ({                      \
-        const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
-        (type *)( (char *)__mptr - offsetof(type,member) );})
-
-#define __stringify_1(x)        #x
-#define __stringify(x)          __stringify_1(x)
-
-#define ___PASTE(a,b) a##b
-#define __PASTE(a,b) ___PASTE(a,b)
-
-#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
-#define DIV_ROUND_CLOSEST(x, divisor)({                 \
-            typeof(divisor) __divisor = divisor;        \
-            (((x) + ((__divisor) / 2)) / (__divisor));  \
-        })
-
-#endif // compiler.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/ctr.h crealityShit/src/ctr.h
--- klipperStock/src/ctr.h	2024-01-14 23:02:00.129796451 -0600
+++ crealityShit/src/ctr.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,38 +0,0 @@
-#ifndef __CTR_H
-#define __CTR_H
-// Definitions for creating compile time requests.  The DECL_CTR macro
-// produces requests (text strings) that are placed in a special
-// section of the intermediate object files (*.o).  The build extracts
-// these strings and places them in out/compile_time_requests.txt.
-// The scripts/buildcommand.py code then generates
-// out/compile_time_request.c from these requests.
-
-#include "compiler.h" // __section
-
-// Declare a compile time request
-#define DECL_CTR(REQUEST)                                               \
-    static char __PASTE(_DECLS_, __LINE__)[] __attribute__((used))      \
-        __section(".compile_time_request") = (REQUEST)
-
-// Macro to encode an integer for use with DECL_CTR_INT()
-#define _CTR_HEX(H) ((H) > 9 ? (H) - 10 + 'A' : (H) + '0')
-#define _CTR_SHIFT(V, S) _CTR_HEX(((uint32_t)(V) >> (S)) & 0x0f)
-#define _CTR_INT(V, S) ((V) < 0 ? _CTR_SHIFT(-(V), (S)) : _CTR_SHIFT((V), (S)))
-#define CTR_INT(VALUE) {                                \
-        ' ', (VALUE) < 0 ? '-' : '+', '0', 'x',         \
-        _CTR_INT((VALUE),28), _CTR_INT((VALUE),24),     \
-        _CTR_INT((VALUE),20), _CTR_INT((VALUE),16),     \
-        _CTR_INT((VALUE),12), _CTR_INT((VALUE),8),      \
-        _CTR_INT((VALUE),4), _CTR_INT((VALUE),0) }
-
-// Declare a compile time request with an integer expression
-#define DECL_CTR_INT(REQUEST, PARAM_COUNT, args...)     \
-    static struct {                                     \
-        char _request[sizeof(REQUEST)-1];               \
-        char _values[(PARAM_COUNT)][12];                \
-        char _end_of_line;                              \
-    } __PASTE(_DECLI_, __LINE__) __attribute__((used))  \
-        __section(".compile_time_request") = {          \
-        (REQUEST), { args }, 0 }
-
-#endif // ctr.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/debugcmds.c crealityShit/src/debugcmds.c
--- klipperStock/src/debugcmds.c	2024-01-14 23:02:00.149796696 -0600
+++ crealityShit/src/debugcmds.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,59 +0,0 @@
-// Debugging commands.
-//
-// Copyright (C) 2016-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/io.h" // readl
-#include "board/irq.h" // irq_save
-#include "command.h" // DECL_COMMAND
-
-void
-command_debug_read(uint32_t *args)
-{
-    uint8_t order = args[0];
-    void *ptr = command_decode_ptr(args[1]);
-    uint32_t v;
-    irqstatus_t flag = irq_save();
-    switch (order) {
-    default: case 0: v = readb(ptr); break;
-    case 1:          v = readw(ptr); break;
-    case 2:          v = readl(ptr); break;
-    }
-    irq_restore(flag);
-    sendf("debug_result val=%u", v);
-}
-DECL_COMMAND_FLAGS(command_debug_read, HF_IN_SHUTDOWN,
-                   "debug_read order=%c addr=%u");
-
-void
-command_debug_write(uint32_t *args)
-{
-    uint8_t order = args[0];
-    void *ptr = command_decode_ptr(args[1]);
-    uint32_t v = args[2];
-    irqstatus_t flag = irq_save();
-    switch (order) {
-    default: case 0: writeb(ptr, v); break;
-    case 1:          writew(ptr, v); break;
-    case 2:          writel(ptr, v); break;
-    }
-    irq_restore(flag);
-}
-DECL_COMMAND_FLAGS(command_debug_write, HF_IN_SHUTDOWN,
-                   "debug_write order=%c addr=%u val=%u");
-
-void
-command_debug_ping(uint32_t *args)
-{
-    uint8_t len = args[0];
-    char *data = command_decode_ptr(args[1]);
-    sendf("pong data=%*s", len, data);
-}
-DECL_COMMAND_FLAGS(command_debug_ping, HF_IN_SHUTDOWN, "debug_ping data=%*s");
-
-void
-command_debug_nop(uint32_t *args)
-{
-}
-DECL_COMMAND_FLAGS(command_debug_nop, HF_IN_SHUTDOWN, "debug_nop");
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/endstop.c crealityShit/src/endstop.c
--- klipperStock/src/endstop.c	2024-01-14 23:02:00.109796205 -0600
+++ crealityShit/src/endstop.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,115 +0,0 @@
-// Handling of end stops.
-//
-// Copyright (C) 2016-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "basecmd.h" // oid_alloc
-#include "board/gpio.h" // struct gpio
-#include "board/irq.h" // irq_disable
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // struct timer
-#include "trsync.h" // trsync_do_trigger
-
-struct endstop {
-    struct timer time;
-    struct gpio_in pin;
-    uint32_t rest_time, sample_time, nextwake;
-    struct trsync *ts;
-    uint8_t flags, sample_count, trigger_count, trigger_reason;
-};
-
-enum { ESF_PIN_HIGH=1<<0, ESF_HOMING=1<<1 };
-
-static uint_fast8_t endstop_oversample_event(struct timer *t);
-
-// Timer callback for an end stop
-static uint_fast8_t
-endstop_event(struct timer *t)
-{
-    struct endstop *e = container_of(t, struct endstop, time);
-    uint8_t val = gpio_in_read(e->pin);
-    uint32_t nextwake = e->time.waketime + e->rest_time;
-    if ((val ? ~e->flags : e->flags) & ESF_PIN_HIGH) {
-        // No match - reschedule for the next attempt
-        e->time.waketime = nextwake;
-        return SF_RESCHEDULE;
-    }
-    e->nextwake = nextwake;
-    e->time.func = endstop_oversample_event;
-    return endstop_oversample_event(t);
-}
-
-// Timer callback for an end stop that is sampling extra times
-static uint_fast8_t
-endstop_oversample_event(struct timer *t)
-{
-    struct endstop *e = container_of(t, struct endstop, time);
-    uint8_t val = gpio_in_read(e->pin);
-    if ((val ? ~e->flags : e->flags) & ESF_PIN_HIGH) {
-        // No longer matching - reschedule for the next attempt
-        e->time.func = endstop_event;
-        e->time.waketime = e->nextwake;
-        e->trigger_count = e->sample_count;
-        return SF_RESCHEDULE;
-    }
-    uint8_t count = e->trigger_count - 1;
-    if (!count) {
-        trsync_do_trigger(e->ts, e->trigger_reason);
-        return SF_DONE;
-    }
-    e->trigger_count = count;
-    e->time.waketime += e->sample_time;
-    return SF_RESCHEDULE;
-}
-
-void
-command_config_endstop(uint32_t *args)
-{
-    struct endstop *e = oid_alloc(args[0], command_config_endstop, sizeof(*e));
-    e->pin = gpio_in_setup(args[1], args[2]);
-}
-DECL_COMMAND(command_config_endstop, "config_endstop oid=%c pin=%c pull_up=%c");
-
-// Home an axis
-void
-command_endstop_home(uint32_t *args)
-{
-    struct endstop *e = oid_lookup(args[0], command_config_endstop);
-    sched_del_timer(&e->time);
-    e->time.waketime = args[1];
-    e->sample_time = args[2];
-    e->sample_count = args[3];
-    if (!e->sample_count) {
-        // Disable end stop checking
-        e->ts = NULL;
-        e->flags = 0;
-        return;
-    }
-    e->rest_time = args[4];
-    e->time.func = endstop_event;
-    e->trigger_count = e->sample_count;
-    e->flags = ESF_HOMING | (args[5] ? ESF_PIN_HIGH : 0);
-    e->ts = trsync_oid_lookup(args[6]);
-    e->trigger_reason = args[7];
-    sched_add_timer(&e->time);
-}
-DECL_COMMAND(command_endstop_home,
-             "endstop_home oid=%c clock=%u sample_ticks=%u sample_count=%c"
-             " rest_ticks=%u pin_value=%c trsync_oid=%c trigger_reason=%c");
-
-void
-command_endstop_query_state(uint32_t *args)
-{
-    uint8_t oid = args[0];
-    struct endstop *e = oid_lookup(oid, command_config_endstop);
-
-    irq_disable();
-    uint8_t eflags = e->flags;
-    uint32_t nextwake = e->nextwake;
-    irq_enable();
-
-    sendf("endstop_state oid=%c homing=%c next_clock=%u pin_value=%c"
-          , oid, !!(eflags & ESF_HOMING), nextwake, gpio_in_read(e->pin));
-}
-DECL_COMMAND(command_endstop_query_state, "endstop_query_state oid=%c");
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/alloc.c crealityShit/src/generic/alloc.c
--- klipperStock/src/generic/alloc.c	2024-01-14 23:02:00.173796990 -0600
+++ crealityShit/src/generic/alloc.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,23 +0,0 @@
-// Generic implementation of dynamic memory pool
-//
-// Copyright (C) 2016,2017  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "misc.h" // dynmem_start
-
-static char dynmem_pool[20 * 1024];
-
-// Return the start of memory available for dynamic allocations
-void *
-dynmem_start(void)
-{
-    return dynmem_pool;
-}
-
-// Return the end of memory available for dynamic allocations
-void *
-dynmem_end(void)
-{
-    return &dynmem_pool[sizeof(dynmem_pool)];
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/armcm_boot.c crealityShit/src/generic/armcm_boot.c
--- klipperStock/src/generic/armcm_boot.c	2024-01-14 23:02:00.177797038 -0600
+++ crealityShit/src/generic/armcm_boot.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,119 +0,0 @@
-// ARM Cortex-M vector table and initial bootup handling
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "armcm_boot.h" // DECL_ARMCM_IRQ
-#include "autoconf.h" // CONFIG_MCU
-#include "board/internal.h" // SysTick
-#include "command.h" // DECL_CONSTANT_STR
-#include "misc.h" // dynmem_start
-
-// Export MCU type
-DECL_CONSTANT_STR("MCU", CONFIG_MCU);
-
-// Symbols created by armcm_link.lds.S linker script
-extern uint32_t _data_start, _data_end, _data_flash;
-extern uint32_t _bss_start, _bss_end, _stack_start;
-extern uint32_t _stack_end;
-
-/****************************************************************
- * Basic interrupt handlers
- ****************************************************************/
-
-static void __noreturn
-reset_handler_stage_two(void)
-{
-    int i;
-
-    // Clear all enabled user interrupts and user pending interrupts
-    for (i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
-        NVIC->ICER[i] = 0xFFFFFFFF;
-        __DSB();
-        NVIC->ICPR[i] = 0xFFFFFFFF;
-    }
-
-    // Reset all user interrupt priorities
-    for (i = 0; i < ARRAY_SIZE(NVIC->IP); i++)
-        NVIC->IP[i] = 0;
-
-    // Disable SysTick interrupt
-    SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk;
-    __DSB();
-
-    // Clear pending pendsv and systick interrupts
-    SCB->ICSR = SCB_ICSR_PENDSVCLR_Msk | SCB_ICSR_PENDSTCLR_Msk;
-
-    // Reset all system interrupt priorities
-#if __CORTEX_M >= 7
-    for (i = 0; i < ARRAY_SIZE(SCB->SHPR); i++)
-        SCB->SHPR[i] = 0;
-#else
-    for (i = 0; i < ARRAY_SIZE(SCB->SHP); i++)
-        SCB->SHP[i] = 0;
-#endif
-
-    __DSB();
-    __ISB();
-    __enable_irq();
-
-    // Copy global variables from flash to ram
-    uint32_t count = (&_data_end - &_data_start) * 4;
-    __builtin_memcpy(&_data_start, &_data_flash, count);
-
-    // Clear the bss segment
-    __builtin_memset(&_bss_start, 0, (&_bss_end - &_bss_start) * 4);
-
-    barrier();
-
-    // Initializing the C library isn't needed...
-    //__libc_init_array();
-
-    // Run the main board specific code
-    armcm_main();
-
-    // The armcm_main() call should not return
-    for (;;)
-        ;
-}
-
-// Initial code entry point - invoked by the processor after a reset
-// Reset interrupts and stack to take control from bootloaders
-void
-ResetHandler(void)
-{
-    __disable_irq();
-
-    // Explicitly load the stack pointer, jump to stage two
-    asm volatile("mov sp, %0\n bx %1"
-                 : : "r"(&_stack_end), "r"(reset_handler_stage_two));
-}
-DECL_ARMCM_IRQ(ResetHandler, -15);
-
-// Code called for any undefined interrupts
-void
-DefaultHandler(void)
-{
-    for (;;)
-        ;
-}
-
-
-/****************************************************************
- * Dynamic memory range
- ****************************************************************/
-
-// Return the start of memory available for dynamic allocations
-void *
-dynmem_start(void)
-{
-    return &_bss_end;
-}
-
-// Return the end of memory available for dynamic allocations
-void *
-dynmem_end(void)
-{
-    return &_stack_start;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/armcm_boot.h crealityShit/src/generic/armcm_boot.h
--- klipperStock/src/generic/armcm_boot.h	2024-01-14 23:02:00.181797089 -0600
+++ crealityShit/src/generic/armcm_boot.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,22 +0,0 @@
-#ifndef __GENERIC_ARMCM_BOOT_H
-#define __GENERIC_ARMCM_BOOT_H
-
-#include "ctr.h" // DECL_CTR_INT
-
-void armcm_main(void);
-
-// Declare an IRQ handler
-#define DECL_ARMCM_IRQ(FUNC, NUM)                                       \
-    DECL_CTR_INT("DECL_ARMCM_IRQ " __stringify(FUNC), 1, CTR_INT(NUM))
-
-// Statically declare an IRQ handler and run-time enable it
-#define armcm_enable_irq(FUNC, NUM, PRIORITY) do {      \
-        DECL_ARMCM_IRQ(FUNC, (NUM));                    \
-        NVIC_SetPriority((NUM), (PRIORITY));            \
-        NVIC_EnableIRQ((NUM));                          \
-    } while (0)
-
-// Vectors created by scripts/buildcommands.py from DECL_ARMCM_IRQ commands
-extern const void * const VectorTable[];
-
-#endif // armcm_boot.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/armcm_irq.c crealityShit/src/generic/armcm_irq.c
--- klipperStock/src/generic/armcm_irq.c	2024-01-14 23:02:00.173796990 -0600
+++ crealityShit/src/generic/armcm_irq.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,75 +0,0 @@
-// Definitions for irq enable/disable on ARM Cortex-M processors
-//
-// Copyright (C) 2017-2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/internal.h" // __CORTEX_M
-#include "irq.h" // irqstatus_t
-#include "sched.h" // DECL_SHUTDOWN
-
-void
-irq_disable(void)
-{
-    asm volatile("cpsid i" ::: "memory");
-}
-
-void
-irq_enable(void)
-{
-    asm volatile("cpsie i" ::: "memory");
-}
-
-irqstatus_t
-irq_save(void)
-{
-    irqstatus_t flag;
-    asm volatile("mrs %0, primask" : "=r" (flag) :: "memory");
-    irq_disable();
-    return flag;
-}
-
-void
-irq_restore(irqstatus_t flag)
-{
-    asm volatile("msr primask, %0" :: "r" (flag) : "memory");
-}
-
-void
-irq_wait(void)
-{
-    if (__CORTEX_M >= 7)
-        // Cortex-m7 may disable cpu counter on wfi, so use nop
-        asm volatile("cpsie i\n    nop\n    cpsid i\n" ::: "memory");
-    else
-        asm volatile("cpsie i\n    wfi\n    cpsid i\n" ::: "memory");
-}
-
-void
-irq_poll(void)
-{
-}
-
-// Clear the active irq if a shutdown happened in an irq handler
-void
-clear_active_irq(void)
-{
-    uint32_t psr;
-    asm volatile("mrs %0, psr" : "=r" (psr));
-    if (!(psr & 0x1ff))
-        // Shutdown did not occur in an irq - nothing to do.
-        return;
-    // Clear active irq status
-    psr = 1<<24; // T-bit
-    uint32_t temp;
-    asm volatile(
-        "  push { %1 }\n"
-        "  adr %0, 1f\n"
-        "  push { %0 }\n"
-        "  push { r0, r1, r2, r3, r4, lr }\n"
-        "  bx %2\n"
-        ".balign 4\n"
-        "1:\n"
-        : "=&r"(temp) : "r"(psr), "r"(0xfffffff9) : "r12", "cc");
-}
-DECL_SHUTDOWN(clear_active_irq);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/armcm_link.lds.S crealityShit/src/generic/armcm_link.lds.S
--- klipperStock/src/generic/armcm_link.lds.S	2024-01-14 23:02:00.181797089 -0600
+++ crealityShit/src/generic/armcm_link.lds.S	1969-12-31 18:00:00.000000000 -0600
@@ -1,73 +0,0 @@
-// Generic ARM Cortex-M linker script
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_FLASH_APPLICATION_ADDRESS
-
-OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
-OUTPUT_ARCH(arm)
-
-MEMORY
-{
-  rom (rx) : ORIGIN = CONFIG_FLASH_APPLICATION_ADDRESS , LENGTH = CONFIG_FLASH_SIZE
-  ram (rwx) : ORIGIN = CONFIG_RAM_START , LENGTH = CONFIG_RAM_SIZE
-}
-
-SECTIONS
-{
-    .text : {
-        . = ALIGN(4);
-        _text_vectortable_start = .;
-        KEEP(*(.vector_table))
-        _text_vectortable_end = .;
-        *(.text .text.*)
-        *(.rodata .rodata*)
-    } > rom
-
-    . = ALIGN(4);
-    _data_flash = .;
-
-#if CONFIG_ARMCM_RAM_VECTORTABLE
-    .ram_vectortable (NOLOAD) : {
-        _ram_vectortable_start = .;
-        . = . + ( _text_vectortable_end - _text_vectortable_start ) ;
-        _ram_vectortable_end = .;
-    } > ram
-#endif
-
-    .data : AT (_data_flash)
-    {
-        . = ALIGN(4);
-        _data_start = .;
-        *(.ramfunc .ramfunc.*);
-        *(.data .data.*);
-        . = ALIGN(4);
-        _data_end = .;
-    } > ram
-
-    .bss (NOLOAD) :
-    {
-        . = ALIGN(4);
-        _bss_start = .;
-        *(.bss .bss.*)
-        *(COMMON)
-        . = ALIGN(4);
-        _bss_end = .;
-    } > ram
-
-    _stack_start = CONFIG_RAM_START + CONFIG_RAM_SIZE - CONFIG_STACK_SIZE ;
-    .stack _stack_start (NOLOAD) :
-    {
-        . = . + CONFIG_STACK_SIZE;
-        _stack_end = .;
-    } > ram
-
-    /DISCARD/ : {
-        // The .init/.fini sections are used by __libc_init_array(), but
-        // that isn't needed so no need to include them in the binary.
-        *(.init)
-        *(.fini)
-    }
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/armcm_reset.c crealityShit/src/generic/armcm_reset.c
--- klipperStock/src/generic/armcm_reset.c	2024-01-14 23:02:00.177797038 -0600
+++ crealityShit/src/generic/armcm_reset.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,50 +0,0 @@
-// Generic reset command handler for ARM Cortex-M boards
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "armcm_reset.h" // try_request_canboot
-#include "autoconf.h" // CONFIG_FLASH_APPLICATION_ADDRESS
-#include "board/internal.h" // NVIC_SystemReset
-#include "board/irq.h" // irq_disable
-#include "command.h" // DECL_COMMAND_FLAGS
-
-#define CANBOOT_SIGNATURE 0x21746f6f426e6143
-#define CANBOOT_REQUEST   0x5984E3FA6CA1589B
-#define CANBOOT_BYPASS    0x7b06ec45a9a8243d
-
-static void
-canboot_reset(uint64_t req_signature)
-{
-    if (CONFIG_FLASH_APPLICATION_ADDRESS == CONFIG_FLASH_BOOT_ADDRESS)
-        // No bootloader
-        return;
-    uint32_t *bl_vectors = (uint32_t *)CONFIG_FLASH_BOOT_ADDRESS;
-    uint64_t *boot_sig = (uint64_t *)(bl_vectors[1] - 9);
-    uint64_t *req_sig = (uint64_t *)bl_vectors[0];
-    if (boot_sig != (void*)ALIGN((size_t)boot_sig, 8)
-        || *boot_sig != CANBOOT_SIGNATURE
-        || req_sig != (void*)ALIGN((size_t)req_sig, 8))
-        return;
-    irq_disable();
-    *req_sig = req_signature;
-#if __CORTEX_M >= 7
-    SCB_CleanDCache_by_Addr((void*)req_sig, sizeof(*req_sig));
-#endif
-    NVIC_SystemReset();
-}
-
-void
-try_request_canboot(void)
-{
-    canboot_reset(CANBOOT_REQUEST);
-}
-
-void
-command_reset(uint32_t *args)
-{
-    canboot_reset(CANBOOT_BYPASS);
-    NVIC_SystemReset();
-}
-DECL_COMMAND_FLAGS(command_reset, HF_IN_SHUTDOWN, "reset");
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/armcm_reset.h crealityShit/src/generic/armcm_reset.h
--- klipperStock/src/generic/armcm_reset.h	2024-01-14 23:02:00.181797089 -0600
+++ crealityShit/src/generic/armcm_reset.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,6 +0,0 @@
-#ifndef __GENERIC_ARMCM_RESET_H
-#define __GENERIC_ARMCM_RESET_H
-
-void try_request_canboot(void);
-
-#endif // armcm_reset.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/armcm_timer.c crealityShit/src/generic/armcm_timer.c
--- klipperStock/src/generic/armcm_timer.c	2024-01-14 23:02:00.173796990 -0600
+++ crealityShit/src/generic/armcm_timer.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,176 +0,0 @@
-// Timer based on ARM Cortex-M3/M4 SysTick and DWT logic
-//
-// Copyright (C) 2017-2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_CLOCK_FREQ
-#include "armcm_boot.h" // DECL_ARMCM_IRQ
-#include "board/internal.h" // SysTick
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_from_us
-#include "command.h" // shutdown
-#include "sched.h" // sched_timer_dispatch
-
-DECL_CONSTANT("CLOCK_FREQ", CONFIG_CLOCK_FREQ);
-
-// Return the number of clock ticks for a given number of microseconds
-uint32_t
-timer_from_us(uint32_t us)
-{
-    return us * (CONFIG_CLOCK_FREQ / 1000000);
-}
-
-// Return true if time1 is before time2.  Always use this function to
-// compare times as regular C comparisons can fail if the counter
-// rolls over.
-uint8_t
-timer_is_before(uint32_t time1, uint32_t time2)
-{
-    return (int32_t)(time1 - time2) < 0;
-}
-
-// Set the next irq time
-static void
-timer_set_diff(uint32_t value)
-{
-    SysTick->LOAD = value;
-    SysTick->VAL = 0;
-    SysTick->LOAD = 0;
-}
-
-// Return the current time (in absolute clock ticks).
-uint32_t
-timer_read_time(void)
-{
-    return DWT->CYCCNT;
-}
-
-// Activate timer dispatch as soon as possible
-void
-timer_kick(void)
-{
-    SysTick->LOAD = 0;
-    SysTick->VAL = 0;
-    SCB->ICSR = SCB_ICSR_PENDSTSET_Msk;
-}
-
-// Implement simple early-boot delay mechanism
-void
-udelay(uint32_t usecs)
-{
-    if (!(CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA_Msk)) {
-        CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
-        DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
-    }
-
-    uint32_t end = timer_read_time() + timer_from_us(usecs);
-    while (timer_is_before(timer_read_time(), end))
-        ;
-}
-
-// Dummy timer to avoid scheduling a SysTick irq greater than 0xffffff
-static uint_fast8_t
-timer_wrap_event(struct timer *t)
-{
-    t->waketime += 0xffffff;
-    return SF_RESCHEDULE;
-}
-static struct timer wrap_timer = {
-    .func = timer_wrap_event,
-    .waketime = 0xffffff,
-};
-void
-timer_reset(void)
-{
-    if (timer_from_us(100000) <= 0xffffff)
-        // Timer in sched.c already ensures SysTick wont overflow
-        return;
-    sched_add_timer(&wrap_timer);
-}
-DECL_SHUTDOWN(timer_reset);
-
-void
-timer_init(void)
-{
-    // Enable Debug Watchpoint and Trace (DWT) for its 32bit timer
-    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
-    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
-    DWT->CYCCNT = 0;
-
-    // Schedule a recurring timer on fast cpus
-    timer_reset();
-
-    // Enable SysTick
-    irqstatus_t flag = irq_save();
-    NVIC_SetPriority(SysTick_IRQn, 2);
-    SysTick->CTRL = (SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk
-                     | SysTick_CTRL_ENABLE_Msk);
-    timer_kick();
-    irq_restore(flag);
-}
-DECL_INIT(timer_init);
-
-static uint32_t timer_repeat_until;
-#define TIMER_IDLE_REPEAT_TICKS timer_from_us(500)
-#define TIMER_REPEAT_TICKS timer_from_us(100)
-
-#define TIMER_MIN_TRY_TICKS timer_from_us(2)
-#define TIMER_DEFER_REPEAT_TICKS timer_from_us(5)
-
-// Invoke timers
-static uint32_t
-timer_dispatch_many(void)
-{
-    uint32_t tru = timer_repeat_until;
-    for (;;) {
-        // Run the next software timer
-        uint32_t next = sched_timer_dispatch();
-
-        uint32_t now = timer_read_time();
-        int32_t diff = next - now;
-        if (diff > (int32_t)TIMER_MIN_TRY_TICKS)
-            // Schedule next timer normally.
-            return diff;
-
-        if (unlikely(timer_is_before(tru, now))) {
-            // Check if there are too many repeat timers
-            if (diff < (int32_t)(-timer_from_us(1000)))
-                try_shutdown("Rescheduled timer in the past");
-            if (sched_tasks_busy()) {
-                timer_repeat_until = now + TIMER_REPEAT_TICKS;
-                return TIMER_DEFER_REPEAT_TICKS;
-            }
-            timer_repeat_until = tru = now + TIMER_IDLE_REPEAT_TICKS;
-        }
-
-        // Next timer in the past or near future - wait for it to be ready
-        irq_enable();
-        while (unlikely(diff > 0))
-            diff = next - timer_read_time();
-        irq_disable();
-    }
-}
-
-// IRQ handler
-void __visible __aligned(16) // aligning helps stabilize perf benchmarks
-SysTick_Handler(void)
-{
-    irq_disable();
-    uint32_t diff = timer_dispatch_many();
-    timer_set_diff(diff);
-    irq_enable();
-}
-DECL_ARMCM_IRQ(SysTick_Handler, SysTick_IRQn);
-
-// Make sure timer_repeat_until doesn't wrap 32bit comparisons
-void
-timer_task(void)
-{
-    uint32_t now = timer_read_time();
-    irq_disable();
-    if (timer_is_before(timer_repeat_until, now))
-        timer_repeat_until = now;
-    irq_enable();
-}
-DECL_TASK(timer_task);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/armcm_timer.h crealityShit/src/generic/armcm_timer.h
--- klipperStock/src/generic/armcm_timer.h	2024-01-14 23:02:00.169796942 -0600
+++ crealityShit/src/generic/armcm_timer.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,8 +0,0 @@
-#ifndef __GENERIC_ARMCM_TIMER_H
-#define __GENERIC_ARMCM_TIMER_H
-
-#include <stdint.h> // uint32_t
-
-void udelay(uint32_t usecs);
-
-#endif // armcm_timer.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/canbus.c crealityShit/src/generic/canbus.c
--- klipperStock/src/generic/canbus.c	2024-01-14 23:02:00.173796990 -0600
+++ crealityShit/src/generic/canbus.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,36 +0,0 @@
-// Wrapper functions connecting canserial.c to low-level can hardware
-//
-// Copyright (C) 2022  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_CANBUS_FREQUENCY
-#include "canbus.h" // canhw_send
-#include "canserial.h" // canserial_notify_tx
-#include "command.h" // DECL_CONSTANT
-
-DECL_CONSTANT("CANBUS_FREQUENCY", CONFIG_CANBUS_FREQUENCY);
-
-int
-canbus_send(struct canbus_msg *msg)
-{
-    return canhw_send(msg);
-}
-
-void
-canbus_set_filter(uint32_t id)
-{
-    canhw_set_filter(id);
-}
-
-void
-canbus_notify_tx(void)
-{
-    canserial_notify_tx();
-}
-
-void
-canbus_process_data(struct canbus_msg *msg)
-{
-    canserial_process_data(msg);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/canbus.h crealityShit/src/generic/canbus.h
--- klipperStock/src/generic/canbus.h	2024-01-14 23:02:00.173796990 -0600
+++ crealityShit/src/generic/canbus.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,30 +0,0 @@
-#ifndef __CANBUS_H__
-#define __CANBUS_H__
-
-#include <stdint.h> // uint32_t
-
-struct canbus_msg {
-    uint32_t id;
-    uint32_t dlc;
-    union {
-        uint8_t data[8];
-        uint32_t data32[2];
-    };
-};
-
-#define CANMSG_ID_RTR (1<<30)
-#define CANMSG_ID_EFF (1<<31)
-
-#define CANMSG_DATA_LEN(msg) ((msg)->dlc > 8 ? 8 : (msg)->dlc)
-
-// callbacks provided by board specific code
-int canhw_send(struct canbus_msg *msg);
-void canhw_set_filter(uint32_t id);
-
-// canbus.c
-int canbus_send(struct canbus_msg *msg);
-void canbus_set_filter(uint32_t id);
-void canbus_notify_tx(void);
-void canbus_process_data(struct canbus_msg *msg);
-
-#endif // canbus.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/canserial.c crealityShit/src/generic/canserial.c
--- klipperStock/src/generic/canserial.c	2024-01-14 23:02:00.181797089 -0600
+++ crealityShit/src/generic/canserial.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,343 +0,0 @@
-// Generic handling of serial over CAN support
-//
-// Copyright (C) 2019 Eug Krashtan <eug.krashtan@gmail.com>
-// Copyright (C) 2020 Pontus Borg <glpontus@gmail.com>
-// Copyright (C) 2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memcpy
-#include "board/io.h" // readb
-#include "board/irq.h" // irq_save
-#include "board/misc.h" // console_sendf
-#include "canbus.h" // canbus_send
-#include "canserial.h" // canserial_notify_tx
-#include "command.h" // DECL_CONSTANT
-#include "fasthash.h" // fasthash64
-#include "sched.h" // sched_wake_task
-
-#define CANBUS_UUID_LEN 6
-
-// Global storage
-static struct canbus_data {
-    uint32_t assigned_id;
-    uint8_t uuid[CANBUS_UUID_LEN];
-
-    // Tx data
-    struct task_wake tx_wake;
-    uint8_t transmit_pos, transmit_max;
-
-    // Rx data
-    struct task_wake rx_wake;
-    uint8_t receive_pos;
-    uint32_t admin_pull_pos, admin_push_pos;
-
-    // Transfer buffers
-    struct canbus_msg admin_queue[8];
-    uint8_t transmit_buf[96];
-    uint8_t receive_buf[192];
-} CanData;
-
-
-/****************************************************************
- * Data transmission over CAN
- ****************************************************************/
-
-void
-canserial_notify_tx(void)
-{
-    sched_wake_task(&CanData.tx_wake);
-}
-
-void
-canserial_tx_task(void)
-{
-    if (!sched_check_wake(&CanData.tx_wake))
-        return;
-    uint32_t id = CanData.assigned_id;
-    if (!id) {
-        CanData.transmit_pos = CanData.transmit_max = 0;
-        return;
-    }
-    struct canbus_msg msg;
-    msg.id = id + 1;
-    uint32_t tpos = CanData.transmit_pos, tmax = CanData.transmit_max;
-    for (;;) {
-        int avail = tmax - tpos, now = avail > 8 ? 8 : avail;
-        if (avail <= 0)
-            break;
-        msg.dlc = now;
-        memcpy(msg.data, &CanData.transmit_buf[tpos], now);
-        int ret = canbus_send(&msg);
-        if (ret <= 0)
-            break;
-        tpos += now;
-    }
-    CanData.transmit_pos = tpos;
-}
-DECL_TASK(canserial_tx_task);
-
-// Encode and transmit a "response" message
-void
-console_sendf(const struct command_encoder *ce, va_list args)
-{
-    // Verify space for message
-    uint32_t tpos = CanData.transmit_pos, tmax = CanData.transmit_max;
-    if (tpos >= tmax)
-        CanData.transmit_pos = CanData.transmit_max = tpos = tmax = 0;
-    uint32_t max_size = ce->max_size;
-    if (tmax + max_size > sizeof(CanData.transmit_buf)) {
-        if (tmax + max_size - tpos > sizeof(CanData.transmit_buf))
-            // Not enough space for message
-            return;
-        // Move buffer
-        tmax -= tpos;
-        memmove(&CanData.transmit_buf[0], &CanData.transmit_buf[tpos], tmax);
-        CanData.transmit_pos = tpos = 0;
-        CanData.transmit_max = tmax;
-    }
-
-    // Generate message
-    uint32_t msglen = command_encode_and_frame(&CanData.transmit_buf[tmax]
-                                               , ce, args);
-
-    // Start message transmit
-    CanData.transmit_max = tmax + msglen;
-    canserial_notify_tx();
-}
-
-
-/****************************************************************
- * CAN "admin" command handling
- ****************************************************************/
-
-// Available commands and responses
-#define CANBUS_CMD_QUERY_UNASSIGNED 0x00
-#define CANBUS_CMD_SET_KLIPPER_NODEID 0x01
-#define CANBUS_CMD_REQUEST_BOOTLOADER 0x02
-#define CANBUS_RESP_NEED_NODEID 0x20
-
-// Helper to verify a UUID in a command matches this chip's UUID
-static int
-can_check_uuid(struct canbus_msg *msg)
-{
-    return (msg->dlc >= 7
-            && memcmp(&msg->data[1], CanData.uuid, sizeof(CanData.uuid)) == 0);
-}
-
-// Helpers to encode/decode a CAN identifier to a 1-byte "nodeid"
-static int
-can_get_nodeid(void)
-{
-    if (!CanData.assigned_id)
-        return 0;
-    return (CanData.assigned_id - 0x100) >> 1;
-}
-static uint32_t
-can_decode_nodeid(int nodeid)
-{
-    return (nodeid << 1) + 0x100;
-}
-
-static void
-can_process_query_unassigned(struct canbus_msg *msg)
-{
-    if (CanData.assigned_id)
-        return;
-    struct canbus_msg send;
-    send.id = CANBUS_ID_ADMIN_RESP;
-    send.dlc = 8;
-    send.data[0] = CANBUS_RESP_NEED_NODEID;
-    memcpy(&send.data[1], CanData.uuid, sizeof(CanData.uuid));
-    send.data[7] = CANBUS_CMD_SET_KLIPPER_NODEID;
-    // Send with retry
-    for (;;) {
-        int ret = canbus_send(&send);
-        if (ret >= 0)
-            return;
-    }
-}
-
-static void
-can_id_conflict(void)
-{
-    CanData.assigned_id = 0;
-    canbus_set_filter(CanData.assigned_id);
-    shutdown("Another CAN node assigned this ID");
-}
-
-static void
-can_process_set_klipper_nodeid(struct canbus_msg *msg)
-{
-    if (msg->dlc < 8)
-        return;
-    uint32_t newid = can_decode_nodeid(msg->data[7]);
-    if (can_check_uuid(msg)) {
-        if (newid != CanData.assigned_id) {
-            CanData.assigned_id = newid;
-            canbus_set_filter(CanData.assigned_id);
-        }
-    } else if (newid == CanData.assigned_id) {
-        can_id_conflict();
-    }
-}
-
-static void
-can_process_request_bootloader(struct canbus_msg *msg)
-{
-    if (!can_check_uuid(msg))
-        return;
-    bootloader_request();
-}
-
-// Handle an "admin" command
-static void
-can_process_admin(struct canbus_msg *msg)
-{
-    if (!msg->dlc)
-        return;
-    switch (msg->data[0]) {
-    case CANBUS_CMD_QUERY_UNASSIGNED:
-        can_process_query_unassigned(msg);
-        break;
-    case CANBUS_CMD_SET_KLIPPER_NODEID:
-        can_process_set_klipper_nodeid(msg);
-        break;
-    case CANBUS_CMD_REQUEST_BOOTLOADER:
-        can_process_request_bootloader(msg);
-        break;
-    }
-}
-
-
-/****************************************************************
- * CAN packet reading
- ****************************************************************/
-
-static void
-canserial_notify_rx(void)
-{
-    sched_wake_task(&CanData.rx_wake);
-}
-
-DECL_CONSTANT("RECEIVE_WINDOW", ARRAY_SIZE(CanData.receive_buf));
-
-// Handle incoming data (called from IRQ handler)
-int
-canserial_process_data(struct canbus_msg *msg)
-{
-    uint32_t id = msg->id;
-    if (CanData.assigned_id && id == CanData.assigned_id) {
-        // Add to incoming data buffer
-        int rpos = CanData.receive_pos;
-        uint32_t len = CANMSG_DATA_LEN(msg);
-        if (len > sizeof(CanData.receive_buf) - rpos)
-            return -1;
-        memcpy(&CanData.receive_buf[rpos], msg->data, len);
-        CanData.receive_pos = rpos + len;
-        canserial_notify_rx();
-    } else if (id == CANBUS_ID_ADMIN
-               || (CanData.assigned_id && id == CanData.assigned_id + 1)) {
-        // Add to admin command queue
-        uint32_t pushp = CanData.admin_push_pos;
-        if (pushp >= CanData.admin_pull_pos + ARRAY_SIZE(CanData.admin_queue))
-            // No space - drop message
-            return -1;
-        uint32_t pos = pushp % ARRAY_SIZE(CanData.admin_queue);
-        memcpy(&CanData.admin_queue[pos], msg, sizeof(*msg));
-        CanData.admin_push_pos = pushp + 1;
-        canserial_notify_rx();
-    }
-    return 0;
-}
-
-// Remove from the receive buffer the given number of bytes
-static void
-console_pop_input(int len)
-{
-    int copied = 0;
-    for (;;) {
-        int rpos = readb(&CanData.receive_pos);
-        int needcopy = rpos - len;
-        if (needcopy) {
-            memmove(&CanData.receive_buf[copied]
-                    , &CanData.receive_buf[copied + len], needcopy - copied);
-            copied = needcopy;
-            canserial_notify_rx();
-        }
-        irqstatus_t flag = irq_save();
-        if (rpos != readb(&CanData.receive_pos)) {
-            // Raced with irq handler - retry
-            irq_restore(flag);
-            continue;
-        }
-        CanData.receive_pos = needcopy;
-        irq_restore(flag);
-        break;
-    }
-}
-
-// Task to process incoming commands and admin messages
-void
-canserial_rx_task(void)
-{
-    if (!sched_check_wake(&CanData.rx_wake))
-        return;
-
-    // Process pending admin messages
-    for (;;) {
-        uint32_t pushp = readl(&CanData.admin_push_pos);
-        uint32_t pullp = CanData.admin_pull_pos;
-        if (pushp == pullp)
-            break;
-        uint32_t pos = pullp % ARRAY_SIZE(CanData.admin_queue);
-        struct canbus_msg *msg = &CanData.admin_queue[pos];
-        uint32_t id = msg->id;
-        if (CanData.assigned_id && id == CanData.assigned_id + 1)
-            can_id_conflict();
-        else if (id == CANBUS_ID_ADMIN)
-            can_process_admin(msg);
-        CanData.admin_pull_pos = pullp + 1;
-    }
-
-    // Check for a complete message block and process it
-    uint_fast8_t rpos = readb(&CanData.receive_pos), pop_count;
-    int ret = command_find_block(CanData.receive_buf, rpos, &pop_count);
-    if (ret > 0)
-        command_dispatch(CanData.receive_buf, pop_count);
-    if (ret) {
-        console_pop_input(pop_count);
-        if (ret > 0)
-            command_send_ack();
-    }
-}
-DECL_TASK(canserial_rx_task);
-
-
-/****************************************************************
- * Setup and shutdown
- ****************************************************************/
-
-void
-command_get_canbus_id(uint32_t *args)
-{
-    sendf("canbus_id canbus_uuid=%.*s canbus_nodeid=%u"
-          , sizeof(CanData.uuid), CanData.uuid, can_get_nodeid());
-}
-DECL_COMMAND_FLAGS(command_get_canbus_id, HF_IN_SHUTDOWN, "get_canbus_id");
-
-void
-canserial_set_uuid(uint8_t *raw_uuid, uint32_t raw_uuid_len)
-{
-    uint64_t hash = fasthash64(raw_uuid, raw_uuid_len, 0xA16231A7);
-    memcpy(CanData.uuid, &hash, sizeof(CanData.uuid));
-    canserial_notify_rx();
-}
-
-void
-canserial_shutdown(void)
-{
-    canserial_notify_tx();
-    canserial_notify_rx();
-}
-DECL_SHUTDOWN(canserial_shutdown);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/canserial.h crealityShit/src/generic/canserial.h
--- klipperStock/src/generic/canserial.h	2024-01-14 23:02:00.177797038 -0600
+++ crealityShit/src/generic/canserial.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,15 +0,0 @@
-#ifndef __CANSERIAL_H__
-#define __CANSERIAL_H__
-
-#include <stdint.h> // uint32_t
-
-#define CANBUS_ID_ADMIN 0x3f0
-#define CANBUS_ID_ADMIN_RESP 0x3f1
-
-// canserial.c
-void canserial_notify_tx(void);
-struct canbus_msg;
-int canserial_process_data(struct canbus_msg *msg);
-void canserial_set_uuid(uint8_t *raw_uuid, uint32_t raw_uuid_len);
-
-#endif // canserial.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/crc16_ccitt.c crealityShit/src/generic/crc16_ccitt.c
--- klipperStock/src/generic/crc16_ccitt.c	2024-01-14 23:02:00.177797038 -0600
+++ crealityShit/src/generic/crc16_ccitt.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,22 +0,0 @@
-// Code for crc16_ccitt
-//
-// Copyright (C) 2016  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "misc.h" // crc16_ccitt
-
-// Implement the standard crc "ccitt" algorithm on the given buffer
-uint16_t
-crc16_ccitt(uint8_t *buf, uint_fast8_t len)
-{
-    uint16_t crc = 0xffff;
-    while (len--) {
-        uint8_t data = *buf++;
-        data ^= crc & 0xff;
-        data ^= data << 4;
-        crc = ((((uint16_t)data << 8) | (crc >> 8)) ^ (uint8_t)(data >> 4)
-               ^ ((uint16_t)data << 3));
-    }
-    return crc;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/gpio.h crealityShit/src/generic/gpio.h
--- klipperStock/src/generic/gpio.h	2024-01-14 23:02:00.173796990 -0600
+++ crealityShit/src/generic/gpio.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,44 +0,0 @@
-#ifndef __GENERIC_GPIO_H
-#define __GENERIC_GPIO_H
-
-#include <stdint.h> // uint8_t
-
-struct gpio_out {
-    uint8_t pin;
-};
-struct gpio_out gpio_out_setup(uint8_t pin, uint8_t val);
-void gpio_out_reset(struct gpio_out g, uint8_t val);
-void gpio_out_toggle_noirq(struct gpio_out g);
-void gpio_out_toggle(struct gpio_out g);
-void gpio_out_write(struct gpio_out g, uint8_t val);
-
-struct gpio_in {
-    uint8_t pin;
-};
-struct gpio_in gpio_in_setup(uint8_t pin, int8_t pull_up);
-void gpio_in_reset(struct gpio_in g, int8_t pull_up);
-uint8_t gpio_in_read(struct gpio_in g);
-
-struct gpio_pwm {
-    uint8_t pin;
-};
-struct gpio_pwm gpio_pwm_setup(uint8_t pin, uint32_t cycle_time, uint8_t val);
-void gpio_pwm_write(struct gpio_pwm g, uint8_t val);
-
-struct gpio_adc {
-    uint8_t pin;
-};
-struct gpio_adc gpio_adc_setup(uint8_t pin);
-uint32_t gpio_adc_sample(struct gpio_adc g);
-uint16_t gpio_adc_read(struct gpio_adc g);
-void gpio_adc_cancel_sample(struct gpio_adc g);
-
-struct spi_config {
-    uint32_t cfg;
-};
-struct spi_config spi_setup(uint32_t bus, uint8_t mode, uint32_t rate);
-void spi_prepare(struct spi_config config);
-void spi_transfer(struct spi_config config, uint8_t receive_data
-                  , uint8_t len, uint8_t *data);
-
-#endif // gpio.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/io.h crealityShit/src/generic/io.h
--- klipperStock/src/generic/io.h	2024-01-14 23:02:00.181797089 -0600
+++ crealityShit/src/generic/io.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,35 +0,0 @@
-#ifndef __GENERIC_IO_H
-#define __GENERIC_IO_H
-
-#include <stdint.h> // uint32_t
-#include "compiler.h" // barrier
-
-static inline void writel(void *addr, uint32_t val) {
-    barrier();
-    *(volatile uint32_t *)addr = val;
-}
-static inline void writew(void *addr, uint16_t val) {
-    barrier();
-    *(volatile uint16_t *)addr = val;
-}
-static inline void writeb(void *addr, uint8_t val) {
-    barrier();
-    *(volatile uint8_t *)addr = val;
-}
-static inline uint32_t readl(const void *addr) {
-    uint32_t val = *(volatile const uint32_t *)addr;
-    barrier();
-    return val;
-}
-static inline uint16_t readw(const void *addr) {
-    uint16_t val = *(volatile const uint16_t *)addr;
-    barrier();
-    return val;
-}
-static inline uint8_t readb(const void *addr) {
-    uint8_t val = *(volatile const uint8_t *)addr;
-    barrier();
-    return val;
-}
-
-#endif // io.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/irq.h crealityShit/src/generic/irq.h
--- klipperStock/src/generic/irq.h	2024-01-14 23:02:00.181797089 -0600
+++ crealityShit/src/generic/irq.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,13 +0,0 @@
-#ifndef __GENERIC_IRQ_H
-#define __GENERIC_IRQ_H
-
-typedef unsigned long irqstatus_t;
-
-void irq_disable(void);
-void irq_enable(void);
-irqstatus_t irq_save(void);
-void irq_restore(irqstatus_t flag);
-void irq_wait(void);
-void irq_poll(void);
-
-#endif // irq.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/misc.h crealityShit/src/generic/misc.h
--- klipperStock/src/generic/misc.h	2024-01-14 23:02:00.169796942 -0600
+++ crealityShit/src/generic/misc.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,23 +0,0 @@
-#ifndef __GENERIC_MISC_H
-#define __GENERIC_MISC_H
-
-#include <stdarg.h> // va_list
-#include <stdint.h> // uint8_t
-
-struct command_encoder;
-void console_sendf(const struct command_encoder *ce, va_list args);
-void *console_receive_buffer(void);
-
-uint32_t timer_from_us(uint32_t us);
-uint8_t timer_is_before(uint32_t time1, uint32_t time2);
-uint32_t timer_read_time(void);
-void timer_kick(void);
-
-void *dynmem_start(void);
-void *dynmem_end(void);
-
-uint16_t crc16_ccitt(uint8_t *buf, uint_fast8_t len);
-
-void bootloader_request(void);
-
-#endif // misc.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/pgm.h crealityShit/src/generic/pgm.h
--- klipperStock/src/generic/pgm.h	2024-01-14 23:02:00.185797137 -0600
+++ crealityShit/src/generic/pgm.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,14 +0,0 @@
-#ifndef __GENERIC_PGM_H
-#define __GENERIC_PGM_H
-// This header provides wrappers for the AVR specific "PROGMEM"
-// declarations on non-avr platforms.
-
-#define NEED_PROGMEM 0
-#define PROGMEM
-#define PSTR(S) S
-#define READP(VAR) VAR
-#define vsnprintf_P(D, S, F, A) vsnprintf(D, S, F, A)
-#define strcasecmp_P(S1, S2) strcasecmp(S1, S2)
-#define memcpy_P(DST, SRC, SIZE) memcpy((DST), (SRC), (SIZE))
-
-#endif // pgm.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/serial_irq.c crealityShit/src/generic/serial_irq.c
--- klipperStock/src/generic/serial_irq.c	2024-01-14 23:02:00.173796990 -0600
+++ crealityShit/src/generic/serial_irq.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,125 +0,0 @@
-// Generic interrupt based serial uart helper code
-//
-// Copyright (C) 2016-2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memmove
-#include "autoconf.h" // CONFIG_SERIAL_BAUD
-#include "board/io.h" // readb
-#include "board/irq.h" // irq_save
-#include "board/misc.h" // console_sendf
-#include "board/pgm.h" // READP
-#include "command.h" // DECL_CONSTANT
-#include "sched.h" // sched_wake_tasks
-#include "serial_irq.h" // serial_enable_tx_irq
-
-#define RX_BUFFER_SIZE 192
-
-static uint8_t receive_buf[RX_BUFFER_SIZE], receive_pos;
-static uint8_t transmit_buf[96], transmit_pos, transmit_max;
-
-DECL_CONSTANT("SERIAL_BAUD", CONFIG_SERIAL_BAUD);
-DECL_CONSTANT("RECEIVE_WINDOW", RX_BUFFER_SIZE);
-
-// Rx interrupt - store read data
-void
-serial_rx_byte(uint_fast8_t data)
-{
-    if (data == MESSAGE_SYNC)
-        sched_wake_tasks();
-    if (receive_pos >= sizeof(receive_buf))
-        // Serial overflow - ignore it as crc error will force retransmit
-        return;
-    receive_buf[receive_pos++] = data;
-}
-
-// Tx interrupt - get next byte to transmit
-int
-serial_get_tx_byte(uint8_t *pdata)
-{
-    if (transmit_pos >= transmit_max)
-        return -1;
-    *pdata = transmit_buf[transmit_pos++];
-    return 0;
-}
-
-// Remove from the receive buffer the given number of bytes
-static void
-console_pop_input(uint_fast8_t len)
-{
-    uint_fast8_t copied = 0;
-    for (;;) {
-        uint_fast8_t rpos = readb(&receive_pos);
-        uint_fast8_t needcopy = rpos - len;
-        if (needcopy) {
-            memmove(&receive_buf[copied], &receive_buf[copied + len]
-                    , needcopy - copied);
-            copied = needcopy;
-            sched_wake_tasks();
-        }
-        irqstatus_t flag = irq_save();
-        if (rpos != readb(&receive_pos)) {
-            // Raced with irq handler - retry
-            irq_restore(flag);
-            continue;
-        }
-        receive_pos = needcopy;
-        irq_restore(flag);
-        break;
-    }
-}
-
-// Process any incoming commands
-void
-console_task(void)
-{
-    uint_fast8_t rpos = readb(&receive_pos), pop_count;
-    int_fast8_t ret = command_find_block(receive_buf, rpos, &pop_count);
-    if (ret > 0)
-        command_dispatch(receive_buf, pop_count);
-    if (ret) {
-        if (CONFIG_SERIAL_BOOTLOADER_SIDECHANNEL && ret < 0 && pop_count == 32
-            && !memcmp(receive_buf, " \x1c Request Serial Bootloader!! ~", 32))
-            bootloader_request();
-        console_pop_input(pop_count);
-        if (ret > 0)
-            command_send_ack();
-    }
-}
-DECL_TASK(console_task);
-
-// Encode and transmit a "response" message
-void
-console_sendf(const struct command_encoder *ce, va_list args)
-{
-    // Verify space for message
-    uint_fast8_t tpos = readb(&transmit_pos), tmax = readb(&transmit_max);
-    if (tpos >= tmax) {
-        tpos = tmax = 0;
-        writeb(&transmit_max, 0);
-        writeb(&transmit_pos, 0);
-    }
-    uint_fast8_t max_size = READP(ce->max_size);
-    if (tmax + max_size > sizeof(transmit_buf)) {
-        if (tmax + max_size - tpos > sizeof(transmit_buf))
-            // Not enough space for message
-            return;
-        // Disable TX irq and move buffer
-        writeb(&transmit_max, 0);
-        tpos = readb(&transmit_pos);
-        tmax -= tpos;
-        memmove(&transmit_buf[0], &transmit_buf[tpos], tmax);
-        writeb(&transmit_pos, 0);
-        writeb(&transmit_max, tmax);
-        serial_enable_tx_irq();
-    }
-
-    // Generate message
-    uint8_t *buf = &transmit_buf[tmax];
-    uint_fast8_t msglen = command_encode_and_frame(buf, ce, args);
-
-    // Start message transmit
-    writeb(&transmit_max, tmax + msglen);
-    serial_enable_tx_irq();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/serial_irq.h crealityShit/src/generic/serial_irq.h
--- klipperStock/src/generic/serial_irq.h	2024-01-14 23:02:00.177797038 -0600
+++ crealityShit/src/generic/serial_irq.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,13 +0,0 @@
-#ifndef __GENERIC_SERIAL_IRQ_H
-#define __GENERIC_SERIAL_IRQ_H
-
-#include <stdint.h> // uint32_t
-
-// callback provided by board specific code
-void serial_enable_tx_irq(void);
-
-// serial_irq.c
-void serial_rx_byte(uint_fast8_t data);
-int serial_get_tx_byte(uint8_t *pdata);
-
-#endif // serial_irq.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/timer_irq.c crealityShit/src/generic/timer_irq.c
--- klipperStock/src/generic/timer_irq.c	2024-01-14 23:02:00.173796990 -0600
+++ crealityShit/src/generic/timer_irq.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,83 +0,0 @@
-// Generic interrupt based timer helper functions
-//
-// Copyright (C) 2017  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_CLOCK_FREQ
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_from_us
-#include "board/timer_irq.h" // timer_dispatch_many
-#include "command.h" // shutdown
-#include "sched.h" // sched_timer_dispatch
-
-DECL_CONSTANT("CLOCK_FREQ", CONFIG_CLOCK_FREQ);
-
-// Return the number of clock ticks for a given number of microseconds
-uint32_t
-timer_from_us(uint32_t us)
-{
-    return us * (CONFIG_CLOCK_FREQ / 1000000);
-}
-
-// Return true if time1 is before time2.  Always use this function to
-// compare times as regular C comparisons can fail if the counter
-// rolls over.
-uint8_t
-timer_is_before(uint32_t time1, uint32_t time2)
-{
-    return (int32_t)(time1 - time2) < 0;
-}
-
-static uint32_t timer_repeat_until;
-#define TIMER_IDLE_REPEAT_TICKS timer_from_us(500)
-#define TIMER_REPEAT_TICKS timer_from_us(100)
-
-#define TIMER_MIN_TRY_TICKS timer_from_us(2)
-#define TIMER_DEFER_REPEAT_TICKS timer_from_us(5)
-
-// Invoke timers - called from board irq code.
-uint32_t
-timer_dispatch_many(void)
-{
-    uint32_t tru = timer_repeat_until;
-    for (;;) {
-        // Run the next software timer
-        uint32_t next = sched_timer_dispatch();
-
-        uint32_t now = timer_read_time();
-        int32_t diff = next - now;
-        if (diff > (int32_t)TIMER_MIN_TRY_TICKS)
-            // Schedule next timer normally.
-            return next;
-
-        if (unlikely(timer_is_before(tru, now))) {
-            // Check if there are too many repeat timers
-            if (diff < (int32_t)(-timer_from_us(1000)))
-                try_shutdown("Rescheduled timer in the past");
-            if (sched_tasks_busy()) {
-                timer_repeat_until = now + TIMER_REPEAT_TICKS;
-                return now + TIMER_DEFER_REPEAT_TICKS;
-            }
-            timer_repeat_until = tru = now + TIMER_IDLE_REPEAT_TICKS;
-        }
-
-        // Next timer in the past or near future - wait for it to be ready
-        irq_enable();
-        while (unlikely(diff > 0))
-            diff = next - timer_read_time();
-        irq_disable();
-    }
-}
-
-// Make sure timer_repeat_until doesn't wrap 32bit comparisons
-void
-timer_task(void)
-{
-    uint32_t now = timer_read_time();
-    irq_disable();
-    if (timer_is_before(timer_repeat_until, now))
-        timer_repeat_until = now;
-    irq_enable();
-}
-DECL_TASK(timer_task);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/timer_irq.h crealityShit/src/generic/timer_irq.h
--- klipperStock/src/generic/timer_irq.h	2024-01-14 23:02:00.177797038 -0600
+++ crealityShit/src/generic/timer_irq.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,6 +0,0 @@
-#ifndef __GENERIC_TIMER_IRQ_H
-#define __GENERIC_TIMER_IRQ_H
-
-uint32_t timer_dispatch_many(void);
-
-#endif // timer_irq.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/usb_canbus.c crealityShit/src/generic/usb_canbus.c
--- klipperStock/src/generic/usb_canbus.c	2024-01-14 23:02:00.181797089 -0600
+++ crealityShit/src/generic/usb_canbus.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,678 +0,0 @@
-// Support for Linux "gs_usb" CANbus adapter emulation
-//
-// Copyright (C) 2018-2022  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memmove
-#include "autoconf.h" // CONFIG_USB_VENDOR_ID
-#include "board/canbus.h" // canbus_notify_tx
-#include "board/canserial.h" // canserial_notify_tx
-#include "board/io.h" // readl
-#include "board/misc.h" // console_sendf
-#include "board/pgm.h" // PROGMEM
-#include "board/usb_cdc_ep.h" // USB_CDC_EP_BULK_IN
-#include "byteorder.h" // cpu_to_le16
-#include "command.h" // DECL_CONSTANT
-#include "generic/usbstd.h" // struct usb_device_descriptor
-#include "sched.h" // sched_wake_task
-#include "usb_cdc.h" // usb_notify_ep0
-
-
-/****************************************************************
- * Linux "gs_usb" definitions
- ****************************************************************/
-
-#define USB_GSUSB_1_VENDOR_ID      0x1d50
-#define USB_GSUSB_1_PRODUCT_ID     0x606f
-
-enum gs_usb_breq {
-    GS_USB_BREQ_HOST_FORMAT = 0,
-    GS_USB_BREQ_BITTIMING,
-    GS_USB_BREQ_MODE,
-    GS_USB_BREQ_BERR,
-    GS_USB_BREQ_BT_CONST,
-    GS_USB_BREQ_DEVICE_CONFIG,
-    GS_USB_BREQ_TIMESTAMP,
-    GS_USB_BREQ_IDENTIFY,
-    GS_USB_BREQ_GET_USER_ID,
-    GS_USB_BREQ_SET_USER_ID,
-    GS_USB_BREQ_DATA_BITTIMING,
-    GS_USB_BREQ_BT_CONST_EXT,
-};
-
-struct gs_host_config {
-    uint32_t byte_order;
-} __packed;
-
-struct gs_device_config {
-    uint8_t reserved1;
-    uint8_t reserved2;
-    uint8_t reserved3;
-    uint8_t icount;
-    uint32_t sw_version;
-    uint32_t hw_version;
-} __packed;
-
-struct gs_device_bt_const {
-    uint32_t feature;
-    uint32_t fclk_can;
-    uint32_t tseg1_min;
-    uint32_t tseg1_max;
-    uint32_t tseg2_min;
-    uint32_t tseg2_max;
-    uint32_t sjw_max;
-    uint32_t brp_min;
-    uint32_t brp_max;
-    uint32_t brp_inc;
-} __packed;
-
-struct gs_device_bittiming {
-    uint32_t prop_seg;
-    uint32_t phase_seg1;
-    uint32_t phase_seg2;
-    uint32_t sjw;
-    uint32_t brp;
-} __packed;
-
-struct gs_device_mode {
-    uint32_t mode;
-    uint32_t flags;
-} __packed;
-
-struct gs_host_frame {
-    uint32_t echo_id;
-    uint32_t can_id;
-
-    uint8_t can_dlc;
-    uint8_t channel;
-    uint8_t flags;
-    uint8_t reserved;
-
-    union {
-        uint8_t data[8];
-        uint32_t data32[2];
-    };
-} __packed;
-
-
-/****************************************************************
- * Message sending
- ****************************************************************/
-
-// Global storage
-static struct usbcan_data {
-    struct task_wake wake;
-
-    // Canbus data from host
-    union {
-        struct gs_host_frame host_frame;
-        uint8_t rx_frame_pad[USB_CDC_EP_BULK_OUT_SIZE];
-    };
-    uint8_t host_status;
-
-    // Canbus data routed locally
-    uint8_t notify_local;
-    uint32_t assigned_id;
-
-    // Data from physical canbus interface
-    uint32_t pull_pos, push_pos;
-    struct canbus_msg queue[8];
-} UsbCan;
-
-enum {
-    HS_TX_ECHO = 1,
-    HS_TX_HW = 2,
-    HS_TX_LOCAL = 4,
-};
-
-DECL_CONSTANT("CANBUS_BRIDGE", 1);
-
-void
-canbus_notify_tx(void)
-{
-    sched_wake_task(&UsbCan.wake);
-}
-
-// Handle incoming data from hw canbus interface (called from IRQ handler)
-void
-canbus_process_data(struct canbus_msg *msg)
-{
-    // Add to admin command queue
-    uint32_t pushp = UsbCan.push_pos;
-    if (pushp - UsbCan.pull_pos >= ARRAY_SIZE(UsbCan.queue))
-        // No space - drop message
-        return;
-    if (UsbCan.assigned_id && (msg->id & ~1) == UsbCan.assigned_id)
-        // Id reserved for local
-        return;
-    uint32_t pos = pushp % ARRAY_SIZE(UsbCan.queue);
-    memcpy(&UsbCan.queue[pos], msg, sizeof(*msg));
-    UsbCan.push_pos = pushp + 1;
-    usb_notify_bulk_out();
-}
-
-// Send a message to the Linux host
-static int
-send_frame(struct canbus_msg *msg)
-{
-    struct gs_host_frame gs = {};
-    gs.echo_id = 0xffffffff;
-    gs.can_id = msg->id;
-    gs.can_dlc = msg->dlc;
-    gs.data32[0] = msg->data32[0];
-    gs.data32[1] = msg->data32[1];
-    return usb_send_bulk_in(&gs, sizeof(gs));
-}
-
-// Send any pending hw frames to host
-static int
-drain_hw_queue(void)
-{
-    for (;;) {
-        uint32_t push_pos = readl(&UsbCan.push_pos);
-        uint32_t pull_pos = UsbCan.pull_pos;
-        if (push_pos != pull_pos) {
-            uint32_t pos = pull_pos % ARRAY_SIZE(UsbCan.queue);
-            int ret = send_frame(&UsbCan.queue[pos]);
-            if (ret < 0)
-                return -1;
-            UsbCan.pull_pos = pull_pos + 1;
-            continue;
-        }
-        return 0;
-    }
-}
-
-void
-usbcan_task(void)
-{
-    if (!sched_check_wake(&UsbCan.wake))
-        return;
-    for (;;) {
-        // Send any pending hw frames to host
-        int ret = drain_hw_queue();
-        if (ret < 0)
-            return;
-
-        // See if previous host frame needs to be transmitted
-        uint_fast8_t host_status = UsbCan.host_status;
-        if (host_status & (HS_TX_HW | HS_TX_LOCAL)) {
-            struct gs_host_frame *gs = &UsbCan.host_frame;
-            struct canbus_msg msg;
-            msg.id = gs->can_id;
-            msg.dlc = gs->can_dlc;
-            msg.data32[0] = gs->data32[0];
-            msg.data32[1] = gs->data32[1];
-            if (host_status & HS_TX_HW) {
-                ret = canhw_send(&msg);
-                if (ret < 0)
-                    return;
-                UsbCan.host_status = host_status = host_status & ~HS_TX_HW;
-            }
-            if (host_status & HS_TX_LOCAL) {
-                ret = canserial_process_data(&msg);
-                if (ret < 0) {
-                    usb_notify_bulk_out();
-                    return;
-                }
-                UsbCan.host_status = host_status & ~HS_TX_LOCAL;
-            }
-            continue;
-        }
-
-        // Send any previous echo frames
-        if (host_status) {
-            ret = usb_send_bulk_in(&UsbCan.host_frame
-                                   , sizeof(UsbCan.host_frame));
-            if (ret < 0)
-                return;
-            UsbCan.host_status = 0;
-            continue;
-        }
-
-        // See if can read a new frame from host
-        ret = usb_read_bulk_out(&UsbCan.host_frame, USB_CDC_EP_BULK_OUT_SIZE);
-        if (ret > 0) {
-            uint32_t id = UsbCan.host_frame.can_id;
-            UsbCan.host_status = HS_TX_ECHO | HS_TX_HW;
-            if (id == CANBUS_ID_ADMIN)
-                UsbCan.host_status = HS_TX_ECHO | HS_TX_HW | HS_TX_LOCAL;
-            else if (UsbCan.assigned_id && UsbCan.assigned_id == id)
-                UsbCan.host_status = HS_TX_ECHO | HS_TX_LOCAL;
-            continue;
-        }
-
-        // No more work to be done
-        if (UsbCan.notify_local) {
-            UsbCan.notify_local = 0;
-            canserial_notify_tx();
-        }
-        return;
-    }
-}
-DECL_TASK(usbcan_task);
-
-int
-canbus_send(struct canbus_msg *msg)
-{
-    int ret = drain_hw_queue();
-    if (ret < 0)
-        goto retry_later;
-    ret = send_frame(msg);
-    if (ret < 0)
-        goto retry_later;
-    UsbCan.notify_local = 0;
-    return msg->dlc;
-retry_later:
-    UsbCan.notify_local = 1;
-    return -1;
-}
-
-void
-canbus_set_filter(uint32_t id)
-{
-    UsbCan.assigned_id = id;
-}
-
-void
-usb_notify_bulk_out(void)
-{
-    canbus_notify_tx();
-}
-
-void
-usb_notify_bulk_in(void)
-{
-    canbus_notify_tx();
-}
-
-
-/****************************************************************
- * USB descriptors
- ****************************************************************/
-
-#define CONCAT1(a, b) a ## b
-#define CONCAT(a, b) CONCAT1(a, b)
-#define USB_STR_MANUFACTURER u"Klipper"
-#define USB_STR_PRODUCT CONCAT(u,CONFIG_MCU)
-#define USB_STR_SERIAL CONCAT(u,CONFIG_USB_SERIAL_NUMBER)
-
-// String descriptors
-enum {
-    USB_STR_ID_MANUFACTURER = 1, USB_STR_ID_PRODUCT, USB_STR_ID_SERIAL,
-};
-
-#define SIZE_cdc_string_langids (sizeof(cdc_string_langids) + 2)
-
-static const struct usb_string_descriptor cdc_string_langids PROGMEM = {
-    .bLength = SIZE_cdc_string_langids,
-    .bDescriptorType = USB_DT_STRING,
-    .data = { cpu_to_le16(USB_LANGID_ENGLISH_US) },
-};
-
-#define SIZE_cdc_string_manufacturer \
-    (sizeof(cdc_string_manufacturer) + sizeof(USB_STR_MANUFACTURER) - 2)
-
-static const struct usb_string_descriptor cdc_string_manufacturer PROGMEM = {
-    .bLength = SIZE_cdc_string_manufacturer,
-    .bDescriptorType = USB_DT_STRING,
-    .data = USB_STR_MANUFACTURER,
-};
-
-#define SIZE_cdc_string_product \
-    (sizeof(cdc_string_product) + sizeof(USB_STR_PRODUCT) - 2)
-
-static const struct usb_string_descriptor cdc_string_product PROGMEM = {
-    .bLength = SIZE_cdc_string_product,
-    .bDescriptorType = USB_DT_STRING,
-    .data = USB_STR_PRODUCT,
-};
-
-#define SIZE_cdc_string_serial \
-    (sizeof(cdc_string_serial) + sizeof(USB_STR_SERIAL) - 2)
-
-static const struct usb_string_descriptor cdc_string_serial PROGMEM = {
-    .bLength = SIZE_cdc_string_serial,
-    .bDescriptorType = USB_DT_STRING,
-    .data = USB_STR_SERIAL,
-};
-
-// Device descriptor
-static const struct usb_device_descriptor gs_device_descriptor PROGMEM = {
-    .bLength = sizeof(gs_device_descriptor),
-    .bDescriptorType = USB_DT_DEVICE,
-    .bcdUSB = cpu_to_le16(0x0200),
-    .bMaxPacketSize0 = USB_CDC_EP0_SIZE,
-    .idVendor = cpu_to_le16(USB_GSUSB_1_VENDOR_ID),
-    .idProduct = cpu_to_le16(USB_GSUSB_1_PRODUCT_ID),
-    .iManufacturer = USB_STR_ID_MANUFACTURER,
-    .iProduct = USB_STR_ID_PRODUCT,
-    .iSerialNumber = USB_STR_ID_SERIAL,
-    .bNumConfigurations = 1,
-};
-
-// Config descriptor
-static const struct config_s {
-    struct usb_config_descriptor config;
-    struct usb_interface_descriptor iface0;
-    struct usb_endpoint_descriptor ep1;
-    struct usb_endpoint_descriptor ep2;
-} PACKED gs_config_descriptor PROGMEM = {
-    .config = {
-        .bLength = sizeof(gs_config_descriptor.config),
-        .bDescriptorType = USB_DT_CONFIG,
-        .wTotalLength = cpu_to_le16(sizeof(gs_config_descriptor)),
-        .bNumInterfaces = 1,
-        .bConfigurationValue = 1,
-        .bmAttributes = 0xC0,
-        .bMaxPower = 50,
-    },
-    .iface0 = {
-        .bLength = sizeof(gs_config_descriptor.iface0),
-        .bDescriptorType = USB_DT_INTERFACE,
-        .bInterfaceNumber = 0,
-        .bNumEndpoints = 2,
-        .bInterfaceClass = 255,
-        .bInterfaceSubClass = 255,
-        .bInterfaceProtocol = 255,
-    },
-    .ep1 = {
-        .bLength = sizeof(gs_config_descriptor.ep1),
-        .bDescriptorType = USB_DT_ENDPOINT,
-        .bEndpointAddress = USB_CDC_EP_BULK_OUT,
-        .bmAttributes = USB_ENDPOINT_XFER_BULK,
-        .wMaxPacketSize = cpu_to_le16(USB_CDC_EP_BULK_OUT_SIZE),
-    },
-    .ep2 = {
-        .bLength = sizeof(gs_config_descriptor.ep2),
-        .bDescriptorType = USB_DT_ENDPOINT,
-        .bEndpointAddress = USB_CDC_EP_BULK_IN | USB_DIR_IN,
-        .bmAttributes = USB_ENDPOINT_XFER_BULK,
-        .wMaxPacketSize = cpu_to_le16(USB_CDC_EP_BULK_IN_SIZE),
-    },
-};
-
-// List of available descriptors
-static const struct descriptor_s {
-    uint_fast16_t wValue;
-    uint_fast16_t wIndex;
-    const void *desc;
-    uint_fast8_t size;
-} usb_descriptors[] PROGMEM = {
-    { USB_DT_DEVICE<<8, 0x0000,
-      &gs_device_descriptor, sizeof(gs_device_descriptor) },
-    { USB_DT_CONFIG<<8, 0x0000,
-      &gs_config_descriptor, sizeof(gs_config_descriptor) },
-    { USB_DT_STRING<<8, 0x0000,
-      &cdc_string_langids, SIZE_cdc_string_langids },
-    { (USB_DT_STRING<<8) | USB_STR_ID_MANUFACTURER, USB_LANGID_ENGLISH_US,
-      &cdc_string_manufacturer, SIZE_cdc_string_manufacturer },
-    { (USB_DT_STRING<<8) | USB_STR_ID_PRODUCT, USB_LANGID_ENGLISH_US,
-      &cdc_string_product, SIZE_cdc_string_product },
-#if !CONFIG_USB_SERIAL_NUMBER_CHIPID
-    { (USB_DT_STRING<<8) | USB_STR_ID_SERIAL, USB_LANGID_ENGLISH_US,
-      &cdc_string_serial, SIZE_cdc_string_serial },
-#endif
-};
-
-// Fill in a USB serial string descriptor from a chip id
-void
-usb_fill_serial(struct usb_string_descriptor *desc, int strlen, void *id)
-{
-    desc->bLength = sizeof(*desc) + strlen * sizeof(desc->data[0]);
-    desc->bDescriptorType = USB_DT_STRING;
-
-    uint8_t *src = id;
-    int i;
-    for (i = 0; i < strlen; i++) {
-        uint8_t c = i & 1 ? src[i/2] & 0x0f : src[i/2] >> 4;
-        desc->data[i] = c < 10 ? c + '0' : c - 10 + 'A';
-    }
-}
-
-
-/****************************************************************
- * USB endpoint 0 control message handling
- ****************************************************************/
-
-// State tracking
-enum {
-    UX_READ = 1<<0, UX_SEND = 1<<1, UX_SEND_PROGMEM = 1<<2, UX_SEND_ZLP = 1<<3
-};
-
-static void *usb_xfer_data;
-static uint8_t usb_xfer_size, usb_xfer_flags;
-
-// Set the USB "stall" condition
-static void
-usb_do_stall(void)
-{
-    usb_stall_ep0();
-    usb_xfer_flags = 0;
-}
-
-// Transfer data on the usb endpoint 0
-static void
-usb_do_xfer(void *data, uint_fast8_t size, uint_fast8_t flags)
-{
-    for (;;) {
-        uint_fast8_t xs = size;
-        if (xs > USB_CDC_EP0_SIZE)
-            xs = USB_CDC_EP0_SIZE;
-        int_fast8_t ret;
-        if (flags & UX_READ)
-            ret = usb_read_ep0(data, xs);
-        else if (NEED_PROGMEM && flags & UX_SEND_PROGMEM)
-            ret = usb_send_ep0_progmem(data, xs);
-        else
-            ret = usb_send_ep0(data, xs);
-        if (ret == xs) {
-            // Success
-            data += xs;
-            size -= xs;
-            if (!size) {
-                // Entire transfer completed successfully
-                if (flags & UX_READ) {
-                    // Send status packet at end of read
-                    flags = UX_SEND;
-                    continue;
-                }
-                if (xs == USB_CDC_EP0_SIZE && flags & UX_SEND_ZLP)
-                    // Must send zero-length-packet
-                    continue;
-                usb_xfer_flags = 0;
-                usb_notify_ep0();
-                return;
-            }
-            continue;
-        }
-        if (ret == -1) {
-            // Interface busy - retry later
-            usb_xfer_data = data;
-            usb_xfer_size = size;
-            usb_xfer_flags = flags;
-            return;
-        }
-        // Error
-        usb_do_stall();
-        return;
-    }
-}
-
-static void
-usb_req_get_descriptor(struct usb_ctrlrequest *req)
-{
-    if (req->bRequestType != USB_DIR_IN)
-        goto fail;
-    void *desc = NULL;
-    uint_fast8_t flags, size, i;
-    for (i=0; i<ARRAY_SIZE(usb_descriptors); i++) {
-        const struct descriptor_s *d = &usb_descriptors[i];
-        if (READP(d->wValue) == req->wValue
-            && READP(d->wIndex) == req->wIndex) {
-            flags = NEED_PROGMEM ? UX_SEND_PROGMEM : UX_SEND;
-            size = READP(d->size);
-            desc = (void*)READP(d->desc);
-        }
-    }
-    if (CONFIG_USB_SERIAL_NUMBER_CHIPID
-        && req->wValue == ((USB_DT_STRING<<8) | USB_STR_ID_SERIAL)
-        && req->wIndex == USB_LANGID_ENGLISH_US) {
-            struct usb_string_descriptor *usbserial_serialid;
-            usbserial_serialid = usbserial_get_serialid();
-            flags = UX_SEND;
-            size = usbserial_serialid->bLength;
-            desc = (void*)usbserial_serialid;
-    }
-    if (desc) {
-        if (size > req->wLength)
-            size = req->wLength;
-        else if (size < req->wLength)
-            flags |= UX_SEND_ZLP;
-        usb_do_xfer(desc, size, flags);
-        return;
-    }
-fail:
-    usb_do_stall();
-}
-
-static void
-usb_req_set_address(struct usb_ctrlrequest *req)
-{
-    if (req->bRequestType || req->wIndex || req->wLength) {
-        usb_do_stall();
-        return;
-    }
-    usb_set_address(req->wValue);
-}
-
-static void
-usb_req_set_configuration(struct usb_ctrlrequest *req)
-{
-    if (req->bRequestType || req->wValue != 1 || req->wIndex || req->wLength) {
-        usb_do_stall();
-        return;
-    }
-    usb_set_configure();
-    usb_notify_bulk_in();
-    usb_notify_bulk_out();
-    usb_do_xfer(NULL, 0, UX_SEND);
-}
-
-struct gs_host_config host_config;
-
-static void
-gs_breq_host_format(struct usb_ctrlrequest *req)
-{
-    // Like candlightfw, little-endian is always used.  Read and ignore value.
-    usb_do_xfer(&host_config, sizeof(host_config), UX_READ);
-}
-
-static const struct gs_device_config device_config PROGMEM = {
-    .sw_version = 2,
-    .hw_version = 1,
-};
-
-static void
-gs_breq_device_config(struct usb_ctrlrequest *req)
-{
-    usb_do_xfer((void*)&device_config, sizeof(device_config), UX_SEND);
-}
-
-static const struct gs_device_bt_const bt_const PROGMEM = {
-    // These are just dummy values for now
-    .feature = 0,
-    .fclk_can = 48000000,
-    .tseg1_min = 1,
-    .tseg1_max = 16,
-    .tseg2_min = 1,
-    .tseg2_max = 8,
-    .sjw_max = 4,
-    .brp_min = 1,
-    .brp_max = 1024,
-    .brp_inc = 1,
-};
-
-static void
-gs_breq_bt_const(struct usb_ctrlrequest *req)
-{
-    usb_do_xfer((void*)&bt_const, sizeof(bt_const), UX_SEND);
-}
-
-struct gs_device_bittiming device_bittiming;
-
-static void
-gs_breq_bittiming(struct usb_ctrlrequest *req)
-{
-    // Bit timing is ignored for now
-    usb_do_xfer(&device_bittiming, sizeof(device_bittiming), UX_READ);
-}
-
-struct gs_device_mode device_mode;
-
-static void
-gs_breq_mode(struct usb_ctrlrequest *req)
-{
-    // Mode is ignored for now
-    usb_do_xfer(&device_mode, sizeof(device_mode), UX_READ);
-}
-
-static void
-usb_state_ready(void)
-{
-    struct usb_ctrlrequest req;
-    int_fast8_t ret = usb_read_ep0_setup(&req, sizeof(req));
-    if (ret != sizeof(req))
-        return;
-    uint32_t req_type = req.bRequestType & USB_TYPE_MASK;
-    if (req_type == USB_TYPE_STANDARD) {
-        switch (req.bRequest) {
-        case USB_REQ_GET_DESCRIPTOR: usb_req_get_descriptor(&req); break;
-        case USB_REQ_SET_ADDRESS: usb_req_set_address(&req); break;
-        case USB_REQ_SET_CONFIGURATION: usb_req_set_configuration(&req); break;
-        default: usb_do_stall(); break;
-        }
-    } else if (req_type == USB_TYPE_VENDOR) {
-        switch (req.bRequest) {
-        case GS_USB_BREQ_HOST_FORMAT: gs_breq_host_format(&req); break;
-        case GS_USB_BREQ_DEVICE_CONFIG: gs_breq_device_config(&req); break;
-        case GS_USB_BREQ_BT_CONST: gs_breq_bt_const(&req); break;
-        case GS_USB_BREQ_BITTIMING: gs_breq_bittiming(&req); break;
-        case GS_USB_BREQ_MODE: gs_breq_mode(&req); break;
-        default: usb_do_stall(); break;
-        }
-    } else {
-        usb_do_stall();
-    }
-}
-
-// State tracking dispatch
-static struct task_wake usb_ep0_wake;
-
-void
-usb_notify_ep0(void)
-{
-    sched_wake_task(&usb_ep0_wake);
-}
-
-void
-usb_ep0_task(void)
-{
-    if (!sched_check_wake(&usb_ep0_wake))
-        return;
-    if (usb_xfer_flags)
-        usb_do_xfer(usb_xfer_data, usb_xfer_size, usb_xfer_flags);
-    else
-        usb_state_ready();
-}
-DECL_TASK(usb_ep0_task);
-
-void
-usb_shutdown(void)
-{
-    usb_notify_bulk_in();
-    usb_notify_bulk_out();
-    usb_notify_ep0();
-}
-DECL_SHUTDOWN(usb_shutdown);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/usb_cdc.c crealityShit/src/generic/usb_cdc.c
--- klipperStock/src/generic/usb_cdc.c	2024-01-14 23:02:00.177797038 -0600
+++ crealityShit/src/generic/usb_cdc.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,535 +0,0 @@
-// Support for standard serial port over USB emulation
-//
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memmove
-#include "autoconf.h" // CONFIG_USB_VENDOR_ID
-#include "board/misc.h" // console_sendf
-#include "board/pgm.h" // PROGMEM
-#include "board/usb_cdc_ep.h" // USB_CDC_EP_BULK_IN
-#include "byteorder.h" // cpu_to_le16
-#include "command.h" // output
-#include "generic/usbstd.h" // struct usb_device_descriptor
-#include "generic/usbstd_cdc.h" // struct usb_cdc_header_descriptor
-#include "sched.h" // sched_wake_task
-#include "usb_cdc.h" // usb_notify_ep0
-
-// To debug a USB connection over UART, uncomment the two macros
-// below, alter the board KConfig to "select USBSERIAL" on a serial
-// UART build (so both USB and UART are enabled in a single build),
-// compile the code using serial UART, add output() calls to the USB
-// code as needed, deploy the new binary, and then connect via
-// console.py using UART to see those output() messages.
-//#define console_sendf(ce,va) console_sendf_usb(ce,va)
-//#define command_find_and_dispatch(rb, rp, pc) ({*(pc) = rp; 1;})
-
-
-/****************************************************************
- * Message block sending
- ****************************************************************/
-
-static struct task_wake usb_bulk_in_wake;
-static uint8_t transmit_buf[192], transmit_pos;
-
-void
-usb_notify_bulk_in(void)
-{
-    sched_wake_task(&usb_bulk_in_wake);
-}
-
-void
-usb_bulk_in_task(void)
-{
-    if (!sched_check_wake(&usb_bulk_in_wake))
-        return;
-    uint_fast8_t tpos = transmit_pos;
-    if (!tpos)
-        return;
-    uint_fast8_t max_tpos = (tpos > USB_CDC_EP_BULK_IN_SIZE
-                             ? USB_CDC_EP_BULK_IN_SIZE : tpos);
-    int_fast8_t ret = usb_send_bulk_in(transmit_buf, max_tpos);
-    if (ret <= 0)
-        return;
-    uint_fast8_t needcopy = tpos - ret;
-    if (needcopy) {
-        memmove(transmit_buf, &transmit_buf[ret], needcopy);
-        usb_notify_bulk_in();
-    }
-    transmit_pos = needcopy;
-}
-DECL_TASK(usb_bulk_in_task);
-
-// Encode and transmit a "response" message
-void
-console_sendf(const struct command_encoder *ce, va_list args)
-{
-    // Verify space for message
-    uint_fast8_t tpos = transmit_pos, max_size = READP(ce->max_size);
-    if (tpos + max_size > sizeof(transmit_buf))
-        // Not enough space for message
-        return;
-
-    // Generate message
-    uint8_t *buf = &transmit_buf[tpos];
-    uint_fast8_t msglen = command_encode_and_frame(buf, ce, args);
-
-    // Start message transmit
-    transmit_pos = tpos + msglen;
-    usb_notify_bulk_in();
-}
-
-
-/****************************************************************
- * Message block reading
- ****************************************************************/
-
-static struct task_wake usb_bulk_out_wake;
-static uint8_t receive_buf[128], receive_pos;
-
-void
-usb_notify_bulk_out(void)
-{
-    sched_wake_task(&usb_bulk_out_wake);
-}
-
-void
-usb_bulk_out_task(void)
-{
-    if (!sched_check_wake(&usb_bulk_out_wake))
-        return;
-    // Read data
-    uint_fast8_t rpos = receive_pos, pop_count;
-    if (rpos + USB_CDC_EP_BULK_OUT_SIZE <= sizeof(receive_buf)) {
-        int_fast8_t ret = usb_read_bulk_out(
-            &receive_buf[rpos], USB_CDC_EP_BULK_OUT_SIZE);
-        if (ret > 0) {
-            rpos += ret;
-            usb_notify_bulk_out();
-        }
-    } else {
-        usb_notify_bulk_out();
-    }
-    // Process a message block
-    int_fast8_t ret = command_find_and_dispatch(receive_buf, rpos, &pop_count);
-    if (ret) {
-        // Move buffer
-        uint_fast8_t needcopy = rpos - pop_count;
-        if (needcopy) {
-            memmove(receive_buf, &receive_buf[pop_count], needcopy);
-            usb_notify_bulk_out();
-        }
-        rpos = needcopy;
-    }
-    receive_pos = rpos;
-}
-DECL_TASK(usb_bulk_out_task);
-
-
-/****************************************************************
- * USB descriptors
- ****************************************************************/
-
-#define CONCAT1(a, b) a ## b
-#define CONCAT(a, b) CONCAT1(a, b)
-#define USB_STR_MANUFACTURER u"Klipper"
-#define USB_STR_PRODUCT CONCAT(u,CONFIG_MCU)
-#define USB_STR_SERIAL CONCAT(u,CONFIG_USB_SERIAL_NUMBER)
-
-// String descriptors
-enum {
-    USB_STR_ID_MANUFACTURER = 1, USB_STR_ID_PRODUCT, USB_STR_ID_SERIAL,
-};
-
-#define SIZE_cdc_string_langids (sizeof(cdc_string_langids) + 2)
-
-static const struct usb_string_descriptor cdc_string_langids PROGMEM = {
-    .bLength = SIZE_cdc_string_langids,
-    .bDescriptorType = USB_DT_STRING,
-    .data = { cpu_to_le16(USB_LANGID_ENGLISH_US) },
-};
-
-#define SIZE_cdc_string_manufacturer \
-    (sizeof(cdc_string_manufacturer) + sizeof(USB_STR_MANUFACTURER) - 2)
-
-static const struct usb_string_descriptor cdc_string_manufacturer PROGMEM = {
-    .bLength = SIZE_cdc_string_manufacturer,
-    .bDescriptorType = USB_DT_STRING,
-    .data = USB_STR_MANUFACTURER,
-};
-
-#define SIZE_cdc_string_product \
-    (sizeof(cdc_string_product) + sizeof(USB_STR_PRODUCT) - 2)
-
-static const struct usb_string_descriptor cdc_string_product PROGMEM = {
-    .bLength = SIZE_cdc_string_product,
-    .bDescriptorType = USB_DT_STRING,
-    .data = USB_STR_PRODUCT,
-};
-
-#define SIZE_cdc_string_serial \
-    (sizeof(cdc_string_serial) + sizeof(USB_STR_SERIAL) - 2)
-
-static const struct usb_string_descriptor cdc_string_serial PROGMEM = {
-    .bLength = SIZE_cdc_string_serial,
-    .bDescriptorType = USB_DT_STRING,
-    .data = USB_STR_SERIAL,
-};
-
-// Device descriptor
-static const struct usb_device_descriptor cdc_device_descriptor PROGMEM = {
-    .bLength = sizeof(cdc_device_descriptor),
-    .bDescriptorType = USB_DT_DEVICE,
-    .bcdUSB = cpu_to_le16(0x0200),
-    .bDeviceClass = USB_CLASS_COMM,
-    .bMaxPacketSize0 = USB_CDC_EP0_SIZE,
-    .idVendor = cpu_to_le16(CONFIG_USB_VENDOR_ID),
-    .idProduct = cpu_to_le16(CONFIG_USB_DEVICE_ID),
-    .bcdDevice = cpu_to_le16(0x0100),
-    .iManufacturer = USB_STR_ID_MANUFACTURER,
-    .iProduct = USB_STR_ID_PRODUCT,
-    .iSerialNumber = USB_STR_ID_SERIAL,
-    .bNumConfigurations = 1,
-};
-
-// Config descriptor
-static const struct config_s {
-    struct usb_config_descriptor config;
-    struct usb_interface_descriptor iface0;
-    struct usb_cdc_header_descriptor cdc_hdr;
-    struct usb_cdc_acm_descriptor cdc_acm;
-    struct usb_cdc_union_descriptor cdc_union;
-    struct usb_endpoint_descriptor ep1;
-    struct usb_interface_descriptor iface1;
-    struct usb_endpoint_descriptor ep2;
-    struct usb_endpoint_descriptor ep3;
-} PACKED cdc_config_descriptor PROGMEM = {
-    .config = {
-        .bLength = sizeof(cdc_config_descriptor.config),
-        .bDescriptorType = USB_DT_CONFIG,
-        .wTotalLength = cpu_to_le16(sizeof(cdc_config_descriptor)),
-        .bNumInterfaces = 2,
-        .bConfigurationValue = 1,
-        .bmAttributes = 0xC0,
-        .bMaxPower = 50,
-    },
-    .iface0 = {
-        .bLength = sizeof(cdc_config_descriptor.iface0),
-        .bDescriptorType = USB_DT_INTERFACE,
-        .bInterfaceNumber = 0,
-        .bNumEndpoints = 1,
-        .bInterfaceClass = USB_CLASS_COMM,
-        .bInterfaceSubClass = USB_CDC_SUBCLASS_ACM,
-        .bInterfaceProtocol = USB_CDC_ACM_PROTO_AT_V25TER,
-    },
-    .cdc_hdr = {
-        .bLength = sizeof(cdc_config_descriptor.cdc_hdr),
-        .bDescriptorType = USB_CDC_CS_INTERFACE,
-        .bDescriptorSubType = USB_CDC_HEADER_TYPE,
-        .bcdCDC = 0x0110,
-    },
-    .cdc_acm = {
-        .bLength = sizeof(cdc_config_descriptor.cdc_acm),
-        .bDescriptorType = USB_CDC_CS_INTERFACE,
-        .bDescriptorSubType = USB_CDC_ACM_TYPE,
-        .bmCapabilities = 0x06,
-    },
-    .cdc_union = {
-        .bLength = sizeof(cdc_config_descriptor.cdc_union),
-        .bDescriptorType = USB_CDC_CS_INTERFACE,
-        .bDescriptorSubType = USB_CDC_UNION_TYPE,
-        .bMasterInterface0 = 0,
-        .bSlaveInterface0 = 1,
-    },
-    .ep1 = {
-        .bLength = sizeof(cdc_config_descriptor.ep1),
-        .bDescriptorType = USB_DT_ENDPOINT,
-        .bEndpointAddress = USB_CDC_EP_ACM | USB_DIR_IN,
-        .bmAttributes = USB_ENDPOINT_XFER_INT,
-        .wMaxPacketSize = cpu_to_le16(USB_CDC_EP_ACM_SIZE),
-        .bInterval = 255,
-    },
-    .iface1 = {
-        .bLength = sizeof(cdc_config_descriptor.iface1),
-        .bDescriptorType = USB_DT_INTERFACE,
-        .bInterfaceNumber = 1,
-        .bNumEndpoints = 2,
-        .bInterfaceClass = 0x0A,
-    },
-    .ep2 = {
-        .bLength = sizeof(cdc_config_descriptor.ep2),
-        .bDescriptorType = USB_DT_ENDPOINT,
-        .bEndpointAddress = USB_CDC_EP_BULK_OUT,
-        .bmAttributes = USB_ENDPOINT_XFER_BULK,
-        .wMaxPacketSize = cpu_to_le16(USB_CDC_EP_BULK_OUT_SIZE),
-    },
-    .ep3 = {
-        .bLength = sizeof(cdc_config_descriptor.ep3),
-        .bDescriptorType = USB_DT_ENDPOINT,
-        .bEndpointAddress = USB_CDC_EP_BULK_IN | USB_DIR_IN,
-        .bmAttributes = USB_ENDPOINT_XFER_BULK,
-        .wMaxPacketSize = cpu_to_le16(USB_CDC_EP_BULK_IN_SIZE),
-    },
-};
-
-// List of available descriptors
-static const struct descriptor_s {
-    uint_fast16_t wValue;
-    uint_fast16_t wIndex;
-    const void *desc;
-    uint_fast8_t size;
-} cdc_descriptors[] PROGMEM = {
-    { USB_DT_DEVICE<<8, 0x0000,
-      &cdc_device_descriptor, sizeof(cdc_device_descriptor) },
-    { USB_DT_CONFIG<<8, 0x0000,
-      &cdc_config_descriptor, sizeof(cdc_config_descriptor) },
-    { USB_DT_STRING<<8, 0x0000,
-      &cdc_string_langids, SIZE_cdc_string_langids },
-    { (USB_DT_STRING<<8) | USB_STR_ID_MANUFACTURER, USB_LANGID_ENGLISH_US,
-      &cdc_string_manufacturer, SIZE_cdc_string_manufacturer },
-    { (USB_DT_STRING<<8) | USB_STR_ID_PRODUCT, USB_LANGID_ENGLISH_US,
-      &cdc_string_product, SIZE_cdc_string_product },
-#if !CONFIG_USB_SERIAL_NUMBER_CHIPID
-    { (USB_DT_STRING<<8) | USB_STR_ID_SERIAL, USB_LANGID_ENGLISH_US,
-      &cdc_string_serial, SIZE_cdc_string_serial },
-#endif
-};
-
-// Fill in a USB serial string descriptor from a chip id
-void
-usb_fill_serial(struct usb_string_descriptor *desc, int strlen, void *id)
-{
-    desc->bLength = sizeof(*desc) + strlen * sizeof(desc->data[0]);
-    desc->bDescriptorType = USB_DT_STRING;
-
-    uint8_t *src = id;
-    int i;
-    for (i = 0; i < strlen; i++) {
-        uint8_t c = i & 1 ? src[i/2] & 0x0f : src[i/2] >> 4;
-        desc->data[i] = c < 10 ? c + '0' : c - 10 + 'A';
-    }
-}
-
-
-/****************************************************************
- * USB endpoint 0 control message handling
- ****************************************************************/
-
-// State tracking
-enum {
-    UX_READ = 1<<0, UX_SEND = 1<<1, UX_SEND_PROGMEM = 1<<2, UX_SEND_ZLP = 1<<3
-};
-
-static void *usb_xfer_data;
-static uint8_t usb_xfer_size, usb_xfer_flags;
-
-// Set the USB "stall" condition
-static void
-usb_do_stall(void)
-{
-    usb_stall_ep0();
-    usb_xfer_flags = 0;
-}
-
-// Transfer data on the usb endpoint 0
-static void
-usb_do_xfer(void *data, uint_fast8_t size, uint_fast8_t flags)
-{
-    for (;;) {
-        uint_fast8_t xs = size;
-        if (xs > USB_CDC_EP0_SIZE)
-            xs = USB_CDC_EP0_SIZE;
-        int_fast8_t ret;
-        if (flags & UX_READ)
-            ret = usb_read_ep0(data, xs);
-        else if (NEED_PROGMEM && flags & UX_SEND_PROGMEM)
-            ret = usb_send_ep0_progmem(data, xs);
-        else
-            ret = usb_send_ep0(data, xs);
-        if (ret == xs) {
-            // Success
-            data += xs;
-            size -= xs;
-            if (!size) {
-                // Entire transfer completed successfully
-                if (flags & UX_READ) {
-                    // Send status packet at end of read
-                    flags = UX_SEND;
-                    continue;
-                }
-                if (xs == USB_CDC_EP0_SIZE && flags & UX_SEND_ZLP)
-                    // Must send zero-length-packet
-                    continue;
-                usb_xfer_flags = 0;
-                usb_notify_ep0();
-                return;
-            }
-            continue;
-        }
-        if (ret == -1) {
-            // Interface busy - retry later
-            usb_xfer_data = data;
-            usb_xfer_size = size;
-            usb_xfer_flags = flags;
-            return;
-        }
-        // Error
-        usb_do_stall();
-        return;
-    }
-}
-
-static void
-usb_req_get_descriptor(struct usb_ctrlrequest *req)
-{
-    if (req->bRequestType != USB_DIR_IN)
-        goto fail;
-    void *desc = NULL;
-    uint_fast8_t flags, size, i;
-    for (i=0; i<ARRAY_SIZE(cdc_descriptors); i++) {
-        const struct descriptor_s *d = &cdc_descriptors[i];
-        if (READP(d->wValue) == req->wValue
-            && READP(d->wIndex) == req->wIndex) {
-            flags = NEED_PROGMEM ? UX_SEND_PROGMEM : UX_SEND;
-            size = READP(d->size);
-            desc = (void*)READP(d->desc);
-        }
-    }
-    if (CONFIG_USB_SERIAL_NUMBER_CHIPID
-        && req->wValue == ((USB_DT_STRING<<8) | USB_STR_ID_SERIAL)
-        && req->wIndex == USB_LANGID_ENGLISH_US) {
-            struct usb_string_descriptor *usbserial_serialid;
-            usbserial_serialid = usbserial_get_serialid();
-            flags = UX_SEND;
-            size = usbserial_serialid->bLength;
-            desc = (void*)usbserial_serialid;
-    }
-    if (desc) {
-        if (size > req->wLength)
-            size = req->wLength;
-        else if (size < req->wLength)
-            flags |= UX_SEND_ZLP;
-        usb_do_xfer(desc, size, flags);
-        return;
-    }
-fail:
-    usb_do_stall();
-}
-
-static void
-usb_req_set_address(struct usb_ctrlrequest *req)
-{
-    if (req->bRequestType || req->wIndex || req->wLength) {
-        usb_do_stall();
-        return;
-    }
-    usb_set_address(req->wValue);
-}
-
-static void
-usb_req_set_configuration(struct usb_ctrlrequest *req)
-{
-    if (req->bRequestType || req->wValue != 1 || req->wIndex || req->wLength) {
-        usb_do_stall();
-        return;
-    }
-    usb_set_configure();
-    usb_notify_bulk_in();
-    usb_notify_bulk_out();
-    usb_do_xfer(NULL, 0, UX_SEND);
-}
-
-static struct usb_cdc_line_coding line_coding;
-static uint8_t line_control_state;
-
-static void
-check_reboot(void)
-{
-    if (line_coding.dwDTERate == 1200 && !(line_control_state & 0x01))
-        // A baud of 1200 is an Arduino style request to enter the bootloader
-        bootloader_request();
-}
-
-static void
-usb_req_set_line_coding(struct usb_ctrlrequest *req)
-{
-    if (req->bRequestType != 0x21 || req->wValue || req->wIndex
-        || req->wLength != sizeof(line_coding)) {
-        usb_do_stall();
-        return;
-    }
-    usb_do_xfer(&line_coding, sizeof(line_coding), UX_READ);
-    check_reboot();
-}
-
-static void
-usb_req_get_line_coding(struct usb_ctrlrequest *req)
-{
-    if (req->bRequestType != 0xa1 || req->wValue || req->wIndex
-        || req->wLength < sizeof(line_coding)) {
-        usb_do_stall();
-        return;
-    }
-    usb_do_xfer(&line_coding, sizeof(line_coding), UX_SEND);
-}
-
-static void
-usb_req_set_line(struct usb_ctrlrequest *req)
-{
-    if (req->bRequestType != 0x21 || req->wIndex || req->wLength) {
-        usb_do_stall();
-        return;
-    }
-    line_control_state = req->wValue;
-    usb_do_xfer(NULL, 0, UX_SEND);
-    check_reboot();
-}
-
-static void
-usb_state_ready(void)
-{
-    struct usb_ctrlrequest req;
-    int_fast8_t ret = usb_read_ep0_setup(&req, sizeof(req));
-    if (ret != sizeof(req))
-        return;
-    switch (req.bRequest) {
-    case USB_REQ_GET_DESCRIPTOR: usb_req_get_descriptor(&req); break;
-    case USB_REQ_SET_ADDRESS: usb_req_set_address(&req); break;
-    case USB_REQ_SET_CONFIGURATION: usb_req_set_configuration(&req); break;
-    case USB_CDC_REQ_SET_LINE_CODING: usb_req_set_line_coding(&req); break;
-    case USB_CDC_REQ_GET_LINE_CODING: usb_req_get_line_coding(&req); break;
-    case USB_CDC_REQ_SET_CONTROL_LINE_STATE: usb_req_set_line(&req); break;
-    default: usb_do_stall(); break;
-    }
-}
-
-// State tracking dispatch
-static struct task_wake usb_ep0_wake;
-
-void
-usb_notify_ep0(void)
-{
-    sched_wake_task(&usb_ep0_wake);
-}
-
-void
-usb_ep0_task(void)
-{
-    if (!sched_check_wake(&usb_ep0_wake))
-        return;
-    if (usb_xfer_flags)
-        usb_do_xfer(usb_xfer_data, usb_xfer_size, usb_xfer_flags);
-    else
-        usb_state_ready();
-}
-DECL_TASK(usb_ep0_task);
-
-void
-usb_shutdown(void)
-{
-    usb_notify_bulk_in();
-    usb_notify_bulk_out();
-    usb_notify_ep0();
-}
-DECL_SHUTDOWN(usb_shutdown);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/usb_cdc_ep.h crealityShit/src/generic/usb_cdc_ep.h
--- klipperStock/src/generic/usb_cdc_ep.h	2024-01-14 23:02:00.173796990 -0600
+++ crealityShit/src/generic/usb_cdc_ep.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,11 +0,0 @@
-#ifndef __GENERIC_USB_CDC_EP_H
-#define __GENERIC_USB_CDC_EP_H
-
-// Default USB endpoint ids
-enum {
-    USB_CDC_EP_BULK_IN = 1,
-    USB_CDC_EP_BULK_OUT = 2,
-    USB_CDC_EP_ACM = 3,
-};
-
-#endif // usb_cdc_ep.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/usb_cdc.h crealityShit/src/generic/usb_cdc.h
--- klipperStock/src/generic/usb_cdc.h	2024-01-14 23:02:00.181797089 -0600
+++ crealityShit/src/generic/usb_cdc.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,32 +0,0 @@
-#ifndef __GENERIC_USB_CDC_H
-#define __GENERIC_USB_CDC_H
-
-#include <stdint.h> // uint_fast8_t
-
-// endpoint sizes
-enum {
-    USB_CDC_EP0_SIZE = 16,
-    USB_CDC_EP_ACM_SIZE = 8,
-    USB_CDC_EP_BULK_OUT_SIZE = 64,
-    USB_CDC_EP_BULK_IN_SIZE = 64,
-};
-
-// callbacks provided by board specific code
-int_fast8_t usb_read_bulk_out(void *data, uint_fast8_t max_len);
-int_fast8_t usb_send_bulk_in(void *data, uint_fast8_t len);
-int_fast8_t usb_read_ep0(void *data, uint_fast8_t max_len);
-int_fast8_t usb_read_ep0_setup(void *data, uint_fast8_t max_len);
-int_fast8_t usb_send_ep0(const void *data, uint_fast8_t len);
-int_fast8_t usb_send_ep0_progmem(const void *data, uint_fast8_t len);
-void usb_stall_ep0(void);
-void usb_set_address(uint_fast8_t addr);
-void usb_set_configure(void);
-struct usb_string_descriptor *usbserial_get_serialid(void);
-
-// usb_cdc.c
-void usb_fill_serial(struct usb_string_descriptor *desc, int strlen, void *id);
-void usb_notify_bulk_in(void);
-void usb_notify_bulk_out(void);
-void usb_notify_ep0(void);
-
-#endif // usb_cdc.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/usbstd_cdc.h crealityShit/src/generic/usbstd_cdc.h
--- klipperStock/src/generic/usbstd_cdc.h	2024-01-14 23:02:00.177797038 -0600
+++ crealityShit/src/generic/usbstd_cdc.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,49 +0,0 @@
-// Standard definitions for USB CDC devices
-#ifndef __GENERIC_USBSTD_CDC_H
-#define __GENERIC_USBSTD_CDC_H
-
-#define USB_CDC_SUBCLASS_ACM 0x02
-
-#define USB_CDC_ACM_PROTO_AT_V25TER 1
-
-struct usb_cdc_header_descriptor {
-    uint8_t bLength;
-    uint8_t bDescriptorType;
-    uint8_t bDescriptorSubType;
-    uint16_t bcdCDC;
-} PACKED;
-
-#define USB_CDC_HEADER_TYPE 0x00
-#define USB_CDC_ACM_TYPE 0x02
-#define USB_CDC_UNION_TYPE 0x06
-
-#define USB_CDC_CS_INTERFACE 0x24
-#define USB_CDC_CS_ENDPOINT 0x25
-
-struct usb_cdc_acm_descriptor {
-    uint8_t bLength;
-    uint8_t bDescriptorType;
-    uint8_t bDescriptorSubType;
-    uint8_t bmCapabilities;
-} PACKED;
-
-struct usb_cdc_union_descriptor {
-    uint8_t bLength;
-    uint8_t bDescriptorType;
-    uint8_t bDescriptorSubType;
-    uint8_t bMasterInterface0;
-    uint8_t bSlaveInterface0;
-} PACKED;
-
-#define USB_CDC_REQ_SET_LINE_CODING 0x20
-#define USB_CDC_REQ_GET_LINE_CODING 0x21
-#define USB_CDC_REQ_SET_CONTROL_LINE_STATE 0x22
-
-struct usb_cdc_line_coding {
-    uint32_t dwDTERate;
-    uint8_t bCharFormat;
-    uint8_t bParityType;
-    uint8_t bDataBits;
-} PACKED;
-
-#endif // usbstd_cdc.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/generic/usbstd.h crealityShit/src/generic/usbstd.h
--- klipperStock/src/generic/usbstd.h	2024-01-14 23:02:00.177797038 -0600
+++ crealityShit/src/generic/usbstd.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,128 +0,0 @@
-// Standard definitions for USB commands and data structures
-#ifndef __GENERIC_USBSTD_H
-#define __GENERIC_USBSTD_H
-
-#include <stdint.h> // uint8_t
-#include "compiler.h" // PACKED
-
-#define USB_DIR_OUT                     0               /* to device */
-#define USB_DIR_IN                      0x80            /* to host */
-
-#define USB_TYPE_MASK                   (0x03 << 5)
-#define USB_TYPE_STANDARD               (0x00 << 5)
-#define USB_TYPE_CLASS                  (0x01 << 5)
-#define USB_TYPE_VENDOR                 (0x02 << 5)
-#define USB_TYPE_RESERVED               (0x03 << 5)
-
-#define USB_REQ_GET_STATUS              0x00
-#define USB_REQ_CLEAR_FEATURE           0x01
-#define USB_REQ_SET_FEATURE             0x03
-#define USB_REQ_SET_ADDRESS             0x05
-#define USB_REQ_GET_DESCRIPTOR          0x06
-#define USB_REQ_SET_DESCRIPTOR          0x07
-#define USB_REQ_GET_CONFIGURATION       0x08
-#define USB_REQ_SET_CONFIGURATION       0x09
-#define USB_REQ_GET_INTERFACE           0x0A
-#define USB_REQ_SET_INTERFACE           0x0B
-#define USB_REQ_SYNCH_FRAME             0x0C
-
-struct usb_ctrlrequest {
-    uint8_t bRequestType;
-    uint8_t bRequest;
-    uint16_t wValue;
-    uint16_t wIndex;
-    uint16_t wLength;
-} PACKED;
-
-#define USB_DT_DEVICE                   0x01
-#define USB_DT_CONFIG                   0x02
-#define USB_DT_STRING                   0x03
-#define USB_DT_INTERFACE                0x04
-#define USB_DT_ENDPOINT                 0x05
-#define USB_DT_DEVICE_QUALIFIER         0x06
-#define USB_DT_OTHER_SPEED_CONFIG       0x07
-#define USB_DT_ENDPOINT_COMPANION       0x30
-
-struct usb_device_descriptor {
-    uint8_t  bLength;
-    uint8_t  bDescriptorType;
-
-    uint16_t bcdUSB;
-    uint8_t  bDeviceClass;
-    uint8_t  bDeviceSubClass;
-    uint8_t  bDeviceProtocol;
-    uint8_t  bMaxPacketSize0;
-    uint16_t idVendor;
-    uint16_t idProduct;
-    uint16_t bcdDevice;
-    uint8_t  iManufacturer;
-    uint8_t  iProduct;
-    uint8_t  iSerialNumber;
-    uint8_t  bNumConfigurations;
-} PACKED;
-
-#define USB_CLASS_PER_INTERFACE         0       /* for DeviceClass */
-#define USB_CLASS_AUDIO                 1
-#define USB_CLASS_COMM                  2
-#define USB_CLASS_HID                   3
-#define USB_CLASS_PHYSICAL              5
-#define USB_CLASS_STILL_IMAGE           6
-#define USB_CLASS_PRINTER               7
-#define USB_CLASS_MASS_STORAGE          8
-#define USB_CLASS_HUB                   9
-
-struct usb_config_descriptor {
-    uint8_t  bLength;
-    uint8_t  bDescriptorType;
-
-    uint16_t wTotalLength;
-    uint8_t  bNumInterfaces;
-    uint8_t  bConfigurationValue;
-    uint8_t  iConfiguration;
-    uint8_t  bmAttributes;
-    uint8_t  bMaxPower;
-} PACKED;
-
-struct usb_interface_descriptor {
-    uint8_t  bLength;
-    uint8_t  bDescriptorType;
-
-    uint8_t  bInterfaceNumber;
-    uint8_t  bAlternateSetting;
-    uint8_t  bNumEndpoints;
-    uint8_t  bInterfaceClass;
-    uint8_t  bInterfaceSubClass;
-    uint8_t  bInterfaceProtocol;
-    uint8_t  iInterface;
-} PACKED;
-
-struct usb_endpoint_descriptor {
-    uint8_t  bLength;
-    uint8_t  bDescriptorType;
-
-    uint8_t  bEndpointAddress;
-    uint8_t  bmAttributes;
-    uint16_t wMaxPacketSize;
-    uint8_t  bInterval;
-} PACKED;
-
-#define USB_ENDPOINT_NUMBER_MASK        0x0f    /* in bEndpointAddress */
-#define USB_ENDPOINT_DIR_MASK           0x80
-
-#define USB_ENDPOINT_XFERTYPE_MASK      0x03    /* in bmAttributes */
-#define USB_ENDPOINT_XFER_CONTROL       0
-#define USB_ENDPOINT_XFER_ISOC          1
-#define USB_ENDPOINT_XFER_BULK          2
-#define USB_ENDPOINT_XFER_INT           3
-#define USB_ENDPOINT_MAX_ADJUSTABLE     0x80
-
-struct usb_string_descriptor {
-    uint8_t bLength;
-    uint8_t bDescriptorType;
-    //uint16_t data[];
-    typeof(*u"") data[];
-} PACKED;
-
-#define USB_LANGID_ENGLISH_US 0x0409
-
-#endif // usbstd.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/gpiocmds.c crealityShit/src/gpiocmds.c
--- klipperStock/src/gpiocmds.c	2024-01-14 23:02:00.169796942 -0600
+++ crealityShit/src/gpiocmds.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,215 +0,0 @@
-// Commands for controlling GPIO output pins
-//
-// Copyright (C) 2016-2020  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "basecmd.h" // oid_alloc
-#include "board/gpio.h" // struct gpio_out
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_is_before
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // sched_add_timer
-
-struct digital_out_s {
-    struct timer timer;
-    uint32_t on_duration, off_duration, end_time;
-    struct gpio_out pin;
-    uint32_t max_duration, cycle_time;
-    struct move_queue_head mq;
-    uint8_t flags;
-};
-
-struct digital_move {
-    struct move_node node;
-    uint32_t waketime, on_duration;
-};
-
-enum {
-    DF_ON=1<<0, DF_TOGGLING=1<<1, DF_CHECK_END=1<<2, DF_DEFAULT_ON=1<<4
-};
-
-static uint_fast8_t digital_load_event(struct timer *timer);
-
-// Software PWM toggle event
-static uint_fast8_t
-digital_toggle_event(struct timer *timer)
-{
-    struct digital_out_s *d = container_of(timer, struct digital_out_s, timer);
-    gpio_out_toggle_noirq(d->pin);
-    d->flags ^= DF_ON;
-    uint32_t waketime = d->timer.waketime;
-    if (d->flags & DF_ON)
-        waketime += d->on_duration;
-    else
-        waketime += d->off_duration;
-    if (d->flags & DF_CHECK_END && !timer_is_before(waketime, d->end_time)) {
-        // End of normal pulsing - next event loads new pwm settings
-        d->timer.func = digital_load_event;
-        waketime = d->end_time;
-    }
-    d->timer.waketime = waketime;
-    return SF_RESCHEDULE;
-}
-
-// Load next pin output setting
-static uint_fast8_t
-digital_load_event(struct timer *timer)
-{
-    // Apply next update and remove it from queue
-    struct digital_out_s *d = container_of(timer, struct digital_out_s, timer);
-    if (move_queue_empty(&d->mq))
-        shutdown("Missed scheduling of next digital out event");
-    struct move_node *mn = move_queue_pop(&d->mq);
-    struct digital_move *m = container_of(mn, struct digital_move, node);
-    uint32_t on_duration = m->on_duration;
-    uint8_t flags = on_duration ? DF_ON : 0;
-    gpio_out_write(d->pin, flags);
-    move_free(m);
-
-    // Calculate next end_time and flags
-    uint32_t end_time = 0;
-    if (!flags || on_duration >= d->cycle_time) {
-        // Pin is in an always on or always off state
-        if (!flags != !(d->flags & DF_DEFAULT_ON) && d->max_duration) {
-            end_time = d->timer.waketime + d->max_duration;
-            flags |= DF_CHECK_END;
-        }
-    } else {
-        flags |= DF_TOGGLING;
-        if (d->max_duration) {
-            end_time = d->timer.waketime + d->max_duration;
-            flags |= DF_CHECK_END;
-        }
-    }
-    if (!move_queue_empty(&d->mq)) {
-        struct move_node *nn = move_queue_first(&d->mq);
-        uint32_t wake = container_of(nn, struct digital_move, node)->waketime;
-        if (flags & DF_CHECK_END && timer_is_before(end_time, wake))
-            shutdown("Scheduled digital out event will exceed max_duration");
-        end_time = wake;
-        flags |= DF_CHECK_END;
-    }
-    d->end_time = end_time;
-    d->flags = flags | (d->flags & DF_DEFAULT_ON);
-
-    // Schedule next event
-    if (!(flags & DF_TOGGLING)) {
-        if (!(flags & DF_CHECK_END))
-            // Pin not toggling and nothing scheduled
-            return SF_DONE;
-        d->timer.waketime = end_time;
-        return SF_RESCHEDULE;
-    }
-    uint32_t waketime = d->timer.waketime + on_duration;
-    if (flags & DF_CHECK_END && !timer_is_before(waketime, end_time)) {
-        d->timer.waketime = end_time;
-        return SF_RESCHEDULE;
-    }
-    d->timer.func = digital_toggle_event;
-    d->timer.waketime = waketime;
-    d->on_duration = on_duration;
-    d->off_duration = d->cycle_time - on_duration;
-    return SF_RESCHEDULE;
-}
-
-void
-command_config_digital_out(uint32_t *args)
-{
-    struct gpio_out pin = gpio_out_setup(args[1], !!args[2]);
-    struct digital_out_s *d = oid_alloc(args[0], command_config_digital_out
-                                        , sizeof(*d));
-    d->pin = pin;
-    d->flags = (args[2] ? DF_ON : 0) | (args[3] ? DF_DEFAULT_ON : 0);
-    d->max_duration = args[4];
-    move_queue_setup(&d->mq, sizeof(struct digital_move));
-}
-DECL_COMMAND(command_config_digital_out,
-             "config_digital_out oid=%c pin=%u value=%c"
-             " default_value=%c max_duration=%u");
-
-void
-command_set_digital_out_pwm_cycle(uint32_t *args)
-{
-    struct digital_out_s *d = oid_lookup(args[0], command_config_digital_out);
-    irq_disable();
-    if (!move_queue_empty(&d->mq))
-        shutdown("Can not set soft pwm cycle ticks while updates pending");
-    d->cycle_time = args[1];
-    irq_enable();
-}
-DECL_COMMAND(command_set_digital_out_pwm_cycle,
-             "set_digital_out_pwm_cycle oid=%c cycle_ticks=%u");
-
-void
-command_queue_digital_out(uint32_t *args)
-{
-    struct digital_out_s *d = oid_lookup(args[0], command_config_digital_out);
-    struct digital_move *m = move_alloc();
-    uint32_t time = m->waketime = args[1];
-    m->on_duration = args[2];
-
-    irq_disable();
-    int first_on_queue = move_queue_push(&m->node, &d->mq);
-    if (!first_on_queue) {
-        irq_enable();
-        return;
-    }
-    uint8_t flags = d->flags;
-    if (flags & DF_CHECK_END && timer_is_before(d->end_time, time))
-        shutdown("Scheduled digital out event will exceed max_duration");
-    d->end_time = time;
-    d->flags = flags | DF_CHECK_END;
-    if (flags & DF_TOGGLING && timer_is_before(d->timer.waketime, time)) {
-        // digital_toggle_event() will schedule a load event when ready
-    } else {
-        // Schedule the loading of the parameters at the requested time
-        sched_del_timer(&d->timer);
-        d->timer.waketime = time;
-        d->timer.func = digital_load_event;
-        sched_add_timer(&d->timer);
-    }
-    irq_enable();
-}
-DECL_COMMAND(command_queue_digital_out,
-             "queue_digital_out oid=%c clock=%u on_ticks=%u");
-
-void
-command_update_digital_out(uint32_t *args)
-{
-    struct digital_out_s *d = oid_lookup(args[0], command_config_digital_out);
-    sched_del_timer(&d->timer);
-    if (!move_queue_empty(&d->mq))
-        shutdown("update_digital_out not valid with active queue");
-    uint8_t value = args[1], flags = d->flags, on_flag = value ? DF_ON : 0;
-    gpio_out_write(d->pin, on_flag);
-    if (!on_flag != !(flags & DF_DEFAULT_ON) && d->max_duration) {
-        d->timer.waketime = d->end_time = timer_read_time() + d->max_duration;
-        d->timer.func = digital_load_event;
-        d->flags = (flags & DF_DEFAULT_ON) | on_flag | DF_CHECK_END;
-        sched_add_timer(&d->timer);
-    } else {
-        d->flags = (flags & DF_DEFAULT_ON) | on_flag;
-    }
-}
-DECL_COMMAND(command_update_digital_out, "update_digital_out oid=%c value=%c");
-
-void
-digital_out_shutdown(void)
-{
-    uint8_t i;
-    struct digital_out_s *d;
-    foreach_oid(i, d, command_config_digital_out) {
-        gpio_out_write(d->pin, d->flags & DF_DEFAULT_ON);
-        d->flags = d->flags & DF_DEFAULT_ON ? DF_ON | DF_DEFAULT_ON : 0;
-        move_queue_clear(&d->mq);
-    }
-}
-DECL_SHUTDOWN(digital_out_shutdown);
-
-void
-command_set_digital_out(uint32_t *args)
-{
-    gpio_out_setup(args[0], args[1]);
-}
-DECL_COMMAND(command_set_digital_out, "set_digital_out pin=%u value=%c");
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/i2ccmds.c crealityShit/src/i2ccmds.c
--- klipperStock/src/i2ccmds.c	2024-01-14 23:02:00.185797137 -0600
+++ crealityShit/src/i2ccmds.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,78 +0,0 @@
-// Commands for sending messages on an I2C bus
-//
-// Copyright (C) 2018  Florian Heilmann <Florian.Heilmann@gmx.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memcpy
-#include "basecmd.h" //oid_alloc
-#include "command.h"  //sendf
-#include "sched.h" //DECL_COMMAND
-#include "board/gpio.h" //i2c_write/read/setup
-#include "i2ccmds.h"
-
-void
-command_config_i2c(uint32_t *args)
-{
-    uint8_t addr = args[3] & 0x7f;
-    struct i2cdev_s *i2c = oid_alloc(args[0], command_config_i2c
-                                     , sizeof(*i2c));
-    i2c->i2c_config = i2c_setup(args[1], args[2], addr);
-}
-DECL_COMMAND(command_config_i2c,
-             "config_i2c oid=%c i2c_bus=%u rate=%u address=%u");
-
-struct i2cdev_s *
-i2cdev_oid_lookup(uint8_t oid)
-{
-    return oid_lookup(oid, command_config_i2c);
-}
-
-void
-command_i2c_write(uint32_t *args)
-{
-    uint8_t oid = args[0];
-    struct i2cdev_s *i2c = oid_lookup(oid, command_config_i2c);
-    uint8_t data_len = args[1];
-    uint8_t *data = command_decode_ptr(args[2]);
-    i2c_write(i2c->i2c_config, data_len, data);
-}
-DECL_COMMAND(command_i2c_write, "i2c_write oid=%c data=%*s");
-
-void
-command_i2c_read(uint32_t * args)
-{
-    uint8_t oid = args[0];
-    struct i2cdev_s *i2c = oid_lookup(oid, command_config_i2c);
-    uint8_t reg_len = args[1];
-    uint8_t *reg = command_decode_ptr(args[2]);
-    uint8_t data_len = args[3];
-    uint8_t data[data_len];
-    i2c_read(i2c->i2c_config, reg_len, reg, data_len, data);
-    sendf("i2c_read_response oid=%c response=%*s", oid, data_len, data);
-}
-DECL_COMMAND(command_i2c_read, "i2c_read oid=%c reg=%*s read_len=%u");
-
-void
-command_i2c_modify_bits(uint32_t *args)
-{
-    uint8_t oid = args[0];
-    struct i2cdev_s *i2c = oid_lookup(oid, command_config_i2c);
-    uint8_t reg_len = args[1];
-    uint8_t *reg = command_decode_ptr(args[2]);
-    uint32_t clear_set_len = args[3];
-    if (clear_set_len % 2 != 0)
-        shutdown("i2c_modify_bits: Odd number of bits!");
-    uint8_t data_len = clear_set_len/2;
-    uint8_t *clear_set = command_decode_ptr(args[4]);
-    uint8_t receive_data[reg_len + data_len];
-    memcpy(receive_data, reg, reg_len);
-    i2c_read(i2c->i2c_config, reg_len, reg, data_len, receive_data + reg_len);
-    for (int i = 0; i < data_len; i++) {
-        receive_data[reg_len + i] &= ~clear_set[i];
-        receive_data[reg_len + i] |= clear_set[data_len + i];
-    }
-    i2c_write(i2c->i2c_config, reg_len + data_len, receive_data);
-}
-DECL_COMMAND(command_i2c_modify_bits,
-             "i2c_modify_bits oid=%c reg=%*s clear_set_bits=%*s");
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/i2ccmds.h crealityShit/src/i2ccmds.h
--- klipperStock/src/i2ccmds.h	2024-01-14 23:02:00.149796696 -0600
+++ crealityShit/src/i2ccmds.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,13 +0,0 @@
-#ifndef __I2CCMDS_H
-#define __I2CCMDS_H
-
-#include <inttypes.h>
-#include "board/gpio.h" // i2c_config
-
-struct i2cdev_s {
-    struct i2c_config i2c_config;
-};
-
-struct i2cdev_s *i2cdev_oid_lookup(uint8_t oid);
-
-#endif
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/initial_pins.c crealityShit/src/initial_pins.c
--- klipperStock/src/initial_pins.c	2024-01-14 23:02:00.185797137 -0600
+++ crealityShit/src/initial_pins.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,27 +0,0 @@
-// Support setting gpio pins at mcu start
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_INITIAL_PINS
-#include "board/gpio.h" // gpio_out_setup
-#include "board/pgm.h" // READP
-#include "ctr.h" // DECL_CTR
-#include "initial_pins.h" // initial_pins
-#include "sched.h" // DECL_INIT
-
-DECL_CTR("DECL_INITIAL_PINS " __stringify(CONFIG_INITIAL_PINS));
-
-void
-initial_pins_setup(void)
-{
-    if (sizeof(CONFIG_INITIAL_PINS) <= 1)
-        return;
-    int i;
-    for (i=0; i<initial_pins_size; i++) {
-        const struct initial_pin_s *ip = &initial_pins[i];
-        gpio_out_setup(READP(ip->pin), READP(ip->flags) & IP_OUT_HIGH);
-    }
-}
-DECL_INIT(initial_pins_setup);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/initial_pins.h crealityShit/src/initial_pins.h
--- klipperStock/src/initial_pins.h	2024-01-14 23:02:00.149796696 -0600
+++ crealityShit/src/initial_pins.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,15 +0,0 @@
-#ifndef __INITIAl_PINS_H
-#define __INITIAl_PINS_H
-
-struct initial_pin_s {
-    int pin;
-    uint8_t flags;
-};
-
-enum { IP_OUT_HIGH = 1 };
-
-// out/compile_time_request.c (auto generated file)
-extern const struct initial_pin_s initial_pins[];
-extern const int initial_pins_size;
-
-#endif // initial_pins.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/Kconfig crealityShit/src/Kconfig
--- klipperStock/src/Kconfig	2024-01-14 23:02:00.141796598 -0600
+++ crealityShit/src/Kconfig	1969-12-31 18:00:00.000000000 -0600
@@ -1,144 +0,0 @@
-# Main Kconfig settings
-
-mainmenu "Klipper Firmware Configuration"
-
-config LOW_LEVEL_OPTIONS
-    bool "Enable extra low-level configuration options"
-    default n
-    help
-        Enable low-level configuration options that (if modified) may
-        result in a build that does not function correctly.
-
-choice
-    prompt "Micro-controller Architecture"
-    config MACH_AVR
-        bool "Atmega AVR"
-    config MACH_ATSAM
-        bool "SAM3/SAM4/SAM E70 (Due and Duet)"
-    config MACH_ATSAMD
-        bool "SAMD21/SAMD51/SAME5x"
-    config MACH_LPC176X
-        bool "LPC176x (Smoothieboard)"
-    config MACH_STM32
-        bool "STMicroelectronics STM32"
-    config MACH_RP2040
-        bool "Raspberry Pi RP2040"
-    config MACH_PRU
-        bool "Beaglebone PRU"
-    config MACH_LINUX
-        bool "Linux process"
-    config MACH_SIMU
-        bool "Host simulator"
-endchoice
-
-source "src/avr/Kconfig"
-source "src/atsam/Kconfig"
-source "src/atsamd/Kconfig"
-source "src/lpc176x/Kconfig"
-source "src/stm32/Kconfig"
-source "src/rp2040/Kconfig"
-source "src/pru/Kconfig"
-source "src/linux/Kconfig"
-source "src/simulator/Kconfig"
-
-# Generic configuration options for serial ports
-config SERIAL
-    bool
-config SERIAL_BOOTLOADER_SIDECHANNEL
-    bool
-config SERIAL_BAUD
-    depends on SERIAL
-    int "Baud rate for serial port" if LOW_LEVEL_OPTIONS
-    default 250000
-    help
-        Specify the baud rate of the serial port. This should be set
-        to 250000. Read the FAQ before changing this value.
-
-# Generic configuration options for USB
-config USBSERIAL
-    bool
-config USBCANBUS
-    bool
-config USB
-    bool
-    default y if USBSERIAL || USBCANBUS
-config USB_VENDOR_ID
-    default 0x1d50
-config USB_DEVICE_ID
-    default 0x614e
-config USB_SERIAL_NUMBER_CHIPID
-    depends on USB && HAVE_CHIPID
-    default y
-config USB_SERIAL_NUMBER
-    default "12345"
-
-menu "USB ids"
-    depends on USB && LOW_LEVEL_OPTIONS
-config USB_VENDOR_ID
-    hex "USB vendor ID" if USBSERIAL
-config USB_DEVICE_ID
-    hex "USB device ID" if USBSERIAL
-config USB_SERIAL_NUMBER_CHIPID
-    bool "USB serial number from CHIPID" if HAVE_CHIPID
-config USB_SERIAL_NUMBER
-    string "USB serial number" if !USB_SERIAL_NUMBER_CHIPID
-endmenu
-
-# Generic configuration options for CANbus
-config CANSERIAL
-    bool
-config CANBUS
-    bool
-    default y if CANSERIAL || USBCANBUS
-config CANBUS_FREQUENCY
-    int "CAN bus speed" if LOW_LEVEL_OPTIONS && CANBUS
-    default 500000
-config CANBUS_FILTER
-    bool
-    default y if CANSERIAL
-
-# Support setting gpio state at startup
-config INITIAL_PINS
-    string "GPIO pins to set at micro-controller startup"
-    depends on LOW_LEVEL_OPTIONS
-    help
-        One may specify a comma separated list of gpio pins to set
-        during the micro-controller startup sequence. By default the
-        pins will be set to output high - preface a pin with a '!'
-        character to set that pin to output low.
-
-# The HAVE_x options allow boards to disable support for some commands
-# if the hardware does not support the feature.
-config HAVE_GPIO
-    bool
-    default n
-config HAVE_GPIO_ADC
-    bool
-    default n
-config HAVE_GPIO_SPI
-    bool
-    default n
-config HAVE_GPIO_I2C
-    bool
-    default n
-config HAVE_GPIO_HARD_PWM
-    bool
-    default n
-config HAVE_GPIO_BITBANGING
-    bool
-    default n
-config HAVE_STRICT_TIMING
-    bool
-    default n
-config HAVE_CHIPID
-    bool
-    default n
-config HAVE_STEPPER_BOTH_EDGE
-    bool
-    default n
-
-config INLINE_STEPPER_HACK
-    # Enables gcc to inline stepper_event() into the main timer irq handler
-    bool
-    depends on HAVE_GPIO
-    default y
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/lcd_hd44780.c crealityShit/src/lcd_hd44780.c
--- klipperStock/src/lcd_hd44780.c	2024-01-14 23:02:00.137796549 -0600
+++ crealityShit/src/lcd_hd44780.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,157 +0,0 @@
-// Commands for sending messages to a 4-bit hd44780 lcd driver
-//
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_MACH_AVR
-#include "basecmd.h" // oid_alloc
-#include "board/gpio.h" // gpio_out_write
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_from_us
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // DECL_SHUTDOWN
-
-struct hd44780 {
-    uint32_t last_cmd_time, cmd_wait_ticks;
-    uint8_t last;
-    struct gpio_out rs, e, d4, d5, d6, d7;
-};
-
-
-/****************************************************************
- * Transmit functions
- ****************************************************************/
-
-static uint32_t
-nsecs_to_ticks(uint32_t ns)
-{
-    return timer_from_us(ns * 1000) / 1000000;
-}
-
-static inline void
-ndelay(uint32_t nsecs)
-{
-    if (CONFIG_MACH_AVR)
-        // Slower MCUs don't require a delay
-        return;
-    uint32_t end = timer_read_time() + nsecs_to_ticks(nsecs);
-    while (timer_is_before(timer_read_time(), end))
-        irq_poll();
-}
-
-// Write 4 bits to the hd44780 using the 4bit parallel interface
-static __always_inline void
-hd44780_xmit_bits(uint8_t toggle, struct gpio_out e, struct gpio_out d4
-                  , struct gpio_out d5, struct gpio_out d6, struct gpio_out d7)
-{
-    gpio_out_toggle(e);
-    if (toggle & 0x10)
-        gpio_out_toggle(d4);
-    if (toggle & 0x20)
-        gpio_out_toggle(d5);
-    if (toggle & 0x40)
-        gpio_out_toggle(d6);
-    if (toggle & 0x80)
-        gpio_out_toggle(d7);
-    ndelay(230);
-    gpio_out_toggle(e);
-}
-
-// Transmit 8 bits to the chip
-static void
-hd44780_xmit_byte(struct hd44780 *h, uint8_t data)
-{
-    struct gpio_out e = h->e, d4 = h->d4, d5 = h->d5, d6 = h->d6, d7 = h->d7;
-    hd44780_xmit_bits(h->last ^ data, e, d4, d5, d6, d7);
-    h->last = data << 4;
-    ndelay(500 - 230);
-    hd44780_xmit_bits(data ^ h->last, e, d4, d5, d6, d7);
-}
-
-// Transmit a series of bytes to the chip
-static void
-hd44780_xmit(struct hd44780 *h, uint8_t len, uint8_t *data)
-{
-    uint32_t last_cmd_time=h->last_cmd_time, cmd_wait_ticks=h->cmd_wait_ticks;
-    while (len--) {
-        uint8_t b = *data++;
-        while (timer_read_time() - last_cmd_time < cmd_wait_ticks)
-            irq_poll();
-        hd44780_xmit_byte(h, b);
-        last_cmd_time = timer_read_time();
-    }
-    h->last_cmd_time = last_cmd_time;
-}
-
-
-/****************************************************************
- * Interface
- ****************************************************************/
-
-void
-command_config_hd44780(uint32_t *args)
-{
-    struct hd44780 *h = oid_alloc(args[0], command_config_hd44780, sizeof(*h));
-    h->rs = gpio_out_setup(args[1], 0);
-    h->e = gpio_out_setup(args[2], 0);
-    h->d4 = gpio_out_setup(args[3], 0);
-    h->d5 = gpio_out_setup(args[4], 0);
-    h->d6 = gpio_out_setup(args[5], 0);
-    h->d7 = gpio_out_setup(args[6], 0);
-
-    if (!CONFIG_HAVE_STRICT_TIMING) {
-        h->cmd_wait_ticks = args[7];
-        return;
-    }
-
-    // Calibrate cmd_wait_ticks
-    irq_disable();
-    uint32_t start = timer_read_time();
-    hd44780_xmit_byte(h, 0);
-    uint32_t end = timer_read_time();
-    irq_enable();
-    uint32_t diff = end - start, delay_ticks = args[7];
-    if (delay_ticks > diff)
-        h->cmd_wait_ticks = delay_ticks - diff;
-}
-DECL_COMMAND(command_config_hd44780,
-             "config_hd44780 oid=%c rs_pin=%u e_pin=%u"
-             " d4_pin=%u d5_pin=%u d6_pin=%u d7_pin=%u delay_ticks=%u");
-
-void
-command_hd44780_send_cmds(uint32_t *args)
-{
-    struct hd44780 *h = oid_lookup(args[0], command_config_hd44780);
-    gpio_out_write(h->rs, 0);
-    uint8_t len = args[1], *cmds = command_decode_ptr(args[2]);
-    hd44780_xmit(h, len, cmds);
-}
-DECL_COMMAND(command_hd44780_send_cmds, "hd44780_send_cmds oid=%c cmds=%*s");
-
-void
-command_hd44780_send_data(uint32_t *args)
-{
-    struct hd44780 *h = oid_lookup(args[0], command_config_hd44780);
-    gpio_out_write(h->rs, 1);
-    uint8_t len = args[1], *data = command_decode_ptr(args[2]);
-    hd44780_xmit(h, len, data);
-}
-DECL_COMMAND(command_hd44780_send_data, "hd44780_send_data oid=%c data=%*s");
-
-void
-hd44780_shutdown(void)
-{
-    uint8_t i;
-    struct hd44780 *h;
-    foreach_oid(i, h, command_config_hd44780) {
-        gpio_out_write(h->rs, 0);
-        gpio_out_write(h->e, 0);
-        gpio_out_write(h->d4, 0);
-        gpio_out_write(h->d5, 0);
-        gpio_out_write(h->d6, 0);
-        gpio_out_write(h->d7, 0);
-        h->last = 0;
-    }
-}
-DECL_SHUTDOWN(hd44780_shutdown);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/lcd_st7920.c crealityShit/src/lcd_st7920.c
--- klipperStock/src/lcd_st7920.c	2024-01-14 23:02:00.153796745 -0600
+++ crealityShit/src/lcd_st7920.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,165 +0,0 @@
-// Commands for sending messages to an st7920 lcd driver
-//
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_MACH_AVR
-#include "basecmd.h" // oid_alloc
-#include "board/gpio.h" // gpio_out_write
-#include "board/irq.h" // irq_poll
-#include "board/misc.h" // timer_from_us
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // DECL_SHUTDOWN
-
-struct st7920 {
-    uint32_t last_cmd_time, sync_wait_ticks, cmd_wait_ticks;
-    struct gpio_out sclk, sid;
-};
-
-
-/****************************************************************
- * Transmit functions
- ****************************************************************/
-
-static uint32_t
-nsecs_to_ticks(uint32_t ns)
-{
-    return timer_from_us(ns * 1000) / 1000000;
-}
-
-static inline void
-ndelay(uint32_t nsecs)
-{
-    if (CONFIG_MACH_AVR)
-        // Slower MCUs don't require a delay
-        return;
-    uint32_t end = timer_read_time() + nsecs_to_ticks(nsecs);
-    while (timer_is_before(timer_read_time(), end))
-        irq_poll();
-}
-
-#define SYNC_CMD  0xf8
-#define SYNC_DATA 0xfa
-
-// Write eight bits to the st7920 via the serial interface
-static void
-st7920_xmit_byte(struct st7920 *s, uint8_t data)
-{
-    struct gpio_out sclk = s->sclk, sid = s->sid;
-    uint8_t i;
-    for (i=0; i<8; i++) {
-        if (data & 0x80) {
-            gpio_out_toggle(sid);
-            data = ~data;
-        }
-        ndelay(200);
-        gpio_out_toggle(sclk);
-        ndelay(200);
-        data <<= 1;
-        gpio_out_toggle(sclk);
-    }
-}
-
-// Transmit a series of command bytes to the chip
-static void
-st7920_xmit(struct st7920 *s, uint8_t count, uint8_t *cmds)
-{
-    if (!count)
-        return;
-
-    // Send first byte (with longer delay)
-    uint32_t last_cmd_time = s->last_cmd_time, wait_ticks = s->sync_wait_ticks;
-    uint8_t cmd = *cmds++;
-    st7920_xmit_byte(s, cmd & 0xf0);
-    while (timer_read_time() - last_cmd_time < wait_ticks)
-        // Can't complete transfer until delay complete
-        irq_poll();
-    st7920_xmit_byte(s, cmd << 4);
-    last_cmd_time = timer_read_time();
-
-    // Send subsequent bytes
-    wait_ticks = s->cmd_wait_ticks;
-    while (--count) {
-        uint8_t cmd = *cmds++;
-        st7920_xmit_byte(s, cmd & 0xf0);
-        while (timer_read_time() - last_cmd_time < wait_ticks)
-            // Can't complete transfer until delay complete
-            irq_poll();
-        st7920_xmit_byte(s, cmd << 4);
-        last_cmd_time = timer_read_time();
-    }
-
-    s->last_cmd_time = last_cmd_time;
-}
-
-
-/****************************************************************
- * Interface
- ****************************************************************/
-
-void
-command_config_st7920(uint32_t *args)
-{
-    struct st7920 *s = oid_alloc(args[0], command_config_st7920, sizeof(*s));
-    s->sclk = gpio_out_setup(args[2], 0);
-    s->sid = gpio_out_setup(args[3], 0);
-    gpio_out_setup(args[1], 1);
-
-    if (!CONFIG_HAVE_STRICT_TIMING) {
-        s->sync_wait_ticks = args[4];
-        s->cmd_wait_ticks = args[5];
-        return;
-    }
-
-    // Calibrate cmd_wait_ticks
-    st7920_xmit_byte(s, SYNC_CMD);
-    st7920_xmit_byte(s, 0x20);
-    irq_disable();
-    uint32_t start = timer_read_time();
-    st7920_xmit_byte(s, 0x00);
-    uint32_t end = timer_read_time();
-    irq_enable();
-    s->last_cmd_time = end;
-    uint32_t diff = end - start, sync_delay_ticks = args[4];
-    if (sync_delay_ticks > diff)
-        s->sync_wait_ticks = sync_delay_ticks - diff;
-    uint32_t cmd_delay_ticks = args[5];
-    if (cmd_delay_ticks > diff)
-        s->cmd_wait_ticks = cmd_delay_ticks - diff;
-}
-DECL_COMMAND(command_config_st7920,
-             "config_st7920 oid=%c cs_pin=%u sclk_pin=%u sid_pin=%u"
-             " sync_delay_ticks=%u cmd_delay_ticks=%u");
-
-void
-command_st7920_send_cmds(uint32_t *args)
-{
-    struct st7920 *s = oid_lookup(args[0], command_config_st7920);
-    st7920_xmit_byte(s, SYNC_CMD);
-    uint8_t len = args[1], *cmds = command_decode_ptr(args[2]);
-    st7920_xmit(s, len, cmds);
-}
-DECL_COMMAND(command_st7920_send_cmds, "st7920_send_cmds oid=%c cmds=%*s");
-
-void
-command_st7920_send_data(uint32_t *args)
-{
-    struct st7920 *s = oid_lookup(args[0], command_config_st7920);
-    st7920_xmit_byte(s, SYNC_DATA);
-    uint8_t len = args[1], *data = command_decode_ptr(args[2]);
-    st7920_xmit(s, len, data);
-}
-DECL_COMMAND(command_st7920_send_data, "st7920_send_data oid=%c data=%*s");
-
-void
-st7920_shutdown(void)
-{
-    uint8_t i;
-    struct st7920 *s;
-    foreach_oid(i, s, command_config_st7920) {
-        gpio_out_write(s->sclk, 0);
-        gpio_out_write(s->sid, 0);
-    }
-}
-DECL_SHUTDOWN(st7920_shutdown);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/linux/analog.c crealityShit/src/linux/analog.c
--- klipperStock/src/linux/analog.c	2024-01-14 23:02:00.117796304 -0600
+++ crealityShit/src/linux/analog.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,68 +0,0 @@
-// Read analog values from Linux IIO device
-//
-// Copyright (C) 2017  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <fcntl.h> // open
-#include <stdio.h> // snprintf
-#include <stdlib.h> // atoi
-#include <unistd.h> // read
-#include "command.h" // shutdown
-#include "gpio.h" // gpio_adc_setup
-#include "internal.h" // report_errno
-#include "sched.h" // sched_shutdown
-
-DECL_CONSTANT("ADC_MAX", 4095); // Assume 12bit adc
-
-#define ANALOG_START (1<<12)
-
-DECL_ENUMERATION_RANGE("pin", "analog0", ANALOG_START, 8);
-
-#define IIO_PATH "/sys/bus/iio/devices/iio:device0/in_voltage%d_raw"
-
-struct gpio_adc
-gpio_adc_setup(uint32_t pin)
-{
-    char fname[256];
-    snprintf(fname, sizeof(fname), IIO_PATH, pin-ANALOG_START);
-
-    int fd = open(fname, O_RDONLY|O_CLOEXEC);
-    if (fd < 0) {
-        report_errno("analog open", fd);
-        goto fail;
-    }
-    int ret = set_non_blocking(fd);
-    if (ret < 0)
-        goto fail;
-    return (struct gpio_adc){ .fd = fd };
-fail:
-    if (fd >= 0)
-        close(fd);
-    shutdown("Unable to open adc device");
-}
-
-uint32_t
-gpio_adc_sample(struct gpio_adc g)
-{
-    return 0;
-}
-
-uint16_t
-gpio_adc_read(struct gpio_adc g)
-{
-    char buf[64];
-    int ret = pread(g.fd, buf, sizeof(buf)-1, 0);
-    if (ret <= 0) {
-        report_errno("analog read", ret);
-        try_shutdown("Error on analog read");
-        return 0;
-    }
-    buf[ret] = '\0';
-    return atoi(buf);
-}
-
-void
-gpio_adc_cancel_sample(struct gpio_adc g)
-{
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/linux/console.c crealityShit/src/linux/console.c
--- klipperStock/src/linux/console.c	2024-01-14 23:02:00.117796304 -0600
+++ crealityShit/src/linux/console.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,193 +0,0 @@
-// TTY based IO
-//
-// Copyright (C) 2017-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#define _GNU_SOURCE
-#include <errno.h> // errno
-#include <fcntl.h> // fcntl
-#include <poll.h> // ppoll
-#include <pty.h> // openpty
-#include <stdio.h> // fprintf
-#include <string.h> // memmove
-#include <sys/stat.h> // chmod
-#include <time.h> // struct timespec
-#include <unistd.h> // ttyname
-#include "board/irq.h" // irq_wait
-#include "board/misc.h" // console_sendf
-#include "command.h" // command_find_block
-#include "internal.h" // console_setup
-#include "sched.h" // sched_wake_task
-
-static struct pollfd main_pfd[1];
-#define MP_TTY_IDX   0
-
-// Report 'errno' in a message written to stderr
-void
-report_errno(char *where, int rc)
-{
-    int e = errno;
-    fprintf(stderr, "Got error %d in %s: (%d)%s\n", rc, where, e, strerror(e));
-}
-
-
-/****************************************************************
- * Setup
- ****************************************************************/
-
-int
-set_non_blocking(int fd)
-{
-    int flags = fcntl(fd, F_GETFL);
-    if (flags < 0) {
-        report_errno("fcntl getfl", flags);
-        return -1;
-    }
-    int ret = fcntl(fd, F_SETFL, flags | O_NONBLOCK);
-    if (ret < 0) {
-        report_errno("fcntl setfl", flags);
-        return -1;
-    }
-    return 0;
-}
-
-int
-set_close_on_exec(int fd)
-{
-    int ret = fcntl(fd, F_SETFD, FD_CLOEXEC);
-    if (ret < 0) {
-        report_errno("fcntl set cloexec", ret);
-        return -1;
-    }
-    return 0;
-}
-
-int
-console_setup(char *name)
-{
-    // Open pseudo-tty
-    struct termios ti;
-    memset(&ti, 0, sizeof(ti));
-    int mfd, sfd, ret = openpty(&mfd, &sfd, NULL, &ti, NULL);
-    if (ret) {
-        report_errno("openpty", ret);
-        return -1;
-    }
-    ret = set_non_blocking(mfd);
-    if (ret)
-        return -1;
-    ret = set_close_on_exec(mfd);
-    if (ret)
-        return -1;
-    ret = set_close_on_exec(sfd);
-    if (ret)
-        return -1;
-    main_pfd[MP_TTY_IDX].fd = mfd;
-    main_pfd[MP_TTY_IDX].events = POLLIN;
-
-    // Create symlink to tty
-    unlink(name);
-    char *tname = ttyname(sfd);
-    if (!tname) {
-        report_errno("ttyname", 0);
-        return -1;
-    }
-    ret = symlink(tname, name);
-    if (ret) {
-        report_errno("symlink", ret);
-        return -1;
-    }
-    ret = chmod(tname, 0660);
-    if (ret) {
-        report_errno("chmod", ret);
-        return -1;
-    }
-
-    // Make sure stderr is non-blocking
-    ret = set_non_blocking(STDERR_FILENO);
-    if (ret)
-        return -1;
-
-    return 0;
-}
-
-
-/****************************************************************
- * Console handling
- ****************************************************************/
-
-static struct task_wake console_wake;
-static uint8_t receive_buf[4096];
-static int receive_pos;
-
-void *
-console_receive_buffer(void)
-{
-    return receive_buf;
-}
-
-// Process any incoming commands
-void
-console_task(void)
-{
-    if (!sched_check_wake(&console_wake))
-        return;
-
-    // Read data
-    int ret = read(main_pfd[MP_TTY_IDX].fd, &receive_buf[receive_pos]
-                   , sizeof(receive_buf) - receive_pos);
-    if (ret < 0) {
-        if (errno == EWOULDBLOCK) {
-            ret = 0;
-        } else {
-            report_errno("read", ret);
-            return;
-        }
-    }
-    if (ret == 15 && receive_buf[receive_pos+14] == '\n'
-        && memcmp(&receive_buf[receive_pos], "FORCE_SHUTDOWN\n", 15) == 0)
-        shutdown("Force shutdown command");
-
-    // Find and dispatch message blocks in the input
-    int len = receive_pos + ret;
-    uint_fast8_t pop_count, msglen = len > MESSAGE_MAX ? MESSAGE_MAX : len;
-    ret = command_find_and_dispatch(receive_buf, msglen, &pop_count);
-    if (ret) {
-        len -= pop_count;
-        if (len) {
-            memmove(receive_buf, &receive_buf[pop_count], len);
-            sched_wake_task(&console_wake);
-        }
-    }
-    receive_pos = len;
-}
-DECL_TASK(console_task);
-
-// Encode and transmit a "response" message
-void
-console_sendf(const struct command_encoder *ce, va_list args)
-{
-    // Generate message
-    uint8_t buf[MESSAGE_MAX];
-    uint_fast8_t msglen = command_encode_and_frame(buf, ce, args);
-
-    // Transmit message
-    int ret = write(main_pfd[MP_TTY_IDX].fd, buf, msglen);
-    if (ret < 0)
-        report_errno("write", ret);
-}
-
-// Sleep until a signal received (waking early for console input if needed)
-void
-console_sleep(sigset_t *sigset)
-{
-    int ret = ppoll(main_pfd, ARRAY_SIZE(main_pfd), NULL, sigset);
-    if (ret <= 0) {
-        if (errno != EINTR)
-            report_errno("ppoll main_pfd", ret);
-        return;
-    }
-    if (main_pfd[MP_TTY_IDX].revents)
-        sched_wake_task(&console_wake);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/linux/gpio.c crealityShit/src/linux/gpio.c
--- klipperStock/src/linux/gpio.c	2024-01-14 23:02:00.117796304 -0600
+++ crealityShit/src/linux/gpio.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,177 +0,0 @@
-// Very basic support via a Linux gpiod device
-//
-// Copyright (C) 2017-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <fcntl.h> // open
-#include <stdio.h> // snprintf
-#include <stdlib.h> // atexit
-#include <string.h> // memset
-#include <sys/ioctl.h> // ioctl
-#include <unistd.h> // close
-#include </usr/include/linux/gpio.h> // GPIOHANDLE_REQUEST_OUTPUT
-#include "command.h" // shutdown
-#include "gpio.h" // gpio_out_write
-#include "internal.h" // report_errno
-#include "sched.h" // sched_shutdown
-
-#define GPIO_CONSUMER "klipper"
-
-DECL_ENUMERATION_RANGE("pin", "gpio0", GPIO(0, 0), MAX_GPIO_LINES);
-DECL_ENUMERATION_RANGE("pin", "gpiochip0/gpio0", GPIO(0, 0), MAX_GPIO_LINES);
-DECL_ENUMERATION_RANGE("pin", "gpiochip1/gpio0", GPIO(1, 0), MAX_GPIO_LINES);
-DECL_ENUMERATION_RANGE("pin", "gpiochip2/gpio0", GPIO(2, 0), MAX_GPIO_LINES);
-DECL_ENUMERATION_RANGE("pin", "gpiochip3/gpio0", GPIO(3, 0), MAX_GPIO_LINES);
-DECL_ENUMERATION_RANGE("pin", "gpiochip4/gpio0", GPIO(4, 0), MAX_GPIO_LINES);
-DECL_ENUMERATION_RANGE("pin", "gpiochip5/gpio0", GPIO(5, 0), MAX_GPIO_LINES);
-DECL_ENUMERATION_RANGE("pin", "gpiochip6/gpio0", GPIO(6, 0), MAX_GPIO_LINES);
-DECL_ENUMERATION_RANGE("pin", "gpiochip7/gpio0", GPIO(7, 0), MAX_GPIO_LINES);
-DECL_ENUMERATION_RANGE("pin", "gpiochip8/gpio0", GPIO(8, 0), MAX_GPIO_LINES);
-
-struct gpio_line {
-    int chipid;
-    int offset;
-    int fd;
-    int state;
-};
-static struct gpio_line gpio_lines[9 * MAX_GPIO_LINES];
-static int gpio_chip_fd[9] = { -1, -1, -1, -1, -1, -1, -1, -1, -1 };
-
-static int
-get_chip_fd(uint8_t chipId)
-{
-    if (gpio_chip_fd[chipId] >= 0)
-        return gpio_chip_fd[chipId];
-    char chipFilename[64];
-    snprintf(chipFilename, sizeof(chipFilename), "/dev/gpiochip%u", chipId);
-    int ret = access(chipFilename, F_OK);
-    if (ret < 0) {
-        report_errno("gpio access", ret);
-        shutdown("GPIO chip device not found");
-    }
-    int fd = open(chipFilename, O_RDWR | O_CLOEXEC);
-    if (fd < 0) {
-        report_errno("gpio open", fd);
-        shutdown("Unable to open GPIO chip device");
-    }
-    gpio_chip_fd[chipId] = fd;
-    int i;
-    for (i=0; i<MAX_GPIO_LINES; i++) {
-        gpio_lines[GPIO(chipId, i)].offset = i;
-        gpio_lines[GPIO(chipId, i)].fd = -1;
-        gpio_lines[GPIO(chipId, i)].chipid = chipId;
-    }
-    return fd;
-}
-
-struct gpio_out
-gpio_out_setup(uint32_t pin, uint8_t val)
-{
-    struct gpio_line *line = &gpio_lines[pin];
-    line->offset = GPIO2PIN(pin);
-    line->chipid = GPIO2PORT(pin);
-    struct gpio_out g = { .line = line };
-    gpio_out_reset(g,val);
-    return g;
-}
-
-static void
-gpio_release_line(struct gpio_line *line)
-{
-    if (line->fd > 0) {
-        close(line->fd);
-        line->fd = -1;
-    }
-}
-
-void
-gpio_out_reset(struct gpio_out g, uint8_t val)
-{
-    gpio_release_line(g.line);
-    struct gpiohandle_request req;
-    memset(&req, 0, sizeof(req));
-    req.lines = 1;
-    req.flags = GPIOHANDLE_REQUEST_OUTPUT;
-    req.lineoffsets[0] = g.line->offset;
-    req.default_values[0] = !!val;
-    strncpy(req.consumer_label, GPIO_CONSUMER, sizeof(req.consumer_label) - 1);
-    int fd = get_chip_fd(g.line->chipid);
-    int ret = ioctl(fd, GPIO_GET_LINEHANDLE_IOCTL, &req);
-    if (ret < 0) {
-        report_errno("gpio_out_reset get line", ret);
-        shutdown("Unable to open out GPIO chip line");
-    }
-    set_close_on_exec(req.fd);
-    g.line->fd = req.fd;
-    g.line->state = !!val;
-}
-
-void
-gpio_out_write(struct gpio_out g, uint8_t val)
-{
-    struct gpiohandle_data data;
-    memset(&data, 0, sizeof(data));
-    data.values[0] = !!val;
-    ioctl(g.line->fd, GPIOHANDLE_SET_LINE_VALUES_IOCTL, &data);
-    g.line->state = !!val;
-}
-
-void
-gpio_out_toggle_noirq(struct gpio_out g)
-{
-    gpio_out_write(g, !g.line->state);
-}
-
-void
-gpio_out_toggle(struct gpio_out g)
-{
-    gpio_out_toggle_noirq(g);
-}
-
-struct gpio_in
-gpio_in_setup(uint32_t pin, int8_t pull_up)
-{
-    struct gpio_line *line = &gpio_lines[pin];
-    line->offset = GPIO2PIN(pin);
-    line->chipid = GPIO2PORT(pin);
-    struct gpio_in g = { .line = line };
-    gpio_in_reset(g, pull_up);
-    return g;
-}
-
-void
-gpio_in_reset(struct gpio_in g, int8_t pull_up)
-{
-    gpio_release_line(g.line);
-    struct gpiohandle_request req;
-    memset(&req, 0, sizeof(req));
-    req.lines = 1;
-    req.flags = GPIOHANDLE_REQUEST_INPUT;
-#if defined(GPIOHANDLE_REQUEST_BIAS_PULL_UP)
-    if (pull_up > 0) {
-        req.flags |= GPIOHANDLE_REQUEST_BIAS_PULL_UP;
-    } else if (pull_up < 0) {
-        req.flags |= GPIOHANDLE_REQUEST_BIAS_PULL_DOWN;
-    }
-#endif
-    req.lineoffsets[0] = g.line->offset;
-    strncpy(req.consumer_label, GPIO_CONSUMER, sizeof(req.consumer_label) - 1);
-    int fd = get_chip_fd(g.line->chipid);
-    int ret = ioctl(fd, GPIO_GET_LINEHANDLE_IOCTL, &req);
-    if (ret < 0) {
-        report_errno("gpio_in_reset get line", ret);
-        shutdown("Unable to open in GPIO chip line");
-    }
-    set_close_on_exec(req.fd);
-    g.line->fd = req.fd;
-}
-
-uint8_t
-gpio_in_read(struct gpio_in g)
-{
-    struct gpiohandle_data data;
-    memset(&data, 0, sizeof(data));
-    ioctl(g.line->fd, GPIOHANDLE_GET_LINE_VALUES_IOCTL, &data);
-    return data.values[0];
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/linux/gpio.h crealityShit/src/linux/gpio.h
--- klipperStock/src/linux/gpio.h	2024-01-14 23:02:00.113796253 -0600
+++ crealityShit/src/linux/gpio.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,55 +0,0 @@
-#ifndef __LINUX_GPIO_H
-#define __LINUX_GPIO_H
-
-#include <stdint.h> // uint8_t
-
-struct gpio_out {
-    struct gpio_line* line;
-};
-struct gpio_out gpio_out_setup(uint32_t pin, uint8_t val);
-void gpio_out_reset(struct gpio_out g, uint8_t val);
-void gpio_out_toggle_noirq(struct gpio_out g);
-void gpio_out_toggle(struct gpio_out g);
-void gpio_out_write(struct gpio_out g, uint8_t val);
-
-struct gpio_in {
-    struct gpio_line* line;
-};
-struct gpio_in gpio_in_setup(uint32_t pin, int8_t pull_up);
-void gpio_in_reset(struct gpio_in g, int8_t pull_up);
-uint8_t gpio_in_read(struct gpio_in g);
-
-struct gpio_adc {
-    int fd;
-};
-struct gpio_adc gpio_adc_setup(uint32_t pin);
-uint32_t gpio_adc_sample(struct gpio_adc g);
-uint16_t gpio_adc_read(struct gpio_adc g);
-void gpio_adc_cancel_sample(struct gpio_adc g);
-
-struct spi_config {
-    int fd;
-    int rate;
-};
-struct spi_config spi_setup(uint32_t bus, uint8_t mode, uint32_t rate);
-void spi_prepare(struct spi_config config);
-void spi_transfer(struct spi_config config, uint8_t receive_data
-                  , uint8_t len, uint8_t *data);
-
-struct gpio_pwm {
-    int duty_fd, enable_fd;
-    uint32_t period;
-};
-struct gpio_pwm gpio_pwm_setup(uint32_t pin, uint32_t cycle_time, uint16_t val);
-void gpio_pwm_write(struct gpio_pwm g, uint16_t val);
-
-struct i2c_config {
-    int fd;
-};
-
-struct i2c_config i2c_setup(uint32_t bus, uint32_t rate, uint8_t addr);
-void i2c_write(struct i2c_config config, uint8_t write_len, uint8_t *write);
-void i2c_read(struct i2c_config config, uint8_t reg_len, uint8_t *reg
-              , uint8_t read_len, uint8_t *read);
-
-#endif // gpio.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/linux/hard_pwm.c crealityShit/src/linux/hard_pwm.c
--- klipperStock/src/linux/hard_pwm.c	2024-01-14 23:02:00.109796205 -0600
+++ crealityShit/src/linux/hard_pwm.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,113 +0,0 @@
-// HW PWM upport via Linux PWM sysfs interface
-//
-// Copyright (C) 2019  Janne Grunau <janne-3d@jannau.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <errno.h> // errno, ENOENT
-
-#include "gpio.h" // struct gpio_pwm
-#include "internal.h" // NSECS_PER_TICK
-#include "command.h" // shutdown
-#include "sched.h" // sched_shutdown
-
-#define MAX_PWM (1 << 15)
-DECL_CONSTANT("PWM_MAX", MAX_PWM);
-
-#define HARD_PWM_START (1<<16)
-#define HARD_PWM(chip, pin) (((chip)<<4) + (pin) + HARD_PWM_START)
-#define HARD_PWM_TO_CHIP(hard_pwm) (((hard_pwm) - HARD_PWM_START) >> 4)
-#define HARD_PWM_TO_PIN(hard_pwm)  (((hard_pwm) - HARD_PWM_START) & 0xf)
-
-DECL_ENUMERATION_RANGE("pin", "pwmchip0/pwm0", HARD_PWM(0, 0), 16);
-DECL_ENUMERATION_RANGE("pin", "pwmchip1/pwm0", HARD_PWM(1, 0), 16);
-DECL_ENUMERATION_RANGE("pin", "pwmchip2/pwm0", HARD_PWM(2, 0), 16);
-DECL_ENUMERATION_RANGE("pin", "pwmchip3/pwm0", HARD_PWM(3, 0), 16);
-DECL_ENUMERATION_RANGE("pin", "pwmchip4/pwm0", HARD_PWM(4, 0), 16);
-DECL_ENUMERATION_RANGE("pin", "pwmchip5/pwm0", HARD_PWM(5, 0), 16);
-DECL_ENUMERATION_RANGE("pin", "pwmchip6/pwm0", HARD_PWM(6, 0), 16);
-DECL_ENUMERATION_RANGE("pin", "pwmchip7/pwm0", HARD_PWM(7, 0), 16);
-
-#define PWM_PATH "/sys/class/pwm/pwmchip%u/pwm%u/%s"
-#define PWM_PATH_BB "/sys/class/pwm/pwm-%u:%u/%s"
-
-struct gpio_pwm gpio_pwm_setup(uint32_t pin, uint32_t cycle_time, uint16_t val)
-{
-    char filename[256];
-    char scratch[16];
-    uint8_t chip_id = HARD_PWM_TO_CHIP(pin);
-    uint8_t pwm_id = HARD_PWM_TO_PIN(pin);
-    const char * pwm_path = PWM_PATH;
-
-    struct gpio_pwm g = {};
-    g.period = cycle_time * NSECS_PER_TICK;
-
-    // configure period/cycle time. Always in nanoseconds
-    snprintf(filename, sizeof(filename), pwm_path, chip_id, pwm_id, "period");
-    int fd = open(filename, O_WRONLY|O_CLOEXEC);
-    if (fd == -1 && errno == ENOENT) {
-        // upstream pwm control file does not exists try BeagleBoard scheme
-        pwm_path = PWM_PATH_BB;
-        snprintf(filename, sizeof(filename), pwm_path, chip_id, pwm_id,
-                 "period");
-        fd = open(filename, O_WRONLY|O_CLOEXEC);
-        if (fd == -1) {
-            report_errno("pwm " PWM_PATH_BB "period for pin", pin);
-            goto fail;
-        }
-    } else if (fd == -1) {
-        report_errno("pwm " PWM_PATH "period for pin", pin);
-        goto fail;
-    }
-    snprintf(scratch, sizeof(scratch), "%u", cycle_time * NSECS_PER_TICK);
-    write(fd, scratch, strlen(scratch));
-    close(fd);
-
-    // write duty cycle
-    snprintf(filename, sizeof(filename), pwm_path, chip_id, pwm_id,
-             "duty_cycle");
-    fd = open(filename, O_WRONLY|O_CLOEXEC);
-    if (fd == -1) {
-        report_errno("pwm duty_cycle", fd);
-        goto fail;
-    }
-    g.duty_fd = fd;
-
-    // enable PWM
-    snprintf(filename, sizeof(filename), pwm_path, chip_id, pwm_id, "enable");
-    fd = open(filename, O_WRONLY|O_CLOEXEC);
-    if (fd == -1) {
-        report_errno("pwm enable", fd);
-        close(g.duty_fd);
-        goto fail;
-    }
-    g.enable_fd = fd;
-    gpio_pwm_write(g, val);
-
-    return g;
-
-fail:
-    if (fd >= 0)
-        close(fd);
-    shutdown("Unable to config pwm device");
-}
-
-
-void gpio_pwm_write(struct gpio_pwm g, uint16_t val)
-{
-    if (!val) {
-        write(g.enable_fd, "0", 2);
-        return;
-    }
-    char scratch[16];
-    uint32_t duty_cycle = g.period * (uint64_t)val / MAX_PWM;
-    int len = snprintf(scratch, sizeof(scratch), "%u", duty_cycle);
-    write(g.duty_fd, scratch, len + 1);
-    write(g.enable_fd, "1", 2);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/linux/i2c.c crealityShit/src/linux/i2c.c
--- klipperStock/src/linux/i2c.c	2024-01-14 23:02:00.113796253 -0600
+++ crealityShit/src/linux/i2c.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,102 +0,0 @@
-// Linux i2c implementation
-//
-// Copyright (C) 2020  Eric Callahan <arksine.code@gmail.com>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-#include <fcntl.h> // open
-#include <linux/i2c-dev.h> // I2C_SLAVE
-#include <stdio.h> // snprintf
-#include <sys/ioctl.h> // ioctl
-#include <unistd.h> // write
-#include "gpio.h" // i2c_setup
-#include "command.h" // shutdown
-#include "internal.h" // report_errno
-#include "sched.h" // sched_shutdown
-
-DECL_ENUMERATION_RANGE("i2c_bus", "i2c.0", 0, 7);
-
-struct i2c_s {
-    uint32_t bus;
-    uint8_t addr;
-    int fd;
-};
-
-static struct i2c_s devices[16];
-static int devices_count;
-
-static int
-i2c_open(uint32_t bus, uint8_t addr)
-{
-    // Find existing device (if already opened)
-    int i;
-    for (i=0; i<devices_count; i++) {
-        if (devices[i].bus == bus && devices[i].addr == addr) {
-            return devices[i].fd;
-        }
-    }
-
-    char fname[256];
-    snprintf(fname, sizeof(fname), "/dev/i2c-%d", bus);
-    int fd = open(fname, O_RDWR|O_CLOEXEC);
-    if (fd < 0) {
-        report_errno("open i2c", fd);
-        goto fail;
-    }
-    int ret = ioctl(fd, I2C_SLAVE, addr);
-    if (ret < 0) {
-        report_errno("ioctl i2c", fd);
-        goto fail;
-    }
-    ret = set_non_blocking(fd);
-    if (ret < 0)
-        goto fail;
-
-    devices[devices_count].bus = bus;
-    devices[devices_count].addr = addr;
-    devices[devices_count].fd = fd;
-    devices_count++;
-
-    return fd;
-
-fail:
-    if (fd >= 0)
-        close(fd);
-    shutdown("Unable to open i2c device");
-}
-
-struct i2c_config
-i2c_setup(uint32_t bus, uint32_t rate, uint8_t addr)
-{
-    // Note:  The rate is set by the kernel driver, for a Raspberry Pi this
-    // is done with the following setting in /boot/config.txt:
-    //
-    // dtparam=i2c_baudrate=<rate>
-
-    int fd = i2c_open(bus, addr);
-    return (struct i2c_config){.fd=fd};
-}
-
-void
-i2c_write(struct i2c_config config, uint8_t write_len, uint8_t *data)
-{
-    int ret = write(config.fd, data, write_len);
-    if (ret != write_len) {
-        if (ret < 0)
-            report_errno("write value i2c", ret);
-        try_shutdown("Unable write i2c device");
-    }
-}
-
-void
-i2c_read(struct i2c_config config, uint8_t reg_len, uint8_t *reg
-         , uint8_t read_len, uint8_t *data)
-{
-    if(reg_len != 0)
-        i2c_write(config, reg_len, reg);
-    int ret = read(config.fd, data, read_len);
-    if (ret != read_len) {
-        if (ret < 0)
-            report_errno("read value i2c", ret);
-        try_shutdown("Unable to read i2c device");
-    }
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/linux/internal.h crealityShit/src/linux/internal.h
--- klipperStock/src/linux/internal.h	2024-01-14 23:02:00.117796304 -0600
+++ crealityShit/src/linux/internal.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,32 +0,0 @@
-#ifndef __LINUX_INTERNAL_H
-#define __LINUX_INTERNAL_H
-// Local definitions for micro-controllers running on linux
-
-#include <signal.h> // sigset_t
-#include <stdint.h> // uint32_t
-#include "autoconf.h" // CONFIG_CLOCK_FREQ
-
-#define MAX_GPIO_LINES    288
-#define GPIO(PORT, NUM) ((PORT) * MAX_GPIO_LINES + (NUM))
-#define GPIO2PORT(PIN) ((PIN) / MAX_GPIO_LINES)
-#define GPIO2PIN(PIN) ((PIN) % MAX_GPIO_LINES)
-
-#define NSECS 1000000000
-#define NSECS_PER_TICK (NSECS / CONFIG_CLOCK_FREQ)
-
-// console.c
-void report_errno(char *where, int rc);
-int set_non_blocking(int fd);
-int set_close_on_exec(int fd);
-int console_setup(char *name);
-void console_sleep(sigset_t *sigset);
-
-// timer.c
-int timer_check_periodic(uint32_t *ts);
-void timer_disable_signals(void);
-void timer_enable_signals(void);
-
-// watchdog.c
-int watchdog_setup(void);
-
-#endif // internal.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/linux/Kconfig crealityShit/src/linux/Kconfig
--- klipperStock/src/linux/Kconfig	2024-01-14 23:02:00.113796253 -0600
+++ crealityShit/src/linux/Kconfig	1969-12-31 18:00:00.000000000 -0600
@@ -1,24 +0,0 @@
-# Kconfig settings for compiling and running the micro-controller code
-# in a Linux process
-
-if MACH_LINUX
-
-config LINUX_SELECT
-    bool
-    default y
-    select HAVE_GPIO_ADC
-    select HAVE_GPIO_SPI
-    select HAVE_GPIO_HARD_PWM
-    select HAVE_GPIO_I2C
-    select HAVE_GPIO_BITBANGING
-    select HAVE_GPIO
-
-config BOARD_DIRECTORY
-    string
-    default "linux"
-
-config CLOCK_FREQ
-    int
-    default 50000000
-
-endif
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/linux/main.c crealityShit/src/linux/main.c
--- klipperStock/src/linux/main.c	2024-01-14 23:02:00.117796304 -0600
+++ crealityShit/src/linux/main.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,97 +0,0 @@
-// Main starting point for micro-controller code running on linux systems
-//
-// Copyright (C) 2017  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include </usr/include/sched.h> // sched_setscheduler
-#include <stdio.h> // fprintf
-#include <string.h> // memset
-#include <unistd.h> // getopt
-#include "board/misc.h" // console_sendf
-#include "command.h" // DECL_CONSTANT
-#include "internal.h" // console_setup
-#include "sched.h" // sched_main
-
-DECL_CONSTANT_STR("MCU", "linux");
-
-
-/****************************************************************
- * Real-time setup
- ****************************************************************/
-
-static int
-realtime_setup(void)
-{
-    struct sched_param sp;
-    memset(&sp, 0, sizeof(sp));
-    sp.sched_priority = 1;
-    int ret = sched_setscheduler(0, SCHED_FIFO, &sp);
-    if (ret < 0) {
-        report_errno("sched_setscheduler", ret);
-        return -1;
-    }
-    return 0;
-}
-
-
-/****************************************************************
- * Restart
- ****************************************************************/
-
-static char **orig_argv;
-
-void
-command_config_reset(uint32_t *args)
-{
-    if (! sched_is_shutdown())
-        shutdown("config_reset only available when shutdown");
-    int ret = execv(orig_argv[0], orig_argv);
-    report_errno("execv", ret);
-}
-DECL_COMMAND_FLAGS(command_config_reset, HF_IN_SHUTDOWN, "config_reset");
-
-
-/****************************************************************
- * Startup
- ****************************************************************/
-
-int
-main(int argc, char **argv)
-{
-    // Parse program args
-    orig_argv = argv;
-    int opt, watchdog = 0, realtime = 0;
-    while ((opt = getopt(argc, argv, "wr")) != -1) {
-        switch (opt) {
-        case 'w':
-            watchdog = 1;
-            break;
-        case 'r':
-            realtime = 1;
-            break;
-        default:
-            fprintf(stderr, "Usage: %s [-w] [-r]\n", argv[0]);
-            return -1;
-        }
-    }
-
-    // Initial setup
-    if (realtime) {
-        int ret = realtime_setup();
-        if (ret)
-            return ret;
-    }
-    int ret = console_setup("/tmp/klipper_host_mcu");
-    if (ret)
-        return -1;
-    if (watchdog) {
-        int ret = watchdog_setup();
-        if (ret)
-            return ret;
-    }
-
-    // Main loop
-    sched_main();
-    return 0;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/linux/Makefile crealityShit/src/linux/Makefile
--- klipperStock/src/linux/Makefile	2024-01-14 23:02:00.113796253 -0600
+++ crealityShit/src/linux/Makefile	1969-12-31 18:00:00.000000000 -0600
@@ -1,14 +0,0 @@
-# Additional linux build rules
-
-dirs-y += src/linux src/generic
-
-src-y += linux/main.c linux/timer.c linux/console.c linux/watchdog.c
-src-y += linux/pca9685.c linux/spidev.c linux/analog.c linux/hard_pwm.c
-src-y += linux/i2c.c linux/gpio.c generic/crc16_ccitt.c generic/alloc.c
-src-y += linux/sensor_ds18b20.c
-
-CFLAGS_klipper.elf += -lutil -lrt -lpthread
-
-flash: $(OUT)klipper.elf
-	@echo "  Flashing"
-	$(Q)sudo ./scripts/flash-linux.sh
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/linux/pca9685.c crealityShit/src/linux/pca9685.c
--- klipperStock/src/linux/pca9685.c	2024-01-14 23:02:00.113796253 -0600
+++ crealityShit/src/linux/pca9685.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,265 +0,0 @@
-// Communicating with a PCA9685 pwm device via linux i2c
-//
-// Copyright (C) 2017  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <fcntl.h> // open
-#include <linux/i2c-dev.h> // I2C_SLAVE
-#include <stdio.h> // snprintf
-#include <sys/ioctl.h> // ioctl
-#include <unistd.h> // write
-#include "basecmd.h" // oid_alloc
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_from_us
-#include "command.h" // DECL_COMMAND
-#include "internal.h" // report_errno
-#include "sched.h" // DECL_SHUTDOWN
-
-
-/****************************************************************
- * Low-level i2c
- ****************************************************************/
-
-#define P9_MODE1    0x00
-#define P9_PRESCALE 0xfe
-#define CHANNEL_MAX 15
-#define CHANNEL_ALL 61
-#define VALUE_MAX 4096
-
-#define OSC_MHZ   25
-#define CLOCK_MHZ timer_from_us(1)
-
-struct i2c_s {
-    uint8_t bus;
-    uint8_t addr;
-    uint32_t cycle_ticks;
-    int fd;
-};
-static struct i2c_s devices[16];
-static int devices_count;
-
-static void
-pca9685_write(int fd, uint8_t channel, uint16_t value)
-{
-    uint8_t full_on = 0x00;
-    if (value >= VALUE_MAX) {
-        full_on = 0x10;
-        value = 0x0000;
-    } else if (!value) {
-        value = 0x1000;
-    }
-    uint8_t msg[5] = { channel*4 + 0x06, 0x00, full_on, value, value >> 8 };
-    int ret = write(fd, msg, sizeof(msg));
-    if (ret < 0) {
-        report_errno("write value i2c", ret);
-        try_shutdown("Unable to update PCA9685 value");
-    }
-}
-
-static int
-open_i2c(uint8_t bus, uint8_t addr, uint32_t cycle_ticks)
-{
-    // Find existing device (if already opened)
-    int i;
-    for (i=0; i<devices_count; i++)
-        if (devices[i].bus == bus && devices[i].addr == addr) {
-            if (cycle_ticks != devices[i].cycle_ticks)
-                shutdown("All PCA9685 channels must have the same cycle_ticks");
-            return devices[i].fd;
-        }
-
-    // Setup new I2C device
-    if (devices_count >= ARRAY_SIZE(devices))
-        shutdown("Too many i2c devices");
-    char fname[256];
-    snprintf(fname, sizeof(fname), "/dev/i2c-%d", bus);
-    int fd = open(fname, O_RDWR|O_CLOEXEC);
-    if (fd < 0) {
-        report_errno("open i2c", fd);
-        goto fail;
-    }
-    int ret = ioctl(fd, I2C_SLAVE, addr);
-    if (ret < 0) {
-        report_errno("ioctl i2c", fd);
-        goto fail;
-    }
-    ret = set_non_blocking(fd);
-    if (ret < 0)
-        goto fail;
-
-    // Init PCA9685
-    const uint8_t sleep_msg[2] = { P9_MODE1, 0x31 };
-    ret = write(fd, sleep_msg, sizeof(sleep_msg));
-    if (ret < 0) {
-        report_errno("write sleep i2c", ret);
-        goto fail;
-    }
-    uint32_t freq = DIV_ROUND_CLOSEST(OSC_MHZ*cycle_ticks, 4096*CLOCK_MHZ) - 1;
-    freq = freq > 0xff ? 0xff : (freq < 0x03 ? 0x03 : freq);
-    uint8_t freq_msg[2] = { P9_PRESCALE, freq };
-    ret = write(fd, freq_msg, sizeof(freq_msg));
-    if (ret < 0) {
-        report_errno("write freq i2c", ret);
-        goto fail;
-    }
-    const uint8_t wake_msg[2] = { P9_MODE1, 0x21 };
-    ret = write(fd, wake_msg, sizeof(wake_msg));
-    if (ret < 0) {
-        report_errno("write unsleep i2c", ret);
-        goto fail;
-    }
-    usleep(500);
-    pca9685_write(fd, CHANNEL_ALL, 0);
-
-    devices[devices_count].bus = bus;
-    devices[devices_count].addr = addr;
-    devices[devices_count].cycle_ticks = cycle_ticks;
-    devices[devices_count].fd = fd;
-    devices_count++;
-    return fd;
-fail:
-    if (fd >= 0)
-        close(fd);
-    shutdown("Unable to open and init PCA9685 device");
-}
-
-
-/****************************************************************
- * Command interface
- ****************************************************************/
-
-struct i2cpwm_s {
-    struct timer timer;
-    int fd;
-    uint8_t channel;
-    uint16_t default_value;
-    uint32_t max_duration;
-    struct move_queue_head mq;
-};
-
-struct pca9685_move {
-    struct move_node node;
-    uint32_t waketime;
-    uint16_t value;
-};
-
-DECL_CONSTANT("PCA9685_MAX", VALUE_MAX);
-
-static uint_fast8_t
-pca9685_end_event(struct timer *timer)
-{
-    shutdown("Missed scheduling of next pca9685 event");
-}
-
-static uint_fast8_t
-pca9685_event(struct timer *timer)
-{
-    // Apply next update and remove it from queue
-    struct i2cpwm_s *p = container_of(timer, struct i2cpwm_s, timer);
-    struct move_node *mn = move_queue_pop(&p->mq);
-    struct pca9685_move *m = container_of(mn, struct pca9685_move, node);
-    uint16_t value = m->value;
-    pca9685_write(p->fd, p->channel, value);
-    move_free(m);
-
-    // Check if more updates queued
-    if (move_queue_empty(&p->mq)) {
-        if (value == p->default_value || !p->max_duration)
-            return SF_DONE;
-
-        // Start the safety timeout
-        p->timer.waketime += p->max_duration;
-        p->timer.func = pca9685_end_event;
-        return SF_RESCHEDULE;
-    }
-
-    // Schedule next update
-    struct move_node *nn = move_queue_first(&p->mq);
-    uint32_t wake = container_of(nn, struct pca9685_move, node)->waketime;
-    if (value != p->default_value && p->max_duration
-        && timer_is_before(p->timer.waketime + p->max_duration, wake))
-        shutdown("Scheduled pca9685 event will exceed max_duration");
-    p->timer.waketime = wake;
-    return SF_RESCHEDULE;
-}
-
-void
-command_config_pca9685(uint32_t *args)
-{
-    uint8_t bus = args[1], addr = args[2], channel = args[3];
-    uint16_t value = args[5], default_value = args[6];
-    if (channel > CHANNEL_MAX || value > VALUE_MAX || default_value > VALUE_MAX)
-        shutdown("Invalid pca9685 channel or value");
-    int fd = open_i2c(bus, addr, args[4]);
-    if (value)
-        pca9685_write(fd, channel, value);
-    struct i2cpwm_s *p = oid_alloc(args[0], command_config_pca9685, sizeof(*p));
-    p->fd = fd;
-    p->channel = channel;
-    p->default_value = default_value;
-    p->max_duration = args[7];
-    p->timer.func = pca9685_event;
-    move_queue_setup(&p->mq, sizeof(struct pca9685_move));
-}
-DECL_COMMAND(command_config_pca9685, "config_pca9685 oid=%c bus=%c addr=%c"
-             " channel=%c cycle_ticks=%u value=%hu"
-             " default_value=%hu max_duration=%u");
-
-void
-command_queue_pca9685_out(uint32_t *args)
-{
-    struct i2cpwm_s *p = oid_lookup(args[0], command_config_pca9685);
-    struct pca9685_move *m = move_alloc();
-    m->waketime = args[1];
-    m->value = args[2];
-    if (m->value > VALUE_MAX)
-        shutdown("Invalid pca9685 value");
-
-    irq_disable();
-    int need_add_timer = move_queue_push(&m->node, &p->mq);
-    irq_enable();
-    if (!need_add_timer)
-        return;
-
-    // queue was empty and a timer needs to be added
-    sched_del_timer(&p->timer);
-    if (p->timer.func == pca9685_end_event
-        && timer_is_before(p->timer.waketime, m->waketime))
-        shutdown("Scheduled pca9685 event will exceed max_duration");
-    p->timer.func = pca9685_event;
-    p->timer.waketime = m->waketime;
-    sched_add_timer(&p->timer);
-}
-DECL_COMMAND(command_queue_pca9685_out,
-             "queue_pca9685_out oid=%c clock=%u value=%hu");
-
-void
-command_set_pca9685_out(uint32_t *args)
-{
-    uint8_t bus = args[0], addr = args[1], channel = args[2];
-    uint16_t value = args[4];
-    if (channel > CHANNEL_MAX || value > VALUE_MAX)
-        shutdown("Invalid pca9685 channel or value");
-    int fd = open_i2c(bus, addr, args[3]);
-    pca9685_write(fd, channel, value);
-}
-DECL_COMMAND(command_set_pca9685_out, "set_pca9685_out bus=%c addr=%c"
-             " channel=%c cycle_ticks=%u value=%hu");
-
-void
-pca9685_shutdown(void)
-{
-    int i;
-    for (i=0; i<devices_count; i++)
-        pca9685_write(devices[i].fd, CHANNEL_ALL, 0);
-    uint8_t j;
-    struct i2cpwm_s *p;
-    foreach_oid(j, p, command_config_pca9685) {
-        if (p->default_value)
-            pca9685_write(p->fd, p->channel, p->default_value);
-        p->timer.func = pca9685_event;
-        move_queue_clear(&p->mq);
-    }
-}
-DECL_SHUTDOWN(pca9685_shutdown);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/linux/sensor_ds18b20.c crealityShit/src/linux/sensor_ds18b20.c
--- klipperStock/src/linux/sensor_ds18b20.c	2024-01-14 23:02:00.113796253 -0600
+++ crealityShit/src/linux/sensor_ds18b20.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,287 +0,0 @@
-// Communicate with a DS18B20 temperature sensor on linux
-//
-// Copyright (C) 2020  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <fcntl.h> // open
-#include <stdio.h> // snprintf
-#include <stdlib.h> // atof
-#include <string.h> // memchr
-#include <unistd.h> // read
-#include <pthread.h> // pthread_create
-#include <time.h> // clock_gettime
-#include "basecmd.h" // oid_alloc
-#include "board/irq.h" // irq_disable
-#include "command.h" // DECL_COMMAND
-#include "internal.h" // report_errno
-#include "sched.h" // DECL_SHUTDOWN
-
-#define W1_READ_TIMEOUT_SEC 5
-
-// Status of a sensor
-enum {
-    W1_IDLE = 0, // No read requested yet
-    W1_READ_REQUESTED = 1, // Reading or waiting to read
-    W1_READY = 2, // Read complete, waiting to report
-    W1_ERROR = 3, // Request shutdown
-};
-
-enum {
-    TS_PENDING = 1,
-};
-
-struct ds18_s {
-    struct timer timer;
-    uint32_t rest_time;
-    int32_t min_value, max_value;
-    uint8_t flags;
-
-    // Set by main thread in configuration phase.
-    // Should only be accessed by reader thread after configuration.
-    int fd;
-
-    // Used for guarding shared members.
-    pthread_mutex_t lock;
-    pthread_cond_t cond;
-
-    // Protect all reads/writes to the following members using the mutex
-    // once reader thread is initialized.
-    int temperature;
-    struct timespec request_time;
-    uint8_t status;
-    uint8_t error_count;
-    uint8_t max_error_count;
-};
-
-// Lock ds18_s mutex, set error status, unlock mutex.
-static void
-locking_handle_read_error(struct ds18_s *d)
-{
-    pthread_mutex_lock(&d->lock);
-    d->status = W1_ERROR;
-    d->error_count++;
-    if (d->error_count <= d->max_error_count) {
-        pthread_mutex_unlock(&d->lock);
-    } else {
-        pthread_mutex_unlock(&d->lock);
-        pthread_exit(NULL);
-    }
-}
-
-// The kernel interface to DS18B20 sensors is a sysfs entry that blocks for
-// around 750ms when read. Most of this is idle time waiting for the result
-// to be ready. Read in a separate thread in order to avoid blocking time-
-// sensitive work.
-static void *
-reader_start_routine(void *param) {
-    struct ds18_s *d = param;
-    for (;;) {
-        // Wait for requests to read temperature sensors
-        pthread_mutex_lock(&d->lock);
-        while (d->status != W1_READ_REQUESTED) {
-            pthread_cond_wait(&d->cond, &d->lock);
-        }
-        pthread_mutex_unlock(&d->lock);
-
-        // Read temp.
-        // The temperature data is at the end of the report, after a "t=".
-        // Example (3.062 degrees C):
-        //
-        // 31 00 4b 46 7f ff 0c 10 77 : crc=77 YES
-        // 31 00 4b 46 7f ff 0c 10 77 t=3062
-        char data[128];
-        int ret = read(d->fd, data, sizeof(data)-1);
-        if (ret < 0) {
-            report_errno("read DS18B20", ret);
-            locking_handle_read_error(d);
-            continue;
-        }
-        data[ret] = '\0';
-        char *temp_string = strstr(data, "t=");
-        if (temp_string == NULL || temp_string[2] == '\0') {
-            locking_handle_read_error(d);
-            continue;
-        }
-        // Don't pass 't' and '=' to atoi
-        temp_string += 2;
-        int val = atoi(temp_string);
-
-        // Store temperature
-        pthread_mutex_lock(&d->lock);
-        d->status = W1_READY;
-        d->temperature = val;
-        pthread_mutex_unlock(&d->lock);
-
-        // Seek file in preparation of next read
-        ret = lseek(d->fd, 0, SEEK_SET);
-        if (ret < 0) {
-            report_errno("seek DS18B20", ret);
-            locking_handle_read_error(d);
-            continue;
-        }
-    }
-    pthread_exit(NULL);
-}
-
-static struct task_wake ds18_wake;
-
-static uint_fast8_t
-ds18_event(struct timer *timer)
-{
-    struct ds18_s *d = container_of(timer, struct ds18_s, timer);
-    // Trigger task to read and send results
-    sched_wake_task(&ds18_wake);
-    d->flags |= TS_PENDING;
-    d->timer.waketime += d->rest_time;
-    return SF_RESCHEDULE;
-}
-
-void
-command_config_ds18b20(uint32_t *args)
-{
-    // Open kernel port
-    uint8_t serial_len = args[1];
-    uint8_t *serial = command_decode_ptr(args[2]);
-    if (memchr(serial, '/', serial_len))
-        goto fail1;
-    char fname[56];
-    snprintf(fname, sizeof(fname), "/sys/bus/w1/devices/%.*s/w1_slave"
-             , serial_len, serial);
-    int fd = open(fname, O_RDONLY|O_CLOEXEC);
-    if (fd < 0) {
-        report_errno("open ds18", fd);
-        goto fail2;
-    }
-
-    struct ds18_s *d = oid_alloc(args[0], command_config_ds18b20, sizeof(*d));
-    d->max_error_count = args[3];
-    d->error_count = 0;
-    d->timer.func = ds18_event;
-    d->fd = fd;
-    d->status = W1_IDLE;
-    int ret;
-    ret = pthread_mutex_init(&d->lock, NULL);
-    if (ret)
-        goto fail3;
-    ret = pthread_cond_init(&d->cond, NULL);
-    if (ret)
-        goto fail4;
-
-    pthread_t reader_tid; // Not used
-    timer_disable_signals();
-    ret = pthread_create(&reader_tid, NULL, reader_start_routine, d);
-    timer_enable_signals();
-    if (ret)
-        goto fail5;
-
-    return;
-fail1:
-    shutdown("Invalid DS18B20 serial id, must not contain '/'");
-fail2:
-    shutdown("Invalid DS18B20 serial id, could not open for reading");
-fail3:
-    shutdown("Could not start DS18B20 reader thread (mutex init)");
-fail4:
-    shutdown("Could not start DS18B20 reader thread (cond init)");
-fail5:
-    shutdown("Could not start DS18B20 reader thread");
-}
-DECL_COMMAND(command_config_ds18b20,
-             "config_ds18b20 oid=%c serial=%*s max_error_count=%c");
-
-void
-command_query_ds18b20(uint32_t *args)
-{
-    struct ds18_s *d = oid_lookup(args[0], command_config_ds18b20);
-
-    sched_del_timer(&d->timer);
-    d->timer.waketime = args[1];
-    d->rest_time = args[2];
-    if (! d->rest_time)
-        return;
-    d->min_value = args[3];
-    d->max_value = args[4];
-    sched_add_timer(&d->timer);
-}
-DECL_COMMAND(command_query_ds18b20,
-             "query_ds18b20 oid=%c clock=%u rest_ticks=%u"
-             " min_value=%i max_value=%i");
-
-// Report temperature if ready, and set back to pending.
-static void
-ds18_send_and_request(struct ds18_s *d, uint32_t next_begin_time, uint8_t oid)
-{
-    struct timespec request_time;
-    int ret = clock_gettime(CLOCK_MONOTONIC, &request_time);
-    if (ret == -1) {
-        report_errno("get monotonic clock time", ret);
-        try_shutdown("Error getting monotonic clock time");
-        return;
-    }
-
-    pthread_mutex_lock(&d->lock);
-    if (d->status == W1_ERROR) {
-        if (d->error_count > d->max_error_count) {
-            try_shutdown("Error reading DS18B20 sensor");
-            pthread_mutex_unlock(&d->lock);
-            return;
-        } else {
-          sendf("ds18b20_result oid=%c next_clock=%u value=%i fault=%u"
-                  , oid, next_begin_time, d->temperature, d->error_count);
-          d->status = W1_READ_REQUESTED;
-        }
-    } else if (d->status == W1_IDLE) {
-        // This happens the first time requesting a temperature.
-        // Nothing to report yet.
-        d->request_time = request_time;
-        d->status = W1_READ_REQUESTED;
-    } else if (d->status == W1_READY) {
-        // Report the previous temperature and request a new one.
-        sendf("ds18b20_result oid=%c next_clock=%u value=%i fault=%u"
-              , oid, next_begin_time, d->temperature, 0);
-        if (d->temperature < d->min_value || d->temperature > d->max_value) {
-            pthread_mutex_unlock(&d->lock);
-            try_shutdown("DS18B20 out of range");
-            return;
-        }
-        d->request_time = request_time;
-        d->status = W1_READ_REQUESTED;
-        d->error_count = 0; //successful reading, reset error count
-    } else if (d->status == W1_READ_REQUESTED) {
-        // Reader thread is already reading (or will be soon).
-        // This can happen if two queries come in quick enough
-        // succession. Wait for the existing read to finish.
-        // This could also happen if the reader thread has hung. In that case,
-        // shut down the MCU. To tell the difference, see if the request time
-        // is too far in the past.
-        if (request_time.tv_sec - d->request_time.tv_sec > W1_READ_TIMEOUT_SEC)
-        {
-            pthread_mutex_unlock(&d->lock);
-            try_shutdown("DS18B20 sensor didn't respond in time");
-            return;
-        }
-    }
-    pthread_cond_signal(&d->cond);
-    pthread_mutex_unlock(&d->lock);
-}
-
-// task to read temperature and send response
-void
-ds18_task(void)
-{
-    if (!sched_check_wake(&ds18_wake))
-        return;
-    uint8_t oid;
-    struct ds18_s *d;
-    foreach_oid(oid, d, command_config_ds18b20) {
-        if (!(d->flags & TS_PENDING))
-            continue;
-        irq_disable();
-        uint32_t next_begin_time = d->timer.waketime;
-        d->flags &= ~TS_PENDING;
-        irq_enable();
-        ds18_send_and_request(d, next_begin_time, oid);
-    }
-}
-DECL_TASK(ds18_task);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/linux/spidev.c crealityShit/src/linux/spidev.c
--- klipperStock/src/linux/spidev.c	2024-01-14 23:02:00.113796253 -0600
+++ crealityShit/src/linux/spidev.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,119 +0,0 @@
-// Very basic shift-register support via a Linux SPI device
-//
-// Copyright (C) 2017-2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <fcntl.h> // open
-#include <linux/spi/spidev.h> // SPI_IOC_MESSAGE
-#include <stdio.h> // snprintf
-#include <string.h> // memset
-#include <sys/ioctl.h> // ioctl
-#include <unistd.h> // write
-#include "command.h" // DECL_COMMAND
-#include "gpio.h" // spi_setup
-#include "internal.h" // report_errno
-#include "sched.h" // shutdown
-
-#define SPIBUS(chip, pin) (((chip)<<8) + (pin))
-#define SPIBUS_TO_BUS(spi_bus) ((spi_bus) >> 8)
-#define SPIBUS_TO_DEV(spi_bus) ((spi_bus) & 0xff)
-
-DECL_ENUMERATION_RANGE("spi_bus", "spidev0.0", SPIBUS(0, 0), 16);
-DECL_ENUMERATION_RANGE("spi_bus", "spidev1.0", SPIBUS(1, 0), 16);
-DECL_ENUMERATION_RANGE("spi_bus", "spidev2.0", SPIBUS(2, 0), 16);
-DECL_ENUMERATION_RANGE("spi_bus", "spidev3.0", SPIBUS(3, 0), 16);
-DECL_ENUMERATION_RANGE("spi_bus", "spidev4.0", SPIBUS(4, 0), 16);
-DECL_ENUMERATION_RANGE("spi_bus", "spidev5.0", SPIBUS(5, 0), 16);
-DECL_ENUMERATION_RANGE("spi_bus", "spidev6.0", SPIBUS(6, 0), 16);
-DECL_ENUMERATION_RANGE("spi_bus", "spidev7.0", SPIBUS(7, 0), 16);
-
-struct spi_s {
-    uint32_t bus, dev;
-    int fd;
-};
-static struct spi_s devices[16];
-static int devices_count;
-
-static int
-spi_open(uint32_t bus, uint32_t dev)
-{
-    // Find existing device (if already opened)
-    int i;
-    for (i=0; i<devices_count; i++)
-        if (devices[i].bus == bus && devices[i].dev == dev)
-            return devices[i].fd;
-
-    // Setup new SPI device
-    if (devices_count >= ARRAY_SIZE(devices))
-        shutdown("Too many spi devices");
-    char fname[256];
-    snprintf(fname, sizeof(fname), "/dev/spidev%d.%d", bus, dev);
-    int fd = open(fname, O_RDWR|O_CLOEXEC);
-    if (fd < 0) {
-        report_errno("open spi", fd);
-        shutdown("Unable to open spi device");
-    }
-    int ret = set_non_blocking(fd);
-    if (ret < 0)
-        shutdown("Unable to set non-blocking on spi device");
-
-    devices[devices_count].bus = bus;
-    devices[devices_count].dev = dev;
-    devices[devices_count].fd = fd;
-    devices_count++;
-    return fd;
-}
-
-struct spi_config
-spi_setup(uint32_t bus, uint8_t mode, uint32_t rate)
-{
-    int bus_id = SPIBUS_TO_BUS(bus), dev_id = SPIBUS_TO_DEV(bus);
-    int fd = spi_open(bus_id, dev_id);
-    int ret = ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &rate);
-    if (ret < 0) {
-        report_errno("ioctl set max spi speed", ret);
-        shutdown("Unable to set SPI speed");
-    }
-    ret = ioctl(fd, SPI_IOC_WR_MODE, &mode);
-    if (ret < 0) {
-        report_errno("ioctl set spi mode", ret);
-        shutdown("Unable to set SPI mode");
-    }
-    return (struct spi_config) { fd , rate};
-}
-
-void
-spi_prepare(struct spi_config config)
-{
-}
-
-void
-spi_transfer(struct spi_config config, uint8_t receive_data
-             , uint8_t len, uint8_t *data)
-{
-    if (!len)
-        return;
-
-    if (receive_data) {
-        struct spi_ioc_transfer transfer;
-        memset(&transfer, 0, sizeof(transfer));
-        transfer.tx_buf = (uintptr_t)data;
-        transfer.rx_buf = (uintptr_t)data;
-        transfer.len = len;
-        transfer.speed_hz = config.rate;
-        transfer.bits_per_word = 8;
-        transfer.cs_change = 0;
-        int ret = ioctl(config.fd, SPI_IOC_MESSAGE(1), &transfer);
-        if (ret < 0) {
-            report_errno("spi ioctl", ret);
-            try_shutdown("Unable to issue spi ioctl");
-        }
-    } else {
-        int ret = write(config.fd, data, len);
-        if (ret < 0) {
-            report_errno("write spi", ret);
-            try_shutdown("Unable to write to spi");
-        }
-    }
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/linux/timer.c crealityShit/src/linux/timer.c
--- klipperStock/src/linux/timer.c	2024-01-14 23:02:00.113796253 -0600
+++ crealityShit/src/linux/timer.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,285 +0,0 @@
-// Handling of timers on linux systems
-//
-// Copyright (C) 2017-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <time.h> // struct timespec
-#include "autoconf.h" // CONFIG_CLOCK_FREQ
-#include "board/io.h" // readl
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_from_us
-#include "command.h" // DECL_CONSTANT
-#include "internal.h" // console_sleep
-#include "sched.h" // DECL_INIT
-
-// Global storage for timer handling
-static struct {
-    // Last time reported by timer_read_time()
-    uint32_t last_read_time;
-    // Fields for converting from a systime to ticks
-    time_t start_sec;
-    // Flags for tracking irq_enable()/irq_disable()
-    uint32_t must_wake_timers;
-    // Time of next software timer (also used to convert from ticks to systime)
-    uint32_t next_wake_counter;
-    struct timespec next_wake;
-    // Unix signal tracking
-    timer_t t_alarm;
-    sigset_t ss_alarm, ss_sleep;
-} TimerInfo;
-
-
-/****************************************************************
- * Timespec helpers
- ****************************************************************/
-
-// Convert a 'struct timespec' to a counter value
-static inline uint32_t
-timespec_to_time(struct timespec ts)
-{
-    return ((ts.tv_sec - TimerInfo.start_sec) * CONFIG_CLOCK_FREQ
-            + ts.tv_nsec / NSECS_PER_TICK);
-}
-
-// Convert an internal time counter to a 'struct timespec'
-static inline struct timespec
-timespec_from_time(uint32_t time)
-{
-    int32_t counter_diff = time - TimerInfo.next_wake_counter;
-    struct timespec ts;
-    ts.tv_sec = TimerInfo.next_wake.tv_sec;
-    ts.tv_nsec = TimerInfo.next_wake.tv_nsec + counter_diff * NSECS_PER_TICK;
-    if ((unsigned long)ts.tv_nsec >= NSECS) {
-        if (ts.tv_nsec < 0) {
-            ts.tv_sec--;
-            ts.tv_nsec += NSECS;
-        } else {
-            ts.tv_sec++;
-            ts.tv_nsec -= NSECS;
-        }
-    }
-    return ts;
-}
-
-// Return the current time
-static struct timespec
-timespec_read(void)
-{
-    struct timespec ts;
-    clock_gettime(CLOCK_MONOTONIC, &ts);
-    return ts;
-}
-
-
-/****************************************************************
- * Timers
- ****************************************************************/
-
-DECL_CONSTANT("CLOCK_FREQ", CONFIG_CLOCK_FREQ);
-
-// Check if a given time has past
-int
-timer_check_periodic(uint32_t *ts)
-{
-    uint32_t lrt = TimerInfo.last_read_time;
-    if (timer_is_before(lrt, *ts))
-        return 0;
-    *ts = lrt + timer_from_us(2000000);
-    return 1;
-}
-
-// Return the number of clock ticks for a given number of microseconds
-uint32_t
-timer_from_us(uint32_t us)
-{
-    return us * (CONFIG_CLOCK_FREQ / 1000000);
-}
-
-// Return true if time1 is before time2.  Always use this function to
-// compare times as regular C comparisons can fail if the counter
-// rolls over.
-uint8_t
-timer_is_before(uint32_t time1, uint32_t time2)
-{
-    return (int32_t)(time1 - time2) < 0;
-}
-
-// Return the current time (in clock ticks)
-uint32_t
-timer_read_time(void)
-{
-    uint32_t t = timespec_to_time(timespec_read());
-    TimerInfo.last_read_time = t;
-    return t;
-}
-
-// Activate timer dispatch as soon as possible
-void
-timer_kick(void)
-{
-    struct itimerspec it = { .it_interval = {0, 0}, .it_value = {0, 1} };
-    timer_settime(TimerInfo.t_alarm, TIMER_ABSTIME, &it, NULL);
-}
-
-#define TIMER_IDLE_REPEAT_COUNT 100
-#define TIMER_REPEAT_COUNT 20
-
-#define TIMER_MIN_TRY_TICKS timer_from_us(2)
-
-// Invoke timers
-static void
-timer_dispatch(void)
-{
-    uint32_t repeat_count = TIMER_REPEAT_COUNT, next;
-    for (;;) {
-        // Run the next software timer
-        next = sched_timer_dispatch();
-
-        repeat_count--;
-        uint32_t lrt = TimerInfo.last_read_time;
-        if (!timer_is_before(lrt, next) && repeat_count)
-            // Can run next timer without overhead of calling timer_read_time()
-            continue;
-
-        uint32_t now = timer_read_time();
-        int32_t diff = next - now;
-        if (diff > (int32_t)TIMER_MIN_TRY_TICKS)
-            // Schedule next timer normally.
-            break;
-
-        if (unlikely(!repeat_count)) {
-            // Check if there are too many repeat timers
-            if (diff < (int32_t)(-timer_from_us(100000)))
-                try_shutdown("Rescheduled timer in the past");
-            if (sched_tasks_busy())
-                return;
-            repeat_count = TIMER_IDLE_REPEAT_COUNT;
-        }
-
-        // Next timer in the past or near future - wait for it to be ready
-        while (unlikely(diff > 0))
-            diff = next - timer_read_time();
-    }
-
-    // Schedule SIGALRM signal
-    struct itimerspec it;
-    it.it_interval = (struct timespec){0, 0};
-    TimerInfo.next_wake = it.it_value = timespec_from_time(next);
-    TimerInfo.next_wake_counter = next;
-    TimerInfo.must_wake_timers = 0;
-    timer_settime(TimerInfo.t_alarm, TIMER_ABSTIME, &it, NULL);
-}
-
-// OS signal handler
-static void
-timer_signal(int signal)
-{
-    TimerInfo.must_wake_timers = 1;
-}
-
-void
-timer_init(void)
-{
-    // Initialize ss_alarm signal set
-    int ret = sigemptyset(&TimerInfo.ss_alarm);
-    if (ret < 0) {
-        report_errno("sigemptyset", ret);
-        return;
-    }
-    ret = sigaddset(&TimerInfo.ss_alarm, SIGALRM);
-    if (ret < 0) {
-        report_errno("sigaddset", ret);
-        return;
-    }
-    // Initialize ss_sleep signal set
-    ret = sigprocmask(0, NULL, &TimerInfo.ss_sleep);
-    if (ret < 0) {
-        report_errno("sigprocmask ss_sleep", ret);
-        return;
-    }
-    ret = sigdelset(&TimerInfo.ss_sleep, SIGALRM);
-    if (ret < 0) {
-        report_errno("sigdelset", ret);
-        return;
-    }
-    // Initialize timespec_to_time() and timespec_from_time()
-    struct timespec curtime = timespec_read();
-    TimerInfo.start_sec = curtime.tv_sec + 1;
-    TimerInfo.next_wake = curtime;
-    TimerInfo.next_wake_counter = timespec_to_time(curtime);
-    // Initialize t_alarm signal based timer
-    ret = timer_create(CLOCK_MONOTONIC, NULL, &TimerInfo.t_alarm);
-    if (ret < 0) {
-        report_errno("timer_create", ret);
-        return;
-    }
-    struct sigaction act = {.sa_handler = timer_signal, .sa_flags = SA_RESTART};
-    ret = sigaction(SIGALRM, &act, NULL);
-    if (ret < 0) {
-        report_errno("sigaction", ret);
-        return;
-    }
-    timer_kick();
-}
-DECL_INIT(timer_init);
-
-// Block SIGALRM signal
-void
-timer_disable_signals(void)
-{
-    sigprocmask(SIG_BLOCK, &TimerInfo.ss_alarm, NULL);
-}
-
-// Restore reception of SIGALRM signal
-void
-timer_enable_signals(void)
-{
-    sigprocmask(SIG_UNBLOCK, &TimerInfo.ss_alarm, NULL);
-}
-
-
-/****************************************************************
- * Interrupt wrappers
- ****************************************************************/
-
-void
-irq_disable(void)
-{
-}
-
-void
-irq_enable(void)
-{
-}
-
-irqstatus_t
-irq_save(void)
-{
-    return 0;
-}
-
-void
-irq_restore(irqstatus_t flag)
-{
-}
-
-void
-irq_wait(void)
-{
-    // Must atomically sleep until signaled
-    if (!readl(&TimerInfo.must_wake_timers)) {
-        timer_disable_signals();
-        if (!TimerInfo.must_wake_timers)
-            console_sleep(&TimerInfo.ss_sleep);
-        timer_enable_signals();
-    }
-    irq_poll();
-}
-
-void
-irq_poll(void)
-{
-    if (readl(&TimerInfo.must_wake_timers))
-        timer_dispatch();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/linux/watchdog.c crealityShit/src/linux/watchdog.c
--- klipperStock/src/linux/watchdog.c	2024-01-14 23:02:00.117796304 -0600
+++ crealityShit/src/linux/watchdog.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,36 +0,0 @@
-// Support for Linux watchdog
-//
-// Copyright (C) 2017  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <fcntl.h> // open
-#include <unistd.h> // write
-#include "internal.h" // report_errno
-#include "sched.h" // DECL_TASK
-
-static int watchdog_fd = -1;
-
-int
-watchdog_setup(void)
-{
-    int ret = open("/dev/watchdog", O_RDWR|O_CLOEXEC);
-    if (ret < 0) {
-        report_errno("watchdog open", ret);
-        return -1;
-    }
-    watchdog_fd = ret;
-    return set_non_blocking(watchdog_fd);
-}
-
-void
-watchdog_task(void)
-{
-    static uint32_t next_watchdog_time;
-    if (watchdog_fd < 0 || !timer_check_periodic(&next_watchdog_time))
-        return;
-    int ret = write(watchdog_fd, ".", 1);
-    if (ret <= 0)
-        report_errno("watchdog write", ret);
-}
-DECL_TASK(watchdog_task);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/lpc176x/adc.c crealityShit/src/lpc176x/adc.c
--- klipperStock/src/lpc176x/adc.c	2024-01-14 23:02:00.145796646 -0600
+++ crealityShit/src/lpc176x/adc.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,156 +0,0 @@
-// Analog to digital support on lpc176x
-//
-// Copyright (C) 2018-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/irq.h" // irq_save
-#include "board/misc.h" // timer_from_us
-#include "command.h" // shutdown
-#include "gpio.h" // gpio_adc_setup
-#include "internal.h" // gpio_peripheral
-#include "sched.h" // sched_shutdown
-
-static const uint8_t adc_pins[] = {
-    GPIO(0, 23), GPIO(0, 24), GPIO(0, 25), GPIO(0, 26),
-    GPIO(1, 30), GPIO(1, 31), GPIO(0, 3), GPIO(0, 2),
-};
-
-static const uint8_t adc_pin_funcs[] = {
-    1, 1, 1, 1, 3, 3, 2, 2
-};
-
-#define ADC_FREQ_MAX 13000000
-DECL_CONSTANT("ADC_MAX", 4095);
-
-// The lpc176x adc is extremely noisy. Implement a 5 entry median
-// filter to weed out obviously incorrect readings.
-static struct {
-    uint32_t adcr;
-    uint16_t pos;
-    uint16_t chan;
-    uint16_t samples[5];
-} adc_status;
-
-enum { ADC_DONE=0x0100 };
-
-// ADC hardware irq handler
-void
-ADC_IRQHandler(void)
-{
-    uint32_t pos = adc_status.pos, chan = adc_status.chan & 0xff;
-    uint32_t result = (&LPC_ADC->ADDR0)[chan];
-    if (pos >= ARRAY_SIZE(adc_status.samples))
-        // All samples complete
-        return;
-    if (pos >= ARRAY_SIZE(adc_status.samples) - 2)
-        // Turn off burst mode
-        LPC_ADC->ADCR = adc_status.adcr | (1 << chan);
-    adc_status.samples[pos++] = (result >> 4) & 0x0fff;
-    adc_status.pos = pos;
-}
-
-struct gpio_adc
-gpio_adc_setup(uint8_t pin)
-{
-    // Find pin in adc_pins table
-    int chan;
-    for (chan=0; ; chan++) {
-        if (chan >= ARRAY_SIZE(adc_pins))
-            shutdown("Not a valid ADC pin");
-        if (adc_pins[chan] == pin)
-            break;
-    }
-
-    if (!is_enabled_pclock(PCLK_ADC)) {
-        // Power up ADC
-        enable_pclock(PCLK_ADC);
-        uint32_t pclk = get_pclock_frequency(PCLK_ADC);
-        uint32_t prescal = DIV_ROUND_UP(pclk, ADC_FREQ_MAX) - 1;
-        LPC_ADC->ADCR = adc_status.adcr = (1<<21) | ((prescal & 0xff) << 8);
-        LPC_ADC->ADINTEN = 0xff;
-        adc_status.chan = ADC_DONE;
-        armcm_enable_irq(ADC_IRQHandler, ADC_IRQn, 0);
-    }
-
-    gpio_peripheral(pin, adc_pin_funcs[chan], 0);
-
-    return (struct gpio_adc){ .chan = chan };
-}
-
-// Try to sample a value. Returns zero if sample ready, otherwise
-// returns the number of clock ticks the caller should wait before
-// retrying this function.
-uint32_t
-gpio_adc_sample(struct gpio_adc g)
-{
-    uint32_t chan = adc_status.chan;
-    if (chan == g.chan) {
-        // Sample already underway - check if it is ready
-        if (adc_status.pos >= ARRAY_SIZE(adc_status.samples))
-            // Sample ready
-            return 0;
-        goto need_delay;
-    }
-    if (!(chan & ADC_DONE))
-        // ADC busy on some other channel
-        goto need_delay;
-
-    // Start new sample
-    adc_status.pos = 0;
-    adc_status.chan = g.chan;
-    LPC_ADC->ADCR = adc_status.adcr | (1 << g.chan) | (1<<16);
-
-need_delay: ;
-    uint32_t pclk = get_pclock_frequency(PCLK_ADC);
-    return ((64 * DIV_ROUND_UP(pclk, ADC_FREQ_MAX)
-             * ARRAY_SIZE(adc_status.samples)) / 4 + timer_from_us(10));
-}
-
-#define ORDER(r1, r2) do {                                      \
-        if (r1 > r2) { uint32_t t = r1; r1 = r2; r2 = t; }      \
-    } while (0)
-
-// Read a value; use only after gpio_adc_sample() returns zero
-uint16_t
-gpio_adc_read(struct gpio_adc g)
-{
-    adc_status.chan |= ADC_DONE;
-    // The lpc176x adc has a defect that causes random reports near
-    // 0xfff. Work around that with a 5 sample median filter.
-    uint16_t *p = adc_status.samples;
-    uint32_t v0 = p[0], v4 = p[1], v1 = p[2], v3 = p[3], v2 = p[4];
-    ORDER(v0, v4);
-    ORDER(v1, v3);
-    ORDER(v0, v1);
-    ORDER(v3, v4);
-    ORDER(v1, v3);
-    ORDER(v1, v2);
-    ORDER(v2, v3);
-    if (v3 >= 0xff0 || v4 >= 0xff0) {
-        ORDER(v0, v1);
-        if (v2 >= 0xff0)
-            // At least 3 reports are clearly bogus - return the minimum sample
-            return v0;
-        // 1 or 2 bogus reports - return the median of the minimum 3 samples
-        return v1;
-    }
-    // Return the median of the 5 samples
-    return v2;
-}
-
-// Cancel a sample that may have been started with gpio_adc_sample()
-void
-gpio_adc_cancel_sample(struct gpio_adc g)
-{
-    uint32_t chan = adc_status.chan;
-    if (chan != g.chan)
-        return;
-    irqstatus_t flag = irq_save();
-    LPC_ADC->ADCR = adc_status.adcr;
-    adc_status.chan = chan | ADC_DONE;
-    adc_status.pos = ARRAY_SIZE(adc_status.samples);
-    (&LPC_ADC->ADDR0)[chan & 0xff];
-    irq_restore(flag);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/lpc176x/chipid.c crealityShit/src/lpc176x/chipid.c
--- klipperStock/src/lpc176x/chipid.c	2024-01-14 23:02:00.141796598 -0600
+++ crealityShit/src/lpc176x/chipid.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,46 +0,0 @@
-// Support for extracting the hardware chip id on lpc176x
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_USB_SERIAL_NUMBER_CHIPID
-#include "generic/irq.h" // irq_disable
-#include "generic/usb_cdc.h" // usb_fill_serial
-#include "generic/usbstd.h" // usb_string_descriptor
-#include "sched.h" // DECL_INIT
-
-// IAP interface
-#define IAP_LOCATION        0x1fff1ff1
-#define IAP_CMD_READ_UID    58
-#define IAP_UID_LEN         16
-typedef void (*IAP)(uint32_t *, uint32_t *);
-
-static struct {
-    struct usb_string_descriptor desc;
-    uint16_t data[IAP_UID_LEN * 2];
-} cdc_chipid;
-
-struct usb_string_descriptor *
-usbserial_get_serialid(void)
-{
-   return &cdc_chipid.desc;
-}
-
-void
-chipid_init(void)
-{
-    if (!CONFIG_USB_SERIAL_NUMBER_CHIPID)
-        return;
-
-    uint32_t iap_cmd_uid[5] = {IAP_CMD_READ_UID, 0, 0, 0, 0};
-    uint32_t iap_resp[5];
-    IAP iap_entry = (IAP)IAP_LOCATION;
-    irq_disable();
-    iap_entry(iap_cmd_uid, iap_resp);
-    irq_enable();
-
-    usb_fill_serial(&cdc_chipid.desc, ARRAY_SIZE(cdc_chipid.data)
-                    , &iap_resp[1]);
-}
-DECL_INIT(chipid_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/lpc176x/gpio.c crealityShit/src/lpc176x/gpio.c
--- klipperStock/src/lpc176x/gpio.c	2024-01-14 23:02:00.145796646 -0600
+++ crealityShit/src/lpc176x/gpio.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,144 +0,0 @@
-// GPIO functions on lpc176x
-//
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // ffs
-#include "board/irq.h" // irq_save
-#include "command.h" // shutdown
-#include "gpio.h" // gpio_out_setup
-#include "internal.h" // gpio_peripheral
-#include "sched.h" // sched_shutdown
-
-
-/****************************************************************
- * Pin mappings
- ****************************************************************/
-
-DECL_ENUMERATION_RANGE("pin", "P0.0", GPIO(0, 0), 32);
-DECL_ENUMERATION_RANGE("pin", "P1.0", GPIO(1, 0), 32);
-DECL_ENUMERATION_RANGE("pin", "P2.0", GPIO(2, 0), 32);
-DECL_ENUMERATION_RANGE("pin", "P3.0", GPIO(3, 0), 32);
-DECL_ENUMERATION_RANGE("pin", "P4.0", GPIO(4, 0), 32);
-
-static LPC_GPIO_TypeDef * const digital_regs[] = {
-    LPC_GPIO0, LPC_GPIO1, LPC_GPIO2, LPC_GPIO3, LPC_GPIO4
-};
-
-// Set the mode and extended function of a pin
-void
-gpio_peripheral(uint32_t gpio, int func, int pull_up)
-{
-    uint32_t bank_pos = GPIO2PORT(gpio) * 2, pin_pos = (gpio % 32) * 2;
-    if (pin_pos >= 32) {
-        pin_pos -= 32;
-        bank_pos++;
-    }
-    uint32_t sel_bits = (func & 0x03) << pin_pos, mask = ~(0x03 << pin_pos);
-    uint32_t mode = (pull_up ? (pull_up > 0 ? 0x00 : 0x03) : 0x02) << pin_pos;
-    volatile uint32_t *pinsel = &LPC_PINCON->PINSEL0;
-    volatile uint32_t *pinmode = &LPC_PINCON->PINMODE0;
-    irqstatus_t flag = irq_save();
-    pinsel[bank_pos] = (pinsel[bank_pos] & mask) | sel_bits;
-    pinmode[bank_pos] = (pinmode[bank_pos] & mask) | mode;
-    irq_restore(flag);
-}
-
-// Convert a register and bit location back to an integer pin identifier
-static int
-regs_to_pin(LPC_GPIO_TypeDef *regs, uint32_t bit)
-{
-    int i;
-    for (i=0; i<ARRAY_SIZE(digital_regs); i++)
-        if (digital_regs[i] == regs)
-            return GPIO(i, ffs(bit)-1);
-    return 0;
-}
-
-
-/****************************************************************
- * General Purpose Input Output (GPIO) pins
- ****************************************************************/
-
-struct gpio_out
-gpio_out_setup(uint8_t pin, uint8_t val)
-{
-    if (GPIO2PORT(pin) >= ARRAY_SIZE(digital_regs))
-        goto fail;
-    LPC_GPIO_TypeDef *regs = digital_regs[GPIO2PORT(pin)];
-    struct gpio_out g = { .regs=regs, .bit=GPIO2BIT(pin) };
-    gpio_out_reset(g, val);
-    return g;
-fail:
-    shutdown("Not an output pin");
-}
-
-void
-gpio_out_reset(struct gpio_out g, uint8_t val)
-{
-    LPC_GPIO_TypeDef *regs = g.regs;
-    int pin = regs_to_pin(regs, g.bit);
-    irqstatus_t flag = irq_save();
-    regs->FIOPIN = (regs->FIOSET & ~g.bit) | (val ? g.bit : 0);
-    regs->FIODIR |= g.bit;
-    gpio_peripheral(pin, 0, 0);
-    irq_restore(flag);
-}
-
-void
-gpio_out_toggle_noirq(struct gpio_out g)
-{
-    LPC_GPIO_TypeDef *regs = g.regs;
-    regs->FIOPIN = regs->FIOSET ^ g.bit;
-}
-
-void
-gpio_out_toggle(struct gpio_out g)
-{
-    irqstatus_t flag = irq_save();
-    gpio_out_toggle_noirq(g);
-    irq_restore(flag);
-}
-
-void
-gpio_out_write(struct gpio_out g, uint8_t val)
-{
-    LPC_GPIO_TypeDef *regs = g.regs;
-    if (val)
-        regs->FIOSET = g.bit;
-    else
-        regs->FIOCLR = g.bit;
-}
-
-
-struct gpio_in
-gpio_in_setup(uint8_t pin, int8_t pull_up)
-{
-    if (GPIO2PORT(pin) >= ARRAY_SIZE(digital_regs))
-        goto fail;
-    LPC_GPIO_TypeDef *regs = digital_regs[GPIO2PORT(pin)];
-    struct gpio_in g = { .regs=regs, .bit=GPIO2BIT(pin) };
-    gpio_in_reset(g, pull_up);
-    return g;
-fail:
-    shutdown("Not an input pin");
-}
-
-void
-gpio_in_reset(struct gpio_in g, int8_t pull_up)
-{
-    LPC_GPIO_TypeDef *regs = g.regs;
-    int pin = regs_to_pin(regs, g.bit);
-    irqstatus_t flag = irq_save();
-    gpio_peripheral(pin, 0, pull_up);
-    regs->FIODIR &= ~g.bit;
-    irq_restore(flag);
-}
-
-uint8_t
-gpio_in_read(struct gpio_in g)
-{
-    LPC_GPIO_TypeDef *regs = g.regs;
-    return !!(regs->FIOPIN & g.bit);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/lpc176x/gpio.h crealityShit/src/lpc176x/gpio.h
--- klipperStock/src/lpc176x/gpio.h	2024-01-14 23:02:00.145796646 -0600
+++ crealityShit/src/lpc176x/gpio.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,58 +0,0 @@
-#ifndef __LPC176X_GPIO_H
-#define __LPC176X_GPIO_H
-
-#include <stdint.h>
-
-struct gpio_out {
-    void *regs;
-    uint32_t bit;
-};
-struct gpio_out gpio_out_setup(uint8_t pin, uint8_t val);
-void gpio_out_reset(struct gpio_out g, uint8_t val);
-void gpio_out_toggle_noirq(struct gpio_out g);
-void gpio_out_toggle(struct gpio_out g);
-void gpio_out_write(struct gpio_out g, uint8_t val);
-
-struct gpio_in {
-    void *regs;
-    uint32_t bit;
-};
-struct gpio_in gpio_in_setup(uint8_t pin, int8_t pull_up);
-void gpio_in_reset(struct gpio_in g, int8_t pull_up);
-uint8_t gpio_in_read(struct gpio_in g);
-
-struct gpio_pwm {
-    void *reg;
-    uint8_t channel;
-};
-struct gpio_pwm gpio_pwm_setup(uint8_t pin, uint32_t cycle_time, uint8_t val);
-void gpio_pwm_write(struct gpio_pwm g, uint32_t val);
-
-struct gpio_adc {
-    uint32_t chan;
-};
-struct gpio_adc gpio_adc_setup(uint8_t pin);
-uint32_t gpio_adc_sample(struct gpio_adc g);
-uint16_t gpio_adc_read(struct gpio_adc g);
-void gpio_adc_cancel_sample(struct gpio_adc g);
-
-struct spi_config {
-    void *spi;
-    uint32_t cr0, cpsr;
-};
-struct spi_config spi_setup(uint32_t bus, uint8_t mode, uint32_t rate);
-void spi_prepare(struct spi_config config);
-void spi_transfer(struct spi_config config, uint8_t receive_data
-                  , uint8_t len, uint8_t *data);
-
-struct i2c_config {
-    void *i2c;
-    uint8_t addr;
-};
-
-struct i2c_config i2c_setup(uint32_t bus, uint32_t rate, uint8_t addr);
-void i2c_write(struct i2c_config config, uint8_t write_len, uint8_t *write);
-void i2c_read(struct i2c_config config, uint8_t reg_len, uint8_t *reg
-              , uint8_t read_len, uint8_t *read);
-
-#endif // gpio.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/lpc176x/hard_pwm.c crealityShit/src/lpc176x/hard_pwm.c
--- klipperStock/src/lpc176x/hard_pwm.c	2024-01-14 23:02:00.141796598 -0600
+++ crealityShit/src/lpc176x/hard_pwm.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,96 +0,0 @@
-// Hardware PWM support on lpc176x
-//
-// Copyright (C) 2021  Michael Kurz <michi.kurz@gmail.com>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_CLOCK_FREQ
-#include "board/irq.h" // irq_save
-#include "command.h" // shutdown
-#include "gpio.h" // gpio_pwm_write
-#include "internal.h" // GPIO
-#include "sched.h" // sched_shutdown
-
-#define MAX_PWM 255
-DECL_CONSTANT("PWM_MAX", MAX_PWM);
-
-struct gpio_pwm_info {
-    uint8_t pin, channel, function;
-    void *reg;
-};
-
-static const struct gpio_pwm_info pwm_regs[] = {
-    {GPIO(1, 18), 1, 2, (void*)&LPC_PWM1->MR1},
-    {GPIO(2,  0), 1, 1, (void*)&LPC_PWM1->MR1},
-    {GPIO(1, 20), 2, 2, (void*)&LPC_PWM1->MR2},
-    {GPIO(2,  1), 2, 1, (void*)&LPC_PWM1->MR2},
-    {GPIO(3, 25), 2, 3, (void*)&LPC_PWM1->MR2},
-    {GPIO(1, 21), 3, 2, (void*)&LPC_PWM1->MR3},
-    {GPIO(2,  2), 3, 1, (void*)&LPC_PWM1->MR3},
-    {GPIO(3, 26), 3, 3, (void*)&LPC_PWM1->MR3},
-    {GPIO(1, 23), 4, 2, (void*)&LPC_PWM1->MR4},
-    {GPIO(2,  3), 4, 1, (void*)&LPC_PWM1->MR4},
-    {GPIO(1, 24), 5, 2, (void*)&LPC_PWM1->MR5},
-    {GPIO(2,  4), 5, 1, (void*)&LPC_PWM1->MR5},
-    {GPIO(1, 26), 6, 2, (void*)&LPC_PWM1->MR6},
-    {GPIO(2,  5), 6, 1, (void*)&LPC_PWM1->MR6}
-};
-
-struct gpio_pwm
-gpio_pwm_setup(uint8_t pin, uint32_t cycle_time, uint8_t val) {
-    // Find pin in pwm_regs table
-    const struct gpio_pwm_info* p = pwm_regs;
-    for (;; p++) {
-        if (p >= &pwm_regs[ARRAY_SIZE(pwm_regs)])
-            shutdown("Not a valid PWM pin");
-        if (p->pin == pin)
-            break;
-    }
-
-    // Map cycle_time to pwm clock divisor
-    uint32_t clock_div = CONFIG_CLOCK_FREQ / get_pclock_frequency(PCLK_PWM1);
-    uint32_t prescaler = (cycle_time / clock_div) / (MAX_PWM - 1);
-    if (prescaler > 0) {
-        prescaler -= 1;
-    }
-
-    gpio_peripheral(p->pin, p->function, 0);
-
-    // Enable clock
-    if (!is_enabled_pclock(PCLK_PWM1)) {
-        enable_pclock(PCLK_PWM1);
-    }
-
-    if (LPC_PWM1->TCR & 0x1) {
-        if (LPC_PWM1->PR != prescaler) {
-            shutdown("PWM already programmed at different speed");
-        }
-    } else {
-        LPC_PWM1->PCR = 0;
-        LPC_PWM1->PR = (uint16_t) prescaler;
-        LPC_PWM1->MR0 = MAX_PWM - 1;
-        LPC_PWM1->TCR = 0x2;  // Reset PWM TC and PC
-        LPC_PWM1->MCR = 0x2;  // Reset Counter on MR0 match
-        LPC_PWM1->TCR = 0x8;  // Enable PWM mode
-        LPC_PWM1->TCR |= 0x1; // Enable PWM peripheral
-    }
-
-    if (LPC_PWM1->PCR & (1 << (p->channel + 8))) {
-        shutdown("PWM output already in use");
-    }
-
-    // Setup channel
-    struct gpio_pwm channel = {.reg = p->reg, .channel = p->channel};
-    gpio_pwm_write(channel, val);
-
-    // Enable channel
-    LPC_PWM1->PCR |= (1 << (p->channel + 8));
-
-    return channel;
-}
-
-void
-gpio_pwm_write(struct gpio_pwm g, uint32_t val) {
-    *(volatile uint32_t*) g.reg = val;
-    LPC_PWM1->LER |= (1 << g.channel);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/lpc176x/i2c.c crealityShit/src/lpc176x/i2c.c
--- klipperStock/src/lpc176x/i2c.c	2024-01-14 23:02:00.141796598 -0600
+++ crealityShit/src/lpc176x/i2c.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,162 +0,0 @@
-// I2C functions on lpc176x
-//
-// Copyright (C) 2018-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/misc.h" // timer_is_before
-#include "command.h" // DECL_COMMAND
-#include "gpio.h" // i2c_setup
-#include "internal.h" // gpio_peripheral
-#include "sched.h" // sched_shutdown
-
-struct i2c_info {
-    LPC_I2C_TypeDef *i2c;
-    uint8_t scl_pin, sda_pin, function, pclk;
-};
-
-DECL_ENUMERATION("i2c_bus", "i2c1", 0);
-DECL_ENUMERATION("i2c_bus", "i2c1a", 1);
-DECL_ENUMERATION("i2c_bus", "i2c0", 2);
-DECL_ENUMERATION("i2c_bus", "i2c2", 3);
-DECL_CONSTANT_STR("BUS_PINS_i2c1", "P0.1,P0.0");
-DECL_CONSTANT_STR("BUS_PINS_i2c1a", "P0.20,P0.19");
-DECL_CONSTANT_STR("BUS_PINS_i2c0", "P0.28,P0.27");
-DECL_CONSTANT_STR("BUS_PINS_i2c2", "P0.11,P0.10");
-
-static const struct i2c_info i2c_bus[] = {
-    { LPC_I2C1, GPIO(0, 1), GPIO(0, 0), 3, PCLK_I2C1 },
-    { LPC_I2C1, GPIO(0, 20), GPIO(0, 19), 3, PCLK_I2C1 },
-    { LPC_I2C0, GPIO(0, 28), GPIO(0, 27), 1, PCLK_I2C0 },
-    { LPC_I2C2, GPIO(0, 11), GPIO(0, 10), 2, PCLK_I2C2 },
-};
-
-// i2c connection status flags
-enum {
-    IF_START = 1<<5, IF_STOP = 1<<4, IF_IRQ = 1<<3, IF_ACK = 1<<2, IF_ENA = 1<<6
-};
-
-struct i2c_config
-i2c_setup(uint32_t bus, uint32_t rate, uint8_t addr)
-{
-    if (bus >= ARRAY_SIZE(i2c_bus))
-        shutdown("Invalid i2c bus");
-
-    const struct i2c_info *info = &i2c_bus[bus];
-    LPC_I2C_TypeDef *i2c = info->i2c;
-    static uint8_t have_run_init;
-    if (!(have_run_init & (1 << bus))) {
-        have_run_init |= 1 << bus;
-
-        // Init pins
-        gpio_peripheral(info->scl_pin, info->function, 0);
-        gpio_peripheral(info->sda_pin, info->function, 0);
-
-        // Set 100Khz frequency
-        enable_pclock(info->pclk);
-        uint32_t pclk = get_pclock_frequency(info->pclk);
-        uint32_t pulse = pclk / (100000 * 2);
-        i2c->I2SCLL = pulse;
-        i2c->I2SCLH = pulse;
-
-        // Enable interface
-        i2c->I2CONCLR = IF_START | IF_IRQ | IF_ACK | IF_ENA;
-        i2c->I2CONSET = IF_ENA;
-    }
-
-    return (struct i2c_config){ .i2c=i2c, .addr=addr<<1 };
-}
-
-static void
-i2c_wait(LPC_I2C_TypeDef *i2c, uint32_t bit, uint32_t timeout)
-{
-    for (;;) {
-        uint32_t flags = i2c->I2CONSET;
-        if (flags & bit)
-            break;
-        if (!timer_is_before(timer_read_time(), timeout))
-            shutdown("i2c timeout");
-    }
-}
-
-static void
-i2c_start(LPC_I2C_TypeDef *i2c, uint32_t timeout)
-{
-    i2c->I2CONCLR = IF_ACK | IF_IRQ | IF_START;
-    i2c->I2CONSET = IF_ACK | IF_START;
-    i2c_wait(i2c, IF_IRQ, timeout);
-    uint32_t status = i2c->I2STAT;
-    if (status != 0x10 && status != 0x08)
-        shutdown("Failed to send i2c start");
-    i2c->I2CONCLR = IF_START;
-}
-
-static uint32_t
-i2c_send_byte(LPC_I2C_TypeDef *i2c, uint8_t b, uint32_t timeout)
-{
-    i2c->I2DAT = b;
-    i2c->I2CONCLR = IF_IRQ;
-    i2c_wait(i2c, IF_IRQ, timeout);
-    return i2c->I2STAT;
-}
-
-static uint8_t
-i2c_read_byte(LPC_I2C_TypeDef *i2c, uint32_t timeout, uint8_t remaining)
-{
-  if (remaining == 0)
-      i2c->I2CONCLR = IF_ACK | IF_IRQ;
-  else {
-      i2c->I2CONSET = IF_ACK;
-      i2c->I2CONCLR = IF_IRQ;
-  }
-  i2c_wait(i2c, IF_IRQ, timeout);
-  uint8_t b = i2c->I2DAT;
-  return b;
-}
-
-static void
-i2c_stop(LPC_I2C_TypeDef *i2c, uint32_t timeout)
-{
-    i2c->I2CONSET = IF_STOP;
-    i2c->I2CONCLR = IF_IRQ;
-    i2c_wait(i2c, IF_STOP, timeout);
-}
-
-void
-i2c_write(struct i2c_config config, uint8_t write_len, uint8_t *write)
-{
-    LPC_I2C_TypeDef *i2c = config.i2c;
-    uint32_t timeout = timer_read_time() + timer_from_us(5000);
-
-    i2c_start(i2c, timeout);
-    i2c_send_byte(i2c, config.addr, timeout);
-    while (write_len--)
-        i2c_send_byte(i2c, *write++, timeout);
-    i2c_stop(i2c, timeout);
-}
-
-void
-i2c_read(struct i2c_config config, uint8_t reg_len, uint8_t *reg
-         , uint8_t read_len, uint8_t *read)
-{
-    LPC_I2C_TypeDef *i2c = config.i2c;
-    uint32_t timeout = timer_read_time() + timer_from_us(5000);
-    uint8_t addr = config.addr | 0x01;
-
-    if (reg_len != 0) {
-        // write the register
-        i2c_start(i2c, timeout);
-        i2c_send_byte(i2c, config.addr, timeout);
-        while(reg_len--)
-            i2c_send_byte(i2c, *reg++, timeout);
-        i2c_stop(i2c, timeout);
-    }
-    // start/re-start and read data
-    i2c_start(i2c, timeout);
-    i2c_send_byte(i2c, addr, timeout);
-    while(read_len--) {
-        *read = i2c_read_byte(i2c, timeout, read_len);
-        read++;
-    }
-    i2c_stop(i2c, timeout);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/lpc176x/internal.h crealityShit/src/lpc176x/internal.h
--- klipperStock/src/lpc176x/internal.h	2024-01-14 23:02:00.145796646 -0600
+++ crealityShit/src/lpc176x/internal.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,28 +0,0 @@
-#ifndef __LPC176X_INTERNAL_H
-#define __LPC176X_INTERNAL_H
-// Local definitions for lpc176x code
-
-#include "LPC17xx.h"
-
-#define GPIO(PORT, NUM) ((PORT) * 32 + (NUM))
-#define GPIO2PORT(PIN) ((PIN) / 32)
-#define GPIO2BIT(PIN) (1<<((PIN) % 32))
-
-#define PCLK_TIMER0 1
-#define PCLK_UART0 3
-#define PCLK_PWM1 6
-#define PCLK_I2C0 7
-#define PCLK_SSP1 10
-#define PCLK_ADC 12
-#define PCLK_I2C1 19
-#define PCLK_SSP0 21
-#define PCLK_UART3 25
-#define PCLK_I2C2 26
-#define PCLK_USB 31
-int is_enabled_pclock(uint32_t pclk);
-void enable_pclock(uint32_t pclk);
-uint32_t get_pclock_frequency(uint32_t pclk);
-void gpio_peripheral(uint32_t gpio, int func, int pullup);
-void usb_disconnect(void);
-
-#endif // internal.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/lpc176x/Kconfig crealityShit/src/lpc176x/Kconfig
--- klipperStock/src/lpc176x/Kconfig	2024-01-14 23:02:00.145796646 -0600
+++ crealityShit/src/lpc176x/Kconfig	1969-12-31 18:00:00.000000000 -0600
@@ -1,96 +0,0 @@
-# Kconfig settings for LPC176x processors
-
-if MACH_LPC176X
-
-config LPC_SELECT
-    bool
-    default y
-    select HAVE_GPIO
-    select HAVE_GPIO_ADC
-    select HAVE_GPIO_I2C
-    select HAVE_GPIO_SPI
-    select HAVE_GPIO_BITBANGING
-    select HAVE_STRICT_TIMING
-    select HAVE_CHIPID
-    select HAVE_GPIO_HARD_PWM
-    select HAVE_STEPPER_BOTH_EDGE
-    select SERIAL_BOOTLOADER_SIDECHANNEL
-
-config BOARD_DIRECTORY
-    string
-    default "lpc176x"
-
-choice
-    prompt "Processor model"
-    config MACH_LPC1768
-        bool "lpc1768 (100 MHz)"
-    config MACH_LPC1769
-        bool "lpc1769 (120 MHz)"
-endchoice
-
-config MCU
-    string
-    default "lpc1768" if MACH_LPC1768
-    default "lpc1769" if MACH_LPC1769
-
-config CLOCK_FREQ
-    int
-    default 100000000 if MACH_LPC1768
-    default 120000000 if MACH_LPC1769
-
-config FLASH_SIZE
-    hex
-    default 0x80000
-
-config FLASH_BOOT_ADDRESS
-    hex
-    default 0x0
-
-config RAM_START
-    hex
-    default 0x10000000
-
-config RAM_SIZE
-    hex
-    default 0x7fe0 # (0x8000 - 32) - top 32 bytes used by IAP functions
-
-config STACK_SIZE
-    int
-    default 512
-
-
-######################################################################
-# Bootloader
-######################################################################
-
-choice
-    prompt "Bootloader offset"
-    config LPC_FLASH_START_4000
-        bool "16KiB bootloader (Smoothieware bootloader)"
-    config LPC_FLASH_START_0000
-        bool "No bootloader"
-endchoice
-config FLASH_APPLICATION_ADDRESS
-    hex
-    default 0x4000 if LPC_FLASH_START_4000
-    default 0x0000
-
-
-######################################################################
-# Communication inteface
-######################################################################
-
-choice
-    prompt "Communication interface"
-    config LPC_USB
-        bool "USB"
-        select USBSERIAL
-    config LPC_SERIAL_UART0_P03_P02
-        bool "Serial (on UART0 P0.3/P0.2)"
-        select SERIAL
-    config LPC_SERIAL_UART3_P429_P428
-        bool "Serial (on UART3 P4.29/P4.28)" if LOW_LEVEL_OPTIONS
-        select SERIAL
-endchoice
-
-endif
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/lpc176x/main.c crealityShit/src/lpc176x/main.c
--- klipperStock/src/lpc176x/main.c	2024-01-14 23:02:00.145796646 -0600
+++ crealityShit/src/lpc176x/main.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,87 +0,0 @@
-// Main starting point for LPC176x boards.
-//
-// Copyright (C) 2018-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_CLOCK_FREQ
-#include "board/armcm_boot.h" // armcm_main
-#include "board/armcm_reset.h" // try_request_canboot
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // bootloader_request
-#include "internal.h" // enable_pclock
-#include "sched.h" // sched_main
-
-
-/****************************************************************
- * watchdog handler
- ****************************************************************/
-
-void
-watchdog_reset(void)
-{
-    LPC_WDT->WDFEED = 0xaa;
-    LPC_WDT->WDFEED = 0x55;
-}
-DECL_TASK(watchdog_reset);
-
-void
-watchdog_init(void)
-{
-    LPC_WDT->WDTC = 4000000 / 2; // 500ms timeout
-    LPC_WDT->WDCLKSEL = 1<<31; // Lock to internal RC
-    LPC_WDT->WDMOD = 0x03; // select reset and enable
-    watchdog_reset();
-}
-DECL_INIT(watchdog_init);
-
-
-/****************************************************************
- * misc functions
- ****************************************************************/
-
-// Try to reboot into bootloader
-void
-bootloader_request(void)
-{
-    if (!CONFIG_FLASH_APPLICATION_ADDRESS)
-        return;
-    try_request_canboot();
-    // Disable USB and pause for 5ms so host recognizes a disconnect
-    irq_disable();
-    if (CONFIG_USB)
-        usb_disconnect();
-    // The "LPC17xx-DFU-Bootloader" will enter the bootloader if the
-    // watchdog timeout flag is set.
-    LPC_WDT->WDMOD = 0x07;
-    NVIC_SystemReset();
-}
-
-// Check if a peripheral clock has been enabled
-int
-is_enabled_pclock(uint32_t pclk)
-{
-    return !!(LPC_SC->PCONP & (1<<pclk));
-}
-
-// Enable a peripheral clock
-void
-enable_pclock(uint32_t pclk)
-{
-    LPC_SC->PCONP |= 1<<pclk;
-}
-
-// Return the frequency of the given peripheral clock
-uint32_t
-get_pclock_frequency(uint32_t pclk)
-{
-    return CONFIG_CLOCK_FREQ;
-}
-
-// Main entry point - called from armcm_boot.c:ResetHandler()
-void
-armcm_main(void)
-{
-    SystemInit();
-    sched_main();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/lpc176x/Makefile crealityShit/src/lpc176x/Makefile
--- klipperStock/src/lpc176x/Makefile	2024-01-14 23:02:00.141796598 -0600
+++ crealityShit/src/lpc176x/Makefile	1969-12-31 18:00:00.000000000 -0600
@@ -1,37 +0,0 @@
-# lpc176x build rules
-
-# Setup the toolchain
-CROSS_PREFIX=arm-none-eabi-
-
-dirs-y += src/lpc176x src/generic lib/lpc176x/device
-
-CFLAGS += -mthumb -mcpu=cortex-m3 -Ilib/lpc176x/device -Ilib/cmsis-core
-
-CFLAGS_klipper.elf += --specs=nano.specs --specs=nosys.specs
-CFLAGS_klipper.elf += -T $(OUT)src/generic/armcm_link.ld
-$(OUT)klipper.elf: $(OUT)src/generic/armcm_link.ld
-
-# Add source files
-src-y += lpc176x/main.c lpc176x/gpio.c
-src-y += generic/armcm_boot.c generic/armcm_irq.c generic/armcm_timer.c
-src-y += generic/armcm_reset.c generic/crc16_ccitt.c
-src-y += ../lib/lpc176x/device/system_LPC17xx.c
-src-$(CONFIG_HAVE_GPIO_ADC) += lpc176x/adc.c
-src-$(CONFIG_HAVE_GPIO_I2C) += lpc176x/i2c.c
-src-$(CONFIG_HAVE_GPIO_SPI) += lpc176x/spi.c
-src-$(CONFIG_USBSERIAL) += lpc176x/usbserial.c lpc176x/chipid.c
-src-$(CONFIG_USBSERIAL) += generic/usb_cdc.c
-src-$(CONFIG_SERIAL) += lpc176x/serial.c generic/serial_irq.c
-src-$(CONFIG_HAVE_GPIO_HARD_PWM) += lpc176x/hard_pwm.c
-
-# Build the additional bin output file
-target-y += $(OUT)klipper.bin
-
-$(OUT)klipper.bin: $(OUT)klipper.elf
-	@echo "  Creating bin file $@"
-	$(Q)$(OBJCOPY) -O binary $< $@
-
-# Flash rules
-flash: $(OUT)klipper.bin
-	@echo "  Flashing $< to $(FLASH_DEVICE)"
-	$(Q)$(PYTHON) ./scripts/flash_usb.py -t $(CONFIG_MCU) -d "$(FLASH_DEVICE)" $(if $(NOSUDO),--no-sudo) $(OUT)klipper.bin
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/lpc176x/serial.c crealityShit/src/lpc176x/serial.c
--- klipperStock/src/lpc176x/serial.c	2024-01-14 23:02:00.141796598 -0600
+++ crealityShit/src/lpc176x/serial.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,98 +0,0 @@
-// lpc176x serial port
-//
-// Copyright (C) 2018-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "autoconf.h" // CONFIG_SERIAL_BAUD
-#include "board/irq.h" // irq_save
-#include "board/serial_irq.h" // serial_rx_data
-#include "command.h" // DECL_CONSTANT_STR
-#include "internal.h" // gpio_peripheral
-#include "sched.h" // DECL_INIT
-
-#if CONFIG_LPC_SERIAL_UART0_P03_P02
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "P0.3,P0.2");
-  #define GPIO_Rx GPIO(0, 3)
-  #define GPIO_Tx GPIO(0, 2)
-  #define GPIO_FUNCTION_UARTx 1
-  #define LPC_UARTx LPC_UART0
-  #define UARTx_IRQn UART0_IRQn
-  #define PCLK_UARTx PCLK_UART0
-#elif CONFIG_LPC_SERIAL_UART3_P429_P428
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "P4.29,P4.28");
-  #define GPIO_Rx GPIO(4, 29)
-  #define GPIO_Tx GPIO(4, 28)
-  #define GPIO_FUNCTION_UARTx 3
-  #define LPC_UARTx LPC_UART3
-  #define UARTx_IRQn UART3_IRQn
-  #define PCLK_UARTx PCLK_UART3
-#endif
-
-// Write tx bytes to the serial port
-static void
-kick_tx(void)
-{
-    for (;;) {
-        if (!(LPC_UARTx->LSR & (1<<5))) {
-            // Output fifo full - enable tx irq
-            LPC_UARTx->IER = 0x03;
-            break;
-        }
-        uint8_t data;
-        int ret = serial_get_tx_byte(&data);
-        if (ret) {
-            // No more data to send - disable tx irq
-            LPC_UARTx->IER = 0x01;
-            break;
-        }
-        LPC_UARTx->THR = data;
-    }
-}
-
-void
-UARTx_IRQHandler(void)
-{
-    uint32_t iir = LPC_UARTx->IIR, status = iir & 0x0f;
-    if (status == 0x04)
-        serial_rx_byte(LPC_UARTx->RBR);
-    else if (status == 0x02)
-        kick_tx();
-}
-
-void
-serial_enable_tx_irq(void)
-{
-    if (LPC_UARTx->LSR & (1<<5)) {
-        irqstatus_t flag = irq_save();
-        kick_tx();
-        irq_restore(flag);
-    }
-}
-
-void
-serial_init(void)
-{
-    // Setup baud
-    enable_pclock(PCLK_UARTx);
-    LPC_UARTx->LCR = (1<<7); // set DLAB bit
-    uint32_t pclk = get_pclock_frequency(PCLK_UARTx);
-    uint32_t div = pclk / (CONFIG_SERIAL_BAUD * 16);
-    LPC_UARTx->DLL = div & 0xff;
-    LPC_UARTx->DLM = (div >> 8) & 0xff;
-    LPC_UARTx->FDR = 0x10;
-    LPC_UARTx->LCR = 3; // 8N1 ; clear DLAB bit
-
-    // Enable fifo
-    LPC_UARTx->FCR = 0x01;
-
-    // Setup pins
-    gpio_peripheral(GPIO_Rx, GPIO_FUNCTION_UARTx, 0);
-    gpio_peripheral(GPIO_Tx, GPIO_FUNCTION_UARTx, 0);
-
-    // Enable receive irq
-    armcm_enable_irq(UARTx_IRQHandler, UARTx_IRQn, 0);
-    LPC_UARTx->IER = 0x01;
-}
-DECL_INIT(serial_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/lpc176x/spi.c crealityShit/src/lpc176x/spi.c
--- klipperStock/src/lpc176x/spi.c	2024-01-14 23:02:00.145796646 -0600
+++ crealityShit/src/lpc176x/spi.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,101 +0,0 @@
-// SPI support on lpc176x
-//
-// Copyright (C) 2018-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "command.h" // shutdown
-#include "gpio.h" // spi_setup
-#include "internal.h" // gpio_peripheral
-#include "sched.h" // sched_shutdown
-
-struct spi_info {
-    LPC_SSP_TypeDef *spi;
-    uint8_t miso_pin, mosi_pin, sck_pin, pclk;
-};
-
-DECL_ENUMERATION("spi_bus", "ssp0", 0);
-DECL_CONSTANT_STR("BUS_PINS_ssp0", "P0.17,P0.18,P0.15");
-DECL_ENUMERATION("spi_bus", "ssp1", 1);
-DECL_CONSTANT_STR("BUS_PINS_ssp1", "P0.8,P0.9,P0.7");
-
-static const struct spi_info spi_bus[] = {
-    { LPC_SSP0, GPIO(0, 17), GPIO(0, 18), GPIO(0, 15), PCLK_SSP0 },
-    { LPC_SSP1, GPIO(0, 8), GPIO(0, 9), GPIO(0, 7), PCLK_SSP1 },
-};
-
-static void
-spi_init(uint32_t bus)
-{
-    static int have_run_init[ARRAY_SIZE(spi_bus)];
-    if (have_run_init[bus])
-        return;
-    have_run_init[bus] = 1;
-
-    // Configure MISO0, MOSI0, SCK0 pins
-    gpio_peripheral(spi_bus[bus].miso_pin, 2, 0);
-    gpio_peripheral(spi_bus[bus].mosi_pin, 2, 0);
-    gpio_peripheral(spi_bus[bus].sck_pin, 2, 0);
-
-    // Setup clock
-    enable_pclock(spi_bus[bus].pclk);
-
-    // Set initial registers
-    LPC_SSP_TypeDef *spi = spi_bus[bus].spi;
-    spi->CR0 = 0x07;
-    spi->CPSR = 254;
-    spi->CR1 = 1<<1;
-}
-
-struct spi_config
-spi_setup(uint32_t bus, uint8_t mode, uint32_t rate)
-{
-    if (bus >= ARRAY_SIZE(spi_bus))
-        shutdown("Invalid spi_setup parameters");
-
-    // Make sure bus is enabled
-    spi_init(bus);
-
-    // Setup clock rate and mode
-    struct spi_config res = {spi_bus[bus].spi, 0, 0};
-    uint32_t pclk = get_pclock_frequency(spi_bus[bus].pclk);
-    uint32_t div = DIV_ROUND_UP(pclk/2, rate) << 1;
-    res.cpsr = div < 2 ? 2 : (div > 254 ? 254 : div);
-    res.cr0 = 0x07 | ((mode & 2) << 5) | ((mode & 1) << 7);
-
-    return res;
-}
-
-void
-spi_prepare(struct spi_config config)
-{
-    LPC_SSP_TypeDef *spi = config.spi;
-    spi->CR0 = config.cr0;
-    spi->CPSR = config.cpsr;
-}
-
-void
-spi_transfer(struct spi_config config, uint8_t receive_data
-             , uint8_t len, uint8_t *data)
-{
-    LPC_SSP_TypeDef *spi = config.spi;
-    if (receive_data) {
-        while (len--) {
-            spi->DR = *data;
-            // wait for read data to be ready
-            while (!(spi->SR & (1<<2)))
-                ;
-            // get data
-            *data++ = spi->DR;
-        }
-    } else {
-        while (len--) {
-            spi->DR = *data++;
-            // wait for read data to be ready
-            while (!(spi->SR & (1<<2)))
-                ;
-            // read data (to clear receive fifo)
-            spi->DR;
-        }
-    }
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/lpc176x/usb_cdc_ep.h crealityShit/src/lpc176x/usb_cdc_ep.h
--- klipperStock/src/lpc176x/usb_cdc_ep.h	2024-01-14 23:02:00.145796646 -0600
+++ crealityShit/src/lpc176x/usb_cdc_ep.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,10 +0,0 @@
-#ifndef __LPC176X_USB_CDC_EP_H
-#define __LPC176X_USB_CDC_EP_H
-
-enum {
-    USB_CDC_EP_ACM = 1,
-    USB_CDC_EP_BULK_OUT = 2,
-    USB_CDC_EP_BULK_IN = 5,
-};
-
-#endif // usb_cdc_ep.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/lpc176x/usbserial.c crealityShit/src/lpc176x/usbserial.c
--- klipperStock/src/lpc176x/usbserial.c	2024-01-14 23:02:00.149796696 -0600
+++ crealityShit/src/lpc176x/usbserial.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,322 +0,0 @@
-// Hardware interface to USB on lpc176x
-//
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memcpy
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/armcm_timer.h" // udelay
-#include "board/misc.h" // timer_read_time
-#include "byteorder.h" // cpu_to_le32
-#include "command.h" // DECL_CONSTANT_STR
-#include "generic/usb_cdc.h" // usb_notify_ep0
-#include "internal.h" // gpio_peripheral
-#include "sched.h" // DECL_INIT
-#include "usb_cdc_ep.h" // USB_CDC_EP_BULK_IN
-
-// Internal endpoint addresses
-#define EP0OUT 0x00
-#define EP0IN 0x01
-#define EP1IN 0x03
-#define EP2OUT 0x04
-#define EP5IN 0x0b
-
-// USB device interupt status flags
-#define EP_SLOW (1<<2)
-#define DEV_STAT (1<<3)
-#define CCEMPTY (1<<4)
-#define CDFULL (1<<5)
-#define EP_RLZED (1<<8)
-
-#define RD_EN (1<<0)
-#define WR_EN (1<<1)
-
-static void
-usb_irq_disable(void)
-{
-    NVIC_DisableIRQ(USB_IRQn);
-}
-
-static void
-usb_irq_enable(void)
-{
-    NVIC_EnableIRQ(USB_IRQn);
-}
-
-static void
-usb_wait(uint32_t flag)
-{
-    while (!(LPC_USB->USBDevIntSt & flag))
-        ;
-    LPC_USB->USBDevIntClr = flag;
-}
-
-
-/****************************************************************
- * Serial Interface Engine (SIE) functions
- ****************************************************************/
-
-#define SIE_CMD_SELECT 0x00
-#define SIE_CMD_SET_ENDPOINT_STATUS 0x40
-#define SIE_CMD_SET_ADDRESS 0xD0
-#define SIE_CMD_CONFIGURE 0xD8
-#define SIE_CMD_SET_DEVICE_STATUS 0xFE
-#define SIE_CMD_CLEAR_BUFFER 0xF2
-#define SIE_CMD_VALIDATE_BUFFER 0xFA
-
-static void
-sie_cmd(uint32_t cmd)
-{
-    LPC_USB->USBDevIntClr = CDFULL | CCEMPTY;
-    LPC_USB->USBCmdCode = 0x00000500 | (cmd << 16);
-    usb_wait(CCEMPTY);
-}
-
-static void
-sie_cmd_write(uint32_t cmd, uint32_t data)
-{
-    sie_cmd(cmd);
-    LPC_USB->USBCmdCode = 0x00000100 | (data << 16);
-    usb_wait(CCEMPTY);
-}
-
-static uint32_t
-sie_cmd_read(uint32_t cmd)
-{
-    sie_cmd(cmd);
-    LPC_USB->USBCmdCode = 0x00000200 | (cmd << 16);
-    usb_wait(CDFULL);
-    return LPC_USB->USBCmdData;
-}
-
-static uint32_t
-sie_select_and_clear(uint32_t idx)
-{
-    LPC_USB->USBEpIntClr = 1<<idx;
-    usb_wait(CDFULL);
-    return LPC_USB->USBCmdData;
-}
-
-
-/****************************************************************
- * Interface
- ****************************************************************/
-
-static int_fast8_t
-usb_write_packet(uint32_t ep, const void *data, uint_fast8_t len)
-{
-    usb_irq_disable();
-    uint32_t sts = sie_cmd_read(SIE_CMD_SELECT | ep);
-    if (sts & 0x01) {
-        // Output buffers full
-        usb_irq_enable();
-        return -1;
-    }
-
-    LPC_USB->USBCtrl = WR_EN | ((ep/2) << 2);
-    LPC_USB->USBTxPLen = len;
-    if (!len)
-        LPC_USB->USBTxData = 0;
-    int i;
-    for (i = 0; i<DIV_ROUND_UP(len, 4); i++) {
-        uint32_t d;
-        memcpy(&d, data, sizeof(d));
-        data += sizeof(d);
-        LPC_USB->USBTxData = cpu_to_le32(d);
-    }
-    sie_cmd(SIE_CMD_VALIDATE_BUFFER);
-    usb_irq_enable();
-
-    return len;
-}
-
-static int_fast8_t
-usb_read_packet(uint32_t ep, void *data, uint_fast8_t max_len)
-{
-    usb_irq_disable();
-    uint32_t sts = sie_cmd_read(SIE_CMD_SELECT | ep);
-    if (!(sts & 0x01)) {
-        // No data available
-        usb_irq_enable();
-        return -1;
-    }
-
-    // Determine packet size
-    LPC_USB->USBCtrl = RD_EN | ((ep/2) << 2);
-    uint32_t plen = LPC_USB->USBRxPLen;
-    while (!(plen & (1<<11)))
-        plen = LPC_USB->USBRxPLen;
-    plen &= 0x3FF;
-    if (plen > max_len)
-        // XXX - return error code?  must keep reading?
-        plen = max_len;
-    // Copy data
-    uint32_t xfer = plen;
-    for (;;) {
-        uint32_t d = le32_to_cpu(LPC_USB->USBRxData);
-        if (xfer <= sizeof(d)) {
-            memcpy(data, &d, xfer);
-            break;
-        }
-        memcpy(data, &d, sizeof(d));
-        data += sizeof(d);
-        xfer -= sizeof(d);
-    }
-    // Clear space for next packet
-    sts = sie_cmd_read(SIE_CMD_CLEAR_BUFFER);
-    usb_irq_enable();
-    if (sts & 0x01)
-        // Packet overwritten
-        return -1;
-
-    return plen;
-}
-
-int_fast8_t
-usb_read_bulk_out(void *data, uint_fast8_t max_len)
-{
-    return usb_read_packet(EP2OUT, data, max_len);
-}
-
-int_fast8_t
-usb_send_bulk_in(void *data, uint_fast8_t len)
-{
-    return usb_write_packet(EP5IN, data, len);
-}
-
-int_fast8_t
-usb_read_ep0(void *data, uint_fast8_t max_len)
-{
-    return usb_read_packet(EP0OUT, data, max_len);
-}
-
-int_fast8_t
-usb_read_ep0_setup(void *data, uint_fast8_t max_len)
-{
-    return usb_read_ep0(data, max_len);
-}
-
-int_fast8_t
-usb_send_ep0(const void *data, uint_fast8_t len)
-{
-    return usb_write_packet(EP0IN, data, len);
-}
-
-void
-usb_stall_ep0(void)
-{
-    usb_irq_disable();
-    sie_cmd_write(SIE_CMD_SET_ENDPOINT_STATUS | 0, (1<<7));
-    usb_irq_enable();
-}
-
-void
-usb_set_address(uint_fast8_t addr)
-{
-    usb_irq_disable();
-    sie_cmd_write(SIE_CMD_SET_ADDRESS, addr | (1<<7));
-    usb_irq_enable();
-    usb_send_ep0(NULL, 0);
-}
-
-static void
-realize_endpoint(uint32_t idx, uint32_t packet_size)
-{
-    LPC_USB->USBDevIntClr = EP_RLZED;
-    LPC_USB->USBReEp |= 1<<idx;
-    LPC_USB->USBEpInd = idx;
-    LPC_USB->USBMaxPSize = packet_size;
-    usb_wait(EP_RLZED);
-    LPC_USB->USBEpIntEn |= 1<<idx;
-    sie_cmd_write(SIE_CMD_SET_ENDPOINT_STATUS | idx, 0);
-}
-
-void
-usb_set_configure(void)
-{
-    usb_irq_disable();
-    realize_endpoint(EP1IN, USB_CDC_EP_ACM_SIZE);
-    realize_endpoint(EP2OUT, USB_CDC_EP_BULK_OUT_SIZE);
-    realize_endpoint(EP5IN, USB_CDC_EP_BULK_IN_SIZE);
-    sie_cmd_write(SIE_CMD_CONFIGURE, 1);
-    usb_irq_enable();
-}
-
-// Force a USB disconnect (used during reboot into bootloader)
-void
-usb_disconnect(void)
-{
-    sie_cmd_write(SIE_CMD_SET_DEVICE_STATUS, 0);
-    udelay(5000);
-}
-
-
-/****************************************************************
- * Setup and interrupts
- ****************************************************************/
-
-void
-USB_IRQHandler(void)
-{
-    uint32_t udis = LPC_USB->USBDevIntSt;
-    if (udis & DEV_STAT) {
-        LPC_USB->USBDevIntClr = DEV_STAT;
-        // XXX - should handle reset and other states
-    }
-    if (udis & EP_SLOW) {
-        uint32_t ueis = LPC_USB->USBEpIntSt;
-        if (ueis & (1<<EP0OUT)) {
-            sie_select_and_clear(EP0OUT);
-            usb_notify_ep0();
-        }
-        if (ueis & (1<<EP0IN)) {
-            sie_select_and_clear(EP0IN);
-            usb_notify_ep0();
-        }
-        if (ueis & (1<<EP2OUT)) {
-            sie_select_and_clear(EP2OUT);
-            usb_notify_bulk_out();
-        }
-        if (ueis & (1<<EP5IN)) {
-            sie_select_and_clear(EP5IN);
-            usb_notify_bulk_in();
-        }
-        LPC_USB->USBDevIntClr = EP_SLOW;
-    }
-}
-
-DECL_CONSTANT_STR("RESERVE_PINS_USB", "P0.30,P0.29,P2.9");
-
-void
-usbserial_init(void)
-{
-    usb_irq_disable();
-    // enable power
-    enable_pclock(PCLK_USB);
-    // enable clock
-    LPC_USB->USBClkCtrl = 0x12;
-    while (LPC_USB->USBClkSt != 0x12)
-        ;
-    // configure USBD-, USBD+, and USB Connect pins
-    gpio_peripheral(GPIO(0, 30), 1, 0);
-    gpio_peripheral(GPIO(0, 29), 1, 0);
-    gpio_peripheral(GPIO(2, 9), 1, 0);
-    // enforce a minimum time bus is disconnected before connecting
-    udelay(5000);
-    // setup endpoints
-    realize_endpoint(EP0OUT, USB_CDC_EP0_SIZE);
-    realize_endpoint(EP0IN, USB_CDC_EP0_SIZE);
-    sie_cmd_write(SIE_CMD_SET_DEVICE_STATUS, 1);
-    // enable irqs
-    LPC_USB->USBDevIntEn = DEV_STAT | EP_SLOW;
-    armcm_enable_irq(USB_IRQHandler, USB_IRQn, 1);
-}
-DECL_INIT(usbserial_init);
-
-void
-usbserial_shutdown(void)
-{
-    usb_irq_enable();
-}
-DECL_SHUTDOWN(usbserial_shutdown);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/Makefile crealityShit/src/Makefile
--- klipperStock/src/Makefile	2024-01-14 23:02:00.109796205 -0600
+++ crealityShit/src/Makefile	1969-12-31 18:00:00.000000000 -0600
@@ -1,13 +0,0 @@
-# Main code build rules
-
-src-y += sched.c command.c basecmd.c debugcmds.c
-src-$(CONFIG_HAVE_GPIO) += initial_pins.c gpiocmds.c stepper.c endstop.c \
-    trsync.c
-src-$(CONFIG_HAVE_GPIO_ADC) += adccmds.c
-src-$(CONFIG_HAVE_GPIO_SPI) += spicmds.c thermocouple.c
-src-$(CONFIG_HAVE_GPIO_I2C) += i2ccmds.c
-src-$(CONFIG_HAVE_GPIO_HARD_PWM) += pwmcmds.c
-bb-src-$(CONFIG_HAVE_GPIO_SPI) := spi_software.c sensor_adxl345.c sensor_angle.c
-bb-src-$(CONFIG_HAVE_GPIO_I2C) += sensor_mpu9250.c
-src-$(CONFIG_HAVE_GPIO_BITBANGING) += $(bb-src-y) lcd_st7920.c lcd_hd44780.c \
-    buttons.c tmcuart.c neopixel.c pulse_counter.c
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/neopixel.c crealityShit/src/neopixel.c
--- klipperStock/src/neopixel.c	2024-01-14 23:02:00.137796549 -0600
+++ crealityShit/src/neopixel.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,200 +0,0 @@
-// Support for bit-banging commands to WS2812 type "neopixel" LEDs
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memcpy
-#include "autoconf.h" // CONFIG_MACH_AVR
-#include "board/gpio.h" // gpio_out_write
-#include "board/irq.h" // irq_poll
-#include "board/misc.h" // timer_read_time
-#include "basecmd.h" // oid_alloc
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // sched_shutdown
-
-// The WS2812 uses a bit-banging protocol where each bit is
-// transmitted as a gpio high pulse of variable length.  The various
-// specs are unclear, but it is believed the timing requirements are:
-// - A zero bit must have a high pulse less than 500ns.
-// - A one bit must have a high pulse longer than 650ns.
-// - The total bit time (gpio high to following gpio high) must not
-//   exceed ~5000ns. The average bit time must be at least 1250ns.
-// - The specs generally indicate a minimum high pulse and low pulse
-//   of 200ns, but the actual requirement might be smaller.
-
-
-
-/****************************************************************
- * Timing
- ****************************************************************/
-
-typedef unsigned int neopixel_time_t;
-
-static neopixel_time_t
-nsecs_to_ticks(uint32_t ns)
-{
-    return timer_from_us(ns * 1000) / 1000000;
-}
-
-static inline int
-neopixel_check_elapsed(neopixel_time_t t1, neopixel_time_t t2
-                       , neopixel_time_t ticks)
-{
-    return t2 - t1 >= ticks;
-}
-
-// The AVR micro-controllers require specialized timing
-#if CONFIG_MACH_AVR
-
-#include <avr/interrupt.h> // TCNT1
-
-static neopixel_time_t
-neopixel_get_time(void)
-{
-    return TCNT1;
-}
-
-#define neopixel_delay(start, ticks) (void)(ticks)
-
-#else
-
-static neopixel_time_t
-neopixel_get_time(void)
-{
-    return timer_read_time();
-}
-
-static inline void
-neopixel_delay(neopixel_time_t start, neopixel_time_t ticks)
-{
-    while (!neopixel_check_elapsed(start, neopixel_get_time(), ticks))
-        ;
-}
-
-#endif
-
-#define PULSE_LONG_TICKS  nsecs_to_ticks(650)
-#define PULSE_SHORT_TICKS nsecs_to_ticks(200)
-#define BIT_MIN_TICKS     nsecs_to_ticks(1250)
-
-
-/****************************************************************
- * Neopixel interface
- ****************************************************************/
-
-struct neopixel_s {
-    struct gpio_out pin;
-    neopixel_time_t bit_max_ticks;
-    uint32_t last_req_time, reset_min_ticks;
-    uint16_t data_size;
-    uint8_t data[0];
-};
-
-void
-command_config_neopixel(uint32_t *args)
-{
-    struct gpio_out pin = gpio_out_setup(args[1], 0);
-    uint16_t data_size = args[2];
-    if (data_size & 0x8000)
-        shutdown("Invalid neopixel data_size");
-    struct neopixel_s *n = oid_alloc(args[0], command_config_neopixel
-                                     , sizeof(*n) + data_size);
-    n->pin = pin;
-    n->data_size = data_size;
-    n->bit_max_ticks = args[3];
-    n->reset_min_ticks = args[4];
-}
-DECL_COMMAND(command_config_neopixel, "config_neopixel oid=%c pin=%u"
-             " data_size=%hu bit_max_ticks=%u reset_min_ticks=%u");
-
-static int
-send_data(struct neopixel_s *n)
-{
-    // Make sure the reset time has elapsed since last request
-    uint32_t last_req_time = n->last_req_time, rmt = n->reset_min_ticks;
-    uint32_t cur = timer_read_time();
-    while (cur - last_req_time < rmt) {
-        irq_poll();
-        cur = timer_read_time();
-    }
-
-    // Transmit data
-    uint8_t *data = n->data;
-    uint_fast16_t data_len = n->data_size;
-    struct gpio_out pin = n->pin;
-    neopixel_time_t last_start = neopixel_get_time();
-    neopixel_time_t bit_max_ticks = n->bit_max_ticks;
-    while (data_len--) {
-        uint_fast8_t byte = *data++;
-        uint_fast8_t bits = 8;
-        while (bits--) {
-            if (byte & 0x80) {
-                // Long pulse
-                neopixel_delay(last_start, BIT_MIN_TICKS);
-                irq_disable();
-                neopixel_time_t start = neopixel_get_time();
-                gpio_out_toggle_noirq(pin);
-                irq_enable();
-
-                if (neopixel_check_elapsed(last_start, start, bit_max_ticks))
-                    goto fail;
-                last_start = start;
-                byte <<= 1;
-
-                neopixel_delay(start, PULSE_LONG_TICKS);
-                irq_disable();
-                gpio_out_toggle_noirq(pin);
-                irq_enable();
-
-                neopixel_delay(neopixel_get_time(), PULSE_SHORT_TICKS);
-            } else {
-                // Short pulse
-                neopixel_delay(last_start, BIT_MIN_TICKS);
-                irq_disable();
-                neopixel_time_t start = neopixel_get_time();
-                gpio_out_toggle_noirq(pin);
-                neopixel_delay(start, PULSE_SHORT_TICKS);
-                gpio_out_toggle_noirq(pin);
-                irq_enable();
-
-                if (neopixel_check_elapsed(last_start, start, bit_max_ticks))
-                    goto fail;
-                last_start = start;
-                byte <<= 1;
-            }
-        }
-    }
-    n->last_req_time = timer_read_time();
-    return 0;
-fail:
-    // A hardware irq messed up the transmission - report a failure
-    gpio_out_write(pin, 0);
-    n->last_req_time = timer_read_time();
-    return -1;
-}
-
-void
-command_neopixel_update(uint32_t *args)
-{
-    uint8_t oid = args[0];
-    struct neopixel_s *n = oid_lookup(oid, command_config_neopixel);
-    uint_fast16_t pos = args[1];
-    uint_fast8_t data_len = args[2];
-    uint8_t *data = command_decode_ptr(args[3]);
-    if (pos & 0x8000 || pos + data_len > n->data_size)
-        shutdown("Invalid neopixel update command");
-    memcpy(&n->data[pos], data, data_len);
-}
-DECL_COMMAND(command_neopixel_update,
-             "neopixel_update oid=%c pos=%hu data=%*s");
-
-void
-command_neopixel_send(uint32_t *args)
-{
-    uint8_t oid = args[0];
-    struct neopixel_s *n = oid_lookup(oid, command_config_neopixel);
-    int ret = send_data(n);
-    sendf("neopixel_result oid=%c success=%c", oid, ret ? 0 : 1);
-}
-DECL_COMMAND(command_neopixel_send, "neopixel_send oid=%c");
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/pru/adc.c crealityShit/src/pru/adc.c
--- klipperStock/src/pru/adc.c	2024-01-14 23:02:00.193797236 -0600
+++ crealityShit/src/pru/adc.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,111 +0,0 @@
-// Analog to digital conversion (ADC) code on PRU
-//
-// Copyright (C) 2017  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/io.h" // readl
-#include "command.h" // shutdown
-#include "compiler.h" // ARRAY_SIZE
-#include "gpio.h" // gpio_adc_setup
-#include "internal.h" // ADC
-#include "sched.h" // sched_shutdown
-
-
-/****************************************************************
- * Analog to Digital Converter (ADC) pins
- ****************************************************************/
-
-DECL_CONSTANT("ADC_MAX", 4095);
-
-static void
-adc_full_reset(void)
-{
-    static uint8_t have_done_reset;
-    if (have_done_reset)
-        return;
-
-    // Disable ADC
-    ADC->ctrl = (1<<2);
-    barrier();
-    // Clear registers
-    ADC->irqstatus = 0xffffffff;
-    ADC->irqenable_clr = 0xffffffff;
-    ADC->dmaenable_clr = 0xffffffff;
-    ADC->adc_clkdiv = 0;
-    ADC->stepenable = 0;
-    ADC->idleconfig = 0;
-    int i;
-    for (i=0; i<8; i++) {
-        ADC->step[i].config = i<<19;
-        ADC->step[i].delay = 0;
-    }
-    // Enable ADC
-    writel(&ADC->ctrl, 0x07);
-    // Drain fifo
-    while (readl(&ADC->fifo0count))
-        readl(&ADC->fifo0data);
-
-    if (!readl(&ADC->ctrl))
-        shutdown("ADC module not enabled");
-    have_done_reset = 1;
-}
-
-DECL_ENUMERATION_RANGE("pin", "AIN0", 4 * 32, 8);
-
-struct gpio_adc
-gpio_adc_setup(uint8_t pin)
-{
-    uint8_t chan = pin - 4 * 32;
-    if (chan >= 8)
-        shutdown("Not an adc channel");
-    adc_full_reset();
-    return (struct gpio_adc){ .chan = chan };
-}
-
-enum { ADC_DUMMY=0xff };
-static uint8_t last_analog_read = ADC_DUMMY;
-static uint16_t last_analog_sample;
-
-// Try to sample a value. Returns zero if sample ready, otherwise
-// returns the number of clock ticks the caller should wait before
-// retrying this function.
-uint32_t
-gpio_adc_sample(struct gpio_adc g)
-{
-    uint8_t last = last_analog_read;
-    if (last == ADC_DUMMY) {
-        // Start sample
-        last_analog_read = g.chan;
-        writel(&ADC->stepenable, 1 << (g.chan + 1));
-        goto need_delay;
-    }
-    if (last == g.chan) {
-        // Check if sample ready
-        while (readl(&ADC->fifo0count)) {
-            uint32_t sample = readl(&ADC->fifo0data);
-            if (sample >> 16 == g.chan) {
-                last_analog_read = ADC_DUMMY;
-                last_analog_sample = sample;
-                return 0;
-            }
-        }
-    }
-need_delay:
-    return 160;
-}
-
-// Read a value; use only after gpio_adc_sample() returns zero
-uint16_t
-gpio_adc_read(struct gpio_adc g)
-{
-    return last_analog_sample;
-}
-
-// Cancel a sample that may have been started with gpio_adc_sample()
-void
-gpio_adc_cancel_sample(struct gpio_adc g)
-{
-    if (last_analog_read == g.chan)
-        last_analog_read = ADC_DUMMY;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/pru/gpio.c crealityShit/src/pru/gpio.c
--- klipperStock/src/pru/gpio.c	2024-01-14 23:02:00.189797188 -0600
+++ crealityShit/src/pru/gpio.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,176 +0,0 @@
-// GPIO functions on PRU
-//
-// Copyright (C) 2017-2020  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/io.h" // readl
-#include "command.h" // shutdown
-#include "compiler.h" // ARRAY_SIZE
-#include "gpio.h" // gpio_out_setup
-#include "sched.h" // sched_shutdown
-
-
-/****************************************************************
- * Pin mappings
- ****************************************************************/
-
-#define GPIO(PORT, NUM) ((PORT) * 32 + (NUM))
-#define GPIO2PORT(PIN) ((PIN) / 32)
-#define GPIO2BIT(PIN) (1<<((PIN) % 32))
-
-struct gpio_regs {
-    uint32_t pad_0[77];
-    volatile uint32_t oe;
-    volatile uint32_t datain;
-    volatile uint32_t dataout;
-    uint32_t pad_140[20];
-    volatile uint32_t cleardataout;
-    volatile uint32_t setdataout;
-};
-
-DECL_ENUMERATION_RANGE("pin", "gpio0_0", GPIO(0, 0), 32);
-DECL_ENUMERATION_RANGE("pin", "gpio1_0", GPIO(1, 0), 32);
-DECL_ENUMERATION_RANGE("pin", "gpio2_0", GPIO(2, 0), 32);
-DECL_ENUMERATION_RANGE("pin", "gpio3_0", GPIO(3, 0), 32);
-
-static struct gpio_regs *digital_regs[] = {
-    (void*)0x44e07000, (void*)0x4804c000, (void*)0x481ac000, (void*)0x481ae000
-};
-
-
-/****************************************************************
- * Pin mux handling
- ****************************************************************/
-
-#define MUXPORT(offset) (((offset)-0x800) / 4)
-
-static uint8_t gpio_mux_offset[32 * ARRAY_SIZE(digital_regs)] = {
-    // gpio 0
-    0xff          , 0xff          , MUXPORT(0x950), MUXPORT(0x954),
-    MUXPORT(0x958), MUXPORT(0x95c), 0xff          , MUXPORT(0x964),
-    MUXPORT(0x8d0), MUXPORT(0x8d4), MUXPORT(0x8d8), MUXPORT(0x8dc),
-    MUXPORT(0x978), MUXPORT(0x97c), MUXPORT(0x980), MUXPORT(0x984),
-    0xff          , 0xff          , 0xff          , 0xff          ,
-    MUXPORT(0x9b4), 0xff          , MUXPORT(0x820), MUXPORT(0x824),
-    0xff          , 0xff          , MUXPORT(0x828), MUXPORT(0x82c),
-    0xff          , 0xff          , MUXPORT(0x870), MUXPORT(0x874),
-
-    // gpio 1
-    MUXPORT(0x800), MUXPORT(0x804), MUXPORT(0x808), MUXPORT(0x80c),
-    MUXPORT(0x810), MUXPORT(0x814), MUXPORT(0x818), MUXPORT(0x81c),
-    0xff          , 0xff          , 0xff          , 0xff          ,
-    MUXPORT(0x830), MUXPORT(0x834), MUXPORT(0x838), MUXPORT(0x83c),
-    MUXPORT(0x840), MUXPORT(0x844), MUXPORT(0x848), MUXPORT(0x84c),
-    0xff          , 0xff          , 0xff          , 0xff          ,
-    0xff          , 0xff          , 0xff          , 0xff          ,
-    MUXPORT(0x878), MUXPORT(0x87c), MUXPORT(0x880), MUXPORT(0x884),
-
-    // gpio 2
-    0xff          , MUXPORT(0x88c), MUXPORT(0x890), MUXPORT(0x894),
-    MUXPORT(0x898), MUXPORT(0x89c), MUXPORT(0x8a0), MUXPORT(0x8a4),
-    MUXPORT(0x8a8), MUXPORT(0x8ac), MUXPORT(0x8b0), MUXPORT(0x8b4),
-    MUXPORT(0x8b8), MUXPORT(0x8bc), MUXPORT(0x8c0), MUXPORT(0x8c4),
-    MUXPORT(0x8c8), MUXPORT(0x8cc), 0xff          , 0xff          ,
-    0xff          , 0xff          , MUXPORT(0x8e0), MUXPORT(0x8e4),
-    MUXPORT(0x8e8), MUXPORT(0x8ec), 0xff          , 0xff          ,
-    0xff          , 0xff          , 0xff          , 0xff          ,
-
-    // gpio 3
-    0xff          , 0xff          , 0xff          , 0xff          ,
-    0xff          , 0xff          , 0xff          , 0xff          ,
-    0xff          , 0xff          , 0xff          , 0xff          ,
-    0xff          , 0xff          , MUXPORT(0x990), MUXPORT(0x994),
-    MUXPORT(0x998), MUXPORT(0x99c), MUXPORT(0x9a0), MUXPORT(0x9a4),
-    MUXPORT(0x9a8), MUXPORT(0x9ac), 0xff          , 0xff          ,
-    0xff          , 0xff          , 0xff          , 0xff          ,
-    0xff          , 0xff          , 0xff          , 0xff          ,
-};
-
-#define MUXREG(mux_offset) ((volatile uint32_t *)0x44e10800 + mux_offset)
-
-static void
-set_pin_mux(uint8_t pin, uint8_t val)
-{
-    return; // XXX - can not set mux value from PRU
-
-    uint8_t mux_offset = gpio_mux_offset[pin];
-    if (mux_offset == 0xff)
-        shutdown("Invalid mux pin");
-    *MUXREG(mux_offset) = val;
-}
-
-
-/****************************************************************
- * General Purpose Input Output (GPIO) pins
- ****************************************************************/
-
-struct gpio_out
-gpio_out_setup(uint8_t pin, uint8_t val)
-{
-    if (GPIO2PORT(pin) >= ARRAY_SIZE(digital_regs))
-        goto fail;
-    struct gpio_regs *regs = digital_regs[GPIO2PORT(pin)];
-    uint32_t bit = GPIO2BIT(pin);
-    struct gpio_out rv = (struct gpio_out){.reg=&regs->cleardataout, .bit=bit};
-    gpio_out_write(rv, val);
-    regs->oe &= ~bit;
-    set_pin_mux(pin, 0x0f);
-    return rv;
-fail:
-    shutdown("Not an output pin");
-}
-
-void
-gpio_out_reset(struct gpio_out g, uint8_t val)
-{
-    shutdown("PRU does not support push/pull pins");
-}
-
-void
-gpio_out_toggle_noirq(struct gpio_out g)
-{
-    gpio_out_write(g, !(*g.reg & g.bit));
-}
-
-void
-gpio_out_toggle(struct gpio_out g)
-{
-    gpio_out_toggle_noirq(g);
-}
-
-void
-gpio_out_write(struct gpio_out g, uint8_t val)
-{
-    volatile uint32_t *reg = g.reg;
-    if (val)
-        reg++;
-    *reg = g.bit;
-}
-
-
-struct gpio_in
-gpio_in_setup(uint8_t pin, int8_t pull_up)
-{
-    if (GPIO2PORT(pin) >= ARRAY_SIZE(digital_regs))
-        goto fail;
-    struct gpio_regs *regs = digital_regs[GPIO2PORT(pin)];
-    uint32_t bit = GPIO2BIT(pin);
-    regs->oe |= bit;
-    set_pin_mux(pin, pull_up > 0 ? 0x37 : (pull_up < 0 ? 0x27 : 0x2f));
-    return (struct gpio_in){ .reg=&regs->datain, .bit=bit };
-fail:
-    shutdown("Not an input pin");
-}
-
-void
-gpio_in_reset(struct gpio_in g, int8_t pull_up)
-{
-    shutdown("PRU does not support push/pull pins");
-}
-
-uint8_t
-gpio_in_read(struct gpio_in g)
-{
-    return !!(*g.reg & g.bit);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/pru/gpio.h crealityShit/src/pru/gpio.h
--- klipperStock/src/pru/gpio.h	2024-01-14 23:02:00.189797188 -0600
+++ crealityShit/src/pru/gpio.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,33 +0,0 @@
-#ifndef __PRU_GPIO_H
-#define __PRU_GPIO_H
-
-#include <stdint.h>
-#include <stdbool.h>
-
-struct gpio_out {
-    volatile uint32_t *reg;
-    uint32_t bit;
-};
-struct gpio_out gpio_out_setup(uint8_t pin, uint8_t val);
-void gpio_out_reset(struct gpio_out g, uint8_t val);
-void gpio_out_toggle_noirq(struct gpio_out g);
-void gpio_out_toggle(struct gpio_out g);
-void gpio_out_write(struct gpio_out g, uint8_t val);
-
-struct gpio_in {
-    volatile uint32_t *reg;
-    uint32_t bit;
-};
-struct gpio_in gpio_in_setup(uint8_t pin, int8_t pull_up);
-void gpio_in_reset(struct gpio_in g, int8_t pull_up);
-uint8_t gpio_in_read(struct gpio_in g);
-
-struct gpio_adc {
-    uint8_t chan;
-};
-struct gpio_adc gpio_adc_setup(uint8_t pin);
-uint32_t gpio_adc_sample(struct gpio_adc g);
-uint16_t gpio_adc_read(struct gpio_adc g);
-void gpio_adc_cancel_sample(struct gpio_adc g);
-
-#endif // gpio.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/pru/internal.h crealityShit/src/pru/internal.h
--- klipperStock/src/pru/internal.h	2024-01-14 23:02:00.189797188 -0600
+++ crealityShit/src/pru/internal.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,74 +0,0 @@
-#ifndef __PRU_INTERNAL_H
-#define __PRU_INTERNAL_H
-// Local definitions for PRU code
-
-#include <stdint.h> // uint32_t
-#include "command.h" // MESSAGE_MAX
-
-#define IEP_EVENT                 7
-#define KICK_ARM_EVENT            16
-#define KICK_PRU0_FROM_ARM_EVENT  17
-#define KICK_PRU0_EVENT           18
-#define KICK_PRU1_EVENT           19
-
-#define WAKE_PRU0_IRQ  0
-#define WAKE_PRU1_IRQ  1
-#define WAKE_ARM_IRQ   2
-
-#define R31_IRQ_OFFSET 30
-
-#define R31_WRITE_IRQ_SELECT (1<<5)
-#define R31_WRITE_IRQ_OFFSET 16
-
-#define ALT_PRU_PTR(ptr) ((typeof(ptr))((uint32_t)(ptr) ^ 0x2000))
-
-// Layout of shared memory
-struct shared_mem {
-    uint32_t signal;
-    void *next_encoder_args;
-    uint32_t next_encoder;
-    const struct command_parser *next_command;
-    uint32_t next_command_args[16];
-    const struct command_parser *command_index;
-    uint32_t command_index_size;
-    const struct command_parser *shutdown_handler;
-    uint8_t read_data[512];
-};
-
-#define SIGNAL_PRU0_WAITING 0xefefefef
-#define SIGNAL_PRU1_READY   0xabababab
-
-#define SHARED_MEM ((struct shared_mem *)0x10000)
-
-// Hardware ADC registers
-struct beaglebone_adc {
-    uint32_t pad_00[10];
-    uint32_t irqstatus;
-    uint32_t irqenable_set;
-    uint32_t irqenable_clr;
-    uint32_t irqwakeup;
-    uint32_t dmaenable_set;
-    uint32_t dmaenable_clr;
-    uint32_t ctrl;
-    uint32_t adcstat;
-    uint32_t adcrange;
-    uint32_t adc_clkdiv;
-    uint32_t adc_misc;
-    uint32_t stepenable;
-    uint32_t idleconfig;
-    uint32_t ts_charge_stepconfig;
-    uint32_t ts_charge_delay;
-    struct {
-        uint32_t config;
-        uint32_t delay;
-    } step[16];
-    uint32_t fifo0count;
-    uint32_t pad_e8[6];
-    uint32_t fifo0data;
-    uint32_t pad_104[63];
-    uint32_t fifo1data;
-};
-
-#define ADC ((struct beaglebone_adc *)0x44e0d000)
-
-#endif // internal.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/pru/Kconfig crealityShit/src/pru/Kconfig
--- klipperStock/src/pru/Kconfig	2024-01-14 23:02:00.189797188 -0600
+++ crealityShit/src/pru/Kconfig	1969-12-31 18:00:00.000000000 -0600
@@ -1,20 +0,0 @@
-# Kconfig settings for PRU
-
-if MACH_PRU
-
-config PRU_SELECT
-    bool
-    default y
-    select HAVE_GPIO
-    #select HAVE_GPIO_ADC
-    select HAVE_STRICT_TIMING
-
-config BOARD_DIRECTORY
-    string
-    default "pru"
-
-config CLOCK_FREQ
-    int
-    default 200000000
-
-endif
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/pru/main.c crealityShit/src/pru/main.c
--- klipperStock/src/pru/main.c	2024-01-14 23:02:00.189797188 -0600
+++ crealityShit/src/pru/main.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,240 +0,0 @@
-// Main starting point for PRU code.
-//
-// Copyright (C) 2017-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <stdint.h> // uint32_t
-#include <pru/io.h> // read_r31
-#include <pru_iep.h> // CT_IEP
-#include <pru_intc.h> // CT_INTC
-#include <rsc_types.h> // resource_table
-#include "board/misc.h" // dynmem_start
-#include "board/io.h" // readl
-#include "board/irq.h" // irq_disable
-#include "command.h" // shutdown
-#include "generic/timer_irq.h" // timer_dispatch_many
-#include "internal.h" // SHARED_MEM
-#include "sched.h" // sched_main
-
-DECL_CONSTANT_STR("MCU", "pru");
-
-
-/****************************************************************
- * Timers
- ****************************************************************/
-
-void
-irq_disable(void)
-{
-}
-
-void
-irq_enable(void)
-{
-}
-
-irqstatus_t
-irq_save(void)
-{
-    return 0;
-}
-
-void
-irq_restore(irqstatus_t flag)
-{
-}
-
-void
-irq_wait(void)
-{
-    asm("slp 1");
-    irq_poll();
-}
-
-// Set the next timer wake up time
-static void
-timer_set(uint32_t value)
-{
-    if (!value)
-        value = 1;
-    CT_IEP.TMR_CMP0 = value;
-}
-
-// Return the current time (in absolute clock ticks).
-uint32_t
-timer_read_time(void)
-{
-    return CT_IEP.TMR_CNT;
-}
-
-// Activate timer dispatch as soon as possible
-void
-timer_kick(void)
-{
-    timer_set(timer_read_time() + 50);
-    CT_IEP.TMR_CMP_STS = 0xff;
-    __delay_cycles(4);
-    CT_INTC.SECR0 = 1 << IEP_EVENT;
-}
-
-static uint32_t in_timer_dispatch;
-
-static void
-_irq_poll(void)
-{
-    uint32_t secr0 = CT_INTC.SECR0;
-    if (secr0 & (1 << KICK_PRU1_EVENT)) {
-        CT_INTC.SECR0 = 1 << KICK_PRU1_EVENT;
-        sched_wake_tasks();
-    }
-    if (secr0 & (1 << IEP_EVENT)) {
-        CT_IEP.TMR_CMP_STS = 0xff;
-        in_timer_dispatch = 1;
-        uint32_t next = timer_dispatch_many();
-        timer_set(next);
-        CT_INTC.SECR0 = 1 << IEP_EVENT;
-        in_timer_dispatch = 0;
-    }
-}
-void __attribute__((optimize("O2")))
-irq_poll(void)
-{
-    if (read_r31() & (1 << (WAKE_PRU1_IRQ + R31_IRQ_OFFSET)))
-        _irq_poll();
-}
-
-void
-timer_init(void)
-{
-    CT_IEP.TMR_CMP_CFG = 0x01 << 1;
-    CT_IEP.TMR_GLB_CFG = 0x11;
-    CT_IEP.TMR_CNT = 0xffffffff;
-    timer_kick();
-}
-DECL_INIT(timer_init);
-
-
-/****************************************************************
- * Console IO
- ****************************************************************/
-
-// Writes over 496 bytes don't fit in a single "rpmsg" page
-DECL_CONSTANT("RECEIVE_WINDOW", 496 - 1);
-
-// Process any incoming commands
-void
-console_task(void)
-{
-    const struct command_parser *cp = SHARED_MEM->next_command;
-    if (!cp)
-        return;
-
-    if (sched_is_shutdown() && !(cp->flags & HF_IN_SHUTDOWN)) {
-        sched_report_shutdown();
-    } else {
-        void (*func)(uint32_t*) = cp->func;
-        func(SHARED_MEM->next_command_args);
-    }
-
-    writel(&SHARED_MEM->next_command, 0);
-}
-DECL_TASK(console_task);
-
-// Encode and transmit a "response" message
-void
-console_sendf(const struct command_encoder *ce, va_list args)
-{
-    SHARED_MEM->next_encoder_args = args;
-    writel(&SHARED_MEM->next_encoder, (uint32_t)ce);
-
-    // Signal PRU0 to transmit message
-    write_r31(R31_WRITE_IRQ_SELECT | (KICK_PRU0_EVENT - R31_WRITE_IRQ_OFFSET));
-    uint32_t itd = in_timer_dispatch;
-    while (readl(&SHARED_MEM->next_encoder))
-        if (!itd)
-            irq_poll();
-}
-
-void
-console_shutdown(void)
-{
-    writel(&SHARED_MEM->next_command, 0);
-    writel(&SHARED_MEM->next_encoder, 0);
-    in_timer_dispatch = 0;
-}
-DECL_SHUTDOWN(console_shutdown);
-
-// Handle shutdown request from PRU0
-static void
-shutdown_handler(uint32_t *args)
-{
-    shutdown("Request from PRU0");
-}
-const struct command_parser shutdown_request = {
-    .func = shutdown_handler,
-};
-
-
-/****************************************************************
- * Dynamic memory
- ****************************************************************/
-
-#define STACK_SIZE 256
-
-// Return the start of memory available for dynamic allocations
-void *
-dynmem_start(void)
-{
-    extern char _heap_start;
-    return &_heap_start;
-}
-
-// Return the end of memory available for dynamic allocations
-void *
-dynmem_end(void)
-{
-    return (void*)(8*1024 - STACK_SIZE);
-}
-
-
-/****************************************************************
- * Resource table
- ****************************************************************/
-
-struct my_resource_table {
-    struct resource_table base;
-
-    uint32_t offset[1]; /* Should match 'num' in actual definition */
-} resourceTable __visible __section(".resource_table") = {
-    {
-        1,              /* Resource table version: only version 1 is
-                         * supported by the current driver */
-        0,              /* number of entries in the table */
-        { 0, 0 },       /* reserved, must be zero */
-    },
-};
-
-
-/****************************************************************
- * Startup
- ****************************************************************/
-
-// Support config_reset
-DECL_COMMAND_FLAGS(config_reset, HF_IN_SHUTDOWN, "config_reset");
-
-// Main entry point
-int
-main(void)
-{
-    // Wait for PRU0 to initialize
-    while (readl(&SHARED_MEM->signal) != SIGNAL_PRU0_WAITING)
-        ;
-    SHARED_MEM->command_index = command_index;
-    SHARED_MEM->command_index_size = command_index_size;
-    SHARED_MEM->shutdown_handler = &shutdown_request;
-    writel(&SHARED_MEM->signal, SIGNAL_PRU1_READY);
-
-    sched_main();
-    return 0;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/pru/Makefile crealityShit/src/pru/Makefile
--- klipperStock/src/pru/Makefile	2024-01-14 23:02:00.189797188 -0600
+++ crealityShit/src/pru/Makefile	1969-12-31 18:00:00.000000000 -0600
@@ -1,38 +0,0 @@
-# Additional PRU build rules
-
-# Setup the toolchain
-CROSS_PREFIX=pru-
-
-dirs-y += src/pru src/generic
-dirs-y += lib/pru_rpmsg
-
-CFLAGS += -Os -minrt -mmcu=am335x.pru1
-CFLAGS += -Ilib/pru_rpmsg/include -Ilib/pru_rpmsg/include/am335x
-
-CFLAGS_klipper.elf := $(filter-out -mmcu=%, $(CFLAGS))
-CFLAGS_klipper.elf += -Wl,-r -nostdlib -Wl,-T,src/pru/pru.lds
-CFLAGS_pru0.elf := $(filter-out -mmcu=%, $(CFLAGS)) -mmcu=am335x.pru0
-CFLAGS_pru1.elf := $(CFLAGS)
-
-# Add source files
-src-y += pru/main.c pru/gpio.c generic/timer_irq.c
-src-$(CONFIG_HAVE_GPIO_ADC) += pru/adc.c
-
-pru0-y := pru/pru0.c generic/crc16_ccitt.c command.c
-pru0-y += ../lib/pru_rpmsg/pru_rpmsg.c ../lib/pru_rpmsg/pru_virtqueue.c
-
-# Build the PRU binaries
-target-y += $(OUT)pru0.elf $(OUT)pru1.elf
-
-$(OUT)pru0.elf: $(patsubst %.c, $(OUT)src/%.o,$(pru0-y))
-	@echo "  Linking $@"
-	$(Q)$(CC) $(CFLAGS_klipper.elf) $^ -o $(OUT)pru0.o
-	$(Q)$(CC) $(CFLAGS_pru0.elf) $(OUT)pru0.o -o $@
-
-$(OUT)pru1.elf: $(OUT)klipper.elf
-	@echo "  Linking $@"
-	$(Q)$(CC) $(CFLAGS_pru1.elf) $< -o $@
-
-flash: $(OUT)pru0.elf $(OUT)pru1.elf
-	@echo "  Flashing"
-	$(Q)sudo ./scripts/flash-pru.sh
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/pru/pru0.c crealityShit/src/pru/pru0.c
--- klipperStock/src/pru/pru0.c	2024-01-14 23:02:00.189797188 -0600
+++ crealityShit/src/pru/pru0.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,416 +0,0 @@
-// Code to handle IO on PRU0 and pass the messages to PRU1
-//
-// Copyright (C) 2017-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <setjmp.h> // setjmp
-#include <stdint.h> // uint32_t
-#include <string.h> // memset
-#include <pru/io.h> // write_r31
-#include <pru_cfg.h> // CT_CFG
-#include <pru_intc.h> // CT_INTC
-#include <pru_rpmsg.h> // pru_rpmsg_send
-#include <pru_virtio_ids.h> // VIRTIO_ID_RPMSG
-#include <rsc_types.h> // resource_table
-#include "board/io.h" // readl
-#include "board/misc.h" // console_sendf
-#include "command.h" // command_encode_add_frame
-#include "compiler.h" // __section
-#include "internal.h" // SHARED_MEM
-#include "sched.h" // sched_shutdown
-
-struct pru_rpmsg_transport transport;
-static uint16_t transport_dst;
-
-
-/****************************************************************
- * IO
- ****************************************************************/
-
-#define CHAN_NAME                                       "rpmsg-pru"
-#define CHAN_DESC                                       "Channel 30"
-#define CHAN_PORT                                       30
-
-#define RPMSG_HDR_SIZE 16
-static uint8_t transmit_buf[RPMSG_BUF_SIZE - RPMSG_HDR_SIZE];
-static int transmit_pos;
-
-// Transmit all pending message blocks
-static void
-flush_messages(void)
-{
-    if (!transmit_pos)
-        return;
-    pru_rpmsg_send(&transport, CHAN_PORT, transport_dst
-                   , transmit_buf, transmit_pos);
-    transmit_pos = 0;
-}
-
-// Verify space for a message block
-static uint8_t *
-get_transmit_ptr(const struct command_encoder *ce)
-{
-    if (transmit_pos + ce->max_size > sizeof(transmit_buf))
-        flush_messages();
-    return &transmit_buf[transmit_pos];
-}
-
-// Finalize a message block and queue it for transmission
-static void
-finalize_transmit(int msglen)
-{
-    transmit_pos += msglen;
-}
-
-// Check if there is data to be sent from PRU1 to the host
-static void
-check_can_send(void)
-{
-    for (;;) {
-        uint32_t rce = readl(&SHARED_MEM->next_encoder);
-        if (!rce)
-            break;
-        // Copy va_args on pru1 for use on pru0
-        void *pru1_args = ALT_PRU_PTR(SHARED_MEM->next_encoder_args);
-        uint32_t local_args[16];
-        memcpy(local_args, pru1_args, sizeof(local_args));
-        const struct command_encoder *pru1_ce = ALT_PRU_PTR((void*)rce);
-        struct command_encoder ce;
-        memcpy(&ce, pru1_ce, sizeof(ce));
-        if (readl(&SHARED_MEM->next_encoder) != rce)
-            continue;
-        // Fixup any pointers in va_args
-        ce.param_types = ALT_PRU_PTR(ce.param_types);
-        uint32_t pos=0, v, i, count = ce.num_params;
-        for (i=0; i<count; i++) {
-            switch (ce.param_types[i]) {
-            case PT_progmem_buffer:
-            case PT_buffer:
-                pos++;
-                // NO BREAK
-            case PT_string:
-                v = local_args[pos];
-                if (v < 0x2000)
-                    // Translate pointer
-                    local_args[pos] = (uint32_t)ALT_PRU_PTR((void*)v);
-            }
-            pos++;
-        }
-        // Encode and build message
-        uint8_t *data = get_transmit_ptr(&ce);
-        int msglen = command_encode_and_frame(data, &ce, (void*)local_args);
-        if (readl(&SHARED_MEM->next_encoder) != rce)
-            continue;
-        writel(&SHARED_MEM->next_encoder, 0);
-        finalize_transmit(msglen);
-    }
-}
-
-// Wait for PRU1 to finish processing a command
-static void
-wait_pru1_command(void)
-{
-    while (readl(&SHARED_MEM->next_command))
-        check_can_send();
-    check_can_send();
-}
-
-// Signal PRU1 that a new command is ready
-static void
-send_pru1_command(const struct command_parser *cp)
-{
-    barrier();
-    SHARED_MEM->next_command = cp;
-    barrier();
-    write_r31(R31_WRITE_IRQ_SELECT | (KICK_PRU1_EVENT - R31_WRITE_IRQ_OFFSET));
-}
-
-// Instruct PRU1 to shutdown
-static void
-send_pru1_shutdown(void)
-{
-    wait_pru1_command();
-    send_pru1_command(SHARED_MEM->shutdown_handler);
-    wait_pru1_command();
-}
-
-// Dispatch all the commands in a message block
-static void
-do_dispatch(uint8_t *buf, uint32_t msglen)
-{
-    uint8_t *p = &buf[MESSAGE_HEADER_SIZE];
-    uint8_t *msgend = &buf[msglen-MESSAGE_TRAILER_SIZE];
-    while (p < msgend) {
-        // Parse command
-        uint_fast8_t cmdid = *p++;
-        const struct command_parser *cp = &SHARED_MEM->command_index[cmdid];
-        if (!cmdid || cmdid >= SHARED_MEM->command_index_size
-            || cp->num_args > ARRAY_SIZE(SHARED_MEM->next_command_args)) {
-            send_pru1_shutdown();
-            return;
-        }
-        p = command_parsef(p, msgend, cp, SHARED_MEM->next_command_args);
-
-        send_pru1_command(ALT_PRU_PTR(cp));
-        wait_pru1_command();
-    }
-}
-
-// See if there are commands from the host ready to be processed
-static int
-check_can_read(void)
-{
-    // Read data
-    uint16_t dst, len;
-    uint8_t *p = SHARED_MEM->read_data;
-    int16_t ret = pru_rpmsg_receive(&transport, &transport_dst, &dst, p, &len);
-    if (ret)
-        return ret == PRU_RPMSG_NO_BUF_AVAILABLE;
-
-    // Check for force shutdown request
-    if (len == 15 && p[14] == '\n' && memcmp(p, "FORCE_SHUTDOWN\n", 15) == 0) {
-        send_pru1_shutdown();
-        return 0;
-    }
-
-    // Parse data into message blocks
-    for (;;) {
-        uint_fast8_t pop_count, msglen = len > MESSAGE_MAX ? MESSAGE_MAX : len;
-        int_fast8_t ret = command_find_block(p, msglen, &pop_count);
-        if (!ret)
-            break;
-        if (ret > 0) {
-            do_dispatch(p, pop_count);
-            command_send_ack();
-        }
-        p += pop_count;
-        len -= pop_count;
-    }
-    return 0;
-}
-
-// Main processing loop
-static void
-process_io(void)
-{
-    for (;;) {
-        CT_INTC.SECR0 = ((1 << KICK_PRU0_FROM_ARM_EVENT)
-                         | (1 << KICK_PRU0_EVENT));
-        check_can_send();
-        int can_sleep = check_can_read();
-        if (can_sleep) {
-            flush_messages();
-            while (!(read_r31() & (1 << (WAKE_PRU0_IRQ + R31_IRQ_OFFSET)))) {
-                //asm("slp 1");
-            }
-        }
-    }
-}
-
-// Startup initialization
-static void
-setup_io(void)
-{
-    // Fixup pointers in command_parsers
-    SHARED_MEM->command_index = ALT_PRU_PTR(SHARED_MEM->command_index);
-    struct command_parser *p = (void*)SHARED_MEM->command_index;
-    int i;
-    for (i=0; i<SHARED_MEM->command_index_size; i++, p++)
-        if (p->param_types)
-            p->param_types = ALT_PRU_PTR(p->param_types);
-}
-
-
-/****************************************************************
- * Compatibility wrappers
- ****************************************************************/
-
-// shutdown() compatibility code
-uint8_t ctr_lookup_static_string(const char *str)
-{
-    return 0;
-}
-
-static jmp_buf shutdown_jmp;
-
-// Handle shutdown()
-void
-sched_shutdown(uint_fast8_t reason)
-{
-    longjmp(shutdown_jmp, 1);
-}
-
-// Generate messages - only used for ack/nak messages
-void
-console_sendf(const struct command_encoder *ce, va_list args)
-{
-    uint8_t *data = get_transmit_ptr(ce);
-    int msglen = command_encode_and_frame(data, ce, args);
-    finalize_transmit(msglen);
-}
-
-
-/****************************************************************
- * Resource table
- ****************************************************************/
-
-/*
- * Sizes of the virtqueues (expressed in number of buffers supported,
- * and must be power of 2)
- */
-#define PRU_RPMSG_VQ0_SIZE      16
-#define PRU_RPMSG_VQ1_SIZE      16
-
-/*
- * The feature bitmap for virtio rpmsg
- */
-#define VIRTIO_RPMSG_F_NS       0               //name service notifications
-
-/* This firmware supports name service notifications as one of its features */
-#define RPMSG_PRU_C0_FEATURES   (1 << VIRTIO_RPMSG_F_NS)
-
-/* Definition for unused interrupts */
-#define HOST_UNUSED             255
-
-/* Mapping sysevts to a channel. Each pair contains a sysevt, channel. */
-static struct ch_map pru_intc_map[] = {
-    {IEP_EVENT, WAKE_PRU1_IRQ},
-    {KICK_ARM_EVENT, WAKE_ARM_IRQ},
-    {KICK_PRU0_FROM_ARM_EVENT, WAKE_PRU0_IRQ},
-    {KICK_PRU0_EVENT, WAKE_PRU0_IRQ},
-    {KICK_PRU1_EVENT, WAKE_PRU1_IRQ},
-};
-
-struct my_resource_table {
-    struct resource_table base;
-
-    uint32_t offset[2]; /* Should match 'num' in actual definition */
-
-    /* rpmsg vdev entry */
-    struct fw_rsc_vdev rpmsg_vdev;
-    struct fw_rsc_vdev_vring rpmsg_vring0;
-    struct fw_rsc_vdev_vring rpmsg_vring1;
-
-    /* intc definition */
-    struct fw_rsc_custom pru_ints;
-} resourceTable __section(".resource_table") = {
-    {
-        1,              /* Resource table version: only version 1 is
-                         * supported by the current driver */
-        2,              /* number of entries in the table */
-        { 0, 0 },       /* reserved, must be zero */
-    },
-    /* offsets to entries */
-    {
-        offsetof(struct my_resource_table, rpmsg_vdev),
-        offsetof(struct my_resource_table, pru_ints),
-    },
-
-    /* rpmsg vdev entry */
-    {
-        (uint32_t)TYPE_VDEV,            //type
-        (uint32_t)VIRTIO_ID_RPMSG,      //id
-        (uint32_t)0,                    //notifyid
-        (uint32_t)RPMSG_PRU_C0_FEATURES,//dfeatures
-        (uint32_t)0,                    //gfeatures
-        (uint32_t)0,                    //config_len
-        (uint8_t)0,                     //status
-        (uint8_t)2,                     //num_of_vrings, only two is supported
-        {(uint8_t)0, (uint8_t)0 },      //reserved
-        /* no config data */
-    },
-    /* the two vrings */
-    {
-        0,                  //da, will be populated by host, can't pass it in
-        16,                 //align (bytes),
-        PRU_RPMSG_VQ0_SIZE, //num of descriptors
-        0,                  //notifyid, will be populated, can't pass right now
-        0                   //reserved
-    },
-    {
-        0,                  //da, will be populated by host, can't pass it in
-        16,                 //align (bytes),
-        PRU_RPMSG_VQ1_SIZE, //num of descriptors
-        0,                  //notifyid, will be populated, can't pass right now
-        0                   //reserved
-    },
-
-    {
-        TYPE_CUSTOM, TYPE_PRU_INTS,
-        sizeof(struct fw_rsc_custom_ints),
-        { /* PRU_INTS version */
-            {
-                0x0000,
-                /* Channel-to-host mapping, 255 for unused */
-                {
-                    WAKE_PRU0_IRQ, WAKE_PRU1_IRQ, WAKE_ARM_IRQ,
-                    HOST_UNUSED, HOST_UNUSED, HOST_UNUSED,
-                    HOST_UNUSED, HOST_UNUSED, HOST_UNUSED, HOST_UNUSED
-                },
-                /* Number of evts being mapped to channels */
-                (sizeof(pru_intc_map) / sizeof(struct ch_map)),
-                /* Pointer to the structure containing mapped events */
-                pru_intc_map,
-            },
-        },
-    },
-};
-
-
-/****************************************************************
- * Startup
- ****************************************************************/
-
-#define VIRTIO_CONFIG_S_DRIVER_OK       4
-
-int
-main(void)
-{
-    // allow access to external memory
-    CT_CFG.SYSCFG_bit.STANDBY_INIT = 0;
-
-    // clear all irqs
-    CT_INTC.SECR0 = 0xffffffff;
-    CT_INTC.SECR1 = 0xffffffff;
-
-    /* Make sure the Linux drivers are ready for RPMsg communication */
-    volatile uint8_t *status = &resourceTable.rpmsg_vdev.status;
-    while (!(*status & VIRTIO_CONFIG_S_DRIVER_OK))
-        ;
-
-    /* Initialize the RPMsg transport structure */
-    pru_rpmsg_init(&transport,
-                   &resourceTable.rpmsg_vring0,
-                   &resourceTable.rpmsg_vring1,
-                   KICK_ARM_EVENT,
-                   KICK_PRU0_FROM_ARM_EVENT);
-
-    /* Create the RPMsg channel between the PRU and ARM user space
-     * using the transport structure. */
-    while (pru_rpmsg_channel(RPMSG_NS_CREATE, &transport, CHAN_NAME
-                             , CHAN_DESC, CHAN_PORT) != PRU_RPMSG_SUCCESS)
-        ;
-
-    // Allow PRU0 and PRU1 to wake from sleep
-    PRU0_CTRL.WAKEUP_EN = 1 << (WAKE_PRU0_IRQ + R31_IRQ_OFFSET);
-    PRU1_CTRL.WAKEUP_EN = 1 << (WAKE_PRU1_IRQ + R31_IRQ_OFFSET);
-
-    // Wait for PRU1 to be ready
-    memset(SHARED_MEM, 0, sizeof(*SHARED_MEM));
-    writel(&SHARED_MEM->signal, SIGNAL_PRU0_WAITING);
-    while (readl(&SHARED_MEM->signal) != SIGNAL_PRU1_READY)
-        ;
-    writel(&SHARED_MEM->signal, 0);
-
-    // Setup incoming message parser
-    setup_io();
-
-    // Support shutdown
-    int ret = setjmp(shutdown_jmp);
-    if (ret)
-        send_pru1_shutdown();
-
-    // Main loop
-    process_io();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/pru/pru.lds crealityShit/src/pru/pru.lds
--- klipperStock/src/pru/pru.lds	2024-01-14 23:02:00.189797188 -0600
+++ crealityShit/src/pru/pru.lds	1969-12-31 18:00:00.000000000 -0600
@@ -1,11 +0,0 @@
-/* Final linker script klipper.elf on the PRU */
-SECTIONS
-{
-    /* binutils on the PRU doesn't support --gc-sections so manually
-     * discard the .compile_time_request section */
-    /* and GDB extended debugging information */
-    /DISCARD/ : {
-        *( .compile_time_request )
-        *( .gnu.debug* )
-    }
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/pulse_counter.c crealityShit/src/pulse_counter.c
--- klipperStock/src/pulse_counter.c	2024-01-14 23:02:00.185797137 -0600
+++ crealityShit/src/pulse_counter.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,99 +0,0 @@
-// Commands for counting edges on GPIO input pins
-//
-// Copyright (C) 2021  Adrian Keet <arkeet@gmail.com>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "basecmd.h" // oid_alloc
-#include "board/gpio.h" // struct gpio_in
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_read_time
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // DECL_TASK
-
-struct counter {
-    struct timer timer;
-    uint32_t poll_ticks;
-    uint32_t sample_ticks, next_sample_time;
-    uint32_t count, last_count_time;
-    uint8_t flags;
-    struct gpio_in pin;
-};
-
-enum {
-    CF_PENDING = 1,
-};
-
-static struct task_wake counter_wake;
-
-static uint_fast8_t
-counter_event(struct timer *timer)
-{
-    struct counter *c = container_of(timer, struct counter, timer);
-
-    uint32_t time = c->timer.waketime;
-    uint8_t last_value = c->count & 1;
-    uint8_t value = gpio_in_read(c->pin);
-    if (last_value != value) {
-        c->count++;
-        c->last_count_time = time;
-    }
-    // useful invariant: c->count & 1 == value
-
-    if (timer_is_before(c->next_sample_time, time)) {
-        c->flags |= CF_PENDING;
-        c->next_sample_time = time + c->sample_ticks;
-        sched_wake_task(&counter_wake);
-    }
-
-    c->timer.waketime += c->poll_ticks;
-    return SF_RESCHEDULE;
-}
-
-void
-command_config_counter(uint32_t *args)
-{
-    struct counter *c = oid_alloc(
-        args[0], command_config_counter, sizeof(*c));
-    c->pin = gpio_in_setup(args[1], args[2]);
-    c->timer.func = counter_event;
-}
-DECL_COMMAND(command_config_counter,
-             "config_counter oid=%c pin=%u pull_up=%c");
-
-void
-command_query_counter(uint32_t *args)
-{
-    struct counter *c = oid_lookup(args[0], command_config_counter);
-    sched_del_timer(&c->timer);
-    c->timer.waketime = args[1];
-    c->poll_ticks = args[2];
-    c->sample_ticks = args[3];
-    c->next_sample_time = c->timer.waketime; // sample immediately
-    sched_add_timer(&c->timer);
-}
-DECL_COMMAND(command_query_counter,
-             "query_counter oid=%c clock=%u poll_ticks=%u sample_ticks=%u");
-
-void
-counter_task(void)
-{
-    if (!sched_check_wake(&counter_wake))
-        return;
-
-    uint8_t oid;
-    struct counter *c;
-    foreach_oid(oid, c, command_config_counter) {
-        if (!(c->flags & CF_PENDING))
-            continue;
-        irq_disable();
-        uint32_t waketime = c->timer.waketime;
-        uint32_t count = c->count;
-        uint32_t count_time = c->last_count_time;
-        c->flags &= ~CF_PENDING;
-        irq_enable();
-        sendf("counter_state oid=%c next_clock=%u count=%u count_clock=%u",
-              oid, waketime, count, count_time);
-    }
-}
-DECL_TASK(counter_task);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/pwmcmds.c crealityShit/src/pwmcmds.c
--- klipperStock/src/pwmcmds.c	2024-01-14 23:02:00.137796549 -0600
+++ crealityShit/src/pwmcmds.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,126 +0,0 @@
-// Commands for controlling hardware based pulse-width-modulator pins
-//
-// Copyright (C) 2016  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "basecmd.h" // oid_alloc
-#include "board/gpio.h" // struct gpio_pwm
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_is_before
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // sched_add_timer
-
-struct pwm_out_s {
-    struct timer timer;
-    struct gpio_pwm pin;
-    uint32_t max_duration;
-    uint16_t default_value;
-    struct move_queue_head mq;
-};
-
-struct pwm_move {
-    struct move_node node;
-    uint32_t waketime;
-    uint16_t value;
-};
-
-static uint_fast8_t
-pwm_end_event(struct timer *timer)
-{
-    shutdown("Missed scheduling of next hard pwm event");
-}
-
-static uint_fast8_t
-pwm_event(struct timer *timer)
-{
-    // Apply next update and remove it from queue
-    struct pwm_out_s *p = container_of(timer, struct pwm_out_s, timer);
-    struct move_node *mn = move_queue_pop(&p->mq);
-    struct pwm_move *m = container_of(mn, struct pwm_move, node);
-    uint16_t value = m->value;
-    gpio_pwm_write(p->pin, value);
-    move_free(m);
-
-    // Check if more updates queued
-    if (move_queue_empty(&p->mq)) {
-        if (value == p->default_value || !p->max_duration)
-            return SF_DONE;
-
-        // Start the safety timeout
-        p->timer.waketime += p->max_duration;
-        p->timer.func = pwm_end_event;
-        return SF_RESCHEDULE;
-    }
-
-    // Schedule next update
-    struct move_node *nn = move_queue_first(&p->mq);
-    uint32_t wake = container_of(nn, struct pwm_move, node)->waketime;
-    if (value != p->default_value && p->max_duration
-        && timer_is_before(p->timer.waketime + p->max_duration, wake))
-        shutdown("Scheduled pwm event will exceed max_duration");
-    p->timer.waketime = wake;
-    return SF_RESCHEDULE;
-}
-
-void
-command_config_pwm_out(uint32_t *args)
-{
-    struct gpio_pwm pin = gpio_pwm_setup(args[1], args[2], args[3]);
-    struct pwm_out_s *p = oid_alloc(args[0], command_config_pwm_out
-                                    , sizeof(*p));
-    p->pin = pin;
-    p->default_value = args[4];
-    p->max_duration = args[5];
-    p->timer.func = pwm_event;
-    move_queue_setup(&p->mq, sizeof(struct pwm_move));
-}
-DECL_COMMAND(command_config_pwm_out,
-             "config_pwm_out oid=%c pin=%u cycle_ticks=%u value=%hu"
-             " default_value=%hu max_duration=%u");
-
-void
-command_queue_pwm_out(uint32_t *args)
-{
-    struct pwm_out_s *p = oid_lookup(args[0], command_config_pwm_out);
-    struct pwm_move *m = move_alloc();
-    m->waketime = args[1];
-    m->value = args[2];
-
-    irq_disable();
-    int need_add_timer = move_queue_push(&m->node, &p->mq);
-    irq_enable();
-    if (!need_add_timer)
-        return;
-
-    // queue was empty and a timer needs to be added
-    sched_del_timer(&p->timer);
-    if (p->timer.func == pwm_end_event
-        && timer_is_before(p->timer.waketime, m->waketime))
-        shutdown("Scheduled pwm event will exceed max_duration");
-    p->timer.func = pwm_event;
-    p->timer.waketime = m->waketime;
-    sched_add_timer(&p->timer);
-}
-DECL_COMMAND(command_queue_pwm_out, "queue_pwm_out oid=%c clock=%u value=%hu");
-
-void
-pwm_shutdown(void)
-{
-    uint8_t i;
-    struct pwm_out_s *p;
-    foreach_oid(i, p, command_config_pwm_out) {
-        gpio_pwm_write(p->pin, p->default_value);
-        p->timer.func = pwm_event;
-        move_queue_clear(&p->mq);
-    }
-}
-DECL_SHUTDOWN(pwm_shutdown);
-
-void
-command_set_pwm_out(uint32_t *args)
-{
-    gpio_pwm_setup(args[0], args[1], args[2]);
-}
-DECL_COMMAND(command_set_pwm_out,
-             "set_pwm_out pin=%u cycle_ticks=%u value=%hu");
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/adc.c crealityShit/src/rp2040/adc.c
--- klipperStock/src/rp2040/adc.c	2024-01-14 23:02:00.137796549 -0600
+++ crealityShit/src/rp2040/adc.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,88 +0,0 @@
-// ADC functions on rp2040
-//
-// Copyright (C) 2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/misc.h" // timer_from_us
-#include "command.h" // shutdown
-#include "gpio.h" // gpio_adc_setup
-#include "hardware/structs/adc.h" // adc_hw
-#include "hardware/structs/padsbank0.h" // padsbank0_hw
-#include "hardware/structs/resets.h" // RESETS_RESET_ADC_BITS
-#include "internal.h" // enable_pclock
-#include "sched.h" // sched_shutdown
-
-DECL_CONSTANT("ADC_MAX", 4095);
-
-#define ADC_TEMPERATURE_PIN 0xfe
-DECL_ENUMERATION("pin", "ADC_TEMPERATURE", ADC_TEMPERATURE_PIN);
-
-struct gpio_adc
-gpio_adc_setup(uint32_t pin)
-{
-    if ((pin < 26 || pin > 29) && pin != ADC_TEMPERATURE_PIN)
-        shutdown("Not a valid ADC pin");
-
-    // Enable the ADC
-    if (!is_enabled_pclock(RESETS_RESET_ADC_BITS)) {
-        enable_pclock(RESETS_RESET_ADC_BITS);
-        adc_hw->cs = ADC_CS_EN_BITS;
-    }
-
-    uint8_t chan;
-    if (pin == ADC_TEMPERATURE_PIN) {
-        chan = 4;
-        adc_hw->cs |= ADC_CS_TS_EN_BITS;
-    } else {
-        chan = pin - 26;
-        padsbank0_hw->io[pin] = PADS_BANK0_GPIO0_OD_BITS;
-    }
-
-    return (struct gpio_adc){ .chan = chan };
-}
-
-enum { ADC_DUMMY=0xff };
-static uint8_t last_analog_read = ADC_DUMMY;
-
-// Try to sample a value. Returns zero if sample ready, otherwise
-// returns the number of clock ticks the caller should wait before
-// retrying this function.
-uint32_t
-gpio_adc_sample(struct gpio_adc g)
-{
-    uint32_t cs = adc_hw->cs;
-    if (!(cs & ADC_CS_READY_BITS))
-        // ADC is busy
-        goto need_delay;
-    if (last_analog_read == g.chan)
-        // Sample now ready
-        return 0;
-    if (last_analog_read != ADC_DUMMY)
-        // Sample on another channel in progress
-        goto need_delay;
-
-    // Begin sample
-    last_analog_read = g.chan;
-    adc_hw->cs = ((cs & ADC_CS_TS_EN_BITS) | ADC_CS_START_ONCE_BITS
-                  | ADC_CS_EN_BITS | (g.chan << ADC_CS_AINSEL_LSB));
-
-need_delay:
-    return timer_from_us(5); // Sample takes 2us but provide extra time
-}
-
-// Read a value; use only after gpio_adc_sample() returns zero
-uint16_t
-gpio_adc_read(struct gpio_adc g)
-{
-    last_analog_read = ADC_DUMMY;
-    return adc_hw->result;
-}
-
-// Cancel a sample that may have been started with gpio_adc_sample()
-void
-gpio_adc_cancel_sample(struct gpio_adc g)
-{
-    if (last_analog_read == g.chan)
-        last_analog_read = ADC_DUMMY;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/bootrom.c crealityShit/src/rp2040/bootrom.c
--- klipperStock/src/rp2040/bootrom.c	2024-01-14 23:02:00.133796499 -0600
+++ crealityShit/src/rp2040/bootrom.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,65 +0,0 @@
-// Hardware interface to bootrom on rp2040
-//
-// Copyright (C) 2021  Lasse Dalegaard <dalegaard@gmail.com>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <stdint.h> // uint16_t, uint32_t, uintptr_t
-#include <string.h> // memcpy
-#include "compiler.h" // noinline, __section
-#include "internal.h" // _ramfunc
-
-#define ROM_TABLE_CODE(c1, c2) ((c1) | ((c2) << 8))
-
-// All functions in here need to be RAM-resident, as we may need
-// to (especially for the flash functions) call while the XIP layer
-// is unavailable.
-
-static __always_inline void *rom_hword_as_ptr(uint16_t rom_address) {
-#if defined(__GNUC__) && (__GNUC__ >= 12)
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Warray-bounds"
-  return (void *)(uintptr_t)*(uint16_t *)(uintptr_t)rom_address;
-#pragma GCC diagnostic pop
-#else
-  return (void *)(uintptr_t)*(uint16_t *)(uintptr_t)rom_address;
-#endif
-}
-
-static void * _ramfunc
-rom_func_lookup(uint32_t code)
-{
-  // Table and lookup function are provided by the BOOTROM
-  void *(*fn)(uint16_t *, uint32_t) = rom_hword_as_ptr(0x18);
-  uint16_t *table = rom_hword_as_ptr(0x14);
-  return fn(table, code);
-}
-
-void _ramfunc
-reset_to_usb_boot(uint32_t gpio_activity_pin_mask
-                  , uint32_t disable_interface_mask)
-{
-  void (*fn)(uint32_t, uint32_t) = rom_func_lookup(ROM_TABLE_CODE('U', 'B'));
-  fn(gpio_activity_pin_mask, disable_interface_mask);
-}
-
-void _ramfunc
-connect_internal_flash(void)
-{
-  void (*fn)(void) = rom_func_lookup(ROM_TABLE_CODE('I', 'F'));
-  fn();
-}
-
-void _ramfunc
-flash_exit_xip(void)
-{
-  void (*fn)(void) = rom_func_lookup(ROM_TABLE_CODE('E', 'X'));
-  fn();
-}
-
-void _ramfunc
-flash_flush_cache(void)
-{
-  void (*fn)(void) = rom_func_lookup(ROM_TABLE_CODE('F', 'C'));
-  fn();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/can.c crealityShit/src/rp2040/can.c
--- klipperStock/src/rp2040/can.c	2024-01-14 23:02:00.133796499 -0600
+++ crealityShit/src/rp2040/can.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,78 +0,0 @@
-// Serial over CAN emulation for rp2040 using can2040 software canbus
-//
-// Copyright (C) 2022  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <stdint.h> // uint32_t
-#include <string.h> // memcpy
-#include "autoconf.h" // CONFIG_CANBUS_FREQUENCY
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/io.h" // readl
-#include "can2040.h" // can2040_setup
-#include "command.h" // DECL_CONSTANT_STR
-#include "fasthash.h" // fasthash64
-#include "generic/canbus.h" // canbus_notify_tx
-#include "generic/canserial.h" // CANBUS_ID_ADMIN
-#include "hardware/structs/resets.h" // RESETS_RESET_PIO0_BITS
-#include "internal.h" // DMA_IRQ_0_IRQn
-#include "sched.h" // DECL_INIT
-
-#define GPIO_STR_CAN_RX "gpio" __stringify(CONFIG_RP2040_CANBUS_GPIO_RX)
-#define GPIO_STR_CAN_TX "gpio" __stringify(CONFIG_RP2040_CANBUS_GPIO_TX)
-DECL_CONSTANT_STR("RESERVE_PINS_CAN", GPIO_STR_CAN_RX "," GPIO_STR_CAN_TX);
-
-static struct can2040 cbus;
-
-// Transmit a packet
-int
-canhw_send(struct canbus_msg *msg)
-{
-    int ret = can2040_transmit(&cbus, (void*)msg);
-    if (ret < 0)
-        return -1;
-    return CANMSG_DATA_LEN(msg);
-}
-
-// Setup the receive packet filter
-void
-canhw_set_filter(uint32_t id)
-{
-    // Filter not implemented (and not necessary)
-}
-
-// can2040 callback function - handle rx and tx notifications
-static void
-can2040_cb(struct can2040 *cd, uint32_t notify, struct can2040_msg *msg)
-{
-    if (notify & CAN2040_NOTIFY_TX) {
-        canbus_notify_tx();
-        return;
-    }
-    if (notify & CAN2040_NOTIFY_RX)
-        canbus_process_data((void*)msg);
-}
-
-// Main PIO irq handler
-void
-PIOx_IRQHandler(void)
-{
-    can2040_pio_irq_handler(&cbus);
-}
-
-void
-can_init(void)
-{
-    // Setup canbus
-    can2040_setup(&cbus, 0);
-    can2040_callback_config(&cbus, can2040_cb);
-
-    // Enable irqs
-    armcm_enable_irq(PIOx_IRQHandler, PIO0_IRQ_0_IRQn, 1);
-
-    // Start canbus
-    uint32_t pclk = get_pclock_frequency(RESETS_RESET_PIO0_RESET);
-    can2040_start(&cbus, pclk, CONFIG_CANBUS_FREQUENCY
-                  , CONFIG_RP2040_CANBUS_GPIO_RX, CONFIG_RP2040_CANBUS_GPIO_TX);
-}
-DECL_INIT(can_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/chipid.c crealityShit/src/rp2040/chipid.c
--- klipperStock/src/rp2040/chipid.c	2024-01-14 23:02:00.129796451 -0600
+++ crealityShit/src/rp2040/chipid.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,135 +0,0 @@
-// Support for extracting the hardware chip id on rp2040
-//
-// Copyright (C) 2021  Lasse Dalegaard <dalegaard@gmail.com>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memcpy
-#include "autoconf.h" // CONFIG_USB_SERIAL_NUMBER_CHIPID
-#include "board/irq.h" // irq_disable, irq_enable
-#include "board/canserial.h" // canserial_set_uuid
-#include "generic/usb_cdc.h" // usb_fill_serial
-#include "generic/usbstd.h" // usb_string_descriptor
-#include "sched.h" // DECL_INIT
-#include "hardware/structs/ioqspi.h" // ioqspi_hw
-#include "hardware/structs/ssi.h" // ssi_hw
-#include "internal.h"
-
-#define CHIP_UID_LEN 8
-
-static struct {
-    struct usb_string_descriptor desc;
-    uint16_t data[CHIP_UID_LEN * 2];
-} cdc_chipid;
-
-struct usb_string_descriptor *
-usbserial_get_serialid(void)
-{
-    return &cdc_chipid.desc;
-}
-
-// Functions for reading out the flash chip ID. Adapted from the official
-// Pi SDK.
-
-static void _ramfunc
-flash_cs_force(int high)
-{
-    uint32_t field_val = high ?
-        IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_VALUE_HIGH :
-        IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_VALUE_LOW;
-    hw_write_masked(&ioqspi_hw->io[1].ctrl,
-        field_val << IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_LSB,
-        IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_BITS
-    );
-}
-
-// To re-enable XIP we need to call flash_enter_xip. It's available in the
-// bootrom, but that version is a generic one that works for most devices and
-// the tradeoff for that is enabling a low performance mode.
-// Instead we copy out the boot2 XIP enabling stage, and save it in RAM
-// so we can call it later on.
-
-#define BOOT2_SIZE 0x100
-
-static uint8_t boot2_copy[BOOT2_SIZE] __aligned(16);
-
-static void
-flash_enter_xip_prepare(void)
-{
-  void * volatile target = (void *)XIP_BASE; // Avoids warning
-  memcpy(boot2_copy, target, BOOT2_SIZE);
-  barrier();
-}
-
-static void _ramfunc
-flash_enter_xip_perform(void)
-{
-  ((void (*)(void))boot2_copy+1)();
-}
-
-#define FLASH_RUID_CMD         0x4B
-#define FLASH_RUID_DUMMY_BYTES 4
-#define FLASH_RUID_DATA_BYTES  8
-#define FLASH_RUID_TOTAL_BYTES (1+FLASH_RUID_DUMMY_BYTES+FLASH_RUID_DATA_BYTES)
-
-static void _ramfunc
-read_unique_id(uint8_t *out)
-{
-    uint8_t txbuf[FLASH_RUID_TOTAL_BYTES] = {0};
-    uint8_t rxbuf[FLASH_RUID_TOTAL_BYTES] = {0};
-
-    uint8_t *txptr = txbuf;
-    uint8_t *rxptr = rxbuf;
-
-    int tx_remaining = FLASH_RUID_TOTAL_BYTES;
-    int rx_remaining = FLASH_RUID_TOTAL_BYTES;
-
-    txbuf[0] = FLASH_RUID_CMD;
-
-    // Set up flash so we can work with it without XIP getting in the way
-    flash_enter_xip_prepare();
-    irq_disable();
-    barrier();
-    connect_internal_flash();
-    flash_exit_xip();
-    flash_cs_force(0);
-
-    while (tx_remaining || rx_remaining) {
-        uint32_t flags = ssi_hw->sr;
-        int can_put = !!(flags & SSI_SR_TFNF_BITS);
-        int can_get = !!(flags & SSI_SR_RFNE_BITS);
-        if (can_put && tx_remaining) {
-            ssi_hw->dr0 = *txptr++;
-            tx_remaining--;
-        }
-        if (can_get && rx_remaining) {
-            *rxptr++ = (uint8_t)ssi_hw->dr0;
-            --rx_remaining;
-        }
-    }
-
-    // Restore XIP
-    flash_cs_force(1);
-    flash_flush_cache();
-    flash_enter_xip_perform();
-    barrier();
-    irq_enable();
-
-    memcpy(out, rxbuf+1+FLASH_RUID_DUMMY_BYTES, FLASH_RUID_DATA_BYTES);
-}
-
-void
-chipid_init(void)
-{
-    if (!(CONFIG_USB_SERIAL_NUMBER_CHIPID || CONFIG_CANBUS))
-        return;
-
-    uint8_t data[8] = {0};
-    read_unique_id(data);
-
-    if (CONFIG_USB_SERIAL_NUMBER_CHIPID)
-        usb_fill_serial(&cdc_chipid.desc, ARRAY_SIZE(cdc_chipid.data), data);
-    if (CONFIG_CANBUS)
-        canserial_set_uuid(data, CHIP_UID_LEN);
-}
-DECL_INIT(chipid_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/gpio.c crealityShit/src/rp2040/gpio.c
--- klipperStock/src/rp2040/gpio.c	2024-01-14 23:02:00.133796499 -0600
+++ crealityShit/src/rp2040/gpio.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,119 +0,0 @@
-// GPIO functions on rp2040
-//
-// Copyright (C) 2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // ffs
-#include "board/irq.h" // irq_save
-#include "command.h" // shutdown
-#include "gpio.h" // gpio_out_setup
-#include "hardware/structs/iobank0.h" // iobank0_hw
-#include "hardware/structs/padsbank0.h" // padsbank0_hw
-#include "hardware/structs/sio.h" // sio_hw
-#include "internal.h" // gpio_peripheral
-#include "sched.h" // sched_shutdown
-
-
-/****************************************************************
- * Pin mappings
- ****************************************************************/
-
-DECL_ENUMERATION_RANGE("pin", "gpio0", 0, 30);
-
-// Set the mode and extended function of a pin
-void
-gpio_peripheral(uint32_t gpio, int func, int pull_up)
-{
-    padsbank0_hw->io[gpio] = (
-        PADS_BANK0_GPIO0_IE_BITS
-        | (PADS_BANK0_GPIO0_DRIVE_VALUE_4MA << PADS_BANK0_GPIO0_DRIVE_MSB)
-        | (pull_up > 0 ? PADS_BANK0_GPIO0_PUE_BITS : 0)
-        | (pull_up < 0 ? PADS_BANK0_GPIO0_PDE_BITS : 0));
-    iobank0_hw->io[gpio].ctrl = func << IO_BANK0_GPIO0_CTRL_FUNCSEL_LSB;
-}
-
-// Convert a register and bit location back to an integer pin identifier
-static int
-mask_to_pin(uint32_t mask)
-{
-    return ffs(mask)-1;
-}
-
-
-/****************************************************************
- * General Purpose Input Output (GPIO) pins
- ****************************************************************/
-
-struct gpio_out
-gpio_out_setup(uint8_t pin, uint8_t val)
-{
-    if (pin >= 30)
-        goto fail;
-    struct gpio_out g = { .bit=1<<pin };
-    gpio_out_reset(g, val);
-    return g;
-fail:
-    shutdown("Not an output pin");
-}
-
-void
-gpio_out_reset(struct gpio_out g, uint8_t val)
-{
-    int pin = mask_to_pin(g.bit);
-    irqstatus_t flag = irq_save();
-    gpio_out_write(g, val);
-    sio_hw->gpio_oe_set = g.bit;
-    gpio_peripheral(pin, 5, 0);
-    irq_restore(flag);
-}
-
-void
-gpio_out_toggle_noirq(struct gpio_out g)
-{
-    sio_hw->gpio_togl = g.bit;
-}
-
-void
-gpio_out_toggle(struct gpio_out g)
-{
-    gpio_out_toggle_noirq(g);
-}
-
-void
-gpio_out_write(struct gpio_out g, uint8_t val)
-{
-    if (val)
-        sio_hw->gpio_set = g.bit;
-    else
-        sio_hw->gpio_clr = g.bit;
-}
-
-
-struct gpio_in
-gpio_in_setup(uint8_t pin, int8_t pull_up)
-{
-    if (pin >= 30)
-        goto fail;
-    struct gpio_in g = { .bit=1<<pin };
-    gpio_in_reset(g, pull_up);
-    return g;
-fail:
-    shutdown("Not an input pin");
-}
-
-void
-gpio_in_reset(struct gpio_in g, int8_t pull_up)
-{
-    int pin = mask_to_pin(g.bit);
-    irqstatus_t flag = irq_save();
-    gpio_peripheral(pin, 5, pull_up);
-    sio_hw->gpio_oe_clr = g.bit;
-    irq_restore(flag);
-}
-
-uint8_t
-gpio_in_read(struct gpio_in g)
-{
-    return !!(sio_hw->gpio_in & g.bit);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/gpio.h crealityShit/src/rp2040/gpio.h
--- klipperStock/src/rp2040/gpio.h	2024-01-14 23:02:00.133796499 -0600
+++ crealityShit/src/rp2040/gpio.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,57 +0,0 @@
-#ifndef __RP2040_GPIO_H
-#define __RP2040_GPIO_H
-
-#include <stdint.h> // uint32_t
-
-struct gpio_out {
-    uint32_t bit;
-};
-struct gpio_out gpio_out_setup(uint8_t pin, uint8_t val);
-void gpio_out_reset(struct gpio_out g, uint8_t val);
-void gpio_out_toggle_noirq(struct gpio_out g);
-void gpio_out_toggle(struct gpio_out g);
-void gpio_out_write(struct gpio_out g, uint8_t val);
-
-struct gpio_in {
-    uint32_t bit;
-};
-struct gpio_in gpio_in_setup(uint8_t pin, int8_t pull_up);
-void gpio_in_reset(struct gpio_in g, int8_t pull_up);
-uint8_t gpio_in_read(struct gpio_in g);
-
-struct gpio_pwm {
-    void *reg;
-    uint8_t shift;
-    uint32_t mask;
-};
-struct gpio_pwm gpio_pwm_setup(uint8_t pin, uint32_t cycle_time, uint8_t val);
-void gpio_pwm_write(struct gpio_pwm g, uint32_t val);
-
-struct gpio_adc {
-    uint8_t chan;
-};
-struct gpio_adc gpio_adc_setup(uint32_t pin);
-uint32_t gpio_adc_sample(struct gpio_adc g);
-uint16_t gpio_adc_read(struct gpio_adc g);
-void gpio_adc_cancel_sample(struct gpio_adc g);
-
-struct spi_config {
-    void *spi;
-    uint32_t cr0, cpsr;
-};
-struct spi_config spi_setup(uint32_t bus, uint8_t mode, uint32_t rate);
-void spi_prepare(struct spi_config config);
-void spi_transfer(struct spi_config config, uint8_t receive_data
-                  , uint8_t len, uint8_t *data);
-
-struct i2c_config {
-    void *i2c;
-    uint8_t addr;
-};
-
-struct i2c_config i2c_setup(uint32_t bus, uint32_t rate, uint8_t addr);
-void i2c_write(struct i2c_config config, uint8_t write_len, uint8_t *write);
-void i2c_read(struct i2c_config config, uint8_t reg_len, uint8_t *reg
-              , uint8_t read_len, uint8_t *read);
-
-#endif // gpio.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/hard_pwm.c crealityShit/src/rp2040/hard_pwm.c
--- klipperStock/src/rp2040/hard_pwm.c	2024-01-14 23:02:00.129796451 -0600
+++ crealityShit/src/rp2040/hard_pwm.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,101 +0,0 @@
-// Hardware PWM support on rp2040
-//
-// Copyright (C) 2021  Lasse Dalegaard <dalegaard@gmail.com>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_CLOCK_FREQ
-#include "command.h" // DECL_CONSTANT
-#include "gpio.h" // gpio_pwm_write
-#include "sched.h" // sched_shutdown
-#include "internal.h" // get_pclock_frequency
-#include "hardware/structs/pwm.h" // pwm_hw
-#include "hardware/structs/iobank0.h" // iobank0_hw
-#include "hardware/regs/resets.h" // RESETS_RESET_PWM_BITS
-
-#define MAX_PWM 255
-DECL_CONSTANT("PWM_MAX", MAX_PWM);
-
-struct gpio_pwm
-gpio_pwm_setup(uint8_t pin, uint32_t cycle_time, uint8_t val) {
-    if(pin >= 30)
-        shutdown("invalid gpio pin");
-
-    // All pins on the rp2040 can be used for PWM, there are 8 PWM
-    // slices and each has two channels.
-    pwm_slice_hw_t * slice = &pwm_hw->slice[(pin >> 1) & 0x7];
-    uint8_t channel = pin & 1;
-
-    // Map cycle_time to clock divider
-    // The rp2040 has an 8.4 fractional divider, so we'll map the requested
-    // cycle time into that. The cycle_time we receive from Klippy is in
-    // relation to the crystal frequency and so we need to scale it up to match
-    // the PWM clock.
-    // For better precision, we introduce a scale factor such that pclk * scale
-    // doesn't overflow. We then multiply by this scale factor at the beginning
-    // and divide by it at the end.
-    uint32_t pclk = get_pclock_frequency(RESETS_RESET_PWM_BITS);
-    uint32_t scale = 1 << __builtin_clz(pclk);
-    uint32_t clock_mult = (scale * get_pclock_frequency(RESETS_RESET_PWM_BITS))
-                          / CONFIG_CLOCK_FREQ;
-    uint32_t cycle_clocks = clock_mult * cycle_time;
-    uint32_t div_int = cycle_clocks / MAX_PWM / scale;
-    uint32_t div_frac = (cycle_clocks - div_int * MAX_PWM * scale) * 16
-                        / MAX_PWM / scale;
-
-    // Clamp range of the divider
-    if(div_int > 255) {
-        div_int = 255;
-        div_frac = 15;
-    } else if(div_int < 1) {
-        div_int = 1;
-        div_frac = 0;
-    }
-
-    uint32_t pwm_div = div_int << 4 | div_frac;
-
-    // Enable clock
-    if (!is_enabled_pclock(RESETS_RESET_PWM_BITS))
-        enable_pclock(RESETS_RESET_PWM_BITS);
-
-    // If this PWM slice hasn't been set up yet, we do the full set
-    // up cycle. If it's already been set up however, we check that
-    // the cycle time requested now matches the cycle time already
-    // set on the slice. This allows both channels to be utilized,
-    // as long as their cycle times are the same.
-    if(!(slice->csr & PWM_CH0_CSR_EN_BITS)) {
-        slice->div = pwm_div;
-        slice->top = MAX_PWM - 1;
-        slice->ctr = PWM_CH0_CTR_RESET;
-        slice->cc = PWM_CH0_CC_RESET;
-        slice->csr = PWM_CH0_CSR_EN_BITS;
-    } else {
-        if (slice->div != pwm_div)
-            shutdown("PWM pin has different cycle time from another in "
-                     "the same slice");
-
-        // PWM is already enabled on this slice, we'll check if the
-        // aliasing GPIO pin is already set up for PWM function. If it
-        // is, then we need to bail out.
-        uint32_t alias_pin = (~pin & 0x10) | (pin & 0xF);
-        uint32_t alias_ctrl = iobank0_hw->io[alias_pin].ctrl;
-        uint32_t alias_func = alias_ctrl & IO_BANK0_GPIO0_CTRL_FUNCSEL_BITS;
-        if (alias_func == IO_BANK0_GPIO0_CTRL_FUNCSEL_VALUE_PWM_A_0)
-            shutdown("Aliasing PWM pin already has PWM enabled");
-    }
-
-    struct gpio_pwm out;
-    out.reg = (void*)&slice->cc;
-    out.shift = channel ? PWM_CH0_CC_B_LSB : PWM_CH0_CC_A_LSB;
-    out.mask = channel ? PWM_CH0_CC_B_BITS : PWM_CH0_CC_A_BITS;
-
-    gpio_peripheral(pin, IO_BANK0_GPIO0_CTRL_FUNCSEL_VALUE_PWM_A_0, 0);
-    gpio_pwm_write(out, val);
-
-    return out;
-}
-
-void
-gpio_pwm_write(struct gpio_pwm g, uint32_t val) {
-    hw_write_masked((uint32_t*)g.reg, val << g.shift, g.mask);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/i2c.c crealityShit/src/rp2040/i2c.c
--- klipperStock/src/rp2040/i2c.c	2024-01-14 23:02:00.129796451 -0600
+++ crealityShit/src/rp2040/i2c.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,215 +0,0 @@
-// I2C functions for rp2040
-//
-// Copyright (C) 2022  Lasse Dalegaard <dalegaard@gmail.com>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/misc.h" // timer_is_before
-#include "gpio.h" // i2c_setup, i2c_read, i2c_write
-#include "command.h" // shutdown
-#include "sched.h" // sched_shutdown
-#include "internal.h" // pclock, gpio_peripheral
-#include "hardware/regs/resets.h" // RESETS_RESET_I2C*_BITS
-#include "hardware/structs/i2c.h"
-
-struct i2c_info {
-    i2c_hw_t *i2c;
-    uint8_t sda_pin, scl_pin, pclk;
-};
-
-DECL_ENUMERATION("i2c_bus", "i2c0a", 0);
-DECL_ENUMERATION("i2c_bus", "i2c0b", 1);
-DECL_ENUMERATION("i2c_bus", "i2c0c", 2);
-DECL_ENUMERATION("i2c_bus", "i2c0d", 3);
-DECL_ENUMERATION("i2c_bus", "i2c0e", 4);
-DECL_ENUMERATION("i2c_bus", "i2c0f", 5);
-DECL_ENUMERATION("i2c_bus", "i2c0g", 6);
-DECL_ENUMERATION("i2c_bus", "i2c0h", 7);
-DECL_ENUMERATION("i2c_bus", "i2c1a", 8);
-DECL_ENUMERATION("i2c_bus", "i2c1b", 9);
-DECL_ENUMERATION("i2c_bus", "i2c1c", 10);
-DECL_ENUMERATION("i2c_bus", "i2c1d", 11);
-DECL_ENUMERATION("i2c_bus", "i2c1e", 12);
-DECL_ENUMERATION("i2c_bus", "i2c1f", 13);
-DECL_ENUMERATION("i2c_bus", "i2c1g", 14);
-DECL_CONSTANT_STR("BUS_PINS_i2c0a", "gpio0,gpio1");
-DECL_CONSTANT_STR("BUS_PINS_i2c0b", "gpio4,gpio5");
-DECL_CONSTANT_STR("BUS_PINS_i2c0c", "gpio8,gpio9");
-DECL_CONSTANT_STR("BUS_PINS_i2c0d", "gpio12,gpio13");
-DECL_CONSTANT_STR("BUS_PINS_i2c0e", "gpio16,gpio17");
-DECL_CONSTANT_STR("BUS_PINS_i2c0f", "gpio20,gpio21");
-DECL_CONSTANT_STR("BUS_PINS_i2c0g", "gpio24,gpio25");
-DECL_CONSTANT_STR("BUS_PINS_i2c0h", "gpio28,gpio29");
-DECL_CONSTANT_STR("BUS_PINS_i2c1a", "gpio2,gpio3");
-DECL_CONSTANT_STR("BUS_PINS_i2c1b", "gpio6,gpio7");
-DECL_CONSTANT_STR("BUS_PINS_i2c1c", "gpio10,gpio11");
-DECL_CONSTANT_STR("BUS_PINS_i2c1d", "gpio14,gpio15");
-DECL_CONSTANT_STR("BUS_PINS_i2c1e", "gpio18,gpio19");
-DECL_CONSTANT_STR("BUS_PINS_i2c1f", "gpio22,gpio23");
-DECL_CONSTANT_STR("BUS_PINS_i2c1g", "gpio26,gpio27");
-
-static const struct i2c_info i2c_bus[] = {
-    { i2c0_hw,  0,  1, RESETS_RESET_I2C0_BITS },
-    { i2c0_hw,  4,  5, RESETS_RESET_I2C0_BITS },
-    { i2c0_hw,  8,  9, RESETS_RESET_I2C0_BITS },
-    { i2c0_hw, 12, 13, RESETS_RESET_I2C0_BITS },
-    { i2c0_hw, 16, 17, RESETS_RESET_I2C0_BITS },
-    { i2c0_hw, 20, 21, RESETS_RESET_I2C0_BITS },
-    { i2c0_hw, 24, 25, RESETS_RESET_I2C0_BITS },
-    { i2c0_hw, 28, 29, RESETS_RESET_I2C0_BITS },
-
-    { i2c1_hw,  2,  3, RESETS_RESET_I2C1_BITS },
-    { i2c1_hw,  6,  7, RESETS_RESET_I2C1_BITS },
-    { i2c1_hw, 10, 11, RESETS_RESET_I2C1_BITS },
-    { i2c1_hw, 14, 15, RESETS_RESET_I2C1_BITS },
-    { i2c1_hw, 18, 19, RESETS_RESET_I2C1_BITS },
-    { i2c1_hw, 22, 23, RESETS_RESET_I2C1_BITS },
-    { i2c1_hw, 26, 27, RESETS_RESET_I2C1_BITS },
-};
-
-struct i2c_config
-i2c_setup(uint32_t bus, uint32_t rate, uint8_t addr)
-{
-    if (bus > ARRAY_SIZE(i2c_bus))
-        shutdown("Invalid i2c bus");
-
-    const struct i2c_info *info = &i2c_bus[bus];
-
-    gpio_peripheral(info->sda_pin, 3, 1);
-    gpio_peripheral(info->scl_pin, 3, 1);
-
-    if (!is_enabled_pclock(info->pclk)) {
-        enable_pclock(info->pclk);
-
-        i2c_hw_t *i2c = info->i2c;
-
-        i2c->enable = 0;
-
-        // We set up the bus in 400 kHz mode, but then set timings afterwards
-        // to match either 100k or 400k mode. This simplifies the setup.
-
-        i2c->con = I2C_IC_CON_SPEED_VALUE_FAST << I2C_IC_CON_SPEED_LSB
-                 | I2C_IC_CON_MASTER_MODE_BITS
-                 | I2C_IC_CON_IC_SLAVE_DISABLE_BITS
-                 | I2C_IC_CON_IC_RESTART_EN_BITS;
-
-        i2c->tx_tl = 0;
-        i2c->rx_tl = 0;
-
-        uint32_t pclk = get_pclock_frequency(info->pclk);
-
-        // See `i2c_set_baudrate` in the Pico SDK `hardware_i2c/i2c.c` file
-        // for details on the calculations here.
-        if (rate > 1000000)
-            rate = 1000000; // Clamp the rate to 1Mbps
-        uint32_t period = (pclk + rate / 2) / rate;
-        uint32_t lcnt = period * 3 / 5;
-        uint32_t hcnt = period - lcnt;
-        uint32_t sda_tx_hold_count = ((pclk * 3) / 10000000) + 1;
-
-        i2c->fs_scl_hcnt = hcnt;
-        i2c->fs_scl_lcnt = lcnt;
-        i2c->fs_spklen = lcnt < 16 ? 1 : lcnt / 16;
-        hw_write_masked(&i2c->sda_hold,
-                        sda_tx_hold_count << I2C_IC_SDA_HOLD_IC_SDA_TX_HOLD_LSB,
-                        I2C_IC_SDA_HOLD_IC_SDA_TX_HOLD_BITS);
-    }
-
-    return (struct i2c_config){ .i2c=info->i2c, .addr=addr };
-}
-
-static void
-i2c_start(i2c_hw_t *i2c, uint8_t addr)
-{
-    i2c->enable = 0;
-    i2c->tar = addr;
-    i2c->enable = 1;
-}
-
-static void
-i2c_stop(i2c_hw_t *i2c)
-{
-    i2c->enable = 0;
-}
-
-static void
-i2c_do_write(i2c_hw_t *i2c, uint8_t addr, uint8_t write_len, uint8_t *write
-             , uint8_t send_stop, uint32_t timeout)
-{
-    for (int i = 0; i < write_len; i++) {
-        int first = i == 0;
-        int last = send_stop && (i == write_len - 1);
-
-        // Wait until there's a spot in the TX FIFO
-        while (i2c->txflr == 16) {
-            if (!timer_is_before(timer_read_time(), timeout))
-                shutdown("i2c timeout");
-        }
-
-        i2c->data_cmd = first << I2C_IC_DATA_CMD_RESTART_LSB
-                      | last << I2C_IC_DATA_CMD_STOP_LSB
-                      | write[i];
-    }
-
-    if (!send_stop)
-        return;
-
-    // Drain the transmit buffer
-    while (i2c->txflr != 0) {
-        if (!timer_is_before(timer_read_time(), timeout))
-            shutdown("i2c timeout");
-    }
-}
-
-static void
-i2c_do_read(i2c_hw_t *i2c, uint8_t addr, uint8_t read_len, uint8_t *read
-            , uint32_t timeout)
-{
-    int have_read = 0;
-    int to_send = read_len;
-    while (have_read < read_len) {
-        if (!timer_is_before(timer_read_time(), timeout))
-            shutdown("i2c timeout");
-
-        if (to_send > 0 && i2c->txflr < 16) {
-            int first = to_send == read_len;
-            int last = to_send == 1;
-
-            // Put a read command in the TX FIFO
-            i2c->data_cmd = first << I2C_IC_DATA_CMD_RESTART_LSB
-                          | last << I2C_IC_DATA_CMD_STOP_LSB
-                          | I2C_IC_DATA_CMD_CMD_BITS;
-            to_send--;
-        }
-
-        if (have_read < read_len && i2c->rxflr > 0) {
-            *read++ = i2c->data_cmd & 0xFF;
-            have_read++;
-        }
-    }
-}
-
-void
-i2c_write(struct i2c_config config, uint8_t write_len, uint8_t *write)
-{
-    i2c_hw_t *i2c = (i2c_hw_t*)config.i2c;
-    uint32_t timeout = timer_read_time() + timer_from_us(5000);
-
-    i2c_start(i2c, config.addr);
-    i2c_do_write(i2c, config.addr, write_len, write, 1, timeout);
-    i2c_stop(i2c);
-}
-
-void
-i2c_read(struct i2c_config config, uint8_t reg_len, uint8_t *reg
-         , uint8_t read_len, uint8_t *read)
-{
-    i2c_hw_t *i2c = (i2c_hw_t*)config.i2c;
-    uint32_t timeout = timer_read_time() + timer_from_us(5000);
-
-    i2c_start(i2c, config.addr);
-    if (reg_len != 0)
-        i2c_do_write(i2c, config.addr, reg_len, reg, 0, timeout);
-    i2c_do_read(i2c, config.addr, read_len, read, timeout);
-    i2c_stop(i2c);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/internal.h crealityShit/src/rp2040/internal.h
--- klipperStock/src/rp2040/internal.h	2024-01-14 23:02:00.137796549 -0600
+++ crealityShit/src/rp2040/internal.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,21 +0,0 @@
-#ifndef __RP2040_INTERNAL_H
-#define __RP2040_INTERNAL_H
-// Local definitions for rp2040
-
-#include "RP2040.h"
-
-void enable_pclock(uint32_t reset_bit);
-int is_enabled_pclock(uint32_t reset_bit);
-uint32_t get_pclock_frequency(uint32_t reset_bit);
-void gpio_peripheral(uint32_t gpio, int func, int pull_up);
-void reset_to_usb_boot(uint32_t gpio_activity_pin_mask
-                       , uint32_t disable_interface_mask);
-void connect_internal_flash(void);
-void flash_exit_xip(void);
-void flash_flush_cache(void);
-
-// Force a function to run from ram
-#define UNIQSEC __FILE__ "." __stringify(__LINE__)
-#define _ramfunc noinline __section(".ramfunc." UNIQSEC)
-
-#endif // internal.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/Kconfig crealityShit/src/rp2040/Kconfig
--- klipperStock/src/rp2040/Kconfig	2024-01-14 23:02:00.133796499 -0600
+++ crealityShit/src/rp2040/Kconfig	1969-12-31 18:00:00.000000000 -0600
@@ -1,123 +0,0 @@
-# Kconfig settings for RP2040 processors
-
-if MACH_RP2040
-
-config RP2040_SELECT
-    bool
-    default y
-    select HAVE_GPIO
-    select HAVE_GPIO_ADC
-    select HAVE_GPIO_SPI
-    select HAVE_GPIO_I2C
-    select HAVE_GPIO_BITBANGING
-    select HAVE_STRICT_TIMING
-    select HAVE_CHIPID
-    select HAVE_GPIO_HARD_PWM
-    select HAVE_STEPPER_BOTH_EDGE
-
-config BOARD_DIRECTORY
-    string
-    default "rp2040"
-
-config MCU
-    string
-    default "rp2040"
-
-config CLOCK_FREQ
-    int
-    default 12000000
-
-config FLASH_SIZE
-    hex
-    default 0x200000
-
-config FLASH_BOOT_ADDRESS
-    hex
-    default 0x10000100 # Stage2 binary starts at 0x10000000
-
-config RAM_START
-    hex
-    default 0x20000000
-
-config RAM_SIZE
-    hex
-    default 0x42000
-
-config STACK_SIZE
-    int
-    default 512
-
-
-######################################################################
-# Bootloader options
-######################################################################
-
-config RP2040_HAVE_STAGE2
-    bool
-config RP2040_HAVE_BOOTLOADER
-    bool
-    default y if !RP2040_HAVE_STAGE2
-
-choice
-    prompt "Bootloader offset"
-    config RP2040_FLASH_START_0100
-        bool "No bootloader"
-        select RP2040_HAVE_STAGE2
-    config RP2040_FLASH_START_4000
-        bool "16KiB bootloader"
-endchoice
-config FLASH_APPLICATION_ADDRESS
-    hex
-    default 0x10004000 if RP2040_FLASH_START_4000
-    default 0x10000100
-
-choice
-    prompt "Flash chip" if LOW_LEVEL_OPTIONS && RP2040_HAVE_STAGE2
-    config RP2040_FLASH_W25Q080
-        bool "W25Q080 with CLKDIV 2"
-    config RP2040_FLASH_GENERIC_03
-        bool "GENERIC_03H with CLKDIV 4"
-endchoice
-
-config RP2040_STAGE2_FILE
-    string
-    default "boot2_generic_03h.S" if RP2040_FLASH_GENERIC_03
-    default "boot2_w25q080.S"
-
-config RP2040_STAGE2_CLKDIV
-    int
-    default 4 if RP2040_FLASH_GENERIC_03
-    default 2
-
-
-######################################################################
-# Communication inteface
-######################################################################
-
-choice
-    prompt "Communication interface"
-    config RP2040_USB
-        bool "USB"
-        select USBSERIAL
-    config RP2040_SERIAL_UART0
-        bool "Serial (on UART0 GPIO1/GPIO0)"
-        select SERIAL
-    config RP2040_CANBUS
-        bool "CAN bus"
-        select CANSERIAL
-    config RP2040_USBCANBUS
-        bool "USB to CAN bus bridge"
-        select USBCANBUS
-endchoice
-
-config RP2040_CANBUS_GPIO_RX
-    int "CAN RX gpio number" if CANBUS
-    default 4
-    range 0 29
-
-config RP2040_CANBUS_GPIO_TX
-    int "CAN TX gpio number" if CANBUS
-    default 5
-    range 0 29
-
-endif
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/main.c crealityShit/src/rp2040/main.c
--- klipperStock/src/rp2040/main.c	2024-01-14 23:02:00.133796499 -0600
+++ crealityShit/src/rp2040/main.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,150 +0,0 @@
-// Startup code on rp2040
-//
-// Copyright (C) 2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <stdint.h> // uint32_t
-#include "board/misc.h" // bootloader_request
-#include "generic/armcm_reset.h" // try_request_canboot
-#include "hardware/structs/clocks.h" // clock_hw_t
-#include "hardware/structs/pll.h" // pll_hw_t
-#include "hardware/structs/resets.h" // sio_hw
-#include "hardware/structs/watchdog.h" // watchdog_hw
-#include "hardware/structs/xosc.h" // xosc_hw
-#include "internal.h" // enable_pclock
-#include "sched.h" // sched_main
-
-
-/****************************************************************
- * Bootloader
- ****************************************************************/
-
-void
-bootloader_request(void)
-{
-    watchdog_hw->ctrl = 0;
-    try_request_canboot();
-    // Use the bootrom-provided code to reset into BOOTSEL mode
-    reset_to_usb_boot(0, 0);
-}
-
-
-/****************************************************************
- * Clock setup
- ****************************************************************/
-
-#define FREQ_XOSC 12000000
-#define FREQ_SYS 125000000
-#define FREQ_USB 48000000
-
-void
-enable_pclock(uint32_t reset_bit)
-{
-    resets_hw->reset |= reset_bit;
-    resets_hw->reset &= ~reset_bit;
-    while (!(resets_hw->reset_done & reset_bit))
-        ;
-}
-
-int
-is_enabled_pclock(uint32_t reset_bit)
-{
-    return !(resets_hw->reset & reset_bit);
-}
-
-uint32_t
-get_pclock_frequency(uint32_t reset_bit)
-{
-    return FREQ_SYS;
-}
-
-static void
-xosc_setup(void)
-{
-    xosc_hw->startup = DIV_ROUND_UP(FREQ_XOSC, 1000 * 256); // 1ms
-    xosc_hw->ctrl = (XOSC_CTRL_FREQ_RANGE_VALUE_1_15MHZ
-                     | (XOSC_CTRL_ENABLE_VALUE_ENABLE << XOSC_CTRL_ENABLE_LSB));
-    while(!(xosc_hw->status & XOSC_STATUS_STABLE_BITS))
-        ;
-}
-
-static void
-pll_setup(pll_hw_t *pll, uint32_t mul, uint32_t postdiv)
-{
-    // Setup pll
-    uint32_t refdiv = 1, fbdiv = mul, postdiv2 = 2, postdiv1 = postdiv/postdiv2;
-    pll->cs = refdiv;
-    pll->fbdiv_int = fbdiv;
-    pll->pwr = PLL_PWR_DSMPD_BITS | PLL_PWR_POSTDIVPD_BITS;
-    while (!(pll->cs & PLL_CS_LOCK_BITS))
-        ;
-
-    // Setup post divider
-    pll->prim = ((postdiv1 << PLL_PRIM_POSTDIV1_LSB)
-                 | (postdiv2 << PLL_PRIM_POSTDIV2_LSB));
-    pll->pwr = PLL_PWR_DSMPD_BITS;
-}
-
-static void
-clk_aux_setup(uint32_t clk_id, uint32_t aux_id)
-{
-    clock_hw_t *clk = &clocks_hw->clk[clk_id];
-    clk->ctrl = 0;
-    clk->ctrl = aux_id | CLOCKS_CLK_PERI_CTRL_ENABLE_BITS;
-}
-
-static void
-clock_setup(void)
-{
-    // Set clk_sys and clk_ref to use internal clock
-    clock_hw_t *csys = &clocks_hw->clk[clk_sys];
-    csys->ctrl &= ~CLOCKS_CLK_SYS_CTRL_SRC_BITS;
-    while (csys->selected != 0x1)
-        ;
-    clock_hw_t *cref = &clocks_hw->clk[clk_ref];
-    cref->ctrl &= ~CLOCKS_CLK_REF_CTRL_SRC_BITS;
-    while (cref->selected != 0x1)
-        ;
-
-    // Reset peripherals (that can be)
-    resets_hw->reset = ~(RESETS_RESET_IO_QSPI_BITS
-                         | RESETS_RESET_PADS_QSPI_BITS);
-
-    // Setup xosc, pll_sys, and switch clk_sys
-    xosc_setup();
-    enable_pclock(RESETS_RESET_PLL_SYS_BITS);
-    pll_setup(pll_sys_hw, 125, 125*FREQ_XOSC/FREQ_SYS);
-    csys->ctrl = 0;
-    csys->div = 1<<CLOCKS_CLK_SYS_DIV_INT_LSB;
-    csys->ctrl = CLOCKS_CLK_SYS_CTRL_SRC_VALUE_CLKSRC_CLK_SYS_AUX;
-    while (!(csys->selected & (1 << 1)))
-        ;
-
-    // Setup pll_usb
-    enable_pclock(RESETS_RESET_PLL_USB_BITS);
-    pll_setup(pll_usb_hw, 40, 40*FREQ_XOSC/FREQ_USB);
-
-    // Setup peripheral clocks
-    clk_aux_setup(clk_peri, CLOCKS_CLK_PERI_CTRL_AUXSRC_VALUE_CLK_SYS);
-    clk_aux_setup(clk_adc, CLOCKS_CLK_ADC_CTRL_AUXSRC_VALUE_CLKSRC_PLL_USB);
-    clk_aux_setup(clk_usb, CLOCKS_CLK_USB_CTRL_AUXSRC_VALUE_CLKSRC_PLL_USB);
-
-    // Enable watchdog tick (at 12Mhz)
-    cref->div = 1<<CLOCKS_CLK_REF_DIV_INT_LSB;
-    cref->ctrl = CLOCKS_CLK_REF_CTRL_SRC_VALUE_XOSC_CLKSRC;
-    while (!(cref->selected & (1 << 2)))
-        ;
-    watchdog_hw->tick = 1 | WATCHDOG_TICK_ENABLE_BITS;
-
-    // Enable GPIO control
-    enable_pclock(RESETS_RESET_IO_BANK0_BITS | RESETS_RESET_PADS_BANK0_BITS);
-}
-
-// Main entry point - called from armcm_boot.c:ResetHandler()
-void
-armcm_main(void)
-{
-    clock_setup();
-    sched_main();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/Makefile crealityShit/src/rp2040/Makefile
--- klipperStock/src/rp2040/Makefile	2024-01-14 23:02:00.129796451 -0600
+++ crealityShit/src/rp2040/Makefile	1969-12-31 18:00:00.000000000 -0600
@@ -1,73 +0,0 @@
-# Additional RP2040 build rules
-
-# Setup the toolchain
-CROSS_PREFIX=arm-none-eabi-
-
-dirs-y += src/rp2040 src/generic lib/rp2040/elf2uf2 lib/fast-hash lib/can2040
-
-CFLAGS += -mcpu=cortex-m0plus -mthumb -Ilib/cmsis-core
-CFLAGS += -Ilib/rp2040 -Ilib/rp2040/cmsis_include -Ilib/fast-hash -Ilib/can2040
-
-# Add source files
-src-y += rp2040/main.c rp2040/watchdog.c rp2040/gpio.c
-src-y += rp2040/adc.c rp2040/timer.c rp2040/bootrom.c
-src-y += generic/armcm_boot.c generic/armcm_irq.c generic/armcm_reset.c
-src-y += generic/timer_irq.c generic/crc16_ccitt.c
-src-$(CONFIG_USBSERIAL) += rp2040/usbserial.c generic/usb_cdc.c
-src-$(CONFIG_USBSERIAL) += rp2040/chipid.c
-src-$(CONFIG_SERIAL) += rp2040/serial.c generic/serial_irq.c
-src-$(CONFIG_CANSERIAL) += rp2040/can.c rp2040/chipid.c ../lib/can2040/can2040.c
-src-$(CONFIG_CANSERIAL) += generic/canserial.c generic/canbus.c
-src-$(CONFIG_CANSERIAL) += ../lib/fast-hash/fasthash.c
-src-$(CONFIG_USBCANBUS) += rp2040/can.c rp2040/chipid.c ../lib/can2040/can2040.c
-src-$(CONFIG_USBCANBUS) += generic/canserial.c generic/usb_canbus.c
-src-$(CONFIG_USBCANBUS) += ../lib/fast-hash/fasthash.c rp2040/usbserial.c
-src-$(CONFIG_HAVE_GPIO_HARD_PWM) += rp2040/hard_pwm.c
-src-$(CONFIG_HAVE_GPIO_SPI) += rp2040/spi.c
-src-$(CONFIG_HAVE_GPIO_I2C) += rp2040/i2c.c
-
-# rp2040 stage2 building
-STAGE2_FILE := $(shell echo $(CONFIG_RP2040_STAGE2_FILE))
-$(OUT)stage2.o: lib/rp2040/boot_stage2/$(STAGE2_FILE) $(OUT)autoconf.h
-	@echo "  Building rp2040 stage2 $@"
-	$(Q)$(CC) $(CFLAGS) -Ilib/rp2040/boot_stage2 -Ilib/rp2040/boot_stage2/asminclude -DPICO_FLASH_SPI_CLKDIV=$(CONFIG_RP2040_STAGE2_CLKDIV) -c $< -o $(OUT)stage2raw1.o
-	$(Q)$(LD) $(OUT)stage2raw1.o --script=lib/rp2040/boot_stage2/boot_stage2.ld -o $(OUT)stage2raw.o
-	$(Q)$(OBJCOPY) -O binary $(OUT)stage2raw.o $(OUT)stage2raw.bin
-	$(Q)lib/rp2040/boot_stage2/pad_checksum -s 0xffffffff $(OUT)stage2raw.bin $(OUT)stage2.S
-	$(Q)$(CC) $(CFLAGS) -c $(OUT)stage2.S -o $(OUT)stage2.o
-
-# Binary output file rules when using stage2
-$(OUT)lib/rp2040/elf2uf2/elf2uf2: lib/rp2040/elf2uf2/main.cpp
-	@echo "  Building $@"
-	$(Q)g++ -g -O -Ilib/rp2040 $< -o $@
-
-$(OUT)klipper.uf2: $(OUT)klipper.elf $(OUT)lib/rp2040/elf2uf2/elf2uf2
-	@echo "  Creating uf2 file $@"
-	$(Q)$(OUT)lib/rp2040/elf2uf2/elf2uf2 $< $@
-
-rptarget-$(CONFIG_RP2040_HAVE_STAGE2) := $(OUT)klipper.uf2
-rplink-$(CONFIG_RP2040_HAVE_STAGE2) := $(OUT)src/rp2040/rp2040_link.ld
-stage2-$(CONFIG_RP2040_HAVE_STAGE2) := $(OUT)stage2.o
-
-# rp2040 building when using a bootloader
-$(OUT)klipper.bin: $(OUT)klipper.elf
-	@echo "  Creating bin file $@"
-	$(Q)$(OBJCOPY) -O binary $< $@
-
-rptarget-$(CONFIG_RP2040_HAVE_BOOTLOADER) := $(OUT)klipper.bin
-rplink-$(CONFIG_RP2040_HAVE_BOOTLOADER) := $(OUT)src/generic/armcm_link.ld
-
-# Set klipper.elf linker rules
-target-y += $(rptarget-y)
-CFLAGS_klipper.elf += --specs=nano.specs --specs=nosys.specs -T $(rplink-y)
-OBJS_klipper.elf += $(stage2-y)
-$(OUT)klipper.elf: $(stage2-y) $(rplink-y)
-
-# Flash rules
-lib/rp2040_flash/rp2040_flash:
-	@echo "  Building rp2040_flash"
-	$(Q)make -C lib/rp2040_flash rp2040_flash
-
-flash: $(rptarget-y) lib/rp2040_flash/rp2040_flash
-	@echo "  Flashing $< to $(FLASH_DEVICE)"
-	$(Q)$(PYTHON) ./scripts/flash_usb.py -t $(CONFIG_MCU) -d "$(FLASH_DEVICE)" $(if $(NOSUDO),--no-sudo) $(rptarget-y)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/rp2040_link.lds.S crealityShit/src/rp2040/rp2040_link.lds.S
--- klipperStock/src/rp2040/rp2040_link.lds.S	2024-01-14 23:02:00.133796499 -0600
+++ crealityShit/src/rp2040/rp2040_link.lds.S	1969-12-31 18:00:00.000000000 -0600
@@ -1,66 +0,0 @@
-// rp2040 linker script (based on armcm_link.lds.S and customized for stage2)
-//
-// Copyright (C) 2019-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_FLASH_SIZE
-
-OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
-OUTPUT_ARCH(arm)
-
-MEMORY
-{
-  rom (rx) : ORIGIN = 0x10000000 , LENGTH = CONFIG_FLASH_SIZE
-  ram (rwx) : ORIGIN = CONFIG_RAM_START , LENGTH = CONFIG_RAM_SIZE
-}
-
-SECTIONS
-{
-    .text : {
-        . = ALIGN(4);
-        KEEP(*(.boot2))
-        _text_vectortable_start = .;
-        KEEP(*(.vector_table))
-        _text_vectortable_end = .;
-        *(.text .text.*)
-        *(.rodata .rodata*)
-    } > rom
-
-    . = ALIGN(4);
-    _data_flash = .;
-
-    .data : AT (_data_flash)
-    {
-        . = ALIGN(4);
-        _data_start = .;
-        *(.ramfunc .ramfunc.*);
-        *(.data .data.*);
-        . = ALIGN(4);
-        _data_end = .;
-    } > ram
-
-    .bss (NOLOAD) :
-    {
-        . = ALIGN(4);
-        _bss_start = .;
-        *(.bss .bss.*)
-        *(COMMON)
-        . = ALIGN(4);
-        _bss_end = .;
-    } > ram
-
-    _stack_start = CONFIG_RAM_START + CONFIG_RAM_SIZE - CONFIG_STACK_SIZE ;
-    .stack _stack_start (NOLOAD) :
-    {
-        . = . + CONFIG_STACK_SIZE;
-        _stack_end = .;
-    } > ram
-
-    /DISCARD/ : {
-        // The .init/.fini sections are used by __libc_init_array(), but
-        // that isn't needed so no need to include them in the binary.
-        *(.init)
-        *(.fini)
-    }
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/serial.c crealityShit/src/rp2040/serial.c
--- klipperStock/src/rp2040/serial.c	2024-01-14 23:02:00.129796451 -0600
+++ crealityShit/src/rp2040/serial.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,92 +0,0 @@
-// rp2040 serial
-//
-// Copyright (C) 2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <stdint.h> // uint32_t
-#include "autoconf.h" // CONFIG_SERIAL
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/irq.h" // irq_save
-#include "board/serial_irq.h" // serial_rx_data
-#include "hardware/structs/resets.h" // RESETS_RESET_UART0_BITS
-#include "hardware/structs/uart.h" // UART0_BASE
-#include "internal.h" // UART0_IRQn
-#include "sched.h" // DECL_INIT
-
-#define UARTx uart0_hw
-#define UARTx_IRQn UART0_IRQ_IRQn
-#define GPIO_Rx 1
-#define GPIO_Tx 0
-
-// Write tx bytes to the serial port
-static void
-kick_tx(void)
-{
-    for (;;) {
-        if (UARTx->fr & UART_UARTFR_TXFF_BITS) {
-            // Output fifo full - enable tx irq
-            UARTx->imsc = (UART_UARTIMSC_RXIM_BITS | UART_UARTIMSC_RTIM_BITS
-                           | UART_UARTIMSC_TXIM_BITS);
-            break;
-        }
-        uint8_t data;
-        int ret = serial_get_tx_byte(&data);
-        if (ret) {
-            // No more data to send - disable tx irq
-            UARTx->imsc = UART_UARTIMSC_RXIM_BITS | UART_UARTIMSC_RTIM_BITS;
-            break;
-        }
-        UARTx->dr = data;
-    }
-}
-
-void
-UARTx_IRQHandler(void)
-{
-    uint32_t mis = UARTx->mis;
-    if (mis & (UART_UARTMIS_RXMIS_BITS | UART_UARTMIS_RTMIS_BITS)) {
-        do {
-            serial_rx_byte(UARTx->dr);
-        } while (!(UARTx->fr & UART_UARTFR_RXFE_BITS));
-    } else if (mis & UART_UARTMIS_TXMIS_BITS) {
-        kick_tx();
-    }
-}
-
-void
-serial_enable_tx_irq(void)
-{
-    if (!(UARTx->fr & UART_UARTFR_TXFF_BITS)) {
-        irqstatus_t flag = irq_save();
-        kick_tx();
-        irq_restore(flag);
-    }
-}
-
-void
-serial_init(void)
-{
-    enable_pclock(RESETS_RESET_UART0_BITS);
-
-    // Setup baud
-    uint32_t pclk = get_pclock_frequency(RESETS_RESET_UART0_BITS);
-    uint32_t div = DIV_ROUND_CLOSEST(pclk * 4, CONFIG_SERIAL_BAUD);
-    UARTx->ibrd = div >> 6;
-    UARTx->fbrd = div & 0x3f;
-
-    // Enable fifo, set 8N1
-    UARTx->lcr_h = UART_UARTLCR_H_FEN_BITS | UART_UARTLCR_H_WLEN_BITS;
-    UARTx->ifls = 0;
-    UARTx->cr = (UART_UARTCR_RXE_BITS | UART_UARTCR_TXE_BITS
-                 | UART_UARTCR_UARTEN_BITS);
-
-    // Setup pins
-    gpio_peripheral(GPIO_Rx, 2, 1);
-    gpio_peripheral(GPIO_Tx, 2, 0);
-
-    // Enable receive irq
-    armcm_enable_irq(UARTx_IRQHandler, UARTx_IRQn, 0);
-    UARTx->imsc = UART_UARTIMSC_RXIM_BITS | UART_UARTIMSC_RTIM_BITS;
-}
-DECL_INIT(serial_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/spi.c crealityShit/src/rp2040/spi.c
--- klipperStock/src/rp2040/spi.c	2024-01-14 23:02:00.133796499 -0600
+++ crealityShit/src/rp2040/spi.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,110 +0,0 @@
-// SPI functions on rp2040
-//
-// Copyright (C) 2021  Lasse Dalegaard <dalegaard@gmail.com>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "gpio.h" // spi_setup, spi_prepare, spi_transfer
-#include "command.h" // shutdown"
-#include "sched.h" // sched_shutdown"
-#include "internal.h" // pclock, gpio_peripheral
-#include "hardware/structs/spi.h" // spi_hw_t
-#include "hardware/regs/resets.h" // RESETS_RESET_SPI*_BITS
-
-DECL_ENUMERATION("spi_bus", "spi0a", 0);
-DECL_CONSTANT_STR("BUS_PINS_spi0a", "gpio0,gpio3,gpio2");
-DECL_ENUMERATION("spi_bus", "spi0b", 1);
-DECL_CONSTANT_STR("BUS_PINS_spi0b", "gpio4,gpio7,gpio6");
-DECL_ENUMERATION("spi_bus", "spi0c", 2);
-DECL_CONSTANT_STR("BUS_PINS_spi0c", "gpio16,gpio19,gpio18");
-DECL_ENUMERATION("spi_bus", "spi0d", 3);
-DECL_CONSTANT_STR("BUS_PINS_spi0d", "gpio20,gpio23,gpio22");
-
-DECL_ENUMERATION("spi_bus", "spi1a", 4);
-DECL_CONSTANT_STR("BUS_PINS_spi1a", "gpio8,gpio11,gpio10");
-DECL_ENUMERATION("spi_bus", "spi1b", 5);
-DECL_CONSTANT_STR("BUS_PINS_spi1b", "gpio12,gpio15,gpio14");
-DECL_ENUMERATION("spi_bus", "spi1c", 6);
-DECL_CONSTANT_STR("BUS_PINS_spi1c", "gpio24,gpio27,gpio26");
-
-struct spi_info {
-    spi_hw_t *spi;
-    uint8_t miso_pin, mosi_pin, sck_pin;
-    uint32_t pclk;
-};
-
-static const struct spi_info spi_bus[] = {
-    {spi0_hw, 0,  3,  2,  RESETS_RESET_SPI0_BITS},
-    {spi0_hw, 4,  7,  6,  RESETS_RESET_SPI0_BITS},
-    {spi0_hw, 16, 19, 18, RESETS_RESET_SPI0_BITS},
-    {spi0_hw, 20, 23, 22, RESETS_RESET_SPI0_BITS},
-
-    {spi1_hw, 8,  11, 10, RESETS_RESET_SPI1_BITS},
-    {spi1_hw, 12, 15, 14, RESETS_RESET_SPI1_BITS},
-    {spi1_hw, 24, 27, 26, RESETS_RESET_SPI1_BITS},
-};
-
-struct spi_config
-spi_setup(uint32_t bus, uint8_t mode, uint32_t rate)
-{
-    if (bus >= ARRAY_SIZE(spi_bus))
-        shutdown("Invalid spi bus");
-
-    if (!is_enabled_pclock(spi_bus[bus].pclk))
-            enable_pclock(spi_bus[bus].pclk);
-
-    gpio_peripheral(spi_bus[bus].miso_pin, 1, 1);
-    gpio_peripheral(spi_bus[bus].mosi_pin, 1, 0);
-    gpio_peripheral(spi_bus[bus].sck_pin, 1, 0);
-
-    uint32_t pclk = get_pclock_frequency(spi_bus[bus].pclk);
-
-    struct spi_config res = {spi_bus[bus].spi, 0, 0};
-
-    uint8_t prescale;
-    for (prescale = 2; prescale <= 254; prescale += 2) {
-        if (pclk < (prescale + 2) * 256 * rate)
-            break;
-    }
-
-    uint8_t postdiv;
-    for (postdiv = 255; postdiv > 0; --postdiv) {
-        if ((pclk / (prescale * postdiv)) > rate)
-            break;
-    }
-
-    res.cr0 |= postdiv << SPI_SSPCR0_SCR_LSB;
-    res.cr0 |= ((mode & 2) != 0) << SPI_SSPCR0_SPO_LSB;
-    res.cr0 |= ((mode & 1) != 0) << SPI_SSPCR0_SPH_LSB;
-    res.cr0 |= 7 << SPI_SSPCR0_DSS_LSB; // 8bit mode
-    res.cpsr = prescale;
-
-    // Enable the peripheral
-    spi_bus[bus].spi->cr1 = SPI_SSPCR1_SSE_BITS;
-
-    return res;
-}
-
-void
-spi_prepare(struct spi_config config)
-{
-    spi_hw_t *spi = config.spi;
-    spi->cr0 = config.cr0;
-    spi->cpsr = config.cpsr;
-}
-
-void
-spi_transfer(struct spi_config config, uint8_t receive_data,
-             uint8_t len, uint8_t *data)
-{
-    spi_hw_t *spi = config.spi;
-    while (len--) {
-        spi->dr = *data;
-        while (!(spi->sr & SPI_SSPSR_RNE_BITS))
-            ;
-        uint8_t rdata = spi->dr;
-        if(receive_data)
-            *data = rdata;
-        data++;
-    }
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/timer.c crealityShit/src/rp2040/timer.c
--- klipperStock/src/rp2040/timer.c	2024-01-14 23:02:00.133796499 -0600
+++ crealityShit/src/rp2040/timer.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,70 +0,0 @@
-// rp2040 timer support
-//
-// Copyright (C) 2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_read_time
-#include "board/timer_irq.h" // timer_dispatch_many
-#include "command.h" // DECL_SHUTDOWN
-#include "hardware/structs/resets.h" // RESETS_RESET_UART0_BITS
-#include "hardware/structs/timer.h" // RESETS_RESET_UART0_BITS
-#include "internal.h" // enable_pclock
-#include "sched.h" // DECL_INIT
-
-
-/****************************************************************
- * Low level timer code
- ****************************************************************/
-
-// Return the current time (in absolute clock ticks).
-uint32_t
-timer_read_time(void)
-{
-    return timer_hw->timerawl;
-}
-
-static inline void
-timer_set(uint32_t next)
-{
-    timer_hw->alarm[0] = next;
-}
-
-// Activate timer dispatch as soon as possible
-void
-timer_kick(void)
-{
-    timer_set(timer_read_time() + 50);
-}
-
-
-/****************************************************************
- * Setup and irqs
- ****************************************************************/
-
-// Hardware timer IRQ handler - dispatch software timers
-void __aligned(16)
-TIMER0_IRQHandler(void)
-{
-    irq_disable();
-    timer_hw->intr = 1;
-    uint32_t next = timer_dispatch_many();
-    timer_set(next);
-    irq_enable();
-}
-
-void
-timer_init(void)
-{
-    irq_disable();
-    enable_pclock(RESETS_RESET_TIMER_BITS);
-    timer_hw->timelw = 0;
-    timer_hw->timehw = 0;
-    armcm_enable_irq(TIMER0_IRQHandler, TIMER_IRQ_0_IRQn, 2);
-    timer_hw->inte = 1;
-    timer_kick();
-    irq_enable();
-}
-DECL_INIT(timer_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/usbserial.c crealityShit/src/rp2040/usbserial.c
--- klipperStock/src/rp2040/usbserial.c	2024-01-14 23:02:00.137796549 -0600
+++ crealityShit/src/rp2040/usbserial.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,331 +0,0 @@
-// Hardware interface to USB on rp2040
-//
-// Copyright (C) 2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memcpy
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/io.h" // writeb
-#include "board/misc.h" // timer_read_time
-#include "board/usb_cdc.h" // usb_notify_ep0
-#include "board/usb_cdc_ep.h" // USB_CDC_EP_BULK_IN
-#include "board/usbstd.h" // USB_ENDPOINT_XFER_INT
-#include "hardware/regs/sysinfo.h" // SYSINFO_CHIP_ID_OFFSET
-#include "hardware/structs/iobank0.h" // iobank0_hw
-#include "hardware/structs/padsbank0.h" // padsbank0_hw
-#include "hardware/structs/resets.h" // RESETS_RESET_USBCTRL_BITS
-#include "hardware/structs/usb.h" // usb_hw
-#include "internal.h" // enable_pclock
-#include "sched.h" // DECL_INIT
-
-
-/****************************************************************
- * USB transfer memory
- ****************************************************************/
-
-#define DPBUF_SIZE 64
-
-static uint32_t
-usb_buf_offset(uint32_t ep)
-{
-    return 0x100 + ep * DPBUF_SIZE * 2;
-}
-
-static int_fast8_t
-usb_write_packet(uint32_t ep, const void *data, uint_fast8_t len)
-{
-    // Check if there is room for this packet
-    uint32_t epb = usb_dpram->ep_buf_ctrl[ep].in;
-    if (epb & (USB_BUF_CTRL_AVAIL|USB_BUF_CTRL_FULL))
-        return -1;
-    uint32_t pid = (epb ^ USB_BUF_CTRL_DATA1_PID) & USB_BUF_CTRL_DATA1_PID;
-    uint32_t new_epb = USB_BUF_CTRL_FULL | USB_BUF_CTRL_LAST | pid | len;
-    usb_dpram->ep_buf_ctrl[ep].in = new_epb;
-    // Copy the packet to the hw buffer
-    void *addr = (void*)usb_dpram + usb_buf_offset(ep);
-    barrier();
-    memcpy(addr, data, len);
-    barrier();
-    // Inform the USB hardware of the available packet
-    usb_dpram->ep_buf_ctrl[ep].in = new_epb | USB_BUF_CTRL_AVAIL;
-    return len;
-}
-
-static int_fast8_t
-usb_read_packet(uint32_t ep, void *data, uint_fast8_t max_len)
-{
-    // Check if there is a packet ready
-    uint32_t epb = usb_dpram->ep_buf_ctrl[ep].out;
-    if ((epb & (USB_BUF_CTRL_AVAIL|USB_BUF_CTRL_FULL)) != USB_BUF_CTRL_FULL)
-        return -1;
-    // Copy the packet to the given buffer
-    uint32_t pid = (epb ^ USB_BUF_CTRL_DATA1_PID) & USB_BUF_CTRL_DATA1_PID;
-    uint32_t new_epb = USB_BUF_CTRL_LAST | pid | DPBUF_SIZE;
-    usb_dpram->ep_buf_ctrl[ep].out = new_epb;
-    uint32_t c = epb & USB_BUF_CTRL_LEN_MASK;
-    if (c > max_len)
-        c = max_len;
-    void *addr = (void*)usb_dpram + usb_buf_offset(ep);
-    barrier();
-    memcpy(data, addr, c);
-    barrier();
-    // Notify the USB hardware that the space is now available
-    usb_dpram->ep_buf_ctrl[ep].out = new_epb | USB_BUF_CTRL_AVAIL;
-    return c;
-}
-
-
-/****************************************************************
- * Interface
- ****************************************************************/
-
-int_fast8_t
-usb_read_bulk_out(void *data, uint_fast8_t max_len)
-{
-    return usb_read_packet(USB_CDC_EP_BULK_OUT, data, max_len);
-}
-
-int_fast8_t
-usb_send_bulk_in(void *data, uint_fast8_t len)
-{
-    return usb_write_packet(USB_CDC_EP_BULK_IN, data, len);
-}
-
-int_fast8_t
-usb_read_ep0_setup(void *data, uint_fast8_t max_len)
-{
-    if (!(usb_hw->intr & USB_INTR_SETUP_REQ_BITS)) {
-        usb_hw->inte = USB_INTE_BUFF_STATUS_BITS | USB_INTE_SETUP_REQ_BITS;
-        return -1;
-    }
-    usb_dpram->ep_buf_ctrl[0].in = 0;
-    usb_dpram->ep_buf_ctrl[0].out = (USB_BUF_CTRL_DATA1_PID | USB_BUF_CTRL_LAST
-                                     | USB_BUF_CTRL_AVAIL | DPBUF_SIZE);
-    usb_hw->sie_status = USB_SIE_STATUS_SETUP_REC_BITS;
-    barrier();
-    memcpy(data, (void*)usb_dpram->setup_packet, max_len);
-    barrier();
-    if (usb_hw->intr & USB_INTR_SETUP_REQ_BITS) {
-        // Raced with next setup packet
-        usb_notify_ep0();
-        return -1;
-    }
-    return max_len;
-}
-
-int_fast8_t
-usb_read_ep0(void *data, uint_fast8_t max_len)
-{
-    if (usb_hw->intr & USB_INTR_SETUP_REQ_BITS)
-        // Early end of transmission
-        return -2;
-    return usb_read_packet(0, data, max_len);
-}
-
-int_fast8_t
-usb_send_ep0(const void *data, uint_fast8_t len)
-{
-    if (usb_hw->intr & USB_INTR_SETUP_REQ_BITS || usb_hw->buf_status & 2)
-        // Early end of transmission
-        return -2;
-    return usb_write_packet(0, data, len);
-}
-
-void
-usb_stall_ep0(void)
-{
-    usb_dpram->ep_buf_ctrl[0].in = 0;
-    usb_dpram->ep_buf_ctrl[0].out = 0;
-    usb_hw->ep_stall_arm = USB_EP_STALL_ARM_BITS;
-    usb_dpram->ep_buf_ctrl[0].in = USB_BUF_CTRL_STALL;
-    usb_dpram->ep_buf_ctrl[0].out = USB_BUF_CTRL_STALL;
-    usb_notify_ep0();
-}
-
-static uint8_t set_address;
-
-void
-usb_set_address(uint_fast8_t addr)
-{
-    writeb(&set_address, addr);
-    usb_send_ep0(NULL, 0);
-}
-
-void
-usb_set_configure(void)
-{
-    usb_dpram->ep_buf_ctrl[USB_CDC_EP_BULK_IN].in = USB_BUF_CTRL_DATA1_PID;
-    usb_dpram->ep_buf_ctrl[USB_CDC_EP_BULK_OUT].out = (
-        USB_BUF_CTRL_AVAIL | USB_BUF_CTRL_LAST | DPBUF_SIZE);
-}
-
-
-/****************************************************************
- * USB Errata workaround
- ****************************************************************/
-
-// The rp2040 USB has an errata causing it to sometimes not connect
-// after a reset.  The following code has extracts from the PICO SDK.
-
-static struct task_wake usb_errata_wake;
-
-// Workaround for rp2040-e5 errata
-void
-usb_errata_task(void)
-{
-    if (!sched_check_wake(&usb_errata_wake))
-        return;
-
-    if (usb_hw->sie_status & USB_SIE_STATUS_CONNECTED_BITS)
-        // Already connected - workaround not needed
-        return;
-
-    // Wait for not in SE0 state
-    if (!(usb_hw->sie_status & USB_SIE_STATUS_LINE_STATE_BITS)) {
-        sched_wake_task(&usb_errata_wake);
-        return;
-    }
-
-    // Backup GPIO15 pad state
-    uint32_t dp = 15;
-    uint32_t gpio_ctrl_prev = iobank0_hw->io[dp].ctrl;
-    uint32_t pad_ctrl_prev = padsbank0_hw->io[dp];
-
-    // Enable bus keep
-    hw_write_masked(&padsbank0_hw->io[dp],
-                    PADS_BANK0_GPIO15_PUE_BITS | PADS_BANK0_GPIO15_PDE_BITS,
-                    PADS_BANK0_GPIO15_PUE_BITS | PADS_BANK0_GPIO15_PDE_BITS);
-    // Disable pad output
-    hw_write_masked(&iobank0_hw->io[dp].ctrl,
-                    0x2 << IO_BANK0_GPIO15_CTRL_OEOVER_LSB,
-                    IO_BANK0_GPIO15_CTRL_OEOVER_BITS);
-    // Enable USB debug muxing function
-    hw_write_masked(&iobank0_hw->io[dp].ctrl,
-                    8 << IO_BANK0_GPIO15_CTRL_FUNCSEL_LSB,
-                    IO_BANK0_GPIO15_CTRL_FUNCSEL_BITS);
-    // Set input override
-    hw_write_masked(&iobank0_hw->io[dp].ctrl,
-                    0x3 << IO_BANK0_GPIO15_CTRL_INOVER_LSB,
-                    IO_BANK0_GPIO15_CTRL_INOVER_BITS);
-    // PHY pullups need to stay on
-    hw_set_alias(usb_hw)->phy_direct = USB_USBPHY_DIRECT_DP_PULLUP_EN_BITS;
-    hw_set_alias(usb_hw)->phy_direct_override =
-        USB_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_EN_OVERRIDE_EN_BITS;
-    // Switch from USB PHY to GPIO PHY, now with J forced
-    usb_hw->muxing = (USB_USB_MUXING_TO_DIGITAL_PAD_BITS
-                      | USB_USB_MUXING_SOFTCON_BITS);
-
-    // Wait 1ms
-    uint32_t endtime = timer_read_time() + timer_from_us(1000);
-    while (timer_is_before(timer_read_time(), endtime))
-        ;
-
-    // Verify in connected state
-    endtime += timer_from_us(1000);
-    for (;;) {
-        if (usb_hw->sie_status & USB_SIE_STATUS_CONNECTED_BITS)
-            break;
-        if (timer_is_before(endtime, timer_read_time()))
-            // Something went wrong - restore state and continue anyway
-            break;
-    }
-
-    // Switch back to USB phy
-    usb_hw->muxing = USB_USB_MUXING_TO_PHY_BITS | USB_USB_MUXING_SOFTCON_BITS;
-    // Unset PHY pullup overrides
-    hw_clear_alias(usb_hw)->phy_direct_override =
-        USB_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_EN_OVERRIDE_EN_BITS;
-
-    // Restore GPIO control states
-    iobank0_hw->io[dp].ctrl = gpio_ctrl_prev;
-    padsbank0_hw->io[dp] = pad_ctrl_prev;
-}
-DECL_TASK(usb_errata_task);
-
-
-/****************************************************************
- * Setup and interrupts
- ****************************************************************/
-
-void
-USB_Handler(void)
-{
-    uint32_t ints = usb_hw->ints;
-    if (ints & USB_INTS_SETUP_REQ_BITS) {
-        usb_hw->inte = USB_INTE_BUFF_STATUS_BITS;
-        usb_notify_ep0();
-    }
-    if (ints & USB_INTS_BUFF_STATUS_BITS) {
-        uint32_t buf_status = usb_hw->buf_status;
-        usb_hw->buf_status = buf_status;
-        if (buf_status & (1 << (USB_CDC_EP_BULK_OUT*2 + 1)))
-            usb_notify_bulk_out();
-        if (buf_status & (1 << (USB_CDC_EP_BULK_IN*2)))
-            usb_notify_bulk_in();
-        if (buf_status & 3) {
-            usb_notify_ep0();
-            if (buf_status & 1 && set_address) {
-                usb_hw->dev_addr_ctrl = set_address;
-                set_address = 0;
-            }
-        }
-    }
-    if (ints & USB_INTS_BUS_RESET_BITS) {
-        usb_hw->sie_status = USB_SIE_STATUS_BUS_RESET_BITS;
-        sched_wake_task(&usb_errata_wake);
-    }
-}
-
-static void
-endpoint_setup(void)
-{
-    // ACM
-    uint32_t ep_acm = (EP_CTRL_ENABLE_BITS | usb_buf_offset(USB_CDC_EP_ACM)
-                       | (USB_ENDPOINT_XFER_INT << EP_CTRL_BUFFER_TYPE_LSB));
-    usb_dpram->ep_ctrl[USB_CDC_EP_ACM-1].in = ep_acm;
-    // BULK
-    uint32_t ep_out = (EP_CTRL_ENABLE_BITS | usb_buf_offset(USB_CDC_EP_BULK_OUT)
-                       | EP_CTRL_INTERRUPT_PER_BUFFER
-                       | (USB_ENDPOINT_XFER_BULK << EP_CTRL_BUFFER_TYPE_LSB));
-    usb_dpram->ep_ctrl[USB_CDC_EP_BULK_OUT-1].out = ep_out;
-    uint32_t ep_in = (EP_CTRL_ENABLE_BITS | usb_buf_offset(USB_CDC_EP_BULK_IN)
-                      | EP_CTRL_INTERRUPT_PER_BUFFER
-                      | (USB_ENDPOINT_XFER_BULK << EP_CTRL_BUFFER_TYPE_LSB));
-    usb_dpram->ep_ctrl[USB_CDC_EP_BULK_IN-1].in = ep_in;
-    usb_dpram->ep_buf_ctrl[USB_CDC_EP_BULK_IN].in = USB_BUF_CTRL_FULL;
-}
-
-void
-usbserial_init(void)
-{
-    // Configure usb clock
-    enable_pclock(RESETS_RESET_USBCTRL_BITS);
-
-    // Setup shared memory area
-    memset(usb_dpram, 0, sizeof(*usb_dpram));
-    endpoint_setup();
-
-    // Enable USB in device mode
-    usb_hw->muxing = USB_USB_MUXING_TO_PHY_BITS | USB_USB_MUXING_SOFTCON_BITS;
-    usb_hw->pwr = (USB_USB_PWR_VBUS_DETECT_BITS
-                   | USB_USB_PWR_VBUS_DETECT_OVERRIDE_EN_BITS);
-    usb_hw->main_ctrl = USB_MAIN_CTRL_CONTROLLER_EN_BITS;
-
-    // Check if usb errata workaround needed
-    enable_pclock(RESETS_RESET_SYSINFO_BITS);
-    uint32_t chip_id = *((io_ro_32*)(SYSINFO_BASE + SYSINFO_CHIP_ID_OFFSET));
-    uint32_t version = ((chip_id & SYSINFO_CHIP_ID_REVISION_BITS)
-                        >> SYSINFO_CHIP_ID_REVISION_LSB);
-
-    // Enable irqs
-    usb_hw->sie_ctrl = USB_SIE_CTRL_EP0_INT_1BUF_BITS;
-    usb_hw->inte = (USB_INTE_BUFF_STATUS_BITS | USB_INTE_SETUP_REQ_BITS
-                    | (version == 1 ? USB_INTE_BUS_RESET_BITS: 0));
-    armcm_enable_irq(USB_Handler, USBCTRL_IRQ_IRQn, 1);
-
-    // Enable USB pullup
-    usb_hw->sie_ctrl = (USB_SIE_CTRL_EP0_INT_1BUF_BITS
-                        | USB_SIE_CTRL_PULLUP_EN_BITS);
-}
-DECL_INIT(usbserial_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/rp2040/watchdog.c crealityShit/src/rp2040/watchdog.c
--- klipperStock/src/rp2040/watchdog.c	2024-01-14 23:02:00.133796499 -0600
+++ crealityShit/src/rp2040/watchdog.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,29 +0,0 @@
-// Watchdog code on rp2040
-//
-// Copyright (C) 2021-2022  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <stdint.h> // uint32_t
-#include "hardware/structs/psm.h" // psm_hw
-#include "hardware/structs/watchdog.h" // watchdog_hw
-#include "sched.h" // DECL_TASK
-
-void
-watchdog_reset(void)
-{
-    watchdog_hw->load = 0x800000; // ~350ms
-}
-DECL_TASK(watchdog_reset);
-
-void
-watchdog_init(void)
-{
-    psm_hw->wdsel = PSM_WDSEL_BITS & ~(PSM_WDSEL_ROSC_BITS|PSM_WDSEL_XOSC_BITS);
-    watchdog_reset();
-    watchdog_hw->ctrl = (WATCHDOG_CTRL_PAUSE_DBG0_BITS
-                         | WATCHDOG_CTRL_PAUSE_DBG1_BITS
-                         | WATCHDOG_CTRL_PAUSE_JTAG_BITS
-                         | WATCHDOG_CTRL_ENABLE_BITS);
-}
-DECL_INIT(watchdog_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/sched.c crealityShit/src/sched.c
--- klipperStock/src/sched.c	2024-01-14 23:02:00.189797188 -0600
+++ crealityShit/src/sched.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,356 +0,0 @@
-// Basic scheduling functions and startup/shutdown code.
-//
-// Copyright (C) 2016-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <setjmp.h> // setjmp
-#include "autoconf.h" // CONFIG_*
-#include "basecmd.h" // stats_update
-#include "board/io.h" // readb
-#include "board/irq.h" // irq_save
-#include "board/misc.h" // timer_from_us
-#include "board/pgm.h" // READP
-#include "command.h" // shutdown
-#include "sched.h" // sched_check_periodic
-#include "stepper.h" // stepper_event
-
-static struct timer periodic_timer, sentinel_timer, deleted_timer;
-
-static struct {
-    struct timer *timer_list, *last_insert;
-    int8_t tasks_status;
-    uint8_t shutdown_status, shutdown_reason;
-} SchedStatus = {.timer_list = &periodic_timer, .last_insert = &periodic_timer};
-
-
-/****************************************************************
- * Timers
- ****************************************************************/
-
-// The periodic_timer simplifies the timer code by ensuring there is
-// always a timer on the timer list and that there is always a timer
-// not far in the future.
-static uint_fast8_t
-periodic_event(struct timer *t)
-{
-    // Make sure the stats task runs periodically
-    sched_wake_tasks();
-    // Reschedule timer
-    periodic_timer.waketime += timer_from_us(100000);
-    sentinel_timer.waketime = periodic_timer.waketime + 0x80000000;
-    return SF_RESCHEDULE;
-}
-
-static struct timer periodic_timer = {
-    .func = periodic_event,
-    .next = &sentinel_timer,
-};
-
-// The sentinel timer is always the last timer on timer_list - its
-// presence allows the code to avoid checking for NULL while
-// traversing timer_list.  Since sentinel_timer.waketime is always
-// equal to (periodic_timer.waketime + 0x80000000) any added timer
-// must always have a waketime less than one of these two timers.
-static uint_fast8_t
-sentinel_event(struct timer *t)
-{
-    shutdown("sentinel timer called");
-}
-
-static struct timer sentinel_timer = {
-    .func = sentinel_event,
-    .waketime = 0x80000000,
-};
-
-// Find position for a timer in timer_list and insert it
-static void __always_inline
-insert_timer(struct timer *pos, struct timer *t, uint32_t waketime)
-{
-    struct timer *prev;
-    for (;;) {
-        prev = pos;
-        if (CONFIG_MACH_AVR)
-            // micro optimization for AVR - reduces register pressure
-            asm("" : "+r"(prev));
-        pos = pos->next;
-        if (timer_is_before(waketime, pos->waketime))
-            break;
-    }
-    t->next = pos;
-    prev->next = t;
-}
-
-// Schedule a function call at a supplied time.
-void
-sched_add_timer(struct timer *add)
-{
-    uint32_t waketime = add->waketime;
-    irqstatus_t flag = irq_save();
-    struct timer *tl = SchedStatus.timer_list;
-    if (unlikely(timer_is_before(waketime, tl->waketime))) {
-        // This timer is before all other scheduled timers
-        if (timer_is_before(waketime, timer_read_time()))
-            try_shutdown("Timer too close");
-        if (tl == &deleted_timer)
-            add->next = deleted_timer.next;
-        else
-            add->next = tl;
-        deleted_timer.waketime = waketime;
-        deleted_timer.next = add;
-        SchedStatus.timer_list = &deleted_timer;
-        timer_kick();
-    } else {
-        insert_timer(tl, add, waketime);
-    }
-    irq_restore(flag);
-}
-
-// The deleted timer is used when deleting an active timer.
-static uint_fast8_t
-deleted_event(struct timer *t)
-{
-    return SF_DONE;
-}
-
-static struct timer deleted_timer = {
-    .func = deleted_event,
-};
-
-// Remove a timer that may be live.
-void
-sched_del_timer(struct timer *del)
-{
-    irqstatus_t flag = irq_save();
-    if (SchedStatus.timer_list == del) {
-        // Deleting the next active timer - replace with deleted_timer
-        deleted_timer.waketime = del->waketime;
-        deleted_timer.next = del->next;
-        SchedStatus.timer_list = &deleted_timer;
-    } else {
-        // Find and remove from timer list (if present)
-        struct timer *pos;
-        for (pos = SchedStatus.timer_list; pos->next; pos = pos->next) {
-            if (pos->next == del) {
-                pos->next = del->next;
-                break;
-            }
-        }
-    }
-    if (SchedStatus.last_insert == del)
-        SchedStatus.last_insert = &periodic_timer;
-    irq_restore(flag);
-}
-
-// Invoke the next timer - called from board hardware irq code.
-unsigned int
-sched_timer_dispatch(void)
-{
-    // Invoke timer callback
-    struct timer *t = SchedStatus.timer_list;
-    uint_fast8_t res;
-    uint32_t updated_waketime;
-    if (CONFIG_INLINE_STEPPER_HACK && likely(!t->func)) {
-        res = stepper_event(t);
-        updated_waketime = t->waketime;
-    } else {
-        res = t->func(t);
-        updated_waketime = t->waketime;
-    }
-
-    // Update timer_list (rescheduling current timer if necessary)
-    unsigned int next_waketime = updated_waketime;
-    if (unlikely(res == SF_DONE)) {
-        next_waketime = t->next->waketime;
-        SchedStatus.timer_list = t->next;
-        if (SchedStatus.last_insert == t)
-            SchedStatus.last_insert = t->next;
-    } else if (!timer_is_before(updated_waketime, t->next->waketime)) {
-        next_waketime = t->next->waketime;
-        SchedStatus.timer_list = t->next;
-        struct timer *pos = SchedStatus.last_insert;
-        if (timer_is_before(updated_waketime, pos->waketime))
-            pos = SchedStatus.timer_list;
-        insert_timer(pos, t, updated_waketime);
-        SchedStatus.last_insert = t;
-    }
-
-    return next_waketime;
-}
-
-// Remove all user timers
-void
-sched_timer_reset(void)
-{
-    SchedStatus.timer_list = &deleted_timer;
-    deleted_timer.waketime = periodic_timer.waketime;
-    deleted_timer.next = SchedStatus.last_insert = &periodic_timer;
-    periodic_timer.next = &sentinel_timer;
-    timer_kick();
-}
-
-
-/****************************************************************
- * Tasks
- ****************************************************************/
-
-#define TS_IDLE      -1
-#define TS_REQUESTED 0
-#define TS_RUNNING   1
-
-// Note that at least one task is ready to run
-void
-sched_wake_tasks(void)
-{
-    SchedStatus.tasks_status = TS_REQUESTED;
-}
-
-// Check if tasks need to be run
-uint8_t
-sched_tasks_busy(void)
-{
-    return SchedStatus.tasks_status >= TS_REQUESTED;
-}
-
-// Note that a task is ready to run
-void
-sched_wake_task(struct task_wake *w)
-{
-    sched_wake_tasks();
-    writeb(&w->wake, 1);
-}
-
-// Check if a task is ready to run (as indicated by sched_wake_task)
-uint8_t
-sched_check_wake(struct task_wake *w)
-{
-    if (!readb(&w->wake))
-        return 0;
-    writeb(&w->wake, 0);
-    return 1;
-}
-
-// Main task dispatch loop
-static void
-run_tasks(void)
-{
-    uint32_t start = timer_read_time();
-    for (;;) {
-        // Check if can sleep
-        irq_poll();
-        if (SchedStatus.tasks_status != TS_REQUESTED) {
-            start -= timer_read_time();
-            irq_disable();
-            if (SchedStatus.tasks_status != TS_REQUESTED) {
-                // Sleep processor (only run timers) until tasks woken
-                SchedStatus.tasks_status = TS_IDLE;
-                do {
-                    irq_wait();
-                } while (SchedStatus.tasks_status != TS_REQUESTED);
-            }
-            irq_enable();
-            start += timer_read_time();
-        }
-        SchedStatus.tasks_status = TS_RUNNING;
-
-        // Run all tasks
-        extern void ctr_run_taskfuncs(void);
-        ctr_run_taskfuncs();
-
-        // Update statistics
-        uint32_t cur = timer_read_time();
-        stats_update(start, cur);
-        start = cur;
-    }
-}
-
-
-/****************************************************************
- * Shutdown processing
- ****************************************************************/
-
-// Return true if the machine is in an emergency stop state
-uint8_t
-sched_is_shutdown(void)
-{
-    return !!SchedStatus.shutdown_status;
-}
-
-// Transition out of shutdown state
-void
-sched_clear_shutdown(void)
-{
-    if (!SchedStatus.shutdown_status)
-        shutdown("Shutdown cleared when not shutdown");
-    if (SchedStatus.shutdown_status == 2)
-        // Ignore attempt to clear shutdown if still processing shutdown
-        return;
-    SchedStatus.shutdown_status = 0;
-}
-
-// Invoke all shutdown functions (as declared by DECL_SHUTDOWN)
-static void
-run_shutdown(int reason)
-{
-    irq_disable();
-    uint32_t cur = timer_read_time();
-    if (!SchedStatus.shutdown_status)
-        SchedStatus.shutdown_reason = reason;
-    SchedStatus.shutdown_status = 2;
-    sched_timer_reset();
-    extern void ctr_run_shutdownfuncs(void);
-    ctr_run_shutdownfuncs();
-    SchedStatus.shutdown_status = 1;
-    irq_enable();
-
-    sendf("shutdown clock=%u static_string_id=%hu", cur
-          , SchedStatus.shutdown_reason);
-}
-
-// Report the last shutdown reason code
-void
-sched_report_shutdown(void)
-{
-    sendf("is_shutdown static_string_id=%hu", SchedStatus.shutdown_reason);
-}
-
-// Shutdown the machine if not already in the process of shutting down
-void __always_inline
-sched_try_shutdown(uint_fast8_t reason)
-{
-    if (!SchedStatus.shutdown_status)
-        sched_shutdown(reason);
-}
-
-static jmp_buf shutdown_jmp;
-
-// Force the machine to immediately run the shutdown handlers
-void
-sched_shutdown(uint_fast8_t reason)
-{
-    irq_disable();
-    longjmp(shutdown_jmp, reason);
-}
-
-
-/****************************************************************
- * Startup
- ****************************************************************/
-
-// Main loop of program
-void
-sched_main(void)
-{
-    extern void ctr_run_initfuncs(void);
-    ctr_run_initfuncs();
-
-    sendf("starting");
-
-    irq_disable();
-    int ret = setjmp(shutdown_jmp);
-    if (ret)
-        run_shutdown(ret);
-    irq_enable();
-
-    run_tasks();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/sched.h crealityShit/src/sched.h
--- klipperStock/src/sched.h	2024-01-14 23:02:00.169796942 -0600
+++ crealityShit/src/sched.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,48 +0,0 @@
-#ifndef __SCHED_H
-#define __SCHED_H
-
-#include <stdint.h> // uint32_t
-#include "ctr.h" // DECL_CTR
-
-// Declare an init function (called at firmware startup)
-#define DECL_INIT(FUNC) _DECL_CALLLIST(ctr_run_initfuncs, FUNC)
-// Declare a task function (called periodically during normal runtime)
-#define DECL_TASK(FUNC) _DECL_CALLLIST(ctr_run_taskfuncs, FUNC)
-// Declare a shutdown function (called on an emergency stop)
-#define DECL_SHUTDOWN(FUNC) _DECL_CALLLIST(ctr_run_shutdownfuncs, FUNC)
-
-// Timer structure for scheduling timed events (see sched_add_timer() )
-struct timer {
-    struct timer *next;
-    uint_fast8_t (*func)(struct timer*);
-    uint32_t waketime;
-};
-
-enum { SF_DONE=0, SF_RESCHEDULE=1 };
-
-// Task waking struct
-struct task_wake {
-    uint8_t wake;
-};
-
-// sched.c
-void sched_add_timer(struct timer*);
-void sched_del_timer(struct timer *del);
-unsigned int sched_timer_dispatch(void);
-void sched_timer_reset(void);
-void sched_wake_tasks(void);
-uint8_t sched_tasks_busy(void);
-void sched_wake_task(struct task_wake *w);
-uint8_t sched_check_wake(struct task_wake *w);
-uint8_t sched_is_shutdown(void);
-void sched_clear_shutdown(void);
-void sched_try_shutdown(uint_fast8_t reason);
-void sched_shutdown(uint_fast8_t reason) __noreturn;
-void sched_report_shutdown(void);
-void sched_main(void);
-
-// Compiler glue for DECL_X macros above.
-#define _DECL_CALLLIST(NAME, FUNC)                                      \
-    DECL_CTR("_DECL_CALLLIST " __stringify(NAME) " " __stringify(FUNC))
-
-#endif // sched.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/sensor_adxl345.c crealityShit/src/sensor_adxl345.c
--- klipperStock/src/sensor_adxl345.c	2024-01-14 23:02:00.149796696 -0600
+++ crealityShit/src/sensor_adxl345.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,223 +0,0 @@
-// Support for gathering acceleration data from ADXL345 chip
-//
-// Copyright (C) 2020  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memcpy
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_read_time
-#include "basecmd.h" // oid_alloc
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // DECL_TASK
-#include "spicmds.h" // spidev_transfer
-
-struct adxl345 {
-    struct timer timer;
-    uint32_t rest_ticks;
-    struct spidev_s *spi;
-    uint16_t sequence, limit_count;
-    uint8_t flags, data_count;
-    uint8_t data[50];
-};
-
-enum {
-    AX_HAVE_START = 1<<0, AX_RUNNING = 1<<1, AX_PENDING = 1<<2,
-};
-
-static struct task_wake adxl345_wake;
-
-// Event handler that wakes adxl345_task() periodically
-static uint_fast8_t
-adxl345_event(struct timer *timer)
-{
-    struct adxl345 *ax = container_of(timer, struct adxl345, timer);
-    ax->flags |= AX_PENDING;
-    sched_wake_task(&adxl345_wake);
-    return SF_DONE;
-}
-
-void
-command_config_adxl345(uint32_t *args)
-{
-    struct adxl345 *ax = oid_alloc(args[0], command_config_adxl345
-                                   , sizeof(*ax));
-    ax->timer.func = adxl345_event;
-    ax->spi = spidev_oid_lookup(args[1]);
-}
-DECL_COMMAND(command_config_adxl345, "config_adxl345 oid=%c spi_oid=%c");
-
-// Report local measurement buffer
-static void
-adxl_report(struct adxl345 *ax, uint8_t oid)
-{
-    sendf("adxl345_data oid=%c sequence=%hu data=%*s"
-          , oid, ax->sequence, ax->data_count, ax->data);
-    ax->data_count = 0;
-    ax->sequence++;
-}
-
-// Report buffer and fifo status
-static void
-adxl_status(struct adxl345 *ax, uint_fast8_t oid
-            , uint32_t time1, uint32_t time2, uint_fast8_t fifo)
-{
-    sendf("adxl345_status oid=%c clock=%u query_ticks=%u next_sequence=%hu"
-          " buffered=%c fifo=%c limit_count=%hu"
-          , oid, time1, time2-time1, ax->sequence
-          , ax->data_count, fifo, ax->limit_count);
-}
-
-// Helper code to reschedule the adxl345_event() timer
-static void
-adxl_reschedule_timer(struct adxl345 *ax)
-{
-    irq_disable();
-    ax->timer.waketime = timer_read_time() + ax->rest_ticks;
-    sched_add_timer(&ax->timer);
-    irq_enable();
-}
-
-// Chip registers
-#define AR_POWER_CTL   0x2D
-#define AR_DATAX0      0x32
-#define AR_FIFO_STATUS 0x39
-#define AM_READ  0x80
-#define AM_MULTI 0x40
-
-#define SET_FIFO_CTL 0x90
-
-// Query accelerometer data
-static void
-adxl_query(struct adxl345 *ax, uint8_t oid)
-{
-    // Read data
-    uint8_t msg[9] = { AR_DATAX0 | AM_READ | AM_MULTI, 0, 0, 0, 0, 0, 0, 0, 0 };
-    spidev_transfer(ax->spi, 1, sizeof(msg), msg);
-    // Extract x, y, z measurements
-    uint_fast8_t fifo_status = msg[8] & ~0x80; // Ignore trigger bit
-    uint8_t *d = &ax->data[ax->data_count];
-    if (((msg[2] & 0xf0) && (msg[2] & 0xf0) != 0xf0)
-        || ((msg[4] & 0xf0) && (msg[4] & 0xf0) != 0xf0)
-        || ((msg[6] & 0xf0) && (msg[6] & 0xf0) != 0xf0)
-        || (msg[7] != SET_FIFO_CTL) || (fifo_status > 32)) {
-        // Data error - may be a CS, MISO, MOSI, or SCLK glitch
-        d[0] = d[1] = d[2] = d[3] = d[4] = 0xff;
-        fifo_status = 0;
-    } else {
-        // Copy data
-        d[0] = msg[1]; // x low bits
-        d[1] = msg[3]; // y low bits
-        d[2] = msg[5]; // z low bits
-        d[3] = (msg[2] & 0x1f) | (msg[6] << 5); // x high bits and z high bits
-        d[4] = (msg[4] & 0x1f) | ((msg[6] << 2) & 0x60); // y high and z high
-    }
-    ax->data_count += 5;
-    if (ax->data_count + 5 > ARRAY_SIZE(ax->data))
-        adxl_report(ax, oid);
-    // Check fifo status
-    if (fifo_status >= 31)
-        ax->limit_count++;
-    if (fifo_status > 1 && fifo_status <= 32) {
-        // More data in fifo - wake this task again
-        sched_wake_task(&adxl345_wake);
-    } else if (ax->flags & AX_RUNNING) {
-        // Sleep until next check time
-        sched_del_timer(&ax->timer);
-        ax->flags &= ~AX_PENDING;
-        adxl_reschedule_timer(ax);
-    }
-}
-
-// Startup measurements
-static void
-adxl_start(struct adxl345 *ax, uint8_t oid)
-{
-    sched_del_timer(&ax->timer);
-    ax->flags = AX_RUNNING;
-    uint8_t msg[2] = { AR_POWER_CTL, 0x08 };
-    spidev_transfer(ax->spi, 0, sizeof(msg), msg);
-    adxl_reschedule_timer(ax);
-}
-
-// End measurements
-static void
-adxl_stop(struct adxl345 *ax, uint8_t oid)
-{
-    // Disable measurements
-    sched_del_timer(&ax->timer);
-    ax->flags = 0;
-    uint8_t msg[2] = { AR_POWER_CTL, 0x00 };
-    uint32_t end1_time = timer_read_time();
-    spidev_transfer(ax->spi, 0, sizeof(msg), msg);
-    uint32_t end2_time = timer_read_time();
-    // Drain any measurements still in fifo
-    uint_fast8_t i;
-    for (i=0; i<33; i++) {
-        msg[0] = AR_FIFO_STATUS | AM_READ;
-        msg[1] = 0x00;
-        spidev_transfer(ax->spi, 1, sizeof(msg), msg);
-        uint_fast8_t fifo_status = msg[1] & ~0x80;
-        if (!fifo_status)
-            break;
-        if (fifo_status <= 32)
-            adxl_query(ax, oid);
-    }
-    // Report final data
-    if (ax->data_count)
-        adxl_report(ax, oid);
-    adxl_status(ax, oid, end1_time, end2_time, msg[1]);
-}
-
-void
-command_query_adxl345(uint32_t *args)
-{
-    struct adxl345 *ax = oid_lookup(args[0], command_config_adxl345);
-
-    if (!args[2]) {
-        // End measurements
-        adxl_stop(ax, args[0]);
-        return;
-    }
-    // Start new measurements query
-    sched_del_timer(&ax->timer);
-    ax->timer.waketime = args[1];
-    ax->rest_ticks = args[2];
-    ax->flags = AX_HAVE_START;
-    ax->sequence = ax->limit_count = 0;
-    ax->data_count = 0;
-    sched_add_timer(&ax->timer);
-}
-DECL_COMMAND(command_query_adxl345,
-             "query_adxl345 oid=%c clock=%u rest_ticks=%u");
-
-void
-command_query_adxl345_status(uint32_t *args)
-{
-    struct adxl345 *ax = oid_lookup(args[0], command_config_adxl345);
-    uint8_t msg[2] = { AR_FIFO_STATUS | AM_READ, 0x00 };
-    uint32_t time1 = timer_read_time();
-    spidev_transfer(ax->spi, 1, sizeof(msg), msg);
-    uint32_t time2 = timer_read_time();
-    adxl_status(ax, args[0], time1, time2, msg[1]);
-}
-DECL_COMMAND(command_query_adxl345_status, "query_adxl345_status oid=%c");
-
-void
-adxl345_task(void)
-{
-    if (!sched_check_wake(&adxl345_wake))
-        return;
-    uint8_t oid;
-    struct adxl345 *ax;
-    foreach_oid(oid, ax, command_config_adxl345) {
-        uint_fast8_t flags = ax->flags;
-        if (!(flags & AX_PENDING))
-            continue;
-        if (flags & AX_HAVE_START)
-            adxl_start(ax, oid);
-        else
-            adxl_query(ax, oid);
-    }
-}
-DECL_TASK(adxl345_task);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/sensor_angle.c crealityShit/src/sensor_angle.c
--- klipperStock/src/sensor_angle.c	2024-01-14 23:02:00.141796598 -0600
+++ crealityShit/src/sensor_angle.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,319 +0,0 @@
-// Support for querying magnetic angle sensors via SPI
-//
-// Copyright (C) 2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "basecmd.h" // oid_alloc
-#include "board/misc.h" // timer_read_time
-#include "board/gpio.h" // gpio_out_write
-#include "board/irq.h" // irq_disable
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // DECL_TASK
-#include "spicmds.h" // spidev_transfer
-
-enum { SA_CHIP_A1333, SA_CHIP_AS5047D, SA_CHIP_TLE5012B, SA_CHIP_MAX };
-
-DECL_ENUMERATION("spi_angle_type", "a1333", SA_CHIP_A1333);
-DECL_ENUMERATION("spi_angle_type", "as5047d", SA_CHIP_AS5047D);
-DECL_ENUMERATION("spi_angle_type", "tle5012b", SA_CHIP_TLE5012B);
-
-enum { TCODE_ERROR = 0xff };
-enum {
-    SE_OVERFLOW, SE_SCHEDULE, SE_SPI_TIME, SE_CRC, SE_DUP, SE_NO_ANGLE
-};
-
-#define MAX_SPI_READ_TIME timer_from_us(50)
-
-struct spi_angle {
-    struct timer timer;
-    uint32_t rest_ticks;
-    struct spidev_s *spi;
-    uint16_t sequence;
-    uint8_t flags, chip_type, data_count, time_shift, overflow;
-    uint8_t data[48];
-};
-
-enum {
-    SA_PENDING = 1<<2,
-};
-
-static struct task_wake angle_wake;
-
-// Event handler that wakes spi_angle_task() periodically
-static uint_fast8_t
-angle_event(struct timer *timer)
-{
-    struct spi_angle *sa = container_of(timer, struct spi_angle, timer);
-    uint8_t flags = sa->flags;
-    if (sa->flags & SA_PENDING)
-        sa->overflow++;
-    else
-        sa->flags = flags | SA_PENDING;
-    sched_wake_task(&angle_wake);
-    sa->timer.waketime += sa->rest_ticks;
-    return SF_RESCHEDULE;
-}
-
-void
-command_config_spi_angle(uint32_t *args)
-{
-    uint8_t chip_type = args[2];
-    if (chip_type > SA_CHIP_MAX)
-        shutdown("Invalid spi_angle chip type");
-    struct spi_angle *sa = oid_alloc(args[0], command_config_spi_angle
-                                     , sizeof(*sa));
-    sa->timer.func = angle_event;
-    sa->spi = spidev_oid_lookup(args[1]);
-    if (!spidev_have_cs_pin(sa->spi))
-        shutdown("angle sensor requires cs pin");
-    sa->chip_type = chip_type;
-}
-DECL_COMMAND(command_config_spi_angle,
-             "config_spi_angle oid=%c spi_oid=%c spi_angle_type=%c");
-
-// Report local measurement buffer
-static void
-angle_report(struct spi_angle *sa, uint8_t oid)
-{
-    sendf("spi_angle_data oid=%c sequence=%hu data=%*s"
-          , oid, sa->sequence, sa->data_count, sa->data);
-    sa->data_count = 0;
-    sa->sequence++;
-}
-
-// Send spi_angle_data message if buffer is full
-static void
-angle_check_report(struct spi_angle *sa, uint8_t oid)
-{
-    if (sa->data_count + 3 > ARRAY_SIZE(sa->data))
-        angle_report(sa, oid);
-}
-
-// Add an entry to the measurement buffer
-static void
-angle_add(struct spi_angle *sa, uint_fast8_t tcode, uint_fast16_t data)
-{
-    sa->data[sa->data_count] = tcode;
-    sa->data[sa->data_count + 1] = data;
-    sa->data[sa->data_count + 2] = data >> 8;
-    sa->data_count += 3;
-}
-
-// Add an error indicator to the measurement buffer
-static void
-angle_add_error(struct spi_angle *sa, uint_fast8_t error_code)
-{
-    angle_add(sa, TCODE_ERROR, error_code);
-}
-
-// Add a measurement to the buffer
-static void
-angle_add_data(struct spi_angle *sa, uint32_t stime, uint32_t mtime
-               , uint_fast16_t angle)
-{
-    uint32_t tdiff = mtime - stime;
-    if (sa->time_shift)
-        tdiff = (tdiff + (1<<(sa->time_shift - 1))) >> sa->time_shift;
-    if (tdiff >= TCODE_ERROR) {
-        angle_add_error(sa, SE_SCHEDULE);
-        return;
-    }
-    angle_add(sa, tdiff, angle);
-}
-
-// a1333 sensor query
-static void
-a1333_query(struct spi_angle *sa, uint32_t stime)
-{
-    uint8_t msg[2] = { 0x32, 0x00 };
-    uint32_t mtime1 = timer_read_time();
-    spidev_transfer(sa->spi, 1, sizeof(msg), msg);
-    uint32_t mtime2 = timer_read_time();
-    // Data is latched on first sclk edge of response
-    if (mtime2 - mtime1 > MAX_SPI_READ_TIME)
-        angle_add_error(sa, SE_SPI_TIME);
-    else if (msg[0] & 0x80)
-        angle_add_error(sa, SE_CRC);
-    else
-        angle_add_data(sa, stime, mtime1, (msg[0] << 9) | (msg[1] << 1));
-}
-
-// as5047d sensor query
-static void
-as5047d_query(struct spi_angle *sa, uint32_t stime)
-{
-    uint8_t msg[2] = { 0x7F, 0xFE };
-    uint32_t mtime1 = timer_read_time();
-    spidev_transfer(sa->spi, 0, sizeof(msg), msg);
-    uint32_t mtime2 = timer_read_time();
-    // Data is latched on CS pin rising after query request
-    if (mtime2 - mtime1 > MAX_SPI_READ_TIME) {
-        angle_add_error(sa, SE_SPI_TIME);
-        return;
-    }
-    msg[0] = 0xC0;
-    msg[1] = 0x00;
-    spidev_transfer(sa->spi, 1, sizeof(msg), msg);
-    uint_fast8_t parity = msg[0] ^ msg[1];
-    parity ^= parity >> 4;
-    parity ^= parity >> 2;
-    parity ^= parity >> 1;
-    if (parity & 1)
-        angle_add_error(sa, SE_CRC);
-    else if (msg[0] & 0x40)
-        angle_add_error(sa, SE_NO_ANGLE);
-    else
-        angle_add_data(sa, stime, mtime2, (msg[0] << 10) | (msg[1] << 2));
-}
-
-#define TLE_READ 0x80
-#define TLE_READ_LATCH (TLE_READ | 0x04)
-#define TLE_REG_AVAL 0x02
-
-// crc8 "J1850" calculation for tle5012b messages
-static uint8_t
-crc8(uint8_t crc, uint8_t data)
-{
-    crc ^= data;
-    int i;
-    for (i=0; i<8; i++)
-        crc = crc & 0x80 ? (crc << 1) ^ 0x1d : crc << 1;
-    return crc;
-}
-
-// microsecond delay helper
-static inline void
-udelay(uint32_t usecs)
-{
-    uint32_t end = timer_read_time() + timer_from_us(usecs);
-    while (!timer_is_before(end, timer_read_time()))
-        irq_poll();
-}
-
-// tle5012b sensor query
-static void
-tle5012b_query(struct spi_angle *sa, uint32_t stime)
-{
-    struct gpio_out cs_pin = spidev_get_cs_pin(sa->spi);
-    // Latch data (data is latched on rising CS of a NULL message)
-    gpio_out_write(cs_pin, 0);
-    udelay(1);
-    irq_disable();
-    gpio_out_write(cs_pin, 1);
-    uint32_t mtime = timer_read_time();
-    irq_enable();
-
-    uint8_t msg[10] = { TLE_READ_LATCH, (TLE_REG_AVAL << 4) | 0x03 };
-    uint8_t crc = 0x05; // 0x05 == crc8(crc8(0xff, msg[0]), msg[1])
-    spidev_transfer(sa->spi, 1, sizeof(msg), msg);
-    int i;
-    for (i=2; i<8; i++)
-        crc = crc8(crc, msg[i]);
-    if (((~crc) & 0xff) != msg[9])
-        angle_add_error(sa, SE_CRC);
-    else if (!(msg[8] & (1<<4)))
-        angle_add_error(sa, SE_NO_ANGLE);
-    else if (!(msg[2] & 0x80))
-        angle_add_error(sa, SE_DUP);
-    else if (mtime - stime > timer_from_us(32 * 32 * 1000000UL / 750000))
-        angle_add_error(sa, SE_SCHEDULE);
-    else
-        angle_add(sa, (msg[6] >> 1) & 0x3f, (msg[2] << 9) | (msg[3] << 1));
-}
-
-void
-command_query_spi_angle(uint32_t *args)
-{
-    uint8_t oid = args[0];
-    struct spi_angle *sa = oid_lookup(oid, command_config_spi_angle);
-
-    sched_del_timer(&sa->timer);
-    sa->flags = 0;
-    if (!args[2]) {
-        // End measurements
-        if (sa->data_count)
-            angle_report(sa, oid);
-        sendf("spi_angle_end oid=%c sequence=%hu", oid, sa->sequence);
-        return;
-    }
-    // Start new measurements query
-    sa->timer.waketime = args[1];
-    sa->rest_ticks = args[2];
-    sa->sequence = 0;
-    sa->data_count = 0;
-    sa->time_shift = args[3];
-    sched_add_timer(&sa->timer);
-}
-DECL_COMMAND(command_query_spi_angle,
-             "query_spi_angle oid=%c clock=%u rest_ticks=%u time_shift=%c");
-
-void
-command_spi_angle_transfer(uint32_t *args)
-{
-    uint8_t oid = args[0];
-    struct spi_angle *sa = oid_lookup(oid, command_config_spi_angle);
-    uint8_t data_len = args[1];
-    uint8_t *data = command_decode_ptr(args[2]);
-    uint32_t mtime;
-    uint_fast8_t chip = sa->chip_type;
-    if (chip == SA_CHIP_TLE5012B) {
-        // Latch data (data is latched on rising CS of a NULL message)
-        struct gpio_out cs_pin = spidev_get_cs_pin(sa->spi);
-        gpio_out_write(cs_pin, 0);
-        udelay(1);
-        irq_disable();
-        gpio_out_write(cs_pin, 1);
-        mtime = timer_read_time();
-        irq_enable();
-        spidev_transfer(sa->spi, 1, data_len, data);
-    } else {
-        uint32_t mtime1 = timer_read_time();
-        spidev_transfer(sa->spi, 1, data_len, data);
-        uint32_t mtime2 = timer_read_time();
-        if (mtime2 - mtime1 > MAX_SPI_READ_TIME)
-            data_len = 0;
-        if (chip == SA_CHIP_AS5047D)
-            mtime = mtime2;
-        else
-            mtime = mtime1;
-    }
-    sendf("spi_angle_transfer_response oid=%c clock=%u response=%*s"
-          , oid, mtime, data_len, data);
-}
-DECL_COMMAND(command_spi_angle_transfer, "spi_angle_transfer oid=%c data=%*s");
-
-// Background task that performs measurements
-void
-spi_angle_task(void)
-{
-    if (!sched_check_wake(&angle_wake))
-        return;
-    uint8_t oid;
-    struct spi_angle *sa;
-    foreach_oid(oid, sa, command_config_spi_angle) {
-        uint_fast8_t flags = sa->flags;
-        if (!(flags & SA_PENDING))
-            continue;
-        irq_disable();
-        uint32_t stime = sa->timer.waketime;
-        uint_fast8_t overflow = sa->overflow;
-        sa->flags = 0;
-        sa->overflow = 0;
-        irq_enable();
-        stime -= sa->rest_ticks;
-        while (overflow--) {
-            angle_add_error(sa, SE_OVERFLOW);
-            angle_check_report(sa, oid);
-        }
-        uint_fast8_t chip = sa->chip_type;
-        if (chip == SA_CHIP_A1333)
-            a1333_query(sa, stime);
-        else if (chip == SA_CHIP_AS5047D)
-            as5047d_query(sa, stime);
-        else if (chip == SA_CHIP_TLE5012B)
-            tle5012b_query(sa, stime);
-        angle_check_report(sa, oid);
-    }
-}
-DECL_TASK(spi_angle_task);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/sensor_mpu9250.c crealityShit/src/sensor_mpu9250.c
--- klipperStock/src/sensor_mpu9250.c	2024-01-14 23:02:00.109796205 -0600
+++ crealityShit/src/sensor_mpu9250.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,277 +0,0 @@
-// Support for gathering acceleration data from mpu9250 chip
-//
-// Copyright (C) 2022 Harry Beyel <harry3b9@gmail.com>
-// Copyright (C) 2020-2021 Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memcpy
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_read_time
-#include "basecmd.h" // oid_alloc
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // DECL_TASK
-#include "board/gpio.h" // i2c_read
-#include "i2ccmds.h" // i2cdev_oid_lookup
-
-// Chip registers
-#define AR_FIFO_SIZE 512
-
-#define AR_PWR_MGMT_1   0x6B
-#define AR_PWR_MGMT_2   0x6C
-#define AR_FIFO_EN      0x23
-#define AR_ACCEL_OUT_XH 0x3B
-#define AR_USER_CTRL    0x6A
-#define AR_FIFO_COUNT_H 0x72
-#define AR_FIFO         0x74
-
-#define SET_ENABLE_FIFO 0x08
-#define SET_DISABLE_FIFO 0x00
-#define SET_USER_FIFO_RESET 0x04
-#define SET_USER_FIFO_EN 0x40
-
-#define SET_PWR_SLEEP   0x40
-#define SET_PWR_WAKE    0x00
-#define SET_PWR_2_ACCEL 0x07 // only enable accelerometers
-#define SET_PWR_2_NONE  0x3F // disable all sensors
-
-#define BYTES_PER_FIFO_ENTRY 6
-
-struct mpu9250 {
-    struct timer timer;
-    uint32_t rest_ticks;
-    struct i2cdev_s *i2c;
-    uint16_t sequence, limit_count;
-    uint8_t flags, data_count;
-    // data size must be <= 255 due to i2c api
-    // = SAMPLES_PER_BLOCK (from mpu9250.py) * BYTES_PER_FIFO_ENTRY + 1
-    uint8_t data[48];
-};
-
-enum {
-    AX_HAVE_START = 1<<0, AX_RUNNING = 1<<1, AX_PENDING = 1<<2,
-};
-
-static struct task_wake mpu9250_wake;
-
-// Reads the fifo byte count from the device.
-uint16_t
-get_fifo_status (struct mpu9250 *mp)
-{
-    uint8_t regs[] = {AR_FIFO_COUNT_H};
-    uint8_t msg[2];
-    i2c_read(mp->i2c->i2c_config, sizeof(regs), regs, 2, msg);
-    msg[0] = 0x1F & msg[0]; // discard 3 MSB per datasheet
-    return (((uint16_t)msg[0]) << 8 | msg[1]);
-}
-
-// Event handler that wakes mpu9250_task() periodically
-static uint_fast8_t
-mpu9250_event(struct timer *timer)
-{
-    struct mpu9250 *ax = container_of(timer, struct mpu9250, timer);
-    ax->flags |= AX_PENDING;
-    sched_wake_task(&mpu9250_wake);
-    return SF_DONE;
-}
-
-void
-command_config_mpu9250(uint32_t *args)
-{
-    struct mpu9250 *mp = oid_alloc(args[0], command_config_mpu9250
-                                   , sizeof(*mp));
-    mp->timer.func = mpu9250_event;
-    mp->i2c = i2cdev_oid_lookup(args[1]);
-}
-DECL_COMMAND(command_config_mpu9250, "config_mpu9250 oid=%c i2c_oid=%c");
-
-// Report local measurement buffer
-static void
-mp9250_report(struct mpu9250 *mp, uint8_t oid)
-{
-    sendf("mpu9250_data oid=%c sequence=%hu data=%*s"
-          , oid, mp->sequence, mp->data_count, mp->data);
-    mp->data_count = 0;
-    mp->sequence++;
-}
-
-// Report buffer and fifo status
-static void
-mp9250_status(struct mpu9250 *mp, uint_fast8_t oid
-            , uint32_t time1, uint32_t time2, uint16_t fifo)
-{
-    sendf("mpu9250_status oid=%c clock=%u query_ticks=%u next_sequence=%hu"
-          " buffered=%c fifo=%u limit_count=%hu"
-          , oid, time1, time2-time1, mp->sequence
-          , mp->data_count, fifo, mp->limit_count);
-}
-
-// Helper code to reschedule the mpu9250_event() timer
-static void
-mp9250_reschedule_timer(struct mpu9250 *mp)
-{
-    irq_disable();
-    mp->timer.waketime = timer_read_time() + mp->rest_ticks;
-    sched_add_timer(&mp->timer);
-    irq_enable();
-}
-
-// Query accelerometer data
-static void
-mp9250_query(struct mpu9250 *mp, uint8_t oid)
-{
-    // Check fifo status
-    uint16_t fifo_bytes = get_fifo_status(mp);
-    if (fifo_bytes >= AR_FIFO_SIZE - BYTES_PER_FIFO_ENTRY)
-        mp->limit_count++;
-
-    // Read data
-    // FIFO data are: [Xh, Xl, Yh, Yl, Zh, Zl]
-    uint8_t reg = AR_FIFO;
-    uint8_t bytes_to_read = fifo_bytes < sizeof(mp->data) - mp->data_count ?
-                                    fifo_bytes & 0xFF :
-                                    (sizeof(mp->data) - mp->data_count) & 0xFF;
-
-    // round down to nearest full packet of data
-    bytes_to_read = bytes_to_read / BYTES_PER_FIFO_ENTRY * BYTES_PER_FIFO_ENTRY;
-
-    // Extract x, y, z measurements into data holder and report
-    if (bytes_to_read > 0) {
-        i2c_read(mp->i2c->i2c_config, sizeof(reg), &reg,
-                bytes_to_read, &mp->data[mp->data_count]);
-        mp->data_count += bytes_to_read;
-
-        // report data when buffer is full
-        if (mp->data_count + BYTES_PER_FIFO_ENTRY > sizeof(mp->data)) {
-            mp9250_report(mp, oid);
-        }
-    }
-
-    // check if we need to run the task again (more packets in fifo?)
-    if ( bytes_to_read > 0 &&
-            bytes_to_read / BYTES_PER_FIFO_ENTRY <
-            fifo_bytes / BYTES_PER_FIFO_ENTRY) {
-        // more data still ready in the fifo buffer
-        sched_wake_task(&mpu9250_wake);
-    }
-    else if (mp->flags & AX_RUNNING) {
-        // No more fifo data, but actively running. Sleep until next check
-        sched_del_timer(&mp->timer);
-        mp->flags &= ~AX_PENDING;
-        mp9250_reschedule_timer(mp);
-    }
-}
-
-// Startup measurements
-static void
-mp9250_start(struct mpu9250 *mp, uint8_t oid)
-{
-    sched_del_timer(&mp->timer);
-    mp->flags = AX_RUNNING;
-    uint8_t msg[2];
-
-    msg[0] = AR_FIFO_EN;
-    msg[1] = SET_DISABLE_FIFO; // disable FIFO
-    i2c_write(mp->i2c->i2c_config, sizeof(msg), msg);
-
-    msg[0] = AR_USER_CTRL;
-    msg[1] = SET_USER_FIFO_RESET; // reset FIFO buffer
-    i2c_write(mp->i2c->i2c_config, sizeof(msg), msg);
-
-    msg[0] = AR_USER_CTRL;
-    msg[1] = SET_USER_FIFO_EN; // enable FIFO buffer access
-    i2c_write(mp->i2c->i2c_config, sizeof(msg), msg);
-
-    msg[0] = AR_FIFO_EN;
-    msg[1] = SET_ENABLE_FIFO; // enable accel output to FIFO
-    i2c_write(mp->i2c->i2c_config, sizeof(msg), msg);
-
-    mp9250_reschedule_timer(mp);
-}
-
-// End measurements
-static void
-mp9250_stop(struct mpu9250 *mp, uint8_t oid)
-{
-    // Disable measurements
-    sched_del_timer(&mp->timer);
-    mp->flags = 0;
-
-    // disable accel FIFO
-    uint8_t msg[2] = { AR_FIFO_EN, SET_DISABLE_FIFO };
-    uint32_t end1_time = timer_read_time();
-    i2c_write(mp->i2c->i2c_config, sizeof(msg), msg);
-    uint32_t end2_time = timer_read_time();
-
-    // Drain any measurements still in fifo
-    uint16_t fifo_bytes = get_fifo_status(mp);
-    while (fifo_bytes >= BYTES_PER_FIFO_ENTRY) {
-        mp9250_query(mp, oid);
-        fifo_bytes = get_fifo_status(mp);
-    }
-
-    // Report final data
-    if (mp->data_count > 0)
-        mp9250_report(mp, oid);
-    mp9250_status(mp, oid, end1_time, end2_time,
-                    fifo_bytes / BYTES_PER_FIFO_ENTRY);
-}
-
-void
-command_query_mpu9250(uint32_t *args)
-{
-    struct mpu9250 *mp = oid_lookup(args[0], command_config_mpu9250);
-
-    if (!args[2]) {
-        // End measurements
-        mp9250_stop(mp, args[0]);
-        return;
-    }
-    // Start new measurements query
-    sched_del_timer(&mp->timer);
-    mp->timer.waketime = args[1];
-    mp->rest_ticks = args[2];
-    mp->flags = AX_HAVE_START;
-    mp->sequence = mp->limit_count = 0;
-    mp->data_count = 0;
-    sched_add_timer(&mp->timer);
-}
-DECL_COMMAND(command_query_mpu9250,
-             "query_mpu9250 oid=%c clock=%u rest_ticks=%u");
-
-void
-command_query_mpu9250_status(uint32_t *args)
-{
-    struct mpu9250 *mp = oid_lookup(args[0], command_config_mpu9250);
-    uint8_t msg[2];
-    uint32_t time1 = timer_read_time();
-    uint8_t regs[] = {AR_FIFO_COUNT_H};
-    i2c_read(mp->i2c->i2c_config, 1, regs, 2, msg);
-    uint32_t time2 = timer_read_time();
-    msg[0] = 0x1F & msg[0]; // discard 3 MSB
-    uint16_t fifo_bytes = (((uint16_t)msg[0]) << 8) | msg[1];
-    mp9250_status(mp, args[0], time1, time2, fifo_bytes / BYTES_PER_FIFO_ENTRY);
-}
-DECL_COMMAND(command_query_mpu9250_status, "query_mpu9250_status oid=%c");
-
-void
-mpu9250_task(void)
-{
-    if (!sched_check_wake(&mpu9250_wake))
-        return;
-    uint8_t oid;
-    struct mpu9250 *mp;
-    foreach_oid(oid, mp, command_config_mpu9250) {
-        uint_fast8_t flags = mp->flags;
-        if (!(flags & AX_PENDING)) {
-            continue;
-        }
-        if (flags & AX_HAVE_START) {
-            mp9250_start(mp, oid);
-        }
-        else {
-            mp9250_query(mp, oid);
-        }
-    }
-}
-DECL_TASK(mpu9250_task);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/simulator/gpio.c crealityShit/src/simulator/gpio.c
--- klipperStock/src/simulator/gpio.c	2024-01-14 23:02:00.185797137 -0600
+++ crealityShit/src/simulator/gpio.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,58 +0,0 @@
-// GPIO functions on simulator.
-//
-// Copyright (C) 2016  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/gpio.h" // gpio_out_write
-
-struct gpio_out gpio_out_setup(uint8_t pin, uint8_t val) {
-    return (struct gpio_out){.pin=pin};
-}
-void gpio_out_reset(struct gpio_out g, uint8_t val) {
-}
-void gpio_out_toggle_noirq(struct gpio_out g) {
-}
-void gpio_out_toggle(struct gpio_out g) {
-}
-void gpio_out_write(struct gpio_out g, uint8_t val) {
-}
-struct gpio_in gpio_in_setup(uint8_t pin, int8_t pull_up) {
-    return (struct gpio_in){.pin=pin};
-}
-void gpio_in_reset(struct gpio_in g, int8_t pull_up) {
-}
-uint8_t gpio_in_read(struct gpio_in g) {
-    return 0;
-}
-struct gpio_pwm gpio_pwm_setup(uint8_t pin, uint32_t cycle_time, uint8_t val) {
-    return (struct gpio_pwm){.pin=pin};
-}
-void gpio_pwm_write(struct gpio_pwm g, uint8_t val) {
-}
-struct gpio_adc gpio_adc_setup(uint8_t pin) {
-    return (struct gpio_adc){.pin=pin};
-}
-uint32_t gpio_adc_sample(struct gpio_adc g) {
-    return 0;
-}
-uint16_t gpio_adc_read(struct gpio_adc g) {
-    return 0;
-}
-void gpio_adc_cancel_sample(struct gpio_adc g) {
-}
-
-struct spi_config
-spi_setup(uint32_t bus, uint8_t mode, uint32_t rate)
-{
-    return (struct spi_config){ };
-}
-void
-spi_prepare(struct spi_config config)
-{
-}
-void
-spi_transfer(struct spi_config config, uint8_t receive_data
-             , uint8_t len, uint8_t *data)
-{
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/simulator/Kconfig crealityShit/src/simulator/Kconfig
--- klipperStock/src/simulator/Kconfig	2024-01-14 23:02:00.185797137 -0600
+++ crealityShit/src/simulator/Kconfig	1969-12-31 18:00:00.000000000 -0600
@@ -1,25 +0,0 @@
-# Kconfig settings for compiling and running the firmware on the host
-# processor for simulation purposes.
-
-if MACH_SIMU
-
-config BOARD_DIRECTORY
-    string
-    default "simulator"
-
-config SIMULATOR_SELECT
-    bool
-    default y
-    select HAVE_GPIO
-    select HAVE_GPIO_ADC
-    select HAVE_GPIO_SPI
-    select HAVE_GPIO_HARD_PWM
-
-config SERIAL
-    default y
-
-config CLOCK_FREQ
-    int
-    default 20000000
-
-endif
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/simulator/main.c crealityShit/src/simulator/main.c
--- klipperStock/src/simulator/main.c	2024-01-14 23:02:00.185797137 -0600
+++ crealityShit/src/simulator/main.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,15 +0,0 @@
-// Main starting point for host simulator.
-//
-// Copyright (C) 2016-2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "sched.h" // sched_main
-
-// Main entry point for simulator.
-int
-main(void)
-{
-    sched_main();
-    return 0;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/simulator/Makefile crealityShit/src/simulator/Makefile
--- klipperStock/src/simulator/Makefile	2024-01-14 23:02:00.185797137 -0600
+++ crealityShit/src/simulator/Makefile	1969-12-31 18:00:00.000000000 -0600
@@ -1,7 +0,0 @@
-# Additional simulator build rules
-
-dirs-y += src/simulator src/generic
-
-src-y += simulator/main.c simulator/gpio.c simulator/timer.c simulator/serial.c
-src-y += generic/crc16_ccitt.c generic/alloc.c
-src-y += generic/timer_irq.c generic/serial_irq.c
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/simulator/serial.c crealityShit/src/simulator/serial.c
--- klipperStock/src/simulator/serial.c	2024-01-14 23:02:00.185797137 -0600
+++ crealityShit/src/simulator/serial.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,50 +0,0 @@
-// Example code for interacting with serial_irq.c
-//
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <fcntl.h> // fcntl
-#include <unistd.h> // STDIN_FILENO
-#include "board/serial_irq.h" // serial_get_tx_byte
-#include "sched.h" // DECL_INIT
-
-void
-serial_init(void)
-{
-    // Make stdin/stdout non-blocking
-    fcntl(STDIN_FILENO, F_SETFL, fcntl(STDIN_FILENO, F_GETFL, 0) | O_NONBLOCK);
-    fcntl(STDOUT_FILENO, F_SETFL
-          , fcntl(STDOUT_FILENO, F_GETFL, 0) | O_NONBLOCK);
-}
-DECL_INIT(serial_init);
-
-void *
-console_receive_buffer(void)
-{
-    return NULL;
-}
-
-static void
-do_uart(void)
-{
-    for (;;) {
-        uint8_t data;
-        int ret = serial_get_tx_byte(&data);
-        if (ret)
-            break;
-        else
-            write(STDOUT_FILENO, &data, sizeof(data));
-
-        // XXX - Normally the code would check if input data is
-        // available and call serial_rx_byte()
-    }
-}
-
-void
-serial_enable_tx_irq(void)
-{
-    // Normally this would enable the hardware irq, but we just call
-    // do_uart() directly in this demo code.
-    do_uart();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/simulator/timer.c crealityShit/src/simulator/timer.c
--- klipperStock/src/simulator/timer.c	2024-01-14 23:02:00.185797137 -0600
+++ crealityShit/src/simulator/timer.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,109 +0,0 @@
-// Example code for running timers in a polling mode
-//
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <time.h> // struct timespec
-#include <unistd.h> // usleep
-#include "autoconf.h" // CONFIG_CLOCK_FREQ
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_from_us
-#include "board/timer_irq.h" // timer_dispatch_many
-#include "command.h" // DECL_CONSTANT
-#include "sched.h" // DECL_INIT
-
-// Helper function that returns the system time as a 32bit counter
-static uint32_t
-get_system_time(void)
-{
-    struct timespec ts;
-    clock_gettime(CLOCK_MONOTONIC, &ts);
-    double t = (double)ts.tv_sec + (double)ts.tv_nsec * .000000001;
-    return (uint32_t)(t * CONFIG_CLOCK_FREQ);
-}
-
-
-/****************************************************************
- * Timers
- ****************************************************************/
-
-static uint32_t next_wake_time;
-
-// Return the current time (in absolute clock ticks).
-uint32_t
-timer_read_time(void)
-{
-    return get_system_time();
-}
-
-// Activate timer dispatch as soon as possible
-void
-timer_kick(void)
-{
-    next_wake_time = timer_read_time();
-}
-
-// Invoke timers - called below from irq_poll()
-static void
-do_timer_dispatch(void)
-{
-    next_wake_time = timer_dispatch_many();
-}
-
-void
-timer_init(void)
-{
-    timer_kick();
-}
-DECL_INIT(timer_init);
-
-
-/****************************************************************
- * Interrupts
- ****************************************************************/
-
-// Disable hardware interrupts
-void
-irq_disable(void)
-{
-}
-
-// Enable hardware interrupts
-void
-irq_enable(void)
-{
-}
-
-// Disable hardware interrupts in not already disabled
-irqstatus_t
-irq_save(void)
-{
-    return 0;
-}
-
-// Restore hardware interrupts to state from flag returned by irq_save()
-void
-irq_restore(irqstatus_t flag)
-{
-}
-
-// Atomically enable hardware interrupts and sleep processor until next irq
-void
-irq_wait(void)
-{
-    // XXX - sleep to prevent excessive cpu usage in simulator
-    usleep(1);
-
-    irq_poll();
-}
-
-// Check if an interrupt is active (used only on architectures that do
-// not have hardware interrupts)
-void
-irq_poll(void)
-{
-    uint32_t now = timer_read_time();
-    if (!timer_is_before(now, next_wake_time))
-        do_timer_dispatch();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/spicmds.c crealityShit/src/spicmds.c
--- klipperStock/src/spicmds.c	2024-01-14 23:02:00.129796451 -0600
+++ crealityShit/src/spicmds.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,177 +0,0 @@
-// Commands for sending messages on an SPI bus
-//
-// Copyright (C) 2016-2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memcpy
-#include "autoconf.h" // CONFIG_HAVE_GPIO_BITBANGING
-#include "board/gpio.h" // gpio_out_write
-#include "basecmd.h" // oid_alloc
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // DECL_SHUTDOWN
-#include "spi_software.h" // spi_software_setup
-#include "spicmds.h" // spidev_transfer
-
-struct spidev_s {
-    union {
-        struct spi_config spi_config;
-        struct spi_software *spi_software;
-    };
-    struct gpio_out pin;
-    uint8_t flags;
-};
-
-enum {
-    SF_HAVE_PIN = 1, SF_SOFTWARE = 2, SF_HARDWARE = 4, SF_CS_ACTIVE_HIGH = 8
-};
-
-void
-command_config_spi(uint32_t *args)
-{
-    struct spidev_s *spi = oid_alloc(args[0], command_config_spi, sizeof(*spi));
-    uint_fast8_t cs_active_high = args[2];
-    spi->pin = gpio_out_setup(args[1], !cs_active_high);
-    spi->flags |= SF_HAVE_PIN | (cs_active_high ? SF_CS_ACTIVE_HIGH : 0);
-}
-DECL_COMMAND(command_config_spi, "config_spi oid=%c pin=%u cs_active_high=%c");
-
-void
-command_config_spi_without_cs(uint32_t *args)
-{
-    struct spidev_s *spi = oid_alloc(args[0], command_config_spi, sizeof(*spi));
-}
-DECL_COMMAND(command_config_spi_without_cs, "config_spi_without_cs oid=%c");
-
-struct spidev_s *
-spidev_oid_lookup(uint8_t oid)
-{
-    return oid_lookup(oid, command_config_spi);
-}
-
-void
-command_spi_set_bus(uint32_t *args)
-{
-    struct spidev_s *spi = spidev_oid_lookup(args[0]);
-    uint8_t mode = args[2];
-    if (mode > 3 || spi->flags & (SF_SOFTWARE|SF_HARDWARE))
-        shutdown("Invalid spi config");
-    spi->spi_config = spi_setup(args[1], mode, args[3]);
-    spi->flags |= SF_HARDWARE;
-}
-DECL_COMMAND(command_spi_set_bus,
-             "spi_set_bus oid=%c spi_bus=%u mode=%u rate=%u");
-
-void
-spidev_set_software_bus(struct spidev_s *spi, struct spi_software *ss)
-{
-    if (spi->flags & (SF_SOFTWARE|SF_HARDWARE))
-        shutdown("Invalid spi config");
-    spi->spi_software = ss;
-    spi->flags |= SF_SOFTWARE;
-}
-
-int
-spidev_have_cs_pin(struct spidev_s *spi)
-{
-    return spi->flags & SF_HAVE_PIN;
-}
-
-struct gpio_out
-spidev_get_cs_pin(struct spidev_s *spi)
-{
-    return spi->pin;
-}
-
-void
-spidev_transfer(struct spidev_s *spi, uint8_t receive_data
-                , uint8_t data_len, uint8_t *data)
-{
-    uint_fast8_t flags = spi->flags;
-    if (!(flags & (SF_SOFTWARE|SF_HARDWARE)))
-        // Not yet initialized
-        return;
-
-    if (CONFIG_HAVE_GPIO_BITBANGING && flags & SF_SOFTWARE)
-        spi_software_prepare(spi->spi_software);
-    else
-        spi_prepare(spi->spi_config);
-
-    if (flags & SF_HAVE_PIN)
-        gpio_out_write(spi->pin, !!(flags & SF_CS_ACTIVE_HIGH));
-
-    if (CONFIG_HAVE_GPIO_BITBANGING && flags & SF_SOFTWARE)
-        spi_software_transfer(spi->spi_software, receive_data, data_len, data);
-    else
-        spi_transfer(spi->spi_config, receive_data, data_len, data);
-
-    if (flags & SF_HAVE_PIN)
-        gpio_out_write(spi->pin, !(flags & SF_CS_ACTIVE_HIGH));
-}
-
-void
-command_spi_transfer(uint32_t *args)
-{
-    uint8_t oid = args[0];
-    struct spidev_s *spi = spidev_oid_lookup(oid);
-    uint8_t data_len = args[1];
-    uint8_t *data = command_decode_ptr(args[2]);
-    spidev_transfer(spi, 1, data_len, data);
-    sendf("spi_transfer_response oid=%c response=%*s", oid, data_len, data);
-}
-DECL_COMMAND(command_spi_transfer, "spi_transfer oid=%c data=%*s");
-
-void
-command_spi_send(uint32_t *args)
-{
-    struct spidev_s *spi = spidev_oid_lookup(args[0]);
-    uint8_t data_len = args[1];
-    uint8_t *data = command_decode_ptr(args[2]);
-    spidev_transfer(spi, 0, data_len, data);
-}
-DECL_COMMAND(command_spi_send, "spi_send oid=%c data=%*s");
-
-
-/****************************************************************
- * Shutdown handling
- ****************************************************************/
-
-struct spidev_shutdown_s {
-    struct spidev_s *spi;
-    uint8_t shutdown_msg_len;
-    uint8_t shutdown_msg[];
-};
-
-void
-command_config_spi_shutdown(uint32_t *args)
-{
-    struct spidev_s *spi = spidev_oid_lookup(args[1]);
-    uint8_t shutdown_msg_len = args[2];
-    struct spidev_shutdown_s *sd = oid_alloc(
-        args[0], command_config_spi_shutdown, sizeof(*sd) + shutdown_msg_len);
-    sd->spi = spi;
-    sd->shutdown_msg_len = shutdown_msg_len;
-    uint8_t *shutdown_msg = command_decode_ptr(args[3]);
-    memcpy(sd->shutdown_msg, shutdown_msg, shutdown_msg_len);
-}
-DECL_COMMAND(command_config_spi_shutdown,
-             "config_spi_shutdown oid=%c spi_oid=%c shutdown_msg=%*s");
-
-void
-spidev_shutdown(void)
-{
-    // Cancel any transmissions that may be in progress
-    uint8_t oid;
-    struct spidev_s *spi;
-    foreach_oid(oid, spi, command_config_spi) {
-        if (spi->flags & SF_HAVE_PIN)
-            gpio_out_write(spi->pin, !(spi->flags & SF_CS_ACTIVE_HIGH));
-    }
-
-    // Send shutdown messages
-    struct spidev_shutdown_s *sd;
-    foreach_oid(oid, sd, command_config_spi_shutdown) {
-        spidev_transfer(sd->spi, 0, sd->shutdown_msg_len, sd->shutdown_msg);
-    }
-}
-DECL_SHUTDOWN(spidev_shutdown);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/spicmds.h crealityShit/src/spicmds.h
--- klipperStock/src/spicmds.h	2024-01-14 23:02:00.169796942 -0600
+++ crealityShit/src/spicmds.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,14 +0,0 @@
-#ifndef __SPICMDS_H
-#define __SPICMDS_H
-
-#include <stdint.h> // uint8_t
-
-struct spidev_s *spidev_oid_lookup(uint8_t oid);
-struct spi_software;
-void spidev_set_software_bus(struct spidev_s *spi, struct spi_software *ss);
-int spidev_have_cs_pin(struct spidev_s *spi);
-struct gpio_out spidev_get_cs_pin(struct spidev_s *spi);
-void spidev_transfer(struct spidev_s *spi, uint8_t receive_data
-                     , uint8_t data_len, uint8_t *data);
-
-#endif // spicmds.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/spi_software.c crealityShit/src/spi_software.c
--- klipperStock/src/spi_software.c	2024-01-14 23:02:00.149796696 -0600
+++ crealityShit/src/spi_software.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,75 +0,0 @@
-// Software SPI emulation
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/gpio.h" // gpio_out_setup
-#include "basecmd.h" // oid_alloc
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // sched_shutdown
-#include "spicmds.h" // spidev_set_software_bus
-
-struct spi_software {
-    struct gpio_in miso;
-    struct gpio_out mosi, sclk;
-    uint8_t mode;
-};
-
-void
-command_spi_set_software_bus(uint32_t *args)
-{
-    uint8_t mode = args[4];
-    if (mode > 3)
-        shutdown("Invalid spi config");
-
-    struct spidev_s *spi = spidev_oid_lookup(args[0]);
-    struct spi_software *ss = alloc_chunk(sizeof(*ss));
-    ss->miso = gpio_in_setup(args[1], 1);
-    ss->mosi = gpio_out_setup(args[2], 0);
-    ss->sclk = gpio_out_setup(args[3], 0);
-    ss->mode = mode;
-    spidev_set_software_bus(spi, ss);
-}
-DECL_COMMAND(command_spi_set_software_bus,
-             "spi_set_software_bus oid=%c miso_pin=%u mosi_pin=%u sclk_pin=%u"
-             " mode=%u rate=%u");
-
-void
-spi_software_prepare(struct spi_software *ss)
-{
-    gpio_out_write(ss->sclk, ss->mode & 0x02);
-}
-
-void
-spi_software_transfer(struct spi_software *ss, uint8_t receive_data
-                      , uint8_t len, uint8_t *data)
-{
-    while (len--) {
-        uint8_t outbuf = *data;
-        uint8_t inbuf = 0;
-        for (uint_fast8_t i = 0; i < 8; i++) {
-            if (ss->mode & 0x01) {
-                // MODE 1 & 3
-                gpio_out_toggle(ss->sclk);
-                gpio_out_write(ss->mosi, outbuf & 0x80);
-                outbuf <<= 1;
-                gpio_out_toggle(ss->sclk);
-                inbuf <<= 1;
-                inbuf |= gpio_in_read(ss->miso);
-            } else {
-                // MODE 0 & 2
-                gpio_out_write(ss->mosi, outbuf & 0x80);
-                outbuf <<= 1;
-                gpio_out_toggle(ss->sclk);
-                inbuf <<= 1;
-                inbuf |= gpio_in_read(ss->miso);
-                gpio_out_toggle(ss->sclk);
-            }
-        }
-
-        if (receive_data)
-            *data = inbuf;
-        data++;
-    }
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/spi_software.h crealityShit/src/spi_software.h
--- klipperStock/src/spi_software.h	2024-01-14 23:02:00.137796549 -0600
+++ crealityShit/src/spi_software.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,11 +0,0 @@
-#ifndef __SPI_SOFTWARE_H
-#define __SPI_SOFTWARE_H
-
-#include <stdint.h> // uint8_t
-
-struct spi_software *spi_software_oid_lookup(uint8_t oid);
-void spi_software_prepare(struct spi_software *ss);
-void spi_software_transfer(struct spi_software *ss, uint8_t receive_data
-                           , uint8_t len, uint8_t *data);
-
-#endif // spi_software.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stepper.c crealityShit/src/stepper.c
--- klipperStock/src/stepper.c	2024-01-14 23:02:00.141796598 -0600
+++ crealityShit/src/stepper.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,351 +0,0 @@
-// Handling of stepper drivers.
-//
-// Copyright (C) 2016-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_*
-#include "basecmd.h" // oid_alloc
-#include "board/gpio.h" // gpio_out_write
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_is_before
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // struct timer
-#include "stepper.h" // stepper_event
-#include "trsync.h" // trsync_add_signal
-
-#if CONFIG_INLINE_STEPPER_HACK && CONFIG_HAVE_STEPPER_BOTH_EDGE
- #define HAVE_SINGLE_SCHEDULE 1
- #define HAVE_EDGE_OPTIMIZATION 1
- #define HAVE_AVR_OPTIMIZATION 0
- DECL_CONSTANT("STEPPER_BOTH_EDGE", 1);
-#elif CONFIG_INLINE_STEPPER_HACK && CONFIG_MACH_AVR
- #define HAVE_SINGLE_SCHEDULE 1
- #define HAVE_EDGE_OPTIMIZATION 0
- #define HAVE_AVR_OPTIMIZATION 1
-#else
- #define HAVE_SINGLE_SCHEDULE 0
- #define HAVE_EDGE_OPTIMIZATION 0
- #define HAVE_AVR_OPTIMIZATION 0
-#endif
-
-struct stepper_move {
-    struct move_node node;
-    uint32_t interval;
-    int16_t add;
-    uint16_t count;
-    uint8_t flags;
-};
-
-enum { MF_DIR=1<<0 };
-
-struct stepper {
-    struct timer time;
-    uint32_t interval;
-    int16_t add;
-    uint32_t count;
-    uint32_t next_step_time, step_pulse_ticks;
-    struct gpio_out step_pin, dir_pin;
-    uint32_t position;
-    struct move_queue_head mq;
-    struct trsync_signal stop_signal;
-    // gcc (pre v6) does better optimization when uint8_t are bitfields
-    uint8_t flags : 8;
-};
-
-enum { POSITION_BIAS=0x40000000 };
-
-enum {
-    SF_LAST_DIR=1<<0, SF_NEXT_DIR=1<<1, SF_INVERT_STEP=1<<2, SF_NEED_RESET=1<<3,
-    SF_SINGLE_SCHED=1<<4, SF_HAVE_ADD=1<<5
-};
-
-// Setup a stepper for the next move in its queue
-static uint_fast8_t
-stepper_load_next(struct stepper *s)
-{
-    if (move_queue_empty(&s->mq)) {
-        // There is no next move - the queue is empty
-        s->count = 0;
-        return SF_DONE;
-    }
-
-    // Load next 'struct stepper_move' into 'struct stepper'
-    struct move_node *mn = move_queue_pop(&s->mq);
-    struct stepper_move *m = container_of(mn, struct stepper_move, node);
-    s->add = m->add;
-    s->interval = m->interval + m->add;
-    if (HAVE_SINGLE_SCHEDULE && s->flags & SF_SINGLE_SCHED) {
-        s->time.waketime += m->interval;
-        if (HAVE_AVR_OPTIMIZATION)
-            s->flags = m->add ? s->flags|SF_HAVE_ADD : s->flags & ~SF_HAVE_ADD;
-        s->count = m->count;
-    } else {
-        // It is necessary to schedule unstep events and so there are
-        // twice as many events.
-        s->next_step_time += m->interval;
-        s->time.waketime = s->next_step_time;
-        s->count = (uint32_t)m->count * 2;
-    }
-    // Add all steps to s->position (stepper_get_position() can calc mid-move)
-    if (m->flags & MF_DIR) {
-        s->position = -s->position + m->count;
-        gpio_out_toggle_noirq(s->dir_pin);
-    } else {
-        s->position += m->count;
-    }
-
-    move_free(m);
-    return SF_RESCHEDULE;
-}
-
-// Optimized step function to step on each step pin edge
-uint_fast8_t
-stepper_event_edge(struct timer *t)
-{
-    struct stepper *s = container_of(t, struct stepper, time);
-    gpio_out_toggle_noirq(s->step_pin);
-    uint32_t count = s->count - 1;
-    if (likely(count)) {
-        s->count = count;
-        s->time.waketime += s->interval;
-        s->interval += s->add;
-        return SF_RESCHEDULE;
-    }
-    return stepper_load_next(s);
-}
-
-#define AVR_STEP_INSNS 40 // minimum instructions between step gpio pulses
-
-// AVR optimized step function
-static uint_fast8_t
-stepper_event_avr(struct timer *t)
-{
-    struct stepper *s = container_of(t, struct stepper, time);
-    gpio_out_toggle_noirq(s->step_pin);
-    uint16_t *pcount = (void*)&s->count, count = *pcount - 1;
-    if (likely(count)) {
-        *pcount = count;
-        s->time.waketime += s->interval;
-        gpio_out_toggle_noirq(s->step_pin);
-        if (s->flags & SF_HAVE_ADD)
-            s->interval += s->add;
-        return SF_RESCHEDULE;
-    }
-    uint_fast8_t ret = stepper_load_next(s);
-    gpio_out_toggle_noirq(s->step_pin);
-    return ret;
-}
-
-// Regular "double scheduled" step function
-uint_fast8_t
-stepper_event_full(struct timer *t)
-{
-    struct stepper *s = container_of(t, struct stepper, time);
-    gpio_out_toggle_noirq(s->step_pin);
-    uint32_t curtime = timer_read_time();
-    uint32_t min_next_time = curtime + s->step_pulse_ticks;
-    s->count--;
-    if (likely(s->count & 1))
-        // Schedule unstep event
-        goto reschedule_min;
-    if (likely(s->count)) {
-        s->next_step_time += s->interval;
-        s->interval += s->add;
-        if (unlikely(timer_is_before(s->next_step_time, min_next_time)))
-            // The next step event is too close - push it back
-            goto reschedule_min;
-        s->time.waketime = s->next_step_time;
-        return SF_RESCHEDULE;
-    }
-    uint_fast8_t ret = stepper_load_next(s);
-    if (ret == SF_DONE || !timer_is_before(s->time.waketime, min_next_time))
-        return ret;
-    // Next step event is too close to the last unstep
-    int32_t diff = s->time.waketime - min_next_time;
-    if (diff < (int32_t)-timer_from_us(1000))
-        shutdown("Stepper too far in past");
-reschedule_min:
-    s->time.waketime = min_next_time;
-    return SF_RESCHEDULE;
-}
-
-// Optimized entry point for step function (may be inlined into sched.c code)
-uint_fast8_t
-stepper_event(struct timer *t)
-{
-    if (HAVE_EDGE_OPTIMIZATION)
-        return stepper_event_edge(t);
-    if (HAVE_AVR_OPTIMIZATION)
-        return stepper_event_avr(t);
-    return stepper_event_full(t);
-}
-
-void
-command_config_stepper(uint32_t *args)
-{
-    struct stepper *s = oid_alloc(args[0], command_config_stepper, sizeof(*s));
-    int_fast8_t invert_step = args[3];
-    s->flags = invert_step > 0 ? SF_INVERT_STEP : 0;
-    s->step_pin = gpio_out_setup(args[1], s->flags & SF_INVERT_STEP);
-    s->dir_pin = gpio_out_setup(args[2], 0);
-    s->position = -POSITION_BIAS;
-    s->step_pulse_ticks = args[4];
-    move_queue_setup(&s->mq, sizeof(struct stepper_move));
-    if (HAVE_EDGE_OPTIMIZATION) {
-        if (!s->step_pulse_ticks && invert_step < 0)
-            s->flags |= SF_SINGLE_SCHED;
-        else
-            s->time.func = stepper_event_full;
-    } else if (HAVE_AVR_OPTIMIZATION) {
-        if (s->step_pulse_ticks <= AVR_STEP_INSNS)
-            s->flags |= SF_SINGLE_SCHED;
-        else
-            s->time.func = stepper_event_full;
-    } else if (!CONFIG_INLINE_STEPPER_HACK) {
-        s->time.func = stepper_event_full;
-    }
-}
-DECL_COMMAND(command_config_stepper, "config_stepper oid=%c step_pin=%c"
-             " dir_pin=%c invert_step=%c step_pulse_ticks=%u");
-
-// Return the 'struct stepper' for a given stepper oid
-static struct stepper *
-stepper_oid_lookup(uint8_t oid)
-{
-    return oid_lookup(oid, command_config_stepper);
-}
-
-// Schedule a set of steps with a given timing
-void
-command_queue_step(uint32_t *args)
-{
-    struct stepper *s = stepper_oid_lookup(args[0]);
-    struct stepper_move *m = move_alloc();
-    m->interval = args[1];
-    m->count = args[2];
-    if (!m->count)
-        shutdown("Invalid count parameter");
-    m->add = args[3];
-    m->flags = 0;
-
-    irq_disable();
-    uint8_t flags = s->flags;
-    if (!!(flags & SF_LAST_DIR) != !!(flags & SF_NEXT_DIR)) {
-        flags ^= SF_LAST_DIR;
-        m->flags |= MF_DIR;
-    }
-    if (s->count) {
-        s->flags = flags;
-        move_queue_push(&m->node, &s->mq);
-    } else if (flags & SF_NEED_RESET) {
-        move_free(m);
-    } else {
-        s->flags = flags;
-        move_queue_push(&m->node, &s->mq);
-        stepper_load_next(s);
-        sched_add_timer(&s->time);
-    }
-    irq_enable();
-}
-DECL_COMMAND(command_queue_step,
-             "queue_step oid=%c interval=%u count=%hu add=%hi");
-
-// Set the direction of the next queued step
-void
-command_set_next_step_dir(uint32_t *args)
-{
-    struct stepper *s = stepper_oid_lookup(args[0]);
-    uint8_t nextdir = args[1] ? SF_NEXT_DIR : 0;
-    irq_disable();
-    s->flags = (s->flags & ~SF_NEXT_DIR) | nextdir;
-    irq_enable();
-}
-DECL_COMMAND(command_set_next_step_dir, "set_next_step_dir oid=%c dir=%c");
-
-// Set an absolute time that the next step will be relative to
-void
-command_reset_step_clock(uint32_t *args)
-{
-    struct stepper *s = stepper_oid_lookup(args[0]);
-    uint32_t waketime = args[1];
-    irq_disable();
-    if (s->count)
-        shutdown("Can't reset time when stepper active");
-    s->next_step_time = s->time.waketime = waketime;
-    s->flags &= ~SF_NEED_RESET;
-    irq_enable();
-}
-DECL_COMMAND(command_reset_step_clock, "reset_step_clock oid=%c clock=%u");
-
-// Return the current stepper position.  Caller must disable irqs.
-static uint32_t
-stepper_get_position(struct stepper *s)
-{
-    uint32_t position = s->position;
-    // If stepper is mid-move, subtract out steps not yet taken
-    if (HAVE_SINGLE_SCHEDULE && s->flags & SF_SINGLE_SCHED)
-        position -= s->count;
-    else
-        position -= s->count / 2;
-    // The top bit of s->position is an optimized reverse direction flag
-    if (position & 0x80000000)
-        return -position;
-    return position;
-}
-
-// Report the current position of the stepper
-void
-command_stepper_get_position(uint32_t *args)
-{
-    uint8_t oid = args[0];
-    struct stepper *s = stepper_oid_lookup(oid);
-    irq_disable();
-    uint32_t position = stepper_get_position(s);
-    irq_enable();
-    sendf("stepper_position oid=%c pos=%i", oid, position - POSITION_BIAS);
-}
-DECL_COMMAND(command_stepper_get_position, "stepper_get_position oid=%c");
-
-// Stop all moves for a given stepper (caller must disable IRQs)
-static void
-stepper_stop(struct trsync_signal *tss, uint8_t reason)
-{
-    struct stepper *s = container_of(tss, struct stepper, stop_signal);
-    sched_del_timer(&s->time);
-    s->next_step_time = s->time.waketime = 0;
-    s->position = -stepper_get_position(s);
-    s->count = 0;
-    s->flags = (s->flags & (SF_INVERT_STEP|SF_SINGLE_SCHED)) | SF_NEED_RESET;
-    gpio_out_write(s->dir_pin, 0);
-    if (!(HAVE_EDGE_OPTIMIZATION && s->flags & SF_SINGLE_SCHED))
-        gpio_out_write(s->step_pin, s->flags & SF_INVERT_STEP);
-    while (!move_queue_empty(&s->mq)) {
-        struct move_node *mn = move_queue_pop(&s->mq);
-        struct stepper_move *m = container_of(mn, struct stepper_move, node);
-        move_free(m);
-    }
-}
-
-// Set the stepper to stop on a "trigger event" (used in homing)
-void
-command_stepper_stop_on_trigger(uint32_t *args)
-{
-    struct stepper *s = stepper_oid_lookup(args[0]);
-    struct trsync *ts = trsync_oid_lookup(args[1]);
-    trsync_add_signal(ts, &s->stop_signal, stepper_stop);
-}
-DECL_COMMAND(command_stepper_stop_on_trigger,
-             "stepper_stop_on_trigger oid=%c trsync_oid=%c");
-
-void
-stepper_shutdown(void)
-{
-    uint8_t i;
-    struct stepper *s;
-    foreach_oid(i, s, command_config_stepper) {
-        move_queue_clear(&s->mq);
-        stepper_stop(&s->stop_signal, 0);
-    }
-}
-DECL_SHUTDOWN(stepper_shutdown);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stepper.h crealityShit/src/stepper.h
--- klipperStock/src/stepper.h	2024-01-14 23:02:00.117796304 -0600
+++ crealityShit/src/stepper.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,8 +0,0 @@
-#ifndef __STEPPER_H
-#define __STEPPER_H
-
-#include <stdint.h> // uint8_t
-
-uint_fast8_t stepper_event(struct timer *t);
-
-#endif // stepper.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/adc.c crealityShit/src/stm32/adc.c
--- klipperStock/src/stm32/adc.c	2024-01-14 23:02:00.109796205 -0600
+++ crealityShit/src/stm32/adc.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,164 +0,0 @@
-// ADC functions on STM32
-//
-// Copyright (C) 2019-2020  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/irq.h" // irq_save
-#include "board/misc.h" // timer_from_us
-#include "command.h" // shutdown
-#include "compiler.h" // ARRAY_SIZE
-#include "generic/armcm_timer.h" // udelay
-#include "gpio.h" // gpio_adc_setup
-#include "internal.h" // GPIO
-#include "sched.h" // sched_shutdown
-
-DECL_CONSTANT("ADC_MAX", 4095);
-
-#define ADC_TEMPERATURE_PIN 0xfe
-DECL_ENUMERATION("pin", "ADC_TEMPERATURE", ADC_TEMPERATURE_PIN);
-
-static const uint8_t adc_pins[] = {
-    GPIO('A', 0), GPIO('A', 1), GPIO('A', 2), GPIO('A', 3),
-    GPIO('A', 4), GPIO('A', 5), GPIO('A', 6), GPIO('A', 7),
-    GPIO('B', 0), GPIO('B', 1), GPIO('C', 0), GPIO('C', 1),
-    GPIO('C', 2), GPIO('C', 3), GPIO('C', 4), GPIO('C', 5),
-
-#if CONFIG_MACH_STM32F1
-    ADC_TEMPERATURE_PIN,
-#elif CONFIG_MACH_STM32F2 || CONFIG_MACH_STM32F4x5
-    ADC_TEMPERATURE_PIN, 0x00, 0x00,
-#elif CONFIG_MACH_STM32F401 || CONFIG_MACH_STM32F446
-    0x00, 0x00, ADC_TEMPERATURE_PIN,
-#endif
-
-#if CONFIG_MACH_STM32F4x5 || CONFIG_MACH_STM32F446
-    0x00, 0x00, 0x00, 0x00,
-    GPIO('F', 6), GPIO('F', 7), GPIO('F', 8), GPIO('F', 9),
-    GPIO('F', 10), GPIO('F', 3), 0x00, 0x00,
-    0x00, 0x00, GPIO('F', 4), GPIO('F', 5),
-#endif
-};
-
-#if CONFIG_MACH_STM32F1
-#define CR2_FLAGS (ADC_CR2_ADON | (7 << ADC_CR2_EXTSEL_Pos) | ADC_CR2_EXTTRIG \
-                   | ADC_CR2_TSVREFE)
-#else
-#define CR2_FLAGS ADC_CR2_ADON
-#endif
-
-// ADC timing:
-// stm32f103: ADC clock=4.5Mhz, Tconv=12.5, Tsamp=41.5, total=12.000us
-// stm32f407: ADC clock=21Mhz, Tconv=12, Tsamp=84, total=4.571us
-// stm32f446: ADC clock=22.5Mhz, Tconv=12, Tsamp=84, total=4.267us
-
-// Perform calibration on stm32f103
-static void
-adc_calibrate(ADC_TypeDef *adc)
-{
-#if CONFIG_MACH_STM32F1
-    adc->CR2 = ADC_CR2_ADON;
-    udelay(10);
-    adc->CR2 = ADC_CR2_ADON | ADC_CR2_RSTCAL;
-    while (adc->CR2 & ADC_CR2_RSTCAL)
-        ;
-    adc->CR2 = ADC_CR2_ADON | ADC_CR2_CAL;
-    while (adc->CR2 & ADC_CR2_CAL)
-        ;
-#endif
-}
-
-struct gpio_adc
-gpio_adc_setup(uint32_t pin)
-{
-    // Find pin in adc_pins table
-    int chan;
-    for (chan=0; ; chan++) {
-        if (chan >= ARRAY_SIZE(adc_pins))
-            shutdown("Not a valid ADC pin");
-        if (adc_pins[chan] == pin)
-            break;
-    }
-
-    // Determine which ADC block to use
-    ADC_TypeDef *adc = ADC1;
-    uint32_t adc_base = ADC1_BASE;
-#if CONFIG_MACH_STM32F4x5 || CONFIG_MACH_STM32F446
-    if (chan >= 19) {
-        // On the STM32F4, some ADC channels are only available from ADC3
-        adc = ADC3;
-        adc_base += 0x800;
-        chan -= 19;
-    }
-#endif
-
-    // Enable the ADC
-    if (!is_enabled_pclock(adc_base)) {
-        enable_pclock(adc_base);
-        adc_calibrate(adc);
-        uint32_t aticks = 4; // 4-12us sample time (depending on stm32 chip)
-        adc->SMPR1 = (aticks | (aticks << 3) | (aticks << 6) | (aticks << 9)
-                      | (aticks << 12) | (aticks << 15) | (aticks << 18)
-                      | (aticks << 21)
-                      | (CONFIG_MACH_STM32F4 ? aticks << 24 : 0));
-        adc->SMPR2 = (aticks | (aticks << 3) | (aticks << 6) | (aticks << 9)
-                      | (aticks << 12) | (aticks << 15) | (aticks << 18)
-                      | (aticks << 21) | (aticks << 24) | (aticks << 27));
-        adc->CR2 = CR2_FLAGS;
-    }
-
-    if (pin == ADC_TEMPERATURE_PIN) {
-#if CONFIG_MACH_STM32F401
-        ADC1_COMMON->CCR = ADC_CCR_TSVREFE;
-#elif !CONFIG_MACH_STM32F1
-        ADC123_COMMON->CCR = ADC_CCR_TSVREFE;
-#endif
-    } else {
-        gpio_peripheral(pin, GPIO_ANALOG, 0);
-    }
-
-    return (struct gpio_adc){ .adc = adc, .chan = chan };
-}
-
-// Try to sample a value. Returns zero if sample ready, otherwise
-// returns the number of clock ticks the caller should wait before
-// retrying this function.
-uint32_t
-gpio_adc_sample(struct gpio_adc g)
-{
-    ADC_TypeDef *adc = g.adc;
-    uint32_t sr = adc->SR;
-    if (sr & ADC_SR_STRT) {
-        if (!(sr & ADC_SR_EOC) || adc->SQR3 != g.chan)
-            // Conversion still in progress or busy on another channel
-            goto need_delay;
-        // Conversion ready
-        return 0;
-    }
-    // Start sample
-    adc->SQR3 = g.chan;
-    adc->CR2 = ADC_CR2_SWSTART | CR2_FLAGS;
-
-need_delay:
-    return timer_from_us(20);
-}
-
-// Read a value; use only after gpio_adc_sample() returns zero
-uint16_t
-gpio_adc_read(struct gpio_adc g)
-{
-    ADC_TypeDef *adc = g.adc;
-    adc->SR = ~ADC_SR_STRT;
-    return adc->DR;
-}
-
-// Cancel a sample that may have been started with gpio_adc_sample()
-void
-gpio_adc_cancel_sample(struct gpio_adc g)
-{
-    ADC_TypeDef *adc = g.adc;
-    irqstatus_t flag = irq_save();
-    if (adc->SR & ADC_SR_STRT && adc->SQR3 == g.chan)
-        gpio_adc_read(g);
-    irq_restore(flag);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/can.c crealityShit/src/stm32/can.c
--- klipperStock/src/stm32/can.c	2024-01-14 23:02:00.101796106 -0600
+++ crealityShit/src/stm32/can.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,281 +0,0 @@
-// Serial over CAN emulation for STM32 boards.
-//
-// Copyright (C) 2019 Eug Krashtan <eug.krashtan@gmail.com>
-// Copyright (C) 2020 Pontus Borg <glpontus@gmail.com>
-// Copyright (C) 2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memcpy
-#include "autoconf.h" // CONFIG_MACH_STM32F1
-#include "board/irq.h" // irq_disable
-#include "command.h" // DECL_CONSTANT_STR
-#include "generic/armcm_boot.h" // armcm_enable_irq
-#include "generic/canbus.h" // canbus_notify_tx
-#include "generic/canserial.h" // CANBUS_ID_ADMIN
-#include "internal.h" // enable_pclock
-#include "sched.h" // DECL_INIT
-
-#if CONFIG_STM32_CANBUS_PA11_PA12 || CONFIG_STM32_CANBUS_PA11_PA12_REMAP
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PA11,PA12");
- #define GPIO_Rx GPIO('A', 11)
- #define GPIO_Tx GPIO('A', 12)
-#endif
-#if CONFIG_STM32_CANBUS_PB8_PB9
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PB8,PB9");
- #define GPIO_Rx GPIO('B', 8)
- #define GPIO_Tx GPIO('B', 9)
-#endif
-#if CONFIG_STM32_CANBUS_PI9_PH13
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PI9,PH13");
- #define GPIO_Rx GPIO('I', 9)
- #define GPIO_Tx GPIO('H', 13)
-#endif
-#if CONFIG_STM32_CANBUS_PB5_PB6
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PB5,PB6");
- #define GPIO_Rx GPIO('B', 5)
- #define GPIO_Tx GPIO('B', 6)
-#endif
-#if CONFIG_STM32_CANBUS_PB12_PB13
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PB12,PB13");
- #define GPIO_Rx GPIO('B', 12)
- #define GPIO_Tx GPIO('B', 13)
-#endif
-#if CONFIG_STM32_CANBUS_PD0_PD1
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PD0,PD1");
- #define GPIO_Rx GPIO('D', 0)
- #define GPIO_Tx GPIO('D', 1)
-#endif
-
-#if CONFIG_MACH_STM32F0
- #define SOC_CAN CAN
- #define CAN_RX0_IRQn  CEC_CAN_IRQn
- #define CAN_RX1_IRQn  CEC_CAN_IRQn
- #define CAN_TX_IRQn   CEC_CAN_IRQn
- #define CAN_SCE_IRQn  CEC_CAN_IRQn
- #define CAN_FUNCTION  GPIO_FUNCTION(4)  // Alternative function mapping number
-#endif
-
-#if CONFIG_MACH_STM32F1
- #define SOC_CAN CAN1
- #define CAN_RX0_IRQn  CAN1_RX0_IRQn
- #define CAN_RX1_IRQn  CAN1_RX1_IRQn
- #define CAN_TX_IRQn   CAN1_TX_IRQn
- #define CAN_SCE_IRQn  CAN1_SCE_IRQn
- #define CAN_FUNCTION  GPIO_FUNCTION(9)  // Alternative function mapping number
-#endif
-
-#if CONFIG_MACH_STM32F4
- #if (CONFIG_STM32_CANBUS_PA11_PA12 || CONFIG_STM32_CANBUS_PB8_PB9 \
-     || CONFIG_STM32_CANBUS_PD0_PD1 || CONFIG_STM32_CANBUS_PI9_PH13)
-  #define SOC_CAN CAN1
-  #define CAN_RX0_IRQn  CAN1_RX0_IRQn
-  #define CAN_RX1_IRQn  CAN1_RX1_IRQn
-  #define CAN_TX_IRQn   CAN1_TX_IRQn
-  #define CAN_SCE_IRQn  CAN1_SCE_IRQn
- #elif CONFIG_STM32_CANBUS_PB5_PB6 || CONFIG_STM32_CANBUS_PB12_PB13
-  #define SOC_CAN CAN2
-  #define CAN_RX0_IRQn  CAN2_RX0_IRQn
-  #define CAN_RX1_IRQn  CAN2_RX1_IRQn
-  #define CAN_TX_IRQn   CAN2_TX_IRQn
-  #define CAN_SCE_IRQn  CAN2_SCE_IRQn
- #else
-  #error Uknown pins for STMF32F4 CAN
- #endif
-
- #define CAN_FUNCTION  GPIO_FUNCTION(9) // Alternative function mapping number
-#endif
-
-#ifndef SOC_CAN
- #error No known CAN device for configured MCU
-#endif
-
-// Transmit a packet
-int
-canhw_send(struct canbus_msg *msg)
-{
-    uint32_t tsr = SOC_CAN->TSR;
-    if (!(tsr & (CAN_TSR_TME0|CAN_TSR_TME1|CAN_TSR_TME2))) {
-        // No space in transmit fifo - enable tx irq
-        irq_disable();
-        SOC_CAN->IER |= CAN_IER_TMEIE;
-        irq_enable();
-        return -1;
-    }
-    int mbox = 2;
-    if (tsr & CAN_TSR_TME0)
-        mbox = 0;
-    else if (tsr & CAN_TSR_TME1)
-        mbox = 1;
-    CAN_TxMailBox_TypeDef *mb = &SOC_CAN->sTxMailBox[mbox];
-
-    /* Set up the DLC */
-    mb->TDTR = (mb->TDTR & 0xFFFFFFF0) | (msg->dlc & 0x0F);
-
-    /* Set up the data field */
-    mb->TDLR = msg->data32[0];
-    mb->TDHR = msg->data32[1];
-
-    /* Request transmission */
-    uint32_t tir;
-    if (msg->id & CANMSG_ID_EFF)
-        tir = ((msg->id & 0x1fffffff) << CAN_TI0R_EXID_Pos) | CAN_TI0R_IDE;
-    else
-        tir = (msg->id & 0x7ff) << CAN_TI0R_STID_Pos;
-    tir |= msg->id & CANMSG_ID_RTR ? CAN_TI0R_RTR : 0;
-    mb->TIR = (msg->id << CAN_TI0R_STID_Pos) | CAN_TI0R_TXRQ;
-    return CANMSG_DATA_LEN(msg);
-}
-
-// Setup the receive packet filter
-void
-canhw_set_filter(uint32_t id)
-{
-    /* Select the start slave bank */
-    SOC_CAN->FMR |= CAN_FMR_FINIT;
-    /* Initialisation mode for the filter */
-    SOC_CAN->FA1R = 0;
-
-    if (CONFIG_CANBUS_FILTER) {
-        uint32_t mask = CAN_TI0R_STID | CAN_TI0R_IDE | CAN_TI0R_RTR;
-        SOC_CAN->sFilterRegister[0].FR1 = CANBUS_ID_ADMIN << CAN_RI0R_STID_Pos;
-        SOC_CAN->sFilterRegister[0].FR2 = mask;
-        SOC_CAN->sFilterRegister[1].FR1 = (id + 1) << CAN_RI0R_STID_Pos;
-        SOC_CAN->sFilterRegister[1].FR2 = mask;
-        SOC_CAN->sFilterRegister[2].FR1 = id << CAN_RI0R_STID_Pos;
-        SOC_CAN->sFilterRegister[2].FR2 = mask;
-    } else {
-        SOC_CAN->sFilterRegister[0].FR1 = 0;
-        SOC_CAN->sFilterRegister[0].FR2 = 0;
-        id = 0;
-    }
-
-    /* 32-bit scale for the filter */
-    SOC_CAN->FS1R = (1<<0) | (1<<1) | (1<<2);
-
-    /* Filter activation */
-    SOC_CAN->FA1R = (1<<0) | (id ? (1<<1) | (1<<2) : 0);
-    /* Leave the initialisation mode for the filter */
-    SOC_CAN->FMR &= ~CAN_FMR_FINIT;
-}
-
-// This function handles CAN global interrupts
-void
-CAN_IRQHandler(void)
-{
-    if (SOC_CAN->RF0R & CAN_RF0R_FMP0) {
-        // Read and ack data packet
-        CAN_FIFOMailBox_TypeDef *mb = &SOC_CAN->sFIFOMailBox[0];
-        uint32_t rir = mb->RIR;
-        struct canbus_msg msg;
-        if (rir & CAN_RI0R_IDE)
-            msg.id = ((rir >> CAN_RI0R_EXID_Pos) & 0x1fffffff) | CANMSG_ID_EFF;
-        else
-            msg.id = (rir >> CAN_RI0R_STID_Pos) & 0x7ff;
-        msg.id |= rir & CAN_RI0R_RTR ? CANMSG_ID_RTR : 0;
-        msg.dlc = mb->RDTR & CAN_RDT0R_DLC;
-        msg.data32[0] = mb->RDLR;
-        msg.data32[1] = mb->RDHR;
-        SOC_CAN->RF0R = CAN_RF0R_RFOM0;
-
-        // Process packet
-        canbus_process_data(&msg);
-    }
-    uint32_t ier = SOC_CAN->IER;
-    if (ier & CAN_IER_TMEIE
-        && SOC_CAN->TSR & (CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2)) {
-        // Tx
-        SOC_CAN->IER = ier & ~CAN_IER_TMEIE;
-        canbus_notify_tx();
-    }
-}
-
-static inline const uint32_t
-make_btr(uint32_t sjw,       // Sync jump width, ... hmm
-         uint32_t time_seg1, // time segment before sample point, 1 .. 16
-         uint32_t time_seg2, // time segment after sample point, 1 .. 8
-         uint32_t brp)       // Baud rate prescaler, 1 .. 1024
-{
-    return (((uint32_t)(sjw-1)) << CAN_BTR_SJW_Pos
-            | ((uint32_t)(time_seg1-1)) << CAN_BTR_TS1_Pos
-            | ((uint32_t)(time_seg2-1)) << CAN_BTR_TS2_Pos
-            | ((uint32_t)(brp - 1)) << CAN_BTR_BRP_Pos);
-}
-
-static inline const uint32_t
-compute_btr(uint32_t pclock, uint32_t bitrate)
-{
-    /*
-        Some equations:
-        Tpclock = 1 / pclock
-        Tq      = brp * Tpclock
-        Tbs1    = Tq * TS1
-        Tbs2    = Tq * TS2
-        NominalBitTime = Tq + Tbs1 + Tbs2
-        BaudRate = 1/NominalBitTime
-
-        Bit value sample point is after Tq+Tbs1. Ideal sample point
-        is at 87.5% of NominalBitTime
-
-        Use the lowest brp where ts1 and ts2 are in valid range
-     */
-
-    uint32_t bit_clocks = pclock / bitrate; // clock ticks per bit
-
-    uint32_t sjw = 2;
-    uint32_t qs;
-    // Find number of time quantas that gives us the exact wanted bit time
-    for (qs = 18; qs > 9; qs--) {
-        // check that bit_clocks / quantas is an integer
-        uint32_t brp_rem = bit_clocks % qs;
-        if (brp_rem == 0)
-            break;
-    }
-    uint32_t brp       = bit_clocks / qs;
-    uint32_t time_seg2 = qs / 8; // sample at ~87.5%
-    uint32_t time_seg1 = qs - (1 + time_seg2);
-
-    return make_btr(sjw, time_seg1, time_seg2, brp);
-}
-
-void
-can_init(void)
-{
-    enable_pclock((uint32_t)SOC_CAN);
-
-    gpio_peripheral(GPIO_Rx, CAN_FUNCTION, 1);
-    gpio_peripheral(GPIO_Tx, CAN_FUNCTION, 0);
-
-    uint32_t pclock = get_pclock_frequency((uint32_t)SOC_CAN);
-
-    uint32_t btr = compute_btr(pclock, CONFIG_CANBUS_FREQUENCY);
-
-    /*##-1- Configure the CAN #######################################*/
-
-    /* Request initialisation */
-    SOC_CAN->MCR = CAN_MCR_INRQ;
-    /* Wait the acknowledge */
-    while (!(SOC_CAN->MSR & CAN_MSR_INAK))
-        ;
-
-    SOC_CAN->BTR = btr;
-
-    // TXFP makes packets posted to the TX mboxes transmit in chronologcal order
-    // ABOM makes the hardware automatically leave bus-off state
-    SOC_CAN->MCR = CAN_MCR_TXFP | CAN_MCR_ABOM;
-    /* Wait the acknowledge */
-    while (SOC_CAN->MSR & CAN_MSR_INAK)
-        ;
-
-    /*##-2- Configure the CAN Filter #######################################*/
-    canhw_set_filter(0);
-
-    /*##-3- Configure Interrupts #################################*/
-    armcm_enable_irq(CAN_IRQHandler, CAN_RX0_IRQn, 0);
-    if (CAN_RX0_IRQn != CAN_RX1_IRQn)
-        armcm_enable_irq(CAN_IRQHandler, CAN_RX1_IRQn, 0);
-    if (CAN_RX0_IRQn != CAN_TX_IRQn)
-        armcm_enable_irq(CAN_IRQHandler, CAN_TX_IRQn, 0);
-    SOC_CAN->IER = CAN_IER_FMPIE0;
-}
-DECL_INIT(can_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/chipid.c crealityShit/src/stm32/chipid.c
--- klipperStock/src/stm32/chipid.c	2024-01-14 23:02:00.097796058 -0600
+++ crealityShit/src/stm32/chipid.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,35 +0,0 @@
-// Support for extracting the hardware chip id on stm32
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "generic/canserial.h" // canserial_set_uuid
-#include "generic/usb_cdc.h" // usb_fill_serial
-#include "generic/usbstd.h" // usb_string_descriptor
-#include "internal.h" // UID_BASE
-#include "sched.h" // DECL_INIT
-
-#define CHIP_UID_LEN 12
-
-static struct {
-    struct usb_string_descriptor desc;
-    uint16_t data[CHIP_UID_LEN * 2];
-} cdc_chipid;
-
-struct usb_string_descriptor *
-usbserial_get_serialid(void)
-{
-   return &cdc_chipid.desc;
-}
-
-void
-chipid_init(void)
-{
-    if (CONFIG_USB_SERIAL_NUMBER_CHIPID)
-        usb_fill_serial(&cdc_chipid.desc, ARRAY_SIZE(cdc_chipid.data)
-                        , (void*)UID_BASE);
-    if (CONFIG_CANBUS)
-        canserial_set_uuid((void*)UID_BASE, CHIP_UID_LEN);
-}
-DECL_INIT(chipid_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/clockline.c crealityShit/src/stm32/clockline.c
--- klipperStock/src/stm32/clockline.c	2024-01-14 23:02:00.101796106 -0600
+++ crealityShit/src/stm32/clockline.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,32 +0,0 @@
-// Code to enable clock lines on stm32
-//
-// Copyright (C) 2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/irq.h" // irq_save
-#include "internal.h" // struct cline
-
-// Enable a peripheral clock
-void
-enable_pclock(uint32_t periph_base)
-{
-    struct cline cl = lookup_clock_line(periph_base);
-    irqstatus_t flag = irq_save();
-    *cl.en |= cl.bit;
-    *cl.en; // Pause 2 cycles to ensure peripheral is enabled
-    if (cl.rst) {
-        // Reset peripheral
-        *cl.rst = cl.bit;
-        *cl.rst = 0;
-    }
-    irq_restore(flag);
-}
-
-// Check if a peripheral clock has been enabled
-int
-is_enabled_pclock(uint32_t periph_base)
-{
-    struct cline cl = lookup_clock_line(periph_base);
-    return *cl.en & cl.bit;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/dfu_reboot.c crealityShit/src/stm32/dfu_reboot.c
--- klipperStock/src/stm32/dfu_reboot.c	2024-01-14 23:02:00.097796058 -0600
+++ crealityShit/src/stm32/dfu_reboot.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,57 +0,0 @@
-// Reboot into stm32 ROM dfu bootloader
-//
-// Copyright (C) 2019-2022  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "internal.h" // NVIC_SystemReset
-#include "board/irq.h" // irq_disable
-
-// Many stm32 chips have a USB capable "DFU bootloader" in their ROM.
-// In order to invoke that bootloader it is necessary to reset the
-// chip and jump to a chip specific hardware address.
-//
-// To reset the chip, the dfu_reboot() code sets a flag in memory (at
-// an arbitrary position that is unlikely to be overwritten during a
-// chip reset), and resets the chip.  If dfu_reboot_check() sees that
-// flag on the next boot it will perform a code jump to the ROM
-// address.
-
-// Location of ram address to set internal flag
-#if CONFIG_MACH_STM32H7
-  #define USB_BOOT_FLAG_ADDR (0x24000000 + 0x8000) // Place flag in "AXI SRAM"
-#else
-  #define USB_BOOT_FLAG_ADDR (CONFIG_RAM_START + CONFIG_RAM_SIZE - 1024)
-#endif
-
-// Signature to set in memory to flag that a dfu reboot is requested
-#define USB_BOOT_FLAG 0x55534220424f4f54 // "USB BOOT"
-
-// Flag that bootloader is desired and reboot
-void
-dfu_reboot(void)
-{
-    if (!CONFIG_STM32_DFU_ROM_ADDRESS)
-        return;
-    irq_disable();
-    uint64_t *bflag = (void*)USB_BOOT_FLAG_ADDR;
-    *bflag = USB_BOOT_FLAG;
-#if CONFIG_MACH_STM32H7
-    SCB_CleanDCache_by_Addr((void*)bflag, sizeof(*bflag));
-#endif
-    NVIC_SystemReset();
-}
-
-// Check if rebooting into system DFU Bootloader
-void
-dfu_reboot_check(void)
-{
-    if (!CONFIG_STM32_DFU_ROM_ADDRESS)
-        return;
-    if (*(uint64_t*)USB_BOOT_FLAG_ADDR != USB_BOOT_FLAG)
-        return;
-    *(uint64_t*)USB_BOOT_FLAG_ADDR = 0;
-    uint32_t *sysbase = (uint32_t*)CONFIG_STM32_DFU_ROM_ADDRESS;
-    asm volatile("mov sp, %0\n bx %1"
-                 : : "r"(sysbase[0]), "r"(sysbase[1]));
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/fdcan.c crealityShit/src/stm32/fdcan.c
--- klipperStock/src/stm32/fdcan.c	2024-01-14 23:02:00.097796058 -0600
+++ crealityShit/src/stm32/fdcan.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,309 +0,0 @@
-// FDCAN support on stm32 chips
-//
-// Copyright (C) 2021-2022  Kevin O'Connor <kevin@koconnor.net>
-// Copyright (C) 2019 Eug Krashtan <eug.krashtan@gmail.com>
-// Copyright (C) 2020 Pontus Borg <glpontus@gmail.com>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "command.h" // DECL_CONSTANT_STR
-#include "generic/armcm_boot.h" // armcm_enable_irq
-#include "generic/canbus.h" // canbus_notify_tx
-#include "generic/canserial.h" // CANBUS_ID_ADMIN
-#include "internal.h" // enable_pclock
-#include "sched.h" // DECL_INIT
-
-
-/****************************************************************
- * Pin configuration
- ****************************************************************/
-
-#if CONFIG_STM32_CANBUS_PA11_PA12
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PA11,PA12");
- #define GPIO_Rx GPIO('A', 11)
- #define GPIO_Tx GPIO('A', 12)
-#elif CONFIG_STM32_CANBUS_PA11_PB9
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PA11,PB9");
- #define GPIO_Rx GPIO('A', 11)
- #define GPIO_Tx GPIO('B', 9)
-#elif CONFIG_STM32_CANBUS_PB8_PB9
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PB8,PB9");
- #define GPIO_Rx GPIO('B', 8)
- #define GPIO_Tx GPIO('B', 9)
-#elif CONFIG_STM32_CANBUS_PD0_PD1
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PD0,PD1");
- #define GPIO_Rx GPIO('D', 0)
- #define GPIO_Tx GPIO('D', 1)
-#elif CONFIG_STM32_CANBUS_PD12_PD13
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PD12,PD13");
- #define GPIO_Rx GPIO('D', 12)
- #define GPIO_Tx GPIO('D', 13)
-#elif CONFIG_STM32_CANBUS_PB0_PB1
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PB0,PB1");
- #define GPIO_Rx GPIO('B', 0)
- #define GPIO_Tx GPIO('B', 1)
-#elif CONFIG_STM32_CANBUS_PC2_PC3
- DECL_CONSTANT_STR("RESERVE_PINS_CAN", "PC2,PC3");
- #define GPIO_Rx GPIO('C', 2)
- #define GPIO_Tx GPIO('C', 3)
-#endif
-
-#if !(CONFIG_STM32_CANBUS_PB0_PB1 || CONFIG_STM32_CANBUS_PC2_PC3)
- #define SOC_CAN FDCAN1
- #define MSG_RAM (((struct fdcan_ram_layout*)SRAMCAN_BASE)->fdcan1)
-#else
- #define SOC_CAN FDCAN2
- #define MSG_RAM (((struct fdcan_ram_layout*)SRAMCAN_BASE)->fdcan2)
-#endif
-
-#if CONFIG_MACH_STM32G0
- #define CAN_IT0_IRQn  TIM16_FDCAN_IT0_IRQn
- #define CAN_FUNCTION  GPIO_FUNCTION(3) // Alternative function mapping number
-#elif CONFIG_MACH_STM32H7 || CONFIG_MACH_STM32G4
- #define CAN_IT0_IRQn  FDCAN1_IT0_IRQn
- #define CAN_FUNCTION  GPIO_FUNCTION(9) // Alternative function mapping number
-#endif
-
-
-/****************************************************************
- * Message ram layout
- ****************************************************************/
-
-struct fdcan_fifo {
-    uint32_t id_section;
-    uint32_t dlc_section;
-    uint32_t data[64 / 4];
-};
-
-#define FDCAN_XTD (1<<30)
-#define FDCAN_RTR (1<<29)
-
-struct fdcan_msg_ram {
-    uint32_t FLS[28]; // Filter list standard
-    uint32_t FLE[16]; // Filter list extended
-    struct fdcan_fifo RXF0[3];
-    struct fdcan_fifo RXF1[3];
-    uint32_t TEF[6]; // Tx event FIFO
-    struct fdcan_fifo TXFIFO[3];
-};
-
-struct fdcan_ram_layout {
-    struct fdcan_msg_ram fdcan1;
-    struct fdcan_msg_ram fdcan2;
-};
-
-
-/****************************************************************
- * CANbus code
- ****************************************************************/
-
-#define FDCAN_IE_TC        (FDCAN_IE_TCE | FDCAN_IE_TCFE | FDCAN_IE_TFEE)
-
-// Transmit a packet
-int
-canhw_send(struct canbus_msg *msg)
-{
-    uint32_t txfqs = SOC_CAN->TXFQS;
-    if (txfqs & FDCAN_TXFQS_TFQF)
-        // No space in transmit fifo - wait for irq
-        return -1;
-
-    uint32_t w_index = ((txfqs & FDCAN_TXFQS_TFQPI) >> FDCAN_TXFQS_TFQPI_Pos);
-    struct fdcan_fifo *txfifo = &MSG_RAM.TXFIFO[w_index];
-    uint32_t ids;
-    if (msg->id & CANMSG_ID_EFF)
-        ids = (msg->id & 0x1fffffff) | FDCAN_XTD;
-    else
-        ids = (msg->id & 0x7ff) << 18;
-    ids |= msg->id & CANMSG_ID_RTR ? FDCAN_RTR : 0;
-    txfifo->id_section = ids;
-    txfifo->dlc_section = (msg->dlc & 0x0f) << 16;
-    txfifo->data[0] = msg->data32[0];
-    txfifo->data[1] = msg->data32[1];
-    barrier();
-    SOC_CAN->TXBAR = ((uint32_t)1 << w_index);
-    return CANMSG_DATA_LEN(msg);
-}
-
-static void
-can_filter(uint32_t index, uint32_t id)
-{
-    MSG_RAM.FLS[index] = ((0x2 << 30) // Classic filter
-                          | (0x1 << 27) // Store in Rx FIFO 0 if filter matches
-                          | (id << 16)
-                          | 0x7FF); // mask all enabled
-}
-
-// Setup the receive packet filter
-void
-canhw_set_filter(uint32_t id)
-{
-    if (!CONFIG_CANBUS_FILTER)
-        return;
-    /* Request initialisation */
-    SOC_CAN->CCCR |= FDCAN_CCCR_INIT;
-    /* Wait the acknowledge */
-    while (!(SOC_CAN->CCCR & FDCAN_CCCR_INIT))
-        ;
-    /* Enable configuration change */
-    SOC_CAN->CCCR |= FDCAN_CCCR_CCE;
-
-    // Load filter
-    can_filter(0, CANBUS_ID_ADMIN);
-    can_filter(1, id);
-    can_filter(2, id + 1);
-
-#if CONFIG_MACH_STM32G0
-    SOC_CAN->RXGFC = ((id ? 3 : 1) << FDCAN_RXGFC_LSS_Pos
-                      | 0x02 << FDCAN_RXGFC_ANFS_Pos);
-#elif CONFIG_MACH_STM32H7 || CONFIG_MAC_STM32G4
-    uint32_t flssa = (uint32_t)MSG_RAM.FLS - SRAMCAN_BASE;
-    SOC_CAN->SIDFC = flssa | ((id ? 3 : 1) << FDCAN_SIDFC_LSS_Pos);
-    SOC_CAN->GFC = 0x02 << FDCAN_GFC_ANFS_Pos;
-#endif
-
-    /* Leave the initialisation mode for the filter */
-    barrier();
-    SOC_CAN->CCCR &= ~FDCAN_CCCR_CCE;
-    SOC_CAN->CCCR &= ~FDCAN_CCCR_INIT;
-}
-
-// This function handles CAN global interrupts
-void
-CAN_IRQHandler(void)
-{
-    uint32_t ir = SOC_CAN->IR;
-
-    if (ir & FDCAN_IE_RF0NE) {
-        SOC_CAN->IR = FDCAN_IE_RF0NE;
-
-        uint32_t rxf0s = SOC_CAN->RXF0S;
-        if (rxf0s & FDCAN_RXF0S_F0FL) {
-            // Read and ack data packet
-            uint32_t idx = (rxf0s & FDCAN_RXF0S_F0GI) >> FDCAN_RXF0S_F0GI_Pos;
-            struct fdcan_fifo *rxf0 = &MSG_RAM.RXF0[idx];
-            uint32_t ids = rxf0->id_section;
-            struct canbus_msg msg;
-            if (ids & FDCAN_XTD)
-                msg.id = (ids & 0x1fffffff) | CANMSG_ID_EFF;
-            else
-                msg.id = (ids >> 18) & 0x7ff;
-            msg.id |= ids & FDCAN_RTR ? CANMSG_ID_RTR : 0;
-            msg.dlc = (rxf0->dlc_section >> 16) & 0x0f;
-            msg.data32[0] = rxf0->data[0];
-            msg.data32[1] = rxf0->data[1];
-            barrier();
-            SOC_CAN->RXF0A = idx;
-
-            // Process packet
-            canbus_process_data(&msg);
-        }
-    }
-    if (ir & FDCAN_IE_TC) {
-        // Tx
-        SOC_CAN->IR = FDCAN_IE_TC;
-        canbus_notify_tx();
-    }
-}
-
-static inline const uint32_t
-make_btr(uint32_t sjw,       // Sync jump width, ... hmm
-         uint32_t time_seg1, // time segment before sample point, 1 .. 16
-         uint32_t time_seg2, // time segment after sample point, 1 .. 8
-         uint32_t brp)       // Baud rate prescaler, 1 .. 1024
-{
-    return (((uint32_t)(sjw-1)) << FDCAN_NBTP_NSJW_Pos
-            | ((uint32_t)(time_seg1-1)) << FDCAN_NBTP_NTSEG1_Pos
-            | ((uint32_t)(time_seg2-1)) << FDCAN_NBTP_NTSEG2_Pos
-            | ((uint32_t)(brp - 1)) << FDCAN_NBTP_NBRP_Pos);
-}
-
-static inline const uint32_t
-compute_btr(uint32_t pclock, uint32_t bitrate)
-{
-    /*
-        Some equations:
-        Tpclock = 1 / pclock
-        Tq      = brp * Tpclock
-        Tbs1    = Tq * TS1
-        Tbs2    = Tq * TS2
-        NominalBitTime = Tq + Tbs1 + Tbs2
-        BaudRate = 1/NominalBitTime
-        Bit value sample point is after Tq+Tbs1. Ideal sample point
-        is at 87.5% of NominalBitTime
-        Use the lowest brp where ts1 and ts2 are in valid range
-     */
-
-    uint32_t bit_clocks = pclock / bitrate; // clock ticks per bit
-
-    uint32_t sjw = 2;
-    uint32_t qs;
-    // Find number of time quantas that gives us the exact wanted bit time
-    for (qs = 18; qs > 9; qs--) {
-        // check that bit_clocks / quantas is an integer
-        uint32_t brp_rem = bit_clocks % qs;
-        if (brp_rem == 0)
-            break;
-    }
-    uint32_t brp       = bit_clocks / qs;
-    uint32_t time_seg2 = qs / 8; // sample at ~87.5%
-    uint32_t time_seg1 = qs - (1 + time_seg2);
-
-    return make_btr(sjw, time_seg1, time_seg2, brp);
-}
-
-void
-can_init(void)
-{
-    enable_pclock((uint32_t)SOC_CAN);
-
-    gpio_peripheral(GPIO_Rx, CAN_FUNCTION, 1);
-    gpio_peripheral(GPIO_Tx, CAN_FUNCTION, 0);
-
-    uint32_t pclock = get_pclock_frequency((uint32_t)SOC_CAN);
-
-    uint32_t btr = compute_btr(pclock, CONFIG_CANBUS_FREQUENCY);
-
-    /*##-1- Configure the CAN #######################################*/
-
-    /* Exit from sleep mode */
-    SOC_CAN->CCCR &= ~FDCAN_CCCR_CSR;
-    /* Wait the acknowledge */
-    while (SOC_CAN->CCCR & FDCAN_CCCR_CSA)
-        ;
-    /* Request initialisation */
-    SOC_CAN->CCCR |= FDCAN_CCCR_INIT;
-    /* Wait the acknowledge */
-    while (!(SOC_CAN->CCCR & FDCAN_CCCR_INIT))
-        ;
-    /* Enable configuration change */
-    SOC_CAN->CCCR |= FDCAN_CCCR_CCE;
-
-    /* Disable protocol exception handling */
-    SOC_CAN->CCCR |= FDCAN_CCCR_PXHD;
-
-    SOC_CAN->NBTP = btr;
-
-#if CONFIG_MACH_STM32H7 || CONFIG_MAC_STM32G4
-    /* Setup message RAM addresses */
-    uint32_t f0sa = (uint32_t)MSG_RAM.RXF0 - SRAMCAN_BASE;
-    SOC_CAN->RXF0C = f0sa | (ARRAY_SIZE(MSG_RAM.RXF0) << FDCAN_RXF0C_F0S_Pos);
-    SOC_CAN->RXESC = (7 << FDCAN_RXESC_F1DS_Pos) | (7 << FDCAN_RXESC_F0DS_Pos);
-    uint32_t tbsa = (uint32_t)MSG_RAM.TXFIFO - SRAMCAN_BASE;
-    SOC_CAN->TXBC = tbsa | (ARRAY_SIZE(MSG_RAM.TXFIFO) << FDCAN_TXBC_TFQS_Pos);
-    SOC_CAN->TXESC = 7 << FDCAN_TXESC_TBDS_Pos;
-#endif
-
-    /* Leave the initialisation mode */
-    SOC_CAN->CCCR &= ~FDCAN_CCCR_CCE;
-    SOC_CAN->CCCR &= ~FDCAN_CCCR_INIT;
-
-    /*##-2- Configure the CAN Filter #######################################*/
-    canhw_set_filter(0);
-
-    /*##-3- Configure Interrupts #################################*/
-    armcm_enable_irq(CAN_IRQHandler, CAN_IT0_IRQn, 1);
-    SOC_CAN->ILE = FDCAN_ILE_EINT0;
-    SOC_CAN->IE = FDCAN_IE_RF0NE | FDCAN_IE_TC;
-}
-DECL_INIT(can_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/gpio.c crealityShit/src/stm32/gpio.c
--- klipperStock/src/stm32/gpio.c	2024-01-14 23:02:00.105796157 -0600
+++ crealityShit/src/stm32/gpio.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,155 +0,0 @@
-// GPIO functions on stm32f4
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // ffs
-#include "board/irq.h" // irq_save
-#include "command.h" // DECL_ENUMERATION_RANGE
-#include "gpio.h" // gpio_out_setup
-#include "internal.h" // gpio_peripheral
-#include "sched.h" // sched_shutdown
-
-DECL_ENUMERATION_RANGE("pin", "PA0", GPIO('A', 0), 16);
-DECL_ENUMERATION_RANGE("pin", "PB0", GPIO('B', 0), 16);
-DECL_ENUMERATION_RANGE("pin", "PC0", GPIO('C', 0), 16);
-#ifdef GPIOD
-DECL_ENUMERATION_RANGE("pin", "PD0", GPIO('D', 0), 16);
-#endif
-#ifdef GPIOE
-DECL_ENUMERATION_RANGE("pin", "PE0", GPIO('E', 0), 16);
-#endif
-#ifdef GPIOF
-DECL_ENUMERATION_RANGE("pin", "PF0", GPIO('F', 0), 16);
-#endif
-#ifdef GPIOG
-DECL_ENUMERATION_RANGE("pin", "PG0", GPIO('G', 0), 16);
-#endif
-#ifdef GPIOH
-DECL_ENUMERATION_RANGE("pin", "PH0", GPIO('H', 0), 16);
-#endif
-#ifdef GPIOI
-DECL_ENUMERATION_RANGE("pin", "PI0", GPIO('I', 0), 16);
-#endif
-
-GPIO_TypeDef * const digital_regs[] = {
-    ['A' - 'A'] = GPIOA, GPIOB, GPIOC,
-#ifdef GPIOD
-    ['D' - 'A'] = GPIOD,
-#endif
-#ifdef GPIOE
-    ['E' - 'A'] = GPIOE,
-#endif
-#ifdef GPIOF
-    ['F' - 'A'] = GPIOF,
-#endif
-#ifdef GPIOG
-    ['G' - 'A'] = GPIOG,
-#endif
-#ifdef GPIOH
-    ['H' - 'A'] = GPIOH,
-#endif
-#ifdef GPIOI
-    ['I' - 'A'] = GPIOI,
-#endif
-};
-
-// Convert a register and bit location back to an integer pin identifier
-static int
-regs_to_pin(GPIO_TypeDef *regs, uint32_t bit)
-{
-    int i;
-    for (i=0; i<ARRAY_SIZE(digital_regs); i++)
-        if (digital_regs[i] == regs)
-            return GPIO('A' + i, ffs(bit)-1);
-    return 0;
-}
-
-// Verify that a gpio is a valid pin
-static int
-gpio_valid(uint32_t pin)
-{
-    uint32_t port = GPIO2PORT(pin);
-    return port < ARRAY_SIZE(digital_regs) && digital_regs[port];
-}
-
-struct gpio_out
-gpio_out_setup(uint32_t pin, uint32_t val)
-{
-    if (!gpio_valid(pin))
-        shutdown("Not an output pin");
-    GPIO_TypeDef *regs = digital_regs[GPIO2PORT(pin)];
-    gpio_clock_enable(regs);
-    struct gpio_out g = { .regs=regs, .bit=GPIO2BIT(pin) };
-    gpio_out_reset(g, val);
-    return g;
-}
-
-void
-gpio_out_reset(struct gpio_out g, uint32_t val)
-{
-    GPIO_TypeDef *regs = g.regs;
-    int pin = regs_to_pin(regs, g.bit);
-    irqstatus_t flag = irq_save();
-    if (val)
-        regs->BSRR = g.bit;
-    else
-        regs->BSRR = g.bit << 16;
-    gpio_peripheral(pin, GPIO_OUTPUT, 0);
-    irq_restore(flag);
-}
-
-void
-gpio_out_toggle_noirq(struct gpio_out g)
-{
-    GPIO_TypeDef *regs = g.regs;
-    regs->ODR ^= g.bit;
-}
-
-void
-gpio_out_toggle(struct gpio_out g)
-{
-    irqstatus_t flag = irq_save();
-    gpio_out_toggle_noirq(g);
-    irq_restore(flag);
-}
-
-void
-gpio_out_write(struct gpio_out g, uint32_t val)
-{
-    GPIO_TypeDef *regs = g.regs;
-    if (val)
-        regs->BSRR = g.bit;
-    else
-        regs->BSRR = g.bit << 16;
-}
-
-
-struct gpio_in
-gpio_in_setup(uint32_t pin, int32_t pull_up)
-{
-    if (!gpio_valid(pin))
-        shutdown("Not a valid input pin");
-    GPIO_TypeDef *regs = digital_regs[GPIO2PORT(pin)];
-    struct gpio_in g = { .regs=regs, .bit=GPIO2BIT(pin) };
-    gpio_in_reset(g, pull_up);
-    return g;
-}
-
-void
-gpio_in_reset(struct gpio_in g, int32_t pull_up)
-{
-    GPIO_TypeDef *regs = g.regs;
-    int pin = regs_to_pin(regs, g.bit);
-    irqstatus_t flag = irq_save();
-    gpio_peripheral(pin, GPIO_INPUT, pull_up);
-    irq_restore(flag);
-}
-
-uint8_t
-gpio_in_read(struct gpio_in g)
-{
-    GPIO_TypeDef *regs = g.regs;
-    return !!(regs->IDR & g.bit);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/gpio.h crealityShit/src/stm32/gpio.h
--- klipperStock/src/stm32/gpio.h	2024-01-14 23:02:00.101796106 -0600
+++ crealityShit/src/stm32/gpio.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,58 +0,0 @@
-#ifndef __STM32_GPIO_H
-#define __STM32_GPIO_H
-
-#include <stdint.h> // uint32_t
-
-struct gpio_out {
-    void *regs;
-    uint32_t bit;
-};
-struct gpio_out gpio_out_setup(uint32_t pin, uint32_t val);
-void gpio_out_reset(struct gpio_out g, uint32_t val);
-void gpio_out_toggle_noirq(struct gpio_out g);
-void gpio_out_toggle(struct gpio_out g);
-void gpio_out_write(struct gpio_out g, uint32_t val);
-
-struct gpio_in {
-    void *regs;
-    uint32_t bit;
-};
-struct gpio_in gpio_in_setup(uint32_t pin, int32_t pull_up);
-void gpio_in_reset(struct gpio_in g, int32_t pull_up);
-uint8_t gpio_in_read(struct gpio_in g);
-
-struct gpio_pwm {
-  void *reg;
-};
-struct gpio_pwm gpio_pwm_setup(uint8_t pin, uint32_t cycle_time, uint8_t val);
-void gpio_pwm_write(struct gpio_pwm g, uint32_t val);
-
-struct gpio_adc {
-    void *adc;
-    uint32_t chan;
-};
-struct gpio_adc gpio_adc_setup(uint32_t pin);
-uint32_t gpio_adc_sample(struct gpio_adc g);
-uint16_t gpio_adc_read(struct gpio_adc g);
-void gpio_adc_cancel_sample(struct gpio_adc g);
-
-struct spi_config {
-    void *spi;
-    uint32_t spi_cr1;
-};
-struct spi_config spi_setup(uint32_t bus, uint8_t mode, uint32_t rate);
-void spi_prepare(struct spi_config config);
-void spi_transfer(struct spi_config config, uint8_t receive_data
-                  , uint8_t len, uint8_t *data);
-
-struct i2c_config {
-    void *i2c;
-    uint8_t addr;
-};
-
-struct i2c_config i2c_setup(uint32_t bus, uint32_t rate, uint8_t addr);
-void i2c_write(struct i2c_config config, uint8_t write_len, uint8_t *write);
-void i2c_read(struct i2c_config config, uint8_t reg_len, uint8_t *reg
-              , uint8_t read_len, uint8_t *read);
-
-#endif // gpio.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/gpioperiph.c crealityShit/src/stm32/gpioperiph.c
--- klipperStock/src/stm32/gpioperiph.c	2024-01-14 23:02:00.105796157 -0600
+++ crealityShit/src/stm32/gpioperiph.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,38 +0,0 @@
-// Code to setup gpio on stm32 chip (except for stm32f1)
-//
-// Copyright (C) 2019-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "internal.h" // gpio_peripheral
-
-// Set the mode and extended function of a pin
-void
-gpio_peripheral(uint32_t gpio, uint32_t mode, int pullup)
-{
-    GPIO_TypeDef *regs = digital_regs[GPIO2PORT(gpio)];
-
-    // Enable GPIO clock
-    gpio_clock_enable(regs);
-
-    // Configure GPIO
-    uint32_t mode_bits = mode & 0xf, func = (mode >> 4) & 0xf, od = mode >> 8;
-    uint32_t pup = pullup ? (pullup > 0 ? 1 : 2) : 0;
-    uint32_t pos = gpio % 16, af_reg = pos / 8;
-    uint32_t af_shift = (pos % 8) * 4, af_msk = 0x0f << af_shift;
-    uint32_t m_shift = pos * 2, m_msk = 0x03 << m_shift;
-
-    regs->AFR[af_reg] = (regs->AFR[af_reg] & ~af_msk) | (func << af_shift);
-    regs->MODER = (regs->MODER & ~m_msk) | (mode_bits << m_shift);
-    regs->PUPDR = (regs->PUPDR & ~m_msk) | (pup << m_shift);
-    regs->OTYPER = (regs->OTYPER & ~(1 << pos)) | (od << pos);
-
-    // Setup OSPEEDR:
-    // stm32f0 is ~10Mhz at 50pF
-    // stm32f2 is ~25Mhz at 40pF
-    // stm32f4 is ~50Mhz at 40pF
-    // stm32g0 is ~30Mhz at 50pF
-    // stm32h7 is ~85Mhz at 50pF
-    uint32_t ospeed = CONFIG_MACH_STM32F0 ? 0x01 : 0x02;
-    regs->OSPEEDR = (regs->OSPEEDR & ~m_msk) | (ospeed << m_shift);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/hard_pwm.c crealityShit/src/stm32/hard_pwm.c
--- klipperStock/src/stm32/hard_pwm.c	2024-01-14 23:02:00.093796007 -0600
+++ crealityShit/src/stm32/hard_pwm.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,293 +0,0 @@
-// Hardware PWM support on stm32
-//
-// Copyright (C) 2021  Michael Kurz <michi.kurz@gmail.com>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_MACH_STM32H7
-#include "board/irq.h" // irq_save
-#include "command.h" // shutdown
-#include "gpio.h" // gpio_pwm_write
-#include "internal.h" // GPIO
-#include "sched.h" // sched_shutdown
-
-#define MAX_PWM 255
-DECL_CONSTANT("PWM_MAX", MAX_PWM);
-
-struct gpio_pwm_info {
-    TIM_TypeDef* timer;
-    uint8_t pin, channel, function;
-};
-
-static const struct gpio_pwm_info pwm_regs[] = {
-#if CONFIG_MACH_STM32F103
-    {TIM2, GPIO('A', 0),  1, GPIO_FUNCTION(2)},
-    {TIM2, GPIO('A', 1),  2, GPIO_FUNCTION(2)},
-    {TIM2, GPIO('A', 2),  3, GPIO_FUNCTION(2)},
-    {TIM2, GPIO('A', 3),  4, GPIO_FUNCTION(2)},
-    {TIM2, GPIO('A', 15), 1, GPIO_FUNCTION(1)},
-    {TIM2, GPIO('B', 3),  2, GPIO_FUNCTION(1)},
-    {TIM2, GPIO('B', 10), 3, GPIO_FUNCTION(1)},
-    {TIM2, GPIO('B', 11), 4, GPIO_FUNCTION(1)},
-    {TIM3, GPIO('A', 6),  1, GPIO_FUNCTION(1)},
-    {TIM3, GPIO('A', 7),  2, GPIO_FUNCTION(1)},
-    {TIM3, GPIO('B', 0),  3, GPIO_FUNCTION(1)},
-    {TIM3, GPIO('B', 1),  4, GPIO_FUNCTION(1)},
-    {TIM3, GPIO('C', 6),  1, GPIO_FUNCTION(2)},
-    {TIM3, GPIO('C', 7),  2, GPIO_FUNCTION(2)},
-    {TIM3, GPIO('C', 8),  3, GPIO_FUNCTION(2)},
-    {TIM3, GPIO('C', 9),  4, GPIO_FUNCTION(2)},
-    {TIM4, GPIO('D', 12), 1, GPIO_FUNCTION(2)},
-    {TIM4, GPIO('D', 13), 2, GPIO_FUNCTION(2)},
-    {TIM4, GPIO('D', 14), 3, GPIO_FUNCTION(2)},
-    {TIM4, GPIO('D', 15), 4, GPIO_FUNCTION(2)},
-    {TIM4, GPIO('B', 6),  1, GPIO_FUNCTION(2)},
-    {TIM4, GPIO('B', 7),  2, GPIO_FUNCTION(2)},
-    {TIM4, GPIO('B', 8),  3, GPIO_FUNCTION(2)},
-    {TIM4, GPIO('B', 9),  4, GPIO_FUNCTION(2)}
-#elif CONFIG_MACH_STM32F4
-  #if CONFIG_MACH_STM32F401
-    {TIM3,  GPIO('A',  6),  1, GPIO_FUNCTION(2)},
-    {TIM3,  GPIO('C',  6),  1, GPIO_FUNCTION(3)},
-    {TIM3,  GPIO('A',  7),  2, GPIO_FUNCTION(2)},
-    {TIM3,  GPIO('C',  7),  2, GPIO_FUNCTION(3)},
-    {TIM3,  GPIO('C',  8),  3, GPIO_FUNCTION(3)},
-    {TIM3,  GPIO('C',  9),  4, GPIO_FUNCTION(3)},
-  #endif
-  #if CONFIG_MACH_STM32F446
-    {TIM2,  GPIO('B',  2),  4, GPIO_FUNCTION(1)},
-  #endif
-  #if CONFIG_MACH_STM32F4x5 || CONFIG_MACH_STM32F446
-    {TIM8,  GPIO('C',  6),  1, GPIO_FUNCTION(3)},
-    {TIM8,  GPIO('C',  7),  2, GPIO_FUNCTION(3)},
-    {TIM8,  GPIO('C',  8),  3, GPIO_FUNCTION(3)},
-    {TIM8,  GPIO('C',  9),  4, GPIO_FUNCTION(3)},
-    {TIM11, GPIO('F',  7),  1, GPIO_FUNCTION(3)},
-    {TIM12, GPIO('B', 14),  1, GPIO_FUNCTION(9)},
-    {TIM12, GPIO('B', 15),  2, GPIO_FUNCTION(9)},
-    {TIM13, GPIO('A',  6),  1, GPIO_FUNCTION(9)},
-    {TIM13, GPIO('F',  8),  1, GPIO_FUNCTION(9)},
-    {TIM14, GPIO('A',  7),  1, GPIO_FUNCTION(9)},
-    {TIM14, GPIO('F',  9),  1, GPIO_FUNCTION(9)},
-  #endif
-    // Pins that map to all klipper defined STM32F4 procs
-    {TIM1,  GPIO('A',  8),  1, GPIO_FUNCTION(1)},
-    {TIM1,  GPIO('E',  9),  1, GPIO_FUNCTION(1)},
-    {TIM1,  GPIO('A',  9),  2, GPIO_FUNCTION(1)},
-    {TIM1,  GPIO('E', 11),  2, GPIO_FUNCTION(1)},
-    {TIM1,  GPIO('A', 10),  3, GPIO_FUNCTION(1)},
-    {TIM1,  GPIO('E', 13),  3, GPIO_FUNCTION(1)},
-    {TIM1,  GPIO('A', 11),  4, GPIO_FUNCTION(1)},
-    {TIM1,  GPIO('E', 14),  4, GPIO_FUNCTION(1)},
-    {TIM2,  GPIO('A',  5),  1, GPIO_FUNCTION(1)},
-    {TIM2,  GPIO('A', 15),  1, GPIO_FUNCTION(1)},
-    {TIM2,  GPIO('B',  3),  2, GPIO_FUNCTION(1)},
-    {TIM2,  GPIO('B', 10),  3, GPIO_FUNCTION(1)},
-    {TIM2,  GPIO('B', 11),  4, GPIO_FUNCTION(1)},
-    {TIM3,  GPIO('B',  4),  1, GPIO_FUNCTION(2)},
-    {TIM3,  GPIO('B',  5),  2, GPIO_FUNCTION(2)},
-    {TIM3,  GPIO('B',  0),  3, GPIO_FUNCTION(2)},
-    {TIM3,  GPIO('B',  1),  4, GPIO_FUNCTION(2)},
-    {TIM4,  GPIO('B',  6),  1, GPIO_FUNCTION(2)},
-    {TIM4,  GPIO('D', 12),  1, GPIO_FUNCTION(2)},
-    {TIM4,  GPIO('B',  7),  2, GPIO_FUNCTION(2)},
-    {TIM4,  GPIO('D', 13),  2, GPIO_FUNCTION(2)},
-    {TIM4,  GPIO('D', 14),  3, GPIO_FUNCTION(2)},
-    {TIM4,  GPIO('D', 15),  4, GPIO_FUNCTION(2)},
-    {TIM5,  GPIO('A',  0),  1, GPIO_FUNCTION(2)},
-    {TIM5,  GPIO('A',  1),  2, GPIO_FUNCTION(2)},
-    {TIM5,  GPIO('A',  2),  3, GPIO_FUNCTION(2)},
-    {TIM5,  GPIO('A',  3),  4, GPIO_FUNCTION(2)},
-    {TIM9,  GPIO('E',  5),  1, GPIO_FUNCTION(3)},
-    {TIM9,  GPIO('E',  6),  2, GPIO_FUNCTION(3)},
-    {TIM10, GPIO('B',  8),  1, GPIO_FUNCTION(3)},
-    {TIM11, GPIO('B',  9),  1, GPIO_FUNCTION(3)}
-#elif CONFIG_MACH_STM32G0
-    {TIM15, GPIO('A',  2), 1, GPIO_FUNCTION(5)},
-    {TIM15, GPIO('A',  3), 2, GPIO_FUNCTION(5)},
-    {TIM14, GPIO('A',  4), 1, GPIO_FUNCTION(4)},
-    {TIM3,  GPIO('A',  6), 1, GPIO_FUNCTION(1)},
-    {TIM3,  GPIO('A',  7), 2, GPIO_FUNCTION(1)},
-    {TIM1,  GPIO('A',  8), 1, GPIO_FUNCTION(2)},
-    {TIM1,  GPIO('A',  9), 2, GPIO_FUNCTION(2)},
-    {TIM1,  GPIO('A', 10), 3, GPIO_FUNCTION(2)},
-    {TIM1,  GPIO('A', 11), 4, GPIO_FUNCTION(2)},
-    {TIM3,  GPIO('B',  0), 3, GPIO_FUNCTION(1)},
-    {TIM3,  GPIO('B',  1), 4, GPIO_FUNCTION(1)},
-    {TIM1,  GPIO('B',  3), 2, GPIO_FUNCTION(1)},
-    {TIM3,  GPIO('B',  4), 1, GPIO_FUNCTION(1)},
-    {TIM3,  GPIO('B',  5), 2, GPIO_FUNCTION(1)},
-    {TIM4,  GPIO('B',  6), 1, GPIO_FUNCTION(9)},
-    {TIM4,  GPIO('B',  7), 2, GPIO_FUNCTION(9)},
-    {TIM4,  GPIO('B',  8), 3, GPIO_FUNCTION(9)},
-    {TIM4,  GPIO('B',  9), 4, GPIO_FUNCTION(9)},
-    {TIM15, GPIO('B', 14), 1, GPIO_FUNCTION(5)},
-    {TIM15, GPIO('B', 15), 2, GPIO_FUNCTION(5)},
-    {TIM15, GPIO('C',  1), 1, GPIO_FUNCTION(2)},
-    {TIM15, GPIO('C',  2), 2, GPIO_FUNCTION(2)},
-    {TIM3,  GPIO('C',  6), 1, GPIO_FUNCTION(1)},
-    {TIM3,  GPIO('C',  7), 2, GPIO_FUNCTION(1)},
-    {TIM3,  GPIO('C',  8), 3, GPIO_FUNCTION(1)},
-    {TIM3,  GPIO('C',  9), 4, GPIO_FUNCTION(1)},
-    {TIM1,  GPIO('C', 10), 3, GPIO_FUNCTION(2)},
-    {TIM1,  GPIO('C', 11), 4, GPIO_FUNCTION(2)},
-    {TIM14, GPIO('C', 12), 1, GPIO_FUNCTION(2)},
-    {TIM16, GPIO('D',  0), 1, GPIO_FUNCTION(2)},
-    {TIM17, GPIO('D',  1), 1, GPIO_FUNCTION(2)},
-    {TIM4,  GPIO('D', 12), 1, GPIO_FUNCTION(2)},
-    {TIM4,  GPIO('D', 13), 2, GPIO_FUNCTION(2)},
-    {TIM4,  GPIO('D', 14), 3, GPIO_FUNCTION(2)},
-    {TIM4,  GPIO('D', 15), 4, GPIO_FUNCTION(2)},
-    {TIM3,  GPIO('E',  3), 1, GPIO_FUNCTION(1)},
-    {TIM3,  GPIO('E',  4), 2, GPIO_FUNCTION(1)},
-    {TIM3,  GPIO('E',  5), 3, GPIO_FUNCTION(1)},
-    {TIM3,  GPIO('E',  6), 4, GPIO_FUNCTION(1)},
-    {TIM1,  GPIO('E',  9), 1, GPIO_FUNCTION(1)},
-    {TIM1,  GPIO('E', 11), 2, GPIO_FUNCTION(1)},
-    {TIM1,  GPIO('E', 13), 3, GPIO_FUNCTION(1)},
-    {TIM1,  GPIO('E', 14), 4, GPIO_FUNCTION(1)},
-    {TIM14, GPIO('F',  0), 1, GPIO_FUNCTION(2)},
-    {TIM15, GPIO('F', 12), 1, GPIO_FUNCTION(0)},
-    {TIM15, GPIO('F', 13), 2, GPIO_FUNCTION(0)},
-#elif CONFIG_MACH_STM32H7
-    {TIM2, GPIO('A', 0),  1, GPIO_FUNCTION(1)},
-    {TIM2, GPIO('A', 5),  1, GPIO_FUNCTION(1)},
-    {TIM2, GPIO('A', 15), 1, GPIO_FUNCTION(1)},
-    {TIM2, GPIO('B', 3),  2, GPIO_FUNCTION(1)},
-    {TIM2, GPIO('A', 1),  2, GPIO_FUNCTION(1)},
-    {TIM2, GPIO('B', 10), 3, GPIO_FUNCTION(1)},
-    {TIM2, GPIO('A', 2),  3, GPIO_FUNCTION(1)},
-    {TIM3, GPIO('C', 6),  1, GPIO_FUNCTION(2)},
-    {TIM3, GPIO('B', 4),  1, GPIO_FUNCTION(2)},
-    {TIM3, GPIO('A', 6),  1, GPIO_FUNCTION(2)},
-    {TIM3, GPIO('C', 7),  2, GPIO_FUNCTION(2)},
-    {TIM3, GPIO('B', 5),  2, GPIO_FUNCTION(2)},
-    {TIM3, GPIO('A', 7),  2, GPIO_FUNCTION(2)},
-    {TIM3, GPIO('C', 8),  3, GPIO_FUNCTION(2)},
-    {TIM3, GPIO('B', 0),  3, GPIO_FUNCTION(2)},
-    {TIM4, GPIO('D', 12), 1, GPIO_FUNCTION(2)},
-    {TIM4, GPIO('B', 6),  1, GPIO_FUNCTION(2)},
-    {TIM4, GPIO('D', 13), 2, GPIO_FUNCTION(2)},
-    {TIM4, GPIO('B', 7),  2, GPIO_FUNCTION(2)},
-    {TIM4, GPIO('D', 14), 3, GPIO_FUNCTION(2)},
-    {TIM4, GPIO('B', 8),  3, GPIO_FUNCTION(2)},
-    {TIM5, GPIO('H', 10), 1, GPIO_FUNCTION(2)},
-    {TIM5, GPIO('A', 0),  1, GPIO_FUNCTION(2)},
-    {TIM5, GPIO('H', 11), 2, GPIO_FUNCTION(2)},
-    {TIM5, GPIO('A', 1),  2, GPIO_FUNCTION(2)},
-    {TIM5, GPIO('H', 12), 3, GPIO_FUNCTION(2)},
-    {TIM5, GPIO('A', 2),  3, GPIO_FUNCTION(2)},
-    {TIM12, GPIO('H', 6),  1, GPIO_FUNCTION(2)},
-    {TIM12, GPIO('B', 14), 1, GPIO_FUNCTION(2)},
-    {TIM12, GPIO('H', 9),  2, GPIO_FUNCTION(2)},
-    {TIM12, GPIO('B', 15), 2, GPIO_FUNCTION(2)},
-    {TIM13, GPIO('F', 8),  1, GPIO_FUNCTION(9)},
-    {TIM13, GPIO('A', 6),  1, GPIO_FUNCTION(9)},
-    {TIM14, GPIO('F', 9),  1, GPIO_FUNCTION(9)},
-    {TIM14, GPIO('A', 7),  1, GPIO_FUNCTION(9)},
-    {TIM15, GPIO('E', 5),  1, GPIO_FUNCTION(4)},
-    {TIM15, GPIO('A', 2),  1, GPIO_FUNCTION(4)},
-    {TIM16, GPIO('F', 6),  1, GPIO_FUNCTION(1)},
-    {TIM16, GPIO('B', 8),  1, GPIO_FUNCTION(1)},
-    {TIM17, GPIO('F', 7),  1, GPIO_FUNCTION(1)},
-    {TIM17, GPIO('B', 9),  1, GPIO_FUNCTION(1)}
-#endif
-};
-
-struct gpio_pwm
-gpio_pwm_setup(uint8_t pin, uint32_t cycle_time, uint8_t val){
-    // Find pin in pwm_regs table
-    const struct gpio_pwm_info* p = pwm_regs;
-    for (;; p++) {
-        if (p >= &pwm_regs[ARRAY_SIZE(pwm_regs)])
-            shutdown("Not a valid PWM pin");
-        if (p->pin == pin)
-            break;
-    }
-
-    // Map cycle_time to pwm clock divisor
-    uint32_t pclk = get_pclock_frequency((uint32_t)p->timer);
-    uint32_t pclock_div = CONFIG_CLOCK_FREQ / pclk;
-    if (pclock_div > 1)
-        pclock_div /= 2; // Timers run at twice the normal pclock frequency
-    uint32_t prescaler = cycle_time / (pclock_div * (MAX_PWM - 1));
-    if (prescaler > 0) {
-        prescaler -= 1;
-    } else if (prescaler > UINT16_MAX) {
-        prescaler = UINT16_MAX;
-    }
-
-    gpio_peripheral(p->pin, p->function, 0);
-
-    // Enable clock
-    if (!is_enabled_pclock((uint32_t) p->timer)) {
-        enable_pclock((uint32_t) p->timer);
-    }
-
-    if (p->timer->CR1 & TIM_CR1_CEN) {
-        if (p->timer->PSC != (uint16_t) prescaler) {
-            shutdown("PWM already programmed at different speed");
-        }
-    } else {
-        p->timer->PSC = (uint16_t) prescaler;
-        p->timer->ARR = MAX_PWM - 1;
-        p->timer->EGR |= TIM_EGR_UG;
-    }
-
-    struct gpio_pwm channel;
-    switch (p->channel) {
-        case 1: {
-            channel.reg = (void*) &p->timer->CCR1;
-            p->timer->CCER &= ~TIM_CCER_CC1E;
-            p->timer->CCMR1 &= ~(TIM_CCMR1_OC1M | TIM_CCMR1_CC1S);
-            p->timer->CCMR1 |= (TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_2 |
-                                TIM_CCMR1_OC1PE | TIM_CCMR1_OC1FE);
-            gpio_pwm_write(channel, val);
-            p->timer->CCER |= TIM_CCER_CC1E;
-            break;
-        }
-        case 2: {
-            channel.reg = (void*) &p->timer->CCR2;
-            p->timer->CCER &= ~TIM_CCER_CC2E;
-            p->timer->CCMR1 &= ~(TIM_CCMR1_OC2M | TIM_CCMR1_CC2S);
-            p->timer->CCMR1 |= (TIM_CCMR1_OC2M_1 | TIM_CCMR1_OC2M_2 |
-                                TIM_CCMR1_OC2PE | TIM_CCMR1_OC2FE);
-            gpio_pwm_write(channel, val);
-            p->timer->CCER |= TIM_CCER_CC2E;
-            break;
-        }
-        case 3: {
-            channel.reg = (void*) &p->timer->CCR3;
-            p->timer->CCER &= ~TIM_CCER_CC3E;
-            p->timer->CCMR2 &= ~(TIM_CCMR2_OC3M | TIM_CCMR2_CC3S);
-            p->timer->CCMR2 |= (TIM_CCMR2_OC3M_1 | TIM_CCMR2_OC3M_2 |
-                                TIM_CCMR2_OC3PE | TIM_CCMR2_OC3FE);
-            gpio_pwm_write(channel, val);
-            p->timer->CCER |= TIM_CCER_CC3E;
-            break;
-        }
-        case 4: {
-            channel.reg = (void*) &p->timer->CCR4;
-            p->timer->CCER &= ~TIM_CCER_CC4E;
-            p->timer->CCMR2 &= ~(TIM_CCMR2_OC4M | TIM_CCMR2_CC4S);
-            p->timer->CCMR2 |= (TIM_CCMR2_OC4M_1 | TIM_CCMR2_OC4M_2 |
-                                TIM_CCMR2_OC4PE | TIM_CCMR2_OC4FE);
-            gpio_pwm_write(channel, val);
-            p->timer->CCER |= TIM_CCER_CC4E;
-            break;
-        }
-        default:
-            shutdown("Invalid PWM channel");
-    }
-    // Enable PWM output
-    p->timer->CR1 |= TIM_CR1_CEN;
-#if CONFIG_MACH_STM32H7 || CONFIG_MACH_STM32G0
-    p->timer->BDTR |= TIM_BDTR_MOE;
-#endif
-    return channel;
-}
-
-void
-gpio_pwm_write(struct gpio_pwm g, uint32_t val) {
-    *(volatile uint32_t*) g.reg = val;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/i2c.c crealityShit/src/stm32/i2c.c
--- klipperStock/src/stm32/i2c.c	2024-01-14 23:02:00.093796007 -0600
+++ crealityShit/src/stm32/i2c.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,183 +0,0 @@
-// I2C functions on stm32
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_MACH_STM32F1
-#include "board/misc.h" // timer_is_before
-#include "command.h" // shutdown
-#include "gpio.h" // i2c_setup
-#include "internal.h" // GPIO
-#include "sched.h" // sched_shutdown
-#include "board/irq.h" //irq_disable
-
-struct i2c_info {
-    I2C_TypeDef *i2c;
-    uint8_t scl_pin, sda_pin;
-};
-
-DECL_ENUMERATION("i2c_bus", "i2c1", 0);
-DECL_CONSTANT_STR("BUS_PINS_i2c1", "PB6,PB7");
-DECL_ENUMERATION("i2c_bus", "i2c1a", 1);
-DECL_CONSTANT_STR("BUS_PINS_i2c1a", "PB8,PB9");
-DECL_ENUMERATION("i2c_bus", "i2c2", 2);
-DECL_CONSTANT_STR("BUS_PINS_i2c2", "PB10,PB11");
-#if CONFIG_MACH_STM32F2 || CONFIG_MACH_STM32F4
-DECL_ENUMERATION("i2c_bus", "i2c3", 3);
-DECL_CONSTANT_STR("BUS_PINS_i2c3", "PA8,PC9");
-  #if CONFIG_MACH_STM32F2 || CONFIG_MACH_STM32F4x5
-DECL_ENUMERATION("i2c_bus", "i2c2a", 4);
-DECL_CONSTANT_STR("BUS_PINS_i2c2a", "PH4,PH5");
-DECL_ENUMERATION("i2c_bus", "i2c3a", 5);
-DECL_CONSTANT_STR("BUS_PINS_i2c3a", "PH7,PH8");
-  #endif
-#endif
-
-static const struct i2c_info i2c_bus[] = {
-    { I2C1, GPIO('B', 6), GPIO('B', 7) },
-    { I2C1, GPIO('B', 8), GPIO('B', 9) },
-    { I2C2, GPIO('B', 10), GPIO('B', 11) },
-#if CONFIG_MACH_STM32F2 || CONFIG_MACH_STM32F4
-    { I2C3, GPIO('A', 8), GPIO('C', 9) },
-  #if CONFIG_MACH_STM32F2 || CONFIG_MACH_STM32F4x5
-    { I2C2, GPIO('H', 4), GPIO('H', 5) },
-    { I2C3, GPIO('H', 7), GPIO('H', 8) },
-  #endif
-#endif
-};
-
-// Work around stm32 errata causing busy bit to be stuck
-static void
-i2c_busy_errata(uint8_t scl_pin, uint8_t sda_pin)
-{
-    if (! CONFIG_MACH_STM32F1)
-        return;
-    gpio_peripheral(scl_pin, GPIO_OUTPUT | GPIO_OPEN_DRAIN, 1);
-    gpio_peripheral(sda_pin, GPIO_OUTPUT | GPIO_OPEN_DRAIN, 1);
-    gpio_peripheral(sda_pin, GPIO_OUTPUT | GPIO_OPEN_DRAIN, -1);
-    gpio_peripheral(scl_pin, GPIO_OUTPUT | GPIO_OPEN_DRAIN, -1);
-    gpio_peripheral(scl_pin, GPIO_OUTPUT | GPIO_OPEN_DRAIN, 1);
-    gpio_peripheral(sda_pin, GPIO_OUTPUT | GPIO_OPEN_DRAIN, 1);
-}
-
-struct i2c_config
-i2c_setup(uint32_t bus, uint32_t rate, uint8_t addr)
-{
-    // Lookup requested i2c bus
-    if (bus >= ARRAY_SIZE(i2c_bus))
-        shutdown("Unsupported i2c bus");
-    const struct i2c_info *ii = &i2c_bus[bus];
-    I2C_TypeDef *i2c = ii->i2c;
-
-    if (!is_enabled_pclock((uint32_t)i2c)) {
-        // Enable i2c clock and gpio
-        enable_pclock((uint32_t)i2c);
-        i2c_busy_errata(ii->scl_pin, ii->sda_pin);
-        gpio_peripheral(ii->scl_pin, GPIO_FUNCTION(4) | GPIO_OPEN_DRAIN, 1);
-        gpio_peripheral(ii->sda_pin, GPIO_FUNCTION(4) | GPIO_OPEN_DRAIN, 1);
-        i2c->CR1 = I2C_CR1_SWRST;
-        i2c->CR1 = 0;
-
-        // Set 100Khz frequency and enable
-        uint32_t pclk = get_pclock_frequency((uint32_t)i2c);
-        i2c->CR2 = pclk / 1000000;
-        i2c->CCR = pclk / 100000 / 2;
-        i2c->TRISE = (pclk / 1000000) + 1;
-        i2c->CR1 = I2C_CR1_PE;
-    }
-
-    return (struct i2c_config){ .i2c=i2c, .addr=addr<<1 };
-}
-
-static uint32_t
-i2c_wait(I2C_TypeDef *i2c, uint32_t set, uint32_t clear, uint32_t timeout)
-{
-    for (;;) {
-        uint32_t sr1 = i2c->SR1;
-        if ((sr1 & set) == set && (sr1 & clear) == 0)
-            return sr1;
-        if (!timer_is_before(timer_read_time(), timeout))
-            shutdown("i2c timeout");
-    }
-}
-
-static void
-i2c_start(I2C_TypeDef *i2c, uint8_t addr, uint8_t xfer_len,
-          uint32_t timeout)
-{
-    i2c->CR1 = I2C_CR1_START | I2C_CR1_PE;
-    i2c_wait(i2c, I2C_SR1_SB, 0, timeout);
-    i2c->DR = addr;
-    if (addr & 0x01)
-        i2c->CR1 |= I2C_CR1_ACK;
-    i2c_wait(i2c, I2C_SR1_ADDR, 0, timeout);
-    irqstatus_t flag = irq_save();
-    uint32_t sr2 = i2c->SR2;
-    if (addr & 0x01 && xfer_len == 1)
-        i2c->CR1 = I2C_CR1_STOP | I2C_CR1_PE;
-    irq_restore(flag);
-    if (!(sr2 & I2C_SR2_MSL))
-        shutdown("Failed to send i2c addr");
-}
-
-static void
-i2c_send_byte(I2C_TypeDef *i2c, uint8_t b, uint32_t timeout)
-{
-    i2c->DR = b;
-    i2c_wait(i2c, I2C_SR1_TXE, 0, timeout);
-}
-
-static uint8_t
-i2c_read_byte(I2C_TypeDef *i2c, uint32_t timeout, uint8_t remaining)
-{
-    i2c_wait(i2c, I2C_SR1_RXNE, 0, timeout);
-    irqstatus_t flag = irq_save();
-    uint8_t b = i2c->DR;
-    if (remaining == 1)
-        i2c->CR1 = I2C_CR1_STOP | I2C_CR1_PE;
-    irq_restore(flag);
-    return b;
-}
-
-static void
-i2c_stop(I2C_TypeDef *i2c, uint32_t timeout)
-{
-    i2c->CR1 = I2C_CR1_STOP | I2C_CR1_PE;
-    i2c_wait(i2c, 0, I2C_SR1_TXE, timeout);
-}
-
-void
-i2c_write(struct i2c_config config, uint8_t write_len, uint8_t *write)
-{
-    I2C_TypeDef *i2c = config.i2c;
-    uint32_t timeout = timer_read_time() + timer_from_us(5000);
-
-    i2c_start(i2c, config.addr, write_len, timeout);
-    while (write_len--)
-        i2c_send_byte(i2c, *write++, timeout);
-    i2c_stop(i2c, timeout);
-}
-
-void
-i2c_read(struct i2c_config config, uint8_t reg_len, uint8_t *reg
-         , uint8_t read_len, uint8_t *read)
-{
-    I2C_TypeDef *i2c = config.i2c;
-    uint32_t timeout = timer_read_time() + timer_from_us(5000);
-    uint8_t addr = config.addr | 0x01;
-
-    if (reg_len) {
-        // write the register
-        i2c_start(i2c, config.addr, reg_len, timeout);
-        while(reg_len--)
-            i2c_send_byte(i2c, *reg++, timeout);
-    }
-    // start/re-start and read data
-    i2c_start(i2c, addr, read_len, timeout);
-    while(read_len--) {
-        *read = i2c_read_byte(i2c, timeout, read_len);
-        read++;
-    }
-    i2c_wait(i2c, 0, I2C_SR1_RXNE, timeout);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/internal.h crealityShit/src/stm32/internal.h
--- klipperStock/src/stm32/internal.h	2024-01-14 23:02:00.109796205 -0600
+++ crealityShit/src/stm32/internal.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,53 +0,0 @@
-#ifndef __STM32_INTERNAL_H
-#define __STM32_INTERNAL_H
-// Local definitions for STM32 code
-
-#include "autoconf.h" // CONFIG_MACH_STM32F1
-
-#if CONFIG_MACH_STM32F0
-#include "stm32f0xx.h"
-#elif CONFIG_MACH_STM32F1
-#include "stm32f1xx.h"
-#elif CONFIG_MACH_STM32F2
-#include "stm32f2xx.h"
-#elif CONFIG_MACH_STM32F4
-#include "stm32f4xx.h"
-#elif CONFIG_MACH_STM32G0
-#include "stm32g0xx.h"
-#elif CONFIG_MACH_STM32G4
-#include "stm32g4xx.h"
-#elif CONFIG_MACH_STM32H7
-#include "stm32h7xx.h"
-#elif CONFIG_MACH_STM32L4
-#include "stm32l4xx.h"
-#endif
-
-// gpio.c
-extern GPIO_TypeDef * const digital_regs[];
-#define GPIO(PORT, NUM) (((PORT)-'A') * 16 + (NUM))
-#define GPIO2PORT(PIN) ((PIN) / 16)
-#define GPIO2BIT(PIN) (1<<((PIN) % 16))
-
-// gpioperiph.c
-#define GPIO_INPUT 0
-#define GPIO_OUTPUT 1
-#define GPIO_OPEN_DRAIN 0x100
-#define GPIO_FUNCTION(fn) (2 | ((fn) << 4))
-#define GPIO_ANALOG 3
-void gpio_peripheral(uint32_t gpio, uint32_t mode, int pullup);
-
-// clockline.c
-void enable_pclock(uint32_t periph_base);
-int is_enabled_pclock(uint32_t periph_base);
-
-// dfu_reboot.c
-void dfu_reboot(void);
-void dfu_reboot_check(void);
-
-// stm32??.c
-struct cline { volatile uint32_t *en, *rst; uint32_t bit; };
-struct cline lookup_clock_line(uint32_t periph_base);
-uint32_t get_pclock_frequency(uint32_t periph_base);
-void gpio_clock_enable(GPIO_TypeDef *regs);
-
-#endif // internal.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/Kconfig crealityShit/src/stm32/Kconfig
--- klipperStock/src/stm32/Kconfig	2024-01-14 23:02:00.101796106 -0600
+++ crealityShit/src/stm32/Kconfig	1969-12-31 18:00:00.000000000 -0600
@@ -1,476 +0,0 @@
-# Kconfig settings for STM32 processors
-
-if MACH_STM32
-
-config STM32_SELECT
-    bool
-    default y
-    select HAVE_GPIO
-    select HAVE_GPIO_ADC
-    select HAVE_GPIO_I2C if !(MACH_STM32F031 || MACH_STM32H7)
-    select HAVE_GPIO_SPI if !MACH_STM32F031
-    select HAVE_GPIO_HARD_PWM if MACH_STM32F1 || MACH_STM32F4 || MACH_STM32G0 || MACH_STM32H7
-    select HAVE_GPIO_BITBANGING if !MACH_STM32F031
-    select HAVE_STRICT_TIMING
-    select HAVE_CHIPID
-    select HAVE_STEPPER_BOTH_EDGE
-    select SERIAL_BOOTLOADER_SIDECHANNEL
-
-config BOARD_DIRECTORY
-    string
-    default "stm32"
-
-
-######################################################################
-# Chip selection
-######################################################################
-
-choice
-    prompt "Processor model"
-    config MACH_STM32F103
-        bool "STM32F103"
-        select MACH_STM32F1
-    config MACH_STM32F207
-        bool "STM32F207"
-        select MACH_STM32F2
-    config MACH_STM32F401
-        bool "STM32F401"
-        select MACH_STM32F4
-    config MACH_STM32F405
-        bool "STM32F405"
-        select MACH_STM32F4
-        select MACH_STM32F4x5
-    config MACH_STM32F407
-        bool "STM32F407"
-        select MACH_STM32F4
-        select MACH_STM32F4x5
-    config MACH_STM32F429
-        bool "STM32F429"
-        select MACH_STM32F4
-        select MACH_STM32F4x5
-    config MACH_STM32F446
-        bool "STM32F446"
-        select MACH_STM32F4
-    config MACH_STM32F031
-        bool "STM32F031"
-        select MACH_STM32F0
-    config MACH_STM32F042
-        bool "STM32F042"
-        select MACH_STM32F0
-        select MACH_STM32F0x2
-    config MACH_STM32F070
-        bool "STM32F070"
-        select MACH_STM32F0
-    config MACH_STM32F072
-        bool "STM32F072"
-        select MACH_STM32F0
-        select MACH_STM32F0x2
-    config MACH_STM32G0B0
-        bool "STM32G0B0"
-        select MACH_STM32G0
-        select MACH_STM32G0Bx
-    config MACH_STM32G0B1
-        bool "STM32G0B1"
-        select MACH_STM32G0
-        select MACH_STM32G0Bx
-    config MACH_STM32G431
-        bool "STM32G431"
-        select MACH_STM32G4
-    config MACH_STM32H723
-        bool "STM32H723"
-        select MACH_STM32H7
-    config MACH_STM32H743
-        bool "STM32H743"
-        select MACH_STM32H7
-    config MACH_STM32H750
-        bool "STM32H750"
-        select MACH_STM32H7
-    config MACH_STM32L412
-        bool "STM32L412"
-        select MACH_STM32L4
-endchoice
-
-config MACH_STM32F103x6
-    depends on LOW_LEVEL_OPTIONS && MACH_STM32F103
-    bool "Only 10KiB of RAM (for rare stm32f103x6 variant)"
-
-config MACH_STM32F0
-    bool
-config MACH_STM32F1
-    bool
-config MACH_STM32F2
-    bool
-config MACH_STM32F4
-    bool
-config MACH_STM32G0
-    bool
-config MACH_STM32G0Bx
-    bool
-config MACH_STM32G4
-    bool
-config MACH_STM32H7
-    bool
-config MACH_STM32F0x2 # F042, F072 series
-    bool
-config MACH_STM32F4x5 # F405, F407, F429 series
-    bool
-config MACH_STM32L4
-    bool
-config HAVE_STM32_USBFS
-    bool
-    default y if MACH_STM32F0x2 || MACH_STM32G0Bx || MACH_STM32L4 || MACH_STM32G4
-    default y if (MACH_STM32F103 || MACH_STM32F070) && !STM32_CLOCK_REF_INTERNAL
-config HAVE_STM32_USBOTG
-    bool
-    default y if MACH_STM32F2 || MACH_STM32F4 || MACH_STM32H7
-config HAVE_STM32_CANBUS
-    bool
-    default y if MACH_STM32F1 || MACH_STM32F2 || MACH_STM32F4x5 || MACH_STM32F446 || MACH_STM32F0x2
-config HAVE_STM32_FDCANBUS
-    bool
-    default y if MACH_STM32G0B1 || MACH_STM32H7 || MACH_STM32G4
-config HAVE_STM32_USBCANBUS
-    bool
-    depends on HAVE_STM32_USBFS || HAVE_STM32_USBOTG
-    depends on HAVE_STM32_CANBUS || HAVE_STM32_FDCANBUS
-    depends on !MACH_STM32F103
-    default y
-
-config MCU
-    string
-    default "stm32f031x6" if MACH_STM32F031
-    default "stm32f042x6" if MACH_STM32F042
-    default "stm32f070xb" if MACH_STM32F070
-    default "stm32f072xb" if MACH_STM32F072
-    default "stm32f103xe" if MACH_STM32F103
-    default "stm32f207xx" if MACH_STM32F207
-    default "stm32f401xc" if MACH_STM32F401
-    default "stm32f405xx" if MACH_STM32F405
-    default "stm32f407xx" if MACH_STM32F407
-    default "stm32f429xx" if MACH_STM32F429
-    default "stm32f446xx" if MACH_STM32F446
-    default "stm32g0b0xx" if MACH_STM32G0B0
-    default "stm32g0b1xx" if MACH_STM32G0B1
-    default "stm32g431xx" if MACH_STM32G431
-    default "stm32h723xx" if MACH_STM32H723
-    default "stm32h743xx" if MACH_STM32H743
-    default "stm32h750xx" if MACH_STM32H750
-    default "stm32l412xx" if MACH_STM32L412
-
-config CLOCK_FREQ
-    int
-    default 48000000 if MACH_STM32F0
-    default 64000000 if MACH_STM32F103 && STM32_CLOCK_REF_INTERNAL
-    default 72000000 if MACH_STM32F103
-    default 120000000 if MACH_STM32F207
-    default 84000000 if MACH_STM32F401
-    default 168000000 if MACH_STM32F4x5
-    default 180000000 if MACH_STM32F446
-    default 64000000 if MACH_STM32G0
-    default 150000000 if MACH_STM32G431
-    default 400000000 if MACH_STM32H7 # 400Mhz is max Klipper currently supports
-    default 80000000 if MACH_STM32L412
-
-config FLASH_SIZE
-    hex
-    default 0x4000 if MACH_STM32F031
-    default 0x8000 if MACH_STM32F042
-    default 0x20000 if MACH_STM32F070 || MACH_STM32F072
-    default 0x10000 if MACH_STM32F103 || MACH_STM32L412 # Flash size of stm32f103x8 (64KiB)
-    default 0x40000 if MACH_STM32F2 || MACH_STM32F401 || MACH_STM32H723
-    default 0x80000 if MACH_STM32F4x5 || MACH_STM32F446
-    default 0x20000 if MACH_STM32G0 || MACH_STM32G431
-    default 0x20000 if MACH_STM32H750
-    default 0x200000 if MACH_STM32H743
-
-config FLASH_BOOT_ADDRESS
-    hex
-    default 0x8000000
-
-config RAM_START
-    hex
-    default 0x20000000
-
-config RAM_SIZE
-    hex
-    default 0x1000 if MACH_STM32F031
-    default 0x1800 if MACH_STM32F042
-    default 0x4000 if MACH_STM32F070 || MACH_STM32F072
-    default 0x2800 if MACH_STM32F103x6
-    default 0x5000 if MACH_STM32F103 && !MACH_STM32F103x6 # Ram size of stm32f103x8
-    default 0x8000 if MACH_STM32G431
-    default 0xa000 if MACH_STM32L412
-    default 0x20000 if MACH_STM32F207
-    default 0x10000 if MACH_STM32F401
-    default 0x20000 if MACH_STM32F4x5 || MACH_STM32F446
-    default 0x24000 if MACH_STM32G0Bx
-    default 0x20000 if MACH_STM32H7
-
-config STACK_SIZE
-    int
-    default 512
-
-config STM32F103GD_DISABLE_SWD
-    bool "Disable SWD at startup (for GigaDevice stm32f103 clones)"
-    depends on MACH_STM32F103 && LOW_LEVEL_OPTIONS
-    default n
-    help
-        The GigaDevice clone of the STM32F103 may not be able to
-        reliably disable SWD at run-time. This can prevent the PA13
-        and PA14 pins from being available. Selecting this option
-        disables SWD at startup and thus makes these pins available.
-
-config STM32_DFU_ROM_ADDRESS
-    hex
-    default 0 if !USB
-    default 0x1fffc400 if MACH_STM32F042
-    default 0x1fffc800 if MACH_STM32F072
-    default 0x1fff0000 if MACH_STM32F4 || MACH_STM32G0 || MACH_STM32G4 || MACH_STM32L4
-    default 0x1ff09800 if MACH_STM32H7
-    default 0
-
-
-######################################################################
-# Bootloader
-######################################################################
-
-choice
-    prompt "Bootloader offset"
-    config STM32_FLASH_START_2000
-        bool "8KiB bootloader" if MACH_STM32F103 || MACH_STM32F070 || MACH_STM32G0 || MACH_STM32F0x2
-    config STM32_FLASH_START_5000
-        bool "20KiB bootloader" if MACH_STM32F103
-    config STM32_FLASH_START_7000
-        bool "28KiB bootloader" if MACH_STM32F103
-    config STM32_FLASH_START_8000
-        bool "32KiB bootloader" if MACH_STM32F1 || MACH_STM32F2 || MACH_STM32F4
-    config STM32_FLASH_START_8800
-        bool "34KiB bootloader (Chitu v6 Bootloader)" if MACH_STM32F103
-    config STM32_FLASH_START_20200
-        bool "128KiB bootloader with 512 byte offset (Prusa Buddy)" if MACH_STM32F4x5
-    config STM32_FLASH_START_C000
-        bool "48KiB bootloader (MKS Robin Nano V3)" if MACH_STM32F4x5
-    config STM32_FLASH_START_10000
-        bool "64KiB bootloader" if MACH_STM32F103 || MACH_STM32F446 || MACH_STM32F401
-
-    config STM32_FLASH_START_800
-        bool "2KiB bootloader (HID Bootloader)" if MACH_STM32F103
-    config STM32_FLASH_START_1000
-        bool "4KiB bootloader" if MACH_STM32F1 || MACH_STM32F0
-    config STM32_FLASH_START_4000
-        bool "16KiB bootloader (HID Bootloader)" if MACH_STM32F207 || MACH_STM32F401 || MACH_STM32F4x5 || MACH_STM32F103 || MACH_STM32F072
-    config STM32_FLASH_START_20000
-        bool "128KiB bootloader (SKR SE BX v2.0)" if MACH_STM32H743 || MACH_STM32H723
-
-    config STM32_FLASH_START_0000
-        bool "No bootloader"
-endchoice
-config FLASH_APPLICATION_ADDRESS
-    hex
-    default 0x8000800 if STM32_FLASH_START_800
-    default 0x8001000 if STM32_FLASH_START_1000
-    default 0x8002000 if STM32_FLASH_START_2000
-    default 0x8004000 if STM32_FLASH_START_4000
-    default 0x8005000 if STM32_FLASH_START_5000
-    default 0x8007000 if STM32_FLASH_START_7000
-    default 0x8008000 if STM32_FLASH_START_8000
-    default 0x8008800 if STM32_FLASH_START_8800
-    default 0x800C000 if STM32_FLASH_START_C000
-    default 0x8010000 if STM32_FLASH_START_10000
-    default 0x8020000 if STM32_FLASH_START_20000
-    default 0x8020200 if STM32_FLASH_START_20200
-    default 0x8000000
-
-config ARMCM_RAM_VECTORTABLE
-    bool
-    default y if MACH_STM32F0 && FLASH_APPLICATION_ADDRESS != 0x8000000
-    default n
-
-
-######################################################################
-# Clock
-######################################################################
-
-choice
-    prompt "Clock Reference" if LOW_LEVEL_OPTIONS
-    config STM32_CLOCK_REF_8M
-        bool "8 MHz crystal"
-    config STM32_CLOCK_REF_12M
-        bool "12 MHz crystal"
-    config STM32_CLOCK_REF_16M
-        bool "16 MHz crystal"
-    config STM32_CLOCK_REF_20M
-        bool "20 MHz crystal"
-    config STM32_CLOCK_REF_25M
-        bool "25 MHz crystal"
-    config STM32_CLOCK_REF_INTERNAL
-        bool "Internal clock"
-endchoice
-config CLOCK_REF_FREQ
-    int
-    default 25000000 if STM32_CLOCK_REF_25M
-    default 20000000 if STM32_CLOCK_REF_20M
-    default 16000000 if STM32_CLOCK_REF_16M
-    default 12000000 if STM32_CLOCK_REF_12M
-    default 1 if STM32_CLOCK_REF_INTERNAL
-    default 8000000
-
-config STM32F0_TRIM
-    int "Internal clock trim override" if LOW_LEVEL_OPTIONS && MACH_STM32F0 && STM32_CLOCK_REF_INTERNAL && !USBSERIAL
-    default 16
-    help
-        Specify the internal clock trim value. Setting this can be
-        useful if the factory default internal clock is not accurate.
-        Default is 16 (use factory default). Each increment increases
-        the clock rate by ~240KHz.
-
-
-######################################################################
-# Communication inteface
-######################################################################
-
-choice
-    prompt "Communication interface"
-    config STM32_USB_PA11_PA12
-        bool "USB (on PA11/PA12)" if HAVE_STM32_USBFS || HAVE_STM32_USBOTG
-        select USBSERIAL
-    config STM32_USB_PA11_PA12_REMAP
-        bool "USB (on PA9/PA10)" if LOW_LEVEL_OPTIONS && MACH_STM32F042
-        select USBSERIAL
-    config STM32_USB_PB14_PB15
-        bool "USB (on PB14/PB15)"
-        depends on MACH_STM32H743 || MACH_STM32H750
-        select USBSERIAL
-    config STM32_SERIAL_USART1
-        bool "Serial (on USART1 PA10/PA9)"
-        select SERIAL
-    config STM32_SERIAL_USART1_ALT_PB7_PB6
-        bool "Serial (on USART1 PB7/PB6)" if LOW_LEVEL_OPTIONS
-        select SERIAL
-    config STM32_SERIAL_USART2
-        bool "Serial (on USART2 PA3/PA2)" if LOW_LEVEL_OPTIONS
-        select SERIAL
-    config STM32_SERIAL_USART2_ALT_PA15_PA14
-        bool "Serial (on USART2 PA15/PA14)" if LOW_LEVEL_OPTIONS && (MACH_STM32F0 || MACH_STM32G4)
-        select SERIAL
-    config STM32_SERIAL_USART2_ALT_PB4_PB3
-        bool "Serial (on USART2 PB4/PB3)" if LOW_LEVEL_OPTIONS && MACH_STM32G4
-        select SERIAL
-    config STM32_SERIAL_USART2_ALT_PD6_PD5
-        bool "Serial (on USART2 PD6/PD5)" if LOW_LEVEL_OPTIONS && !MACH_STM32F0
-        select SERIAL
-    config STM32_SERIAL_USART3
-        bool "Serial (on USART3 PB11/PB10)" if LOW_LEVEL_OPTIONS
-        depends on !MACH_STM32F0 && !MACH_STM32F401
-        select SERIAL
-    config STM32_SERIAL_USART3_ALT_PD9_PD8
-        bool "Serial (on USART3 PD9/PD8)" if LOW_LEVEL_OPTIONS
-        depends on !MACH_STM32F0 && !MACH_STM32F401
-        select SERIAL
-    config STM32_SERIAL_UART4
-        bool "Serial (on UART4 PA0/PA1)"
-        depends on MACH_STM32H7
-        select SERIAL
-    config STM32_CANBUS_PA11_PA12
-        bool "CAN bus (on PA11/PA12)"
-        depends on HAVE_STM32_CANBUS || HAVE_STM32_FDCANBUS
-        select CANSERIAL
-    config STM32_CANBUS_PA11_PA12_REMAP
-        bool "CAN bus (on PA9/PA10)" if LOW_LEVEL_OPTIONS
-        depends on HAVE_STM32_CANBUS && MACH_STM32F042
-        select CANSERIAL
-    config STM32_CANBUS_PA11_PB9
-        bool "CAN bus (on PA11/PB9)"
-        depends on HAVE_STM32_CANBUS || HAVE_STM32_FDCANBUS
-        select CANSERIAL
-    config STM32_MMENU_CANBUS_PB8_PB9
-        bool "CAN bus (on PB8/PB9)" if LOW_LEVEL_OPTIONS
-        depends on HAVE_STM32_CANBUS || HAVE_STM32_FDCANBUS
-        select CANSERIAL
-    config STM32_MMENU_CANBUS_PI9_PH13
-        bool "CAN bus (on PI9/PH13)" if LOW_LEVEL_OPTIONS
-        depends on HAVE_STM32_CANBUS && MACH_STM32F4
-        select CANSERIAL
-    config STM32_MMENU_CANBUS_PB5_PB6
-        bool "CAN bus (on PB5/PB6)" if LOW_LEVEL_OPTIONS
-        depends on HAVE_STM32_CANBUS && MACH_STM32F4
-        select CANSERIAL
-    config STM32_MMENU_CANBUS_PB12_PB13
-        bool "CAN bus (on PB12/PB13)" if LOW_LEVEL_OPTIONS
-        depends on HAVE_STM32_CANBUS && MACH_STM32F4
-        select CANSERIAL
-    config STM32_MMENU_CANBUS_PD0_PD1
-        bool "CAN bus (on PD0/PD1)" if LOW_LEVEL_OPTIONS
-        depends on HAVE_STM32_CANBUS || HAVE_STM32_FDCANBUS
-        select CANSERIAL
-    config STM32_MMENU_CANBUS_PB0_PB1
-        bool "CAN bus (on PB0/PB1)"
-        depends on HAVE_STM32_FDCANBUS
-        select CANSERIAL
-    config STM32_MMENU_CANBUS_PD12_PD13
-        bool "CAN bus (on PD12/PD13)"
-        depends on HAVE_STM32_FDCANBUS
-        select CANSERIAL
-    config STM32_MMENU_CANBUS_PC2_PC3
-        bool "CAN bus (on PC2/PC3)"
-        depends on HAVE_STM32_FDCANBUS
-        select CANSERIAL
-    config STM32_USBCANBUS_PA11_PA12
-        bool "USB to CAN bus bridge (USB on PA11/PA12)"
-        depends on HAVE_STM32_USBCANBUS
-        select USBCANBUS
-endchoice
-choice
-    prompt "CAN bus interface" if USBCANBUS
-    config STM32_CMENU_CANBUS_PB8_PB9
-        bool "CAN bus (on PB8/PB9)"
-    config STM32_CMENU_CANBUS_PI9_PH13
-        bool "CAN bus (on PI9/PH13)"
-        depends on HAVE_STM32_CANBUS && MACH_STM32F4
-    config STM32_CMENU_CANBUS_PB5_PB6
-        bool "CAN bus (on PB5/PB6)"
-        depends on HAVE_STM32_CANBUS && MACH_STM32F4
-    config STM32_CMENU_CANBUS_PB12_PB13
-        bool "CAN bus (on PB12/PB13)"
-        depends on HAVE_STM32_CANBUS && MACH_STM32F4
-    config STM32_CMENU_CANBUS_PD0_PD1
-        bool "CAN bus (on PD0/PD1)"
-        depends on HAVE_STM32_CANBUS || HAVE_STM32_FDCANBUS
-    config STM32_CMENU_CANBUS_PB0_PB1
-        bool "CAN bus (on PB0/PB1)"
-        depends on HAVE_STM32_FDCANBUS
-    config STM32_CMENU_CANBUS_PD12_PD13
-        bool "CAN bus (on PD12/PD13)"
-        depends on HAVE_STM32_FDCANBUS
-    config STM32_CMENU_CANBUS_PC2_PC3
-        bool "CAN bus (on PC2/PC3)"
-        depends on HAVE_STM32_FDCANBUS
-endchoice
-
-
-config STM32_CANBUS_PB8_PB9
-    bool
-    default y if STM32_MMENU_CANBUS_PB8_PB9 || STM32_CMENU_CANBUS_PB8_PB9
-config STM32_CANBUS_PI9_PH13
-    bool
-    default y if STM32_MMENU_CANBUS_PI9_PH13 || STM32_CMENU_CANBUS_PI9_PH13
-config STM32_CANBUS_PB5_PB6
-    bool
-    default y if STM32_MMENU_CANBUS_PB5_PB6 || STM32_CMENU_CANBUS_PB5_PB6
-config STM32_CANBUS_PB12_PB13
-    bool
-    default y if STM32_MMENU_CANBUS_PB12_PB13 || STM32_CMENU_CANBUS_PB12_PB13
-config STM32_CANBUS_PD0_PD1
-    bool
-    default y if STM32_MMENU_CANBUS_PD0_PD1 || STM32_CMENU_CANBUS_PD0_PD1
-config STM32_CANBUS_PB0_PB1
-    bool
-    default y if STM32_MMENU_CANBUS_PB0_PB1 || STM32_CMENU_CANBUS_PB0_PB1
-config STM32_CANBUS_PD12_PD13
-    bool
-    default y if STM32_MMENU_CANBUS_PD12_PD13 || STM32_CMENU_CANBUS_PD12_PD13
-config STM32_CANBUS_PC2_PC3
-    bool
-    default y if STM32_MMENU_CANBUS_PC2_PC3 || STM32_CMENU_CANBUS_PC2_PC3
-
-endif
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/Makefile crealityShit/src/stm32/Makefile
--- klipperStock/src/stm32/Makefile	2024-01-14 23:02:00.093796007 -0600
+++ crealityShit/src/stm32/Makefile	1969-12-31 18:00:00.000000000 -0600
@@ -1,102 +0,0 @@
-# Additional STM32 build rules
-
-# Setup the toolchain
-CROSS_PREFIX=arm-none-eabi-
-
-dirs-y += src/stm32 src/generic lib/fast-hash
-dirs-$(CONFIG_MACH_STM32F0) += lib/stm32f0
-dirs-$(CONFIG_MACH_STM32F1) += lib/stm32f1
-dirs-$(CONFIG_MACH_STM32F2) += lib/stm32f2
-dirs-$(CONFIG_MACH_STM32F4) += lib/stm32f4
-dirs-$(CONFIG_MACH_STM32G0) += lib/stm32g0
-dirs-$(CONFIG_MACH_STM32G4) += lib/stm32g4
-dirs-$(CONFIG_MACH_STM32H7) += lib/stm32h7
-dirs-$(CONFIG_MACH_STM32L4) += lib/stm32l4
-
-MCU := $(shell echo $(CONFIG_MCU))
-MCU_UPPER := $(shell echo $(CONFIG_MCU) | tr a-z A-Z | tr X x)
-
-CFLAGS-$(CONFIG_MACH_STM32F0) += -mcpu=cortex-m0 -Ilib/stm32f0/include
-CFLAGS-$(CONFIG_MACH_STM32F1) += -mcpu=cortex-m3 -Ilib/stm32f1/include
-CFLAGS-$(CONFIG_MACH_STM32F2) += -mcpu=cortex-m3 -Ilib/stm32f2/include
-CFLAGS-$(CONFIG_MACH_STM32F4) += -mcpu=cortex-m4 -Ilib/stm32f4/include
-CFLAGS-$(CONFIG_MACH_STM32G0) += -mcpu=cortex-m0plus -Ilib/stm32g0/include
-CFLAGS-$(CONFIG_MACH_STM32G4) += -mcpu=cortex-m4 -Ilib/stm32g4/include
-CFLAGS-$(CONFIG_MACH_STM32H7) += -mcpu=cortex-m7 -Ilib/stm32h7/include
-CFLAGS-$(CONFIG_MACH_STM32L4) += -mcpu=cortex-m4 -Ilib/stm32l4/include
-CFLAGS += $(CFLAGS-y) -D$(MCU_UPPER) -mthumb -Ilib/cmsis-core -Ilib/fast-hash
-
-CFLAGS_klipper.elf += --specs=nano.specs --specs=nosys.specs
-CFLAGS_klipper.elf += -T $(OUT)src/generic/armcm_link.ld
-$(OUT)klipper.elf: $(OUT)src/generic/armcm_link.ld
-
-# Add source files
-src-y += stm32/watchdog.c stm32/gpio.c stm32/clockline.c stm32/dfu_reboot.c
-src-y += generic/crc16_ccitt.c
-src-y += generic/armcm_boot.c generic/armcm_irq.c generic/armcm_reset.c
-src-$(CONFIG_MACH_STM32F0) += ../lib/stm32f0/system_stm32f0xx.c
-src-$(CONFIG_MACH_STM32F0) += generic/timer_irq.c stm32/stm32f0_timer.c
-src-$(CONFIG_MACH_STM32F0) += stm32/stm32f0.c stm32/gpioperiph.c
-src-$(CONFIG_MACH_STM32F0) += stm32/stm32f0_adc.c stm32/stm32f0_i2c.c
-src-$(CONFIG_MACH_STM32F1) += ../lib/stm32f1/system_stm32f1xx.c
-src-$(CONFIG_MACH_STM32F1) += stm32/stm32f1.c generic/armcm_timer.c
-src-$(CONFIG_MACH_STM32F1) += stm32/adc.c stm32/i2c.c
-src-$(CONFIG_MACH_STM32F2) += ../lib/stm32f2/system_stm32f2xx.c
-src-$(CONFIG_MACH_STM32F2) += stm32/stm32f4.c generic/armcm_timer.c
-src-$(CONFIG_MACH_STM32F2) += stm32/gpioperiph.c stm32/adc.c stm32/i2c.c
-src-$(CONFIG_MACH_STM32F4) += ../lib/stm32f4/system_stm32f4xx.c
-src-$(CONFIG_MACH_STM32F4) += stm32/stm32f4.c generic/armcm_timer.c
-src-$(CONFIG_MACH_STM32F4) += stm32/gpioperiph.c stm32/adc.c stm32/i2c.c
-src-$(CONFIG_MACH_STM32G0) += generic/timer_irq.c stm32/stm32f0_timer.c
-src-$(CONFIG_MACH_STM32G0) += stm32/stm32g0.c stm32/gpioperiph.c
-src-$(CONFIG_MACH_STM32G0) += stm32/stm32f0_adc.c stm32/stm32f0_i2c.c
-src-$(CONFIG_MACH_STM32G4) += ../lib/stm32g4/system_stm32g4xx.c
-src-$(CONFIG_MACH_STM32G4) += stm32/stm32g4.c generic/armcm_timer.c
-src-$(CONFIG_MACH_STM32G4) += stm32/gpioperiph.c stm32/stm32h7_adc.c
-src-$(CONFIG_MACH_STM32G4) += stm32/stm32f0_i2c.c
-src-$(CONFIG_MACH_STM32H7) += ../lib/stm32h7/system_stm32h7xx.c
-src-$(CONFIG_MACH_STM32H7) += stm32/stm32h7.c generic/armcm_timer.c
-src-$(CONFIG_MACH_STM32H7) += stm32/gpioperiph.c stm32/stm32h7_adc.c
-src-$(CONFIG_MACH_STM32L4) += ../lib/stm32l4/system_stm32l4xx.c
-src-$(CONFIG_MACH_STM32L4) += stm32/stm32l4.c generic/armcm_timer.c
-src-$(CONFIG_MACH_STM32L4) += stm32/gpioperiph.c
-src-$(CONFIG_MACH_STM32L4) += stm32/stm32h7_adc.c stm32/stm32f0_i2c.c
-spi-src-y := stm32/spi.c
-spi-src-$(CONFIG_MACH_STM32H7) := stm32/stm32h7_spi.c
-src-$(CONFIG_HAVE_GPIO_SPI) += $(spi-src-y)
-usb-src-$(CONFIG_HAVE_STM32_USBFS) := stm32/usbfs.c
-usb-src-$(CONFIG_HAVE_STM32_USBOTG) := stm32/usbotg.c
-src-$(CONFIG_USBSERIAL) += $(usb-src-y) stm32/chipid.c generic/usb_cdc.c
-serial-src-y := stm32/serial.c
-serial-src-$(CONFIG_MACH_STM32F0) := stm32/stm32f0_serial.c
-serial-src-$(CONFIG_MACH_STM32G0) := stm32/stm32f0_serial.c
-serial-src-$(CONFIG_MACH_STM32G4) := stm32/stm32f0_serial.c
-serial-src-$(CONFIG_MACH_STM32H7) := stm32/stm32f0_serial.c
-src-$(CONFIG_SERIAL) += $(serial-src-y) generic/serial_irq.c
-canbus-src-y := generic/canserial.c ../lib/fast-hash/fasthash.c
-canbus-src-$(CONFIG_HAVE_STM32_CANBUS) += stm32/can.c
-canbus-src-$(CONFIG_HAVE_STM32_FDCANBUS) += stm32/fdcan.c
-src-$(CONFIG_CANSERIAL) += $(canbus-src-y) generic/canbus.c stm32/chipid.c
-src-$(CONFIG_USBCANBUS) += $(usb-src-y) $(canbus-src-y)
-src-$(CONFIG_USBCANBUS) += stm32/chipid.c generic/usb_canbus.c
-src-$(CONFIG_HAVE_GPIO_HARD_PWM) += stm32/hard_pwm.c
-
-# Binary output file rules
-target-y += $(OUT)klipper.bin
-
-$(OUT)klipper.bin: $(OUT)klipper.elf
-	@echo "  Creating hex file $@"
-	$(Q)$(OBJCOPY) -O binary $< $@
-
-# Flash rules
-lib/hidflash/hid-flash:
-	@echo "  Building hid-flash"
-	$(Q)make -C lib/hidflash
-
-flash: $(OUT)klipper.bin lib/hidflash/hid-flash
-	@echo "  Flashing $< to $(FLASH_DEVICE)"
-	$(Q)$(PYTHON) ./scripts/flash_usb.py -t $(CONFIG_MCU) -d "$(FLASH_DEVICE)" -s "$(CONFIG_FLASH_APPLICATION_ADDRESS)" $(if $(NOSUDO),--no-sudo) $(OUT)klipper.bin
-
-serialflash: $(OUT)klipper.bin
-	@echo "  Flashing $< to $(FLASH_DEVICE) via stm32flash"
-	$(Q)stm32flash -w $< -v -g 0 $(FLASH_DEVICE)
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/serial.c crealityShit/src/stm32/serial.c
--- klipperStock/src/stm32/serial.c	2024-01-14 23:02:00.097796058 -0600
+++ crealityShit/src/stm32/serial.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,96 +0,0 @@
-// STM32 serial
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_SERIAL_BAUD
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/serial_irq.h" // serial_rx_byte
-#include "command.h" // DECL_CONSTANT_STR
-#include "internal.h" // enable_pclock
-#include "sched.h" // DECL_INIT
-
-// Select the configured serial port
-#if CONFIG_STM32_SERIAL_USART1
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "PA10,PA9");
-  #define GPIO_Rx GPIO('A', 10)
-  #define GPIO_Tx GPIO('A', 9)
-  #define USARTx USART1
-  #define USARTx_IRQn USART1_IRQn
-#elif CONFIG_STM32_SERIAL_USART1_ALT_PB7_PB6
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "PB7,PB6");
-  #define GPIO_Rx GPIO('B', 7)
-  #define GPIO_Tx GPIO('B', 6)
-  #define USARTx USART1
-  #define USARTx_IRQn USART1_IRQn
-#elif CONFIG_STM32_SERIAL_USART2
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "PA3,PA2");
-  #define GPIO_Rx GPIO('A', 3)
-  #define GPIO_Tx GPIO('A', 2)
-  #define USARTx USART2
-  #define USARTx_IRQn USART2_IRQn
-#elif CONFIG_STM32_SERIAL_USART2_ALT_PD6_PD5
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "PD6,PD5");
-  #define GPIO_Rx GPIO('D', 6)
-  #define GPIO_Tx GPIO('D', 5)
-  #define USARTx USART2
-  #define USARTx_IRQn USART2_IRQn
-#elif CONFIG_STM32_SERIAL_USART3
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "PB11,PB10");
-  #define GPIO_Rx GPIO('B', 11)
-  #define GPIO_Tx GPIO('B', 10)
-  #define USARTx USART3
-  #define USARTx_IRQn USART3_IRQn
-#elif CONFIG_STM32_SERIAL_USART3_ALT_PD9_PD8
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "PD9,PD8");
-  #define GPIO_Rx GPIO('D', 9)
-  #define GPIO_Tx GPIO('D', 8)
-  #define USARTx USART3
-  #define USARTx_IRQn USART3_IRQn
-#endif
-
-#define CR1_FLAGS (USART_CR1_UE | USART_CR1_RE | USART_CR1_TE   \
-                   | USART_CR1_RXNEIE)
-
-void
-USARTx_IRQHandler(void)
-{
-    uint32_t sr = USARTx->SR;
-    if (sr & (USART_SR_RXNE | USART_SR_ORE)) {
-        // The ORE flag is automatically cleared by reading SR, followed
-        // by reading DR.
-        serial_rx_byte(USARTx->DR);
-    }
-    if (sr & USART_SR_TXE && USARTx->CR1 & USART_CR1_TXEIE) {
-        uint8_t data;
-        int ret = serial_get_tx_byte(&data);
-        if (ret)
-            USARTx->CR1 = CR1_FLAGS;
-        else
-            USARTx->DR = data;
-    }
-}
-
-void
-serial_enable_tx_irq(void)
-{
-    USARTx->CR1 = CR1_FLAGS | USART_CR1_TXEIE;
-}
-
-void
-serial_init(void)
-{
-    enable_pclock((uint32_t)USARTx);
-
-    uint32_t pclk = get_pclock_frequency((uint32_t)USARTx);
-    uint32_t div = DIV_ROUND_CLOSEST(pclk, CONFIG_SERIAL_BAUD);
-    USARTx->BRR = (((div / 16) << USART_BRR_DIV_Mantissa_Pos)
-                   | ((div % 16) << USART_BRR_DIV_Fraction_Pos));
-    USARTx->CR1 = CR1_FLAGS;
-    armcm_enable_irq(USARTx_IRQHandler, USARTx_IRQn, 0);
-
-    gpio_peripheral(GPIO_Rx, GPIO_FUNCTION(7), 1);
-    gpio_peripheral(GPIO_Tx, GPIO_FUNCTION(7), 0);
-}
-DECL_INIT(serial_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/spi.c crealityShit/src/stm32/spi.c
--- klipperStock/src/stm32/spi.c	2024-01-14 23:02:00.097796058 -0600
+++ crealityShit/src/stm32/spi.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,137 +0,0 @@
-// SPI functions on STM32
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/io.h" // readb, writeb
-#include "command.h" // shutdown
-#include "gpio.h" // spi_setup
-#include "internal.h" // gpio_peripheral
-#include "sched.h" // sched_shutdown
-
-struct spi_info {
-    SPI_TypeDef *spi;
-    uint8_t miso_pin, mosi_pin, sck_pin, function;
-};
-
-DECL_ENUMERATION("spi_bus", "spi2", 0);
-DECL_CONSTANT_STR("BUS_PINS_spi2", "PB14,PB15,PB13");
-DECL_ENUMERATION("spi_bus", "spi1", 1);
-DECL_CONSTANT_STR("BUS_PINS_spi1", "PA6,PA7,PA5");
-DECL_ENUMERATION("spi_bus", "spi1a", 2);
-DECL_CONSTANT_STR("BUS_PINS_spi1a", "PB4,PB5,PB3");
-#if CONFIG_MACH_STM32G4
- DECL_ENUMERATION("spi_bus", "spi2_PA10_PA11_PF1", 3);
- DECL_CONSTANT_STR("BUS_PINS_spi2_PA10_PA11_PF1", "PA10,PA11,PF1");
-#elif !CONFIG_MACH_STM32F1
- DECL_ENUMERATION("spi_bus", "spi2a", 3);
- DECL_CONSTANT_STR("BUS_PINS_spi2a", "PC2,PC3,PB10");
-#endif
-#ifdef SPI3
- DECL_ENUMERATION("spi_bus", "spi3", 4);
- DECL_CONSTANT_STR("BUS_PINS_spi3", "PB4,PB5,PB3");
- #if CONFIG_MACH_STM32F4 || CONFIG_MACH_STM32G4
-  DECL_ENUMERATION("spi_bus", "spi3a", 5);
-  DECL_CONSTANT_STR("BUS_PINS_spi3a", "PC11,PC12,PC10");
-  #ifdef SPI4
-   DECL_ENUMERATION("spi_bus", "spi4", 6);
-   DECL_CONSTANT_STR("BUS_PINS_spi4", "PE13,PE14,PE12");
-  #elif defined(GPIOI)
-   DECL_ENUMERATION("spi_bus", "spi2b", 6);
-   DECL_CONSTANT_STR("BUS_PINS_spi2b", "PI2,PI3,PI1");
-  #endif
- #endif
-#endif
-
-#if CONFIG_MACH_STM32F0 || CONFIG_MACH_STM32G0
- #define SPI_FUNCTION GPIO_FUNCTION(0)
-#else
- #define SPI_FUNCTION GPIO_FUNCTION(5)
-#endif
-
-static const struct spi_info spi_bus[] = {
-    { SPI2, GPIO('B', 14), GPIO('B', 15), GPIO('B', 13), SPI_FUNCTION },
-    { SPI1, GPIO('A', 6), GPIO('A', 7), GPIO('A', 5), SPI_FUNCTION },
-    { SPI1, GPIO('B', 4), GPIO('B', 5), GPIO('B', 3), SPI_FUNCTION },
-#if CONFIG_MACH_STM32G4
-    { SPI2, GPIO('A', 10), GPIO('A', 11), GPIO('F', 1), SPI_FUNCTION },
-#else
-    { SPI2, GPIO('C', 2), GPIO('C', 3), GPIO('B', 10), SPI_FUNCTION },
-#endif
-#ifdef SPI3
-    { SPI3, GPIO('B', 4), GPIO('B', 5), GPIO('B', 3), GPIO_FUNCTION(6) },
- #if CONFIG_MACH_STM32F4 || CONFIG_MACH_STM32G4
-    { SPI3, GPIO('C', 11), GPIO('C', 12), GPIO('C', 10), GPIO_FUNCTION(6) },
-  #ifdef SPI4
-    { SPI4, GPIO('E', 13), GPIO('E', 14), GPIO('E', 12), GPIO_FUNCTION(5) },
-  #elif defined(GPIOI)
-    { SPI2, GPIO('I', 2), GPIO('I', 3), GPIO('I', 1), GPIO_FUNCTION(5) },
-  #endif
- #endif
-#endif
-};
-
-struct spi_config
-spi_setup(uint32_t bus, uint8_t mode, uint32_t rate)
-{
-    if (bus >= ARRAY_SIZE(spi_bus))
-        shutdown("Invalid spi bus");
-
-    // Enable SPI
-    SPI_TypeDef *spi = spi_bus[bus].spi;
-    if (!is_enabled_pclock((uint32_t)spi)) {
-        enable_pclock((uint32_t)spi);
-        gpio_peripheral(spi_bus[bus].miso_pin, spi_bus[bus].function, 1);
-        gpio_peripheral(spi_bus[bus].mosi_pin, spi_bus[bus].function, 0);
-        gpio_peripheral(spi_bus[bus].sck_pin, spi_bus[bus].function, 0);
-
-        // Configure CR2 on stm32 f0/g0/l4/g4
-#if CONFIG_MACH_STM32F0 || CONFIG_MACH_STM32G0 || CONFIG_MACH_STM32L4 \
-    || CONFIG_MACH_STM32G4
-        spi->CR2 = SPI_CR2_FRXTH | (7 << SPI_CR2_DS_Pos);
-#endif
-    }
-
-    // Calculate CR1 register
-    uint32_t pclk = get_pclock_frequency((uint32_t)spi);
-    uint32_t div = 0;
-    while ((pclk >> (div + 1)) > rate && div < 7)
-        div++;
-    uint32_t cr1 = ((mode << SPI_CR1_CPHA_Pos) | (div << SPI_CR1_BR_Pos)
-                    | SPI_CR1_SPE | SPI_CR1_MSTR | SPI_CR1_SSM | SPI_CR1_SSI);
-
-    return (struct spi_config){ .spi = spi, .spi_cr1 = cr1 };
-}
-
-void
-spi_prepare(struct spi_config config)
-{
-    SPI_TypeDef *spi = config.spi;
-    uint32_t cr1 = spi->CR1;
-    if (cr1 == config.spi_cr1)
-        return;
-    // The SPE bit must be disabled before changing CPOL/CPHA bits
-    spi->CR1 = cr1 & ~SPI_CR1_SPE;
-    spi->CR1; // Force flush of previous write
-    spi->CR1 = config.spi_cr1;
-}
-
-void
-spi_transfer(struct spi_config config, uint8_t receive_data,
-             uint8_t len, uint8_t *data)
-{
-    SPI_TypeDef *spi = config.spi;
-    while (len--) {
-        writeb((void*)&spi->DR, *data);
-        while (!(spi->SR & SPI_SR_RXNE))
-            ;
-        uint8_t rdata = readb((void*)&spi->DR);
-        if (receive_data)
-            *data = rdata;
-        data++;
-    }
-    // Wait for any remaining SCLK updates before returning
-    while ((spi->SR & (SPI_SR_TXE|SPI_SR_BSY)) != SPI_SR_TXE)
-        ;
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/stm32f0_adc.c crealityShit/src/stm32/stm32f0_adc.c
--- klipperStock/src/stm32/stm32f0_adc.c	2024-01-14 23:02:00.105796157 -0600
+++ crealityShit/src/stm32/stm32f0_adc.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,159 +0,0 @@
-// ADC functions on STM32
-//
-// Copyright (C) 2019-2020  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/irq.h" // irq_save
-#include "board/misc.h" // timer_from_us
-#include "command.h" // shutdown
-#include "compiler.h" // ARRAY_SIZE
-#include "generic/armcm_timer.h" // udelay
-#include "gpio.h" // gpio_adc_setup
-#include "internal.h" // GPIO
-#include "sched.h" // sched_shutdown
-
-DECL_CONSTANT("ADC_MAX", 4095);
-
-#define ADC_TEMPERATURE_PIN 0xfe
-DECL_ENUMERATION("pin", "ADC_TEMPERATURE", ADC_TEMPERATURE_PIN);
-
-static const uint8_t adc_pins[] = {
-    GPIO('A', 0), GPIO('A', 1), GPIO('A', 2), GPIO('A', 3),
-    GPIO('A', 4), GPIO('A', 5), GPIO('A', 6), GPIO('A', 7),
-    GPIO('B', 0), GPIO('B', 1),
-#if CONFIG_MACH_STM32F0
-    GPIO('C', 0), GPIO('C', 1),
-    GPIO('C', 2), GPIO('C', 3), GPIO('C', 4), GPIO('C', 5),
-    ADC_TEMPERATURE_PIN
-#elif CONFIG_MACH_STM32G0
-    GPIO('B', 2), GPIO('B', 10),
-    ADC_TEMPERATURE_PIN, 0x00, 0x00,
-    GPIO('B', 11), GPIO('B', 12), GPIO('C', 4), GPIO('C', 5),
-#endif
-};
-
-// Setup and calibrate ADC on stm32f0 chips
-static void
-stm32f0_adc_setup(void)
-{
-#if CONFIG_MACH_STM32F0
-    #define CR_FLAGS 0
-    ADC_TypeDef *adc = ADC1;
-    // 100: 41.5 ADC clock cycles
-    adc->SMPR = 4 << ADC_SMPR_SMP_Pos;
-#endif
-}
-
-// Setup and calibrate ADC on stm32g0 chips
-static void
-stm32g0_adc_setup(void)
-{
-#if CONFIG_MACH_STM32G0
-    #define CR_FLAGS ADC_CR_ADVREGEN
-    ADC_TypeDef *adc = ADC1;
-    // 101: 39.5 ADC clock cycles
-    adc->SMPR = 5 << ADC_SMPR_SMP1_Pos;
-    adc->CFGR2 = 2 << ADC_CFGR2_CKMODE_Pos; // 16Mhz
-
-    // Enable voltage regulator
-    adc->CR = CR_FLAGS;
-    uint32_t end = timer_read_time() + timer_from_us(20);
-    while (timer_is_before(timer_read_time(), end))
-        ;
-#endif
-}
-
-struct gpio_adc
-gpio_adc_setup(uint32_t pin)
-{
-    // Find pin in adc_pins table
-    int chan;
-    for (chan=0; ; chan++) {
-        if (chan >= ARRAY_SIZE(adc_pins))
-            shutdown("Not a valid ADC pin");
-        if (adc_pins[chan] == pin)
-            break;
-    }
-
-    // Enable the ADC
-    if (!is_enabled_pclock(ADC1_BASE)) {
-        enable_pclock(ADC1_BASE);
-        if (CONFIG_MACH_STM32F0)
-            stm32f0_adc_setup();
-        else if (CONFIG_MACH_STM32G0)
-            stm32g0_adc_setup();
-
-        // Start calibration and wait for completion
-        ADC_TypeDef *adc = ADC1;
-        adc->CR = CR_FLAGS | ADC_CR_ADCAL;
-        while (adc->CR & ADC_CR_ADCAL)
-            ;
-        // Enable ADC
-        adc->ISR = ADC_ISR_ADRDY;
-        adc->ISR; // Dummy read to make sure write is flushed
-        adc->CR = CR_FLAGS | ADC_CR_ADEN;
-        while (!(adc->ISR & ADC_ISR_ADRDY))
-            ;
-    }
-
-    if (pin == ADC_TEMPERATURE_PIN)
-        ADC1_COMMON->CCR = ADC_CCR_TSEN;
-    else
-        gpio_peripheral(pin, GPIO_ANALOG, 0);
-
-    return (struct gpio_adc){ .chan = 1 << chan };
-}
-
-// Try to sample a value. Returns zero if sample ready, otherwise
-// returns the number of clock ticks the caller should wait before
-// retrying this function.
-uint32_t
-gpio_adc_sample(struct gpio_adc g)
-{
-    ADC_TypeDef *adc = ADC1;
-    if (adc->CR & ADC_CR_ADSTART)
-        goto need_delay;
-    if (adc->ISR & ADC_ISR_EOC) {
-        if (adc->CHSELR == g.chan)
-            return 0;
-        goto need_delay;
-    }
-#if CONFIG_MACH_STM32G0
-    if (adc->CHSELR != g.chan) {
-        adc->ISR = ADC_ISR_CCRDY;
-        adc->CHSELR = g.chan;
-        while (!(adc->ISR & ADC_ISR_CCRDY))
-            ;
-    }
-#else
-    adc->CHSELR = g.chan;
-#endif
-    adc->CR = CR_FLAGS | ADC_CR_ADSTART;
-
-need_delay:
-    return timer_from_us(10);
-}
-
-// Read a value; use only after gpio_adc_sample() returns zero
-uint16_t
-gpio_adc_read(struct gpio_adc g)
-{
-    ADC_TypeDef *adc = ADC1;
-    return adc->DR;
-}
-
-// Cancel a sample that may have been started with gpio_adc_sample()
-void
-gpio_adc_cancel_sample(struct gpio_adc g)
-{
-    ADC_TypeDef *adc = ADC1;
-    irqstatus_t flag = irq_save();
-    if (adc->CHSELR == g.chan) {
-        if (adc->CR & ADC_CR_ADSTART)
-            adc->CR = CR_FLAGS | ADC_CR_ADSTP;
-        if (adc->ISR & ADC_ISR_EOC)
-            gpio_adc_read(g);
-    }
-    irq_restore(flag);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/stm32f0.c crealityShit/src/stm32/stm32f0.c
--- klipperStock/src/stm32/stm32f0.c	2024-01-14 23:02:00.105796157 -0600
+++ crealityShit/src/stm32/stm32f0.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,195 +0,0 @@
-// Code to setup clocks on stm32f0
-//
-// Copyright (C) 2019-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_CLOCK_REF_FREQ
-#include "board/armcm_boot.h" // armcm_main
-#include "board/armcm_reset.h" // try_request_canboot
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // bootloader_request
-#include "command.h" // DECL_CONSTANT_STR
-#include "internal.h" // enable_pclock
-#include "sched.h" // sched_main
-
-
-/****************************************************************
- * Clock setup
- ****************************************************************/
-
-#define FREQ_PERIPH 48000000
-
-// Map a peripheral address to its enable bits
-struct cline
-lookup_clock_line(uint32_t periph_base)
-{
-    if (periph_base >= AHB2PERIPH_BASE) {
-        uint32_t bit = 1 << ((periph_base - AHB2PERIPH_BASE) / 0x400 + 17);
-        return (struct cline){.en=&RCC->AHBENR, .rst=&RCC->AHBRSTR, .bit=bit};
-    } else if (periph_base >= SYSCFG_BASE) {
-        uint32_t bit = 1 << ((periph_base - SYSCFG_BASE) / 0x400);
-        return (struct cline){.en=&RCC->APB2ENR, .rst=&RCC->APB2RSTR, .bit=bit};
-    } else {
-        uint32_t bit = 1 << ((periph_base - APBPERIPH_BASE) / 0x400);
-        return (struct cline){.en=&RCC->APB1ENR, .rst=&RCC->APB1RSTR, .bit=bit};
-    }
-}
-
-// Return the frequency of the given peripheral clock
-uint32_t
-get_pclock_frequency(uint32_t periph_base)
-{
-    return FREQ_PERIPH;
-}
-
-// Enable a GPIO peripheral clock
-void
-gpio_clock_enable(GPIO_TypeDef *regs)
-{
-    uint32_t rcc_pos = ((uint32_t)regs - AHB2PERIPH_BASE) / 0x400;
-    RCC->AHBENR |= 1 << (rcc_pos + 17);
-    RCC->AHBENR;
-}
-
-#if !CONFIG_STM32_CLOCK_REF_INTERNAL
-DECL_CONSTANT_STR("RESERVE_PINS_crystal", "PF0,PF1");
-#endif
-
-// Configure and enable the PLL as clock source
-static void
-pll_setup(void)
-{
-    uint32_t cfgr;
-    if (!CONFIG_STM32_CLOCK_REF_INTERNAL) {
-        // Configure 48Mhz PLL from external crystal (HSE)
-        uint32_t div = CONFIG_CLOCK_FREQ / CONFIG_CLOCK_REF_FREQ;
-        RCC->CR = ((RCC->CR & ~RCC_CR_HSITRIM) | RCC_CR_HSEON
-                   | (CONFIG_STM32F0_TRIM << RCC_CR_HSITRIM_Pos));
-        cfgr = RCC_CFGR_PLLSRC_HSE_PREDIV | ((div - 2) << RCC_CFGR_PLLMUL_Pos);
-    } else {
-        // Configure 48Mhz PLL from internal 8Mhz oscillator (HSI)
-        uint32_t div2 = (CONFIG_CLOCK_FREQ / 8000000) * 2;
-        cfgr = RCC_CFGR_PLLSRC_HSI_DIV2 | ((div2 - 2) << RCC_CFGR_PLLMUL_Pos);
-    }
-    RCC->CFGR = cfgr;
-    RCC->CR |= RCC_CR_PLLON;
-
-    // Wait for PLL lock
-    while (!(RCC->CR & RCC_CR_PLLRDY))
-        ;
-
-    // Switch system clock to PLL
-    RCC->CFGR = cfgr | RCC_CFGR_SW_PLL;
-    while ((RCC->CFGR & RCC_CFGR_SWS_Msk) != RCC_CFGR_SWS_PLL)
-        ;
-
-    // Setup CFGR3 register
-    uint32_t cfgr3 = RCC_CFGR3_I2C1SW;
-#if CONFIG_USB
-        // Select PLL as source for USB clock
-        cfgr3 |= RCC_CFGR3_USBSW;
-#endif
-    RCC->CFGR3 = cfgr3;
-}
-
-// Configure and enable internal 48Mhz clock on the stm32f042
-static void
-hsi48_setup(void)
-{
-#if CONFIG_MACH_STM32F0x2
-    // Enable HSI48
-    RCC->CR2 |= RCC_CR2_HSI48ON;
-    while (!(RCC->CR2 & RCC_CR2_HSI48RDY))
-        ;
-
-    // Switch system clock to HSI48
-    RCC->CFGR = RCC_CFGR_SW_HSI48;
-    while ((RCC->CFGR & RCC_CFGR_SWS_Msk) != RCC_CFGR_SWS_HSI48)
-        ;
-
-    // Enable USB clock recovery
-    if (CONFIG_USB) {
-        enable_pclock(CRS_BASE);
-        CRS->CR |= CRS_CR_AUTOTRIMEN | CRS_CR_CEN;
-    }
-
-    // Setup I2C1 clock
-    RCC->CFGR3 = RCC_CFGR3_I2C1SW;
-#endif
-}
-
-// Enable high speed internal 14Mhz clock for ADC
-static void
-hsi14_setup(void)
-{
-    // Enable HSI14 for ADC
-    RCC->CR2 = RCC_CR2_HSI14ON;
-    while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
-        ;
-}
-
-
-/****************************************************************
- * Bootloader
- ****************************************************************/
-
-// Handle reboot requests
-void
-bootloader_request(void)
-{
-    try_request_canboot();
-    dfu_reboot();
-}
-
-
-/****************************************************************
- * Startup
- ****************************************************************/
-
-// Copy vector table and remap ram so new vector table is used
-static void
-enable_ram_vectortable(void)
-{
-    // Symbols created by armcm_link.lds.S linker script
-    extern uint32_t _ram_vectortable_start, _ram_vectortable_end;
-    extern uint32_t _text_vectortable_start;
-
-    uint32_t count = (&_ram_vectortable_end - &_ram_vectortable_start) * 4;
-    __builtin_memcpy(&_ram_vectortable_start, &_text_vectortable_start, count);
-    barrier();
-
-    SYSCFG->CFGR1 |= 3 << SYSCFG_CFGR1_MEM_MODE_Pos;
-}
-
-// Main entry point - called from armcm_boot.c:ResetHandler()
-void
-armcm_main(void)
-{
-    dfu_reboot_check();
-    SystemInit();
-
-    enable_pclock(SYSCFG_BASE);
-    if (CONFIG_ARMCM_RAM_VECTORTABLE)
-        enable_ram_vectortable();
-
-    // Set flash latency
-    FLASH->ACR = (1 << FLASH_ACR_LATENCY_Pos) | FLASH_ACR_PRFTBE;
-
-    // Configure main clock
-    if (CONFIG_MACH_STM32F0x2 && CONFIG_STM32_CLOCK_REF_INTERNAL && CONFIG_USB)
-        hsi48_setup();
-    else
-        pll_setup();
-
-    // Turn on hsi14 oscillator for ADC
-    hsi14_setup();
-
-    // Support pin remapping USB/CAN pins on low pinout stm32f042
-#ifdef SYSCFG_CFGR1_PA11_PA12_RMP
-    if (CONFIG_STM32_USB_PA11_PA12_REMAP || CONFIG_STM32_CANBUS_PA11_PA12_REMAP)
-        SYSCFG->CFGR1 |= SYSCFG_CFGR1_PA11_PA12_RMP;
-#endif
-
-    sched_main();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/stm32f0_i2c.c crealityShit/src/stm32/stm32f0_i2c.c
--- klipperStock/src/stm32/stm32f0_i2c.c	2024-01-14 23:02:00.101796106 -0600
+++ crealityShit/src/stm32/stm32f0_i2c.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,179 +0,0 @@
-// I2C functions on stm32f0
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/misc.h" // timer_is_before
-#include "command.h" // shutdown
-#include "gpio.h" // i2c_setup
-#include "internal.h" // GPIO
-#include "sched.h" // sched_shutdown
-
-struct i2c_info {
-    I2C_TypeDef *i2c;
-    uint8_t scl_pin, sda_pin, function;
-};
-
-#if CONFIG_MACH_STM32F0
-DECL_ENUMERATION("i2c_bus", "i2c1_PB6_PB7", 0);
-DECL_CONSTANT_STR("BUS_PINS_i2c1_PB6_PB7", "PB6,PB7");
-DECL_ENUMERATION("i2c_bus", "i2c1_PF1_PF0", 1);
-DECL_CONSTANT_STR("BUS_PINS_i2c1_PF1_PF0", "PF1,PF0");
-DECL_ENUMERATION("i2c_bus", "i2c1_PB8_PB9", 2);
-DECL_CONSTANT_STR("BUS_PINS_i2c1_PB8_PB9", "PB8,PB9");
-// Deprecated "i2c1a" style mappings
-DECL_ENUMERATION("i2c_bus", "i2c1", 0);
-DECL_CONSTANT_STR("BUS_PINS_i2c1", "PB6,PB7");
-DECL_ENUMERATION("i2c_bus", "i2c1a", 1);
-DECL_CONSTANT_STR("BUS_PINS_i2c1a", "PF1,PF0");
-
-#elif CONFIG_MACH_STM32G0 || CONFIG_MACH_STM32L4
-DECL_ENUMERATION("i2c_bus", "i2c1_PB6_PB7", 0);
-DECL_CONSTANT_STR("BUS_PINS_i2c1_PB6_PB7", "PB6,PB7");
-DECL_ENUMERATION("i2c_bus", "i2c1_PB8_PB9", 1);
-DECL_CONSTANT_STR("BUS_PINS_i2c1_PB8_PB9", "PB8,PB9");
-#if CONFIG_MACH_STM32G0
-#define GPIO_AF_INDEX 6
-DECL_ENUMERATION("i2c_bus", "i2c3_PB3_PB4", 2);
-DECL_CONSTANT_STR("BUS_PINS_i2c3_PB3_PB4", "PB3,PB4");
-#elif CONFIG_MACH_STM32L4
-#define GPIO_AF_INDEX 4
-DECL_ENUMERATION("i2c_bus", "i2c3_PA7_PB4", 2);
-DECL_CONSTANT_STR("BUS_PINS_i2c3_PA7_PB4", "PA7,PB4");
-#endif
-DECL_ENUMERATION("i2c_bus", "i2c2_PB10_PB11", 3);
-DECL_CONSTANT_STR("BUS_PINS_i2c2_PB10_PB11", "PB10,PB11");
-DECL_ENUMERATION("i2c_bus", "i2c2_PB13_PB14", 4);
-DECL_CONSTANT_STR("BUS_PINS_i2c2_PB13_PB14", "PB13,PB14");
-DECL_ENUMERATION("i2c_bus", "i2c1_PA9_PA10", 5);
-DECL_CONSTANT_STR("BUS_PINS_i2c1_PA9_PA10", "PA9,PA10");
-#elif CONFIG_MACH_STM32G4
-DECL_ENUMERATION("i2c_bus", "i2c1_PA13_PA14", 0);
-DECL_CONSTANT_STR("BUS_PINS_i2c1_PA13_PA14", "PA13,PA14");
-DECL_ENUMERATION("i2c_bus", "i2c1_PA15_PA14", 1);
-DECL_CONSTANT_STR("BUS_PINS_i2c1_PA15_PA14", "PA15,PA14");
-DECL_ENUMERATION("i2c_bus", "i2c1_PB8_PB7", 2);
-DECL_CONSTANT_STR("BUS_PINS_i2c1_PB8_PB7", "PB8,PB7");
-DECL_ENUMERATION("i2c_bus", "i2c1_PB8_PB9", 3);
-DECL_CONSTANT_STR("BUS_PINS_i2c1_PB8_PB9", "PB8,PB9");
-DECL_ENUMERATION("i2c_bus", "i2c2_PA9_PA8", 4);
-DECL_CONSTANT_STR("BUS_PINS_i2c2_PA9_PA8", "PA9,PA8");
-DECL_ENUMERATION("i2c_bus", "i2c2_PC4_PF0", 5);
-DECL_CONSTANT_STR("BUS_PINS_i2c2_PC4_PF0", "PC4,PF0");
-DECL_ENUMERATION("i2c_bus", "i2c3_PC8_PC9", 6);
-DECL_CONSTANT_STR("BUS_PINS_i2c3_PC8_PC9", "PC8,PC9");
-DECL_ENUMERATION("i2c_bus", "i2c3_PC8_PC11", 7);
-DECL_CONSTANT_STR("BUS_PINS_i2c3_PC8_PC11", "PC8,PC11");
-#endif
-
-static const struct i2c_info i2c_bus[] = {
-#if CONFIG_MACH_STM32F0
-    { I2C1, GPIO('B', 6), GPIO('B', 7), GPIO_FUNCTION(1) },
-    { I2C1, GPIO('F', 1), GPIO('F', 0), GPIO_FUNCTION(1) },
-    { I2C1, GPIO('B', 8), GPIO('B', 9), GPIO_FUNCTION(1) },
-
-#elif CONFIG_MACH_STM32G0 || CONFIG_MACH_STM32L4
-    { I2C1, GPIO('B', 6), GPIO('B', 7), GPIO_FUNCTION(GPIO_AF_INDEX) },
-    { I2C1, GPIO('B', 8), GPIO('B', 9), GPIO_FUNCTION(GPIO_AF_INDEX) },
-#if CONFIG_MACH_STM32G0
-    { I2C3, GPIO('B', 3), GPIO('B', 4), GPIO_FUNCTION(GPIO_AF_INDEX) },
-#elif CONFIG_MACH_STM32L4
-    { I2C3, GPIO('A', 7), GPIO('B', 4), GPIO_FUNCTION(GPIO_AF_INDEX) },
-#endif
-    { I2C2, GPIO('B', 10), GPIO('B', 11), GPIO_FUNCTION(GPIO_AF_INDEX) },
-    { I2C2, GPIO('B', 13), GPIO('B', 14), GPIO_FUNCTION(GPIO_AF_INDEX) },
-    { I2C1, GPIO('A', 9), GPIO('A', 10), GPIO_FUNCTION(GPIO_AF_INDEX) },
-#elif CONFIG_MACH_STM32G4
-    { I2C1, GPIO('A', 13), GPIO('A', 14), GPIO_FUNCTION(4) },
-    { I2C1, GPIO('A', 15), GPIO('A', 14), GPIO_FUNCTION(4) },
-    { I2C1, GPIO('B', 8), GPIO('B', 7), GPIO_FUNCTION(4) },
-    { I2C1, GPIO('B', 8), GPIO('B', 9), GPIO_FUNCTION(4) },
-    { I2C2, GPIO('A', 9), GPIO('A', 8), GPIO_FUNCTION(4) },
-    { I2C2, GPIO('C', 4), GPIO('F', 0), GPIO_FUNCTION(4) },
-    { I2C3, GPIO('C', 8), GPIO('C', 9), GPIO_FUNCTION(8) },
-    { I2C3, GPIO('C', 8), GPIO('C', 11), GPIO_FUNCTION(8) },
-//    { I2C3, GPIO('A', 8), GPIO('B', 5), GPIO_FUNCTION(4) },
-#endif
-};
-
-struct i2c_config
-i2c_setup(uint32_t bus, uint32_t rate, uint8_t addr)
-{
-    // Lookup requested i2c bus
-    if (bus >= ARRAY_SIZE(i2c_bus))
-        shutdown("Unsupported i2c bus");
-    const struct i2c_info *ii = &i2c_bus[bus];
-    I2C_TypeDef *i2c = ii->i2c;
-
-    if (!is_enabled_pclock((uint32_t)i2c)) {
-        // Enable i2c clock and gpio
-        enable_pclock((uint32_t)i2c);
-        gpio_peripheral(ii->scl_pin, ii->function | GPIO_OPEN_DRAIN, 1);
-        gpio_peripheral(ii->sda_pin, ii->function | GPIO_OPEN_DRAIN, 1);
-
-        // Set 100Khz frequency and enable
-        i2c->TIMINGR = ((0xB << I2C_TIMINGR_PRESC_Pos)
-                        | (0x13 << I2C_TIMINGR_SCLL_Pos)
-                        | (0xF << I2C_TIMINGR_SCLH_Pos)
-                        | (0x2 << I2C_TIMINGR_SDADEL_Pos)
-                        | (0x4 << I2C_TIMINGR_SCLDEL_Pos));
-        i2c->CR1 = I2C_CR1_PE;
-    }
-
-    return (struct i2c_config){ .i2c=i2c, .addr=addr<<1 };
-}
-
-static uint32_t
-i2c_wait(I2C_TypeDef *i2c, uint32_t set, uint32_t timeout)
-{
-    for (;;) {
-        uint32_t isr = i2c->ISR;
-        if (isr & set)
-            return isr;
-        if (!timer_is_before(timer_read_time(), timeout))
-            shutdown("i2c timeout");
-    }
-}
-
-void
-i2c_write(struct i2c_config config, uint8_t write_len, uint8_t *write)
-{
-    I2C_TypeDef *i2c = config.i2c;
-    uint32_t timeout = timer_read_time() + timer_from_us(5000);
-
-    // Send start and address
-    i2c->CR2 = (I2C_CR2_START | config.addr | (write_len << I2C_CR2_NBYTES_Pos)
-                | I2C_CR2_AUTOEND);
-    while (write_len--) {
-        i2c_wait(i2c, I2C_ISR_TXIS, timeout);
-        i2c->TXDR = *write++;
-    }
-    i2c_wait(i2c, I2C_ISR_TXE, timeout);
-}
-
-void
-i2c_read(struct i2c_config config, uint8_t reg_len, uint8_t *reg
-         , uint8_t read_len, uint8_t *read)
-{
-    I2C_TypeDef *i2c = config.i2c;
-    uint32_t timeout = timer_read_time() + timer_from_us(5000);
-
-    // Send start, address, reg
-    i2c->CR2 = (I2C_CR2_START | config.addr |
-               (reg_len << I2C_CR2_NBYTES_Pos));
-    while (reg_len--) {
-        i2c_wait(i2c, I2C_ISR_TXIS, timeout);
-        i2c->TXDR = *reg++;
-    }
-    i2c_wait(i2c, I2C_ISR_TC, timeout);
-
-    // send restart, read data
-    i2c->CR2 = (I2C_CR2_START | I2C_CR2_RD_WRN | config.addr |
-               (read_len << I2C_CR2_NBYTES_Pos) | I2C_CR2_AUTOEND);
-    while (read_len--) {
-        i2c_wait(i2c, I2C_ISR_RXNE, timeout);
-        *read++ = i2c->RXDR;
-    }
-    i2c_wait(i2c, I2C_ISR_STOPF, timeout);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/stm32f0_serial.c crealityShit/src/stm32/stm32f0_serial.c
--- klipperStock/src/stm32/stm32f0_serial.c	2024-01-14 23:02:00.101796106 -0600
+++ crealityShit/src/stm32/stm32f0_serial.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,150 +0,0 @@
-// STM32F0 serial
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_SERIAL_BAUD
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/serial_irq.h" // serial_rx_byte
-#include "command.h" // DECL_CONSTANT_STR
-#include "internal.h" // enable_pclock
-#include "sched.h" // DECL_INIT
-
-// Select the configured serial port
-#if CONFIG_STM32_SERIAL_USART1
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "PA10,PA9");
-  #define GPIO_Rx GPIO('A', 10)
-  #define GPIO_Tx GPIO('A', 9)
-  #define USARTx_FUNCTION GPIO_FUNCTION( \
-            (CONFIG_MACH_STM32H7 | CONFIG_MACH_STM32G4) ? 7 : 1)
-  #define USARTx USART1
-  #define USARTx_IRQn USART1_IRQn
-#elif CONFIG_STM32_SERIAL_USART1_ALT_PB7_PB6
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "PB7,PB6");
-  #define GPIO_Rx GPIO('B', 7)
-  #define GPIO_Tx GPIO('B', 6)
-  #define USARTx_FUNCTION GPIO_FUNCTION( \
-            (CONFIG_MACH_STM32H7 | CONFIG_MACH_STM32G4) ? 7 : 0)
-  #define USARTx USART1
-  #define USARTx_IRQn USART1_IRQn
-#elif CONFIG_STM32_SERIAL_USART2
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "PA3,PA2");
-  #define GPIO_Rx GPIO('A', 3)
-  #define GPIO_Tx GPIO('A', 2)
-  #define USARTx_FUNCTION GPIO_FUNCTION( \
-            (CONFIG_MACH_STM32H7 | CONFIG_MACH_STM32G4) ? 7 : 1)
-  #define USARTx USART2
-  #define USARTx_IRQn USART2_IRQn
-#elif CONFIG_STM32_SERIAL_USART2_ALT_PA15_PA14
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "PA15,PA14");
-  #define GPIO_Rx GPIO('A', 15)
-  #define GPIO_Tx GPIO('A', 14)
-  #define USARTx_FUNCTION GPIO_FUNCTION(CONFIG_MACH_STM32G4 ? 7 : 1)
-  #define USARTx USART2
-  #define USARTx_IRQn USART2_IRQn
-#elif CONFIG_STM32_SERIAL_USART2_ALT_PB4_PB3
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "PB4,PB3");
-  #define GPIO_Rx GPIO('B', 4)
-  #define GPIO_Tx GPIO('B', 3)
-  #define USARTx_FUNCTION GPIO_FUNCTION(7)
-  #define USARTx USART2
-  #define USARTx_IRQn USART2_IRQn
-#elif CONFIG_STM32_SERIAL_USART2_ALT_PD6_PD5
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "PD6,PD5");
-  #define GPIO_Rx GPIO('D', 6)
-  #define GPIO_Tx GPIO('D', 5)
-  #define USARTx_FUNCTION GPIO_FUNCTION(7)
-  #define USARTx USART2
-  #define USARTx_IRQn USART2_IRQn
-#elif CONFIG_STM32_SERIAL_USART3
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "PB11,PB10");
-  #define GPIO_Rx GPIO('B', 11)
-  #define GPIO_Tx GPIO('B', 10)
-  #define USARTx_FUNCTION GPIO_FUNCTION(7)
-  #define USARTx USART3
-  #define USARTx_IRQn USART3_IRQn
-#elif CONFIG_STM32_SERIAL_USART3_ALT_PD9_PD8
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "PD9,PD8");
-  #define GPIO_Rx GPIO('D', 9)
-  #define GPIO_Tx GPIO('D', 8)
-  #define USARTx_FUNCTION GPIO_FUNCTION(7)
-  #define USARTx USART3
-  #define USARTx_IRQn USART3_IRQn
-#elif CONFIG_STM32_SERIAL_UART4
-  DECL_CONSTANT_STR("RESERVE_PINS_serial", "PA1,PA0");
-  #define GPIO_Rx GPIO('A', 1)
-  #define GPIO_Tx GPIO('A', 0)
-  #define USARTx_FUNCTION GPIO_FUNCTION(8)
-  #define USARTx UART4
-  #define USARTx_IRQn UART4_IRQn
-#endif
-
-#if CONFIG_MACH_STM32F031
-  // The stm32f031 has same pins for USART2, but everything is routed to USART1
-  #define USART2 USART1
-  #define USART2_IRQn USART1_IRQn
-#endif
-
-#if CONFIG_MACH_STM32G0
-  // Some of the stm32g0 MCUs have slightly different register names
-  #if CONFIG_MACH_STM32G0B1
-    #define USART2_IRQn USART2_LPUART2_IRQn
-  #endif
-  #define USART_CR1_RXNEIE USART_CR1_RXNEIE_RXFNEIE
-  #define USART_CR1_TXEIE USART_CR1_TXEIE_TXFNFIE
-  #define USART_ISR_RXNE USART_ISR_RXNE_RXFNE
-  #define USART_ISR_TXE USART_ISR_TXE_TXFNF
-  #define USART_BRR_DIV_MANTISSA_Pos 4
-  #define USART_BRR_DIV_FRACTION_Pos 0
-#elif CONFIG_MACH_STM32G4
-  #define USART_BRR_DIV_MANTISSA_Pos 4
-  #define USART_BRR_DIV_FRACTION_Pos 0
-#elif CONFIG_MACH_STM32H7
-  // The stm32h7 has slightly different register names
-  #define USART_ISR_RXNE USART_ISR_RXNE_RXFNE
-  #define USART_ISR_TXE USART_ISR_TXE_TXFNF
-#endif
-
-#define CR1_FLAGS (USART_CR1_UE | USART_CR1_RE | USART_CR1_TE   \
-                   | USART_CR1_RXNEIE)
-
-void
-USARTx_IRQHandler(void)
-{
-    uint32_t sr = USARTx->ISR;
-    if (sr & USART_ISR_RXNE)
-        serial_rx_byte(USARTx->RDR);
-    if (sr & USART_ISR_TXE && USARTx->CR1 & USART_CR1_TXEIE) {
-        uint8_t data;
-        int ret = serial_get_tx_byte(&data);
-        if (ret)
-            USARTx->CR1 = CR1_FLAGS;
-        else
-            USARTx->TDR = data;
-    }
-}
-
-void
-serial_enable_tx_irq(void)
-{
-    USARTx->CR1 = CR1_FLAGS | USART_CR1_TXEIE;
-}
-
-void
-serial_init(void)
-{
-    enable_pclock((uint32_t)USARTx);
-
-    uint32_t pclk = get_pclock_frequency((uint32_t)USARTx);
-    uint32_t div = DIV_ROUND_CLOSEST(pclk, CONFIG_SERIAL_BAUD);
-    USARTx->BRR = (((div / 16) << USART_BRR_DIV_MANTISSA_Pos)
-                   | ((div % 16) << USART_BRR_DIV_FRACTION_Pos));
-    USARTx->CR3 = USART_CR3_OVRDIS; // disable the ORE ISR
-    USARTx->CR1 = CR1_FLAGS;
-    armcm_enable_irq(USARTx_IRQHandler, USARTx_IRQn, 0);
-
-    gpio_peripheral(GPIO_Rx, USARTx_FUNCTION, 1);
-    gpio_peripheral(GPIO_Tx, USARTx_FUNCTION, 0);
-}
-DECL_INIT(serial_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/stm32f0_timer.c crealityShit/src/stm32/stm32f0_timer.c
--- klipperStock/src/stm32/stm32f0_timer.c	2024-01-14 23:02:00.101796106 -0600
+++ crealityShit/src/stm32/stm32f0_timer.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,129 +0,0 @@
-// STM32F0 timer support
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/armcm_timer.h" // udelay
-#include "board/internal.h" // TIM3
-#include "board/io.h" // readl
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_read_time
-#include "sched.h" // DECL_INIT
-#include "command.h" // DECL_SHUTDOWN
-#include "board/timer_irq.h" // timer_dispatch_many
-
-
-/****************************************************************
- * Low level timer code
- ****************************************************************/
-
-// Use 32bit TIM2 timer if available (otherwise use 16bit TIM3 timer)
-#if defined(TIM2)
-  #define TIMx TIM2
-  #define TIMx_IRQn TIM2_IRQn
-  #define HAVE_TIMER_32BIT 1
-#elif defined(TIM3)
-  #define TIMx TIM3
-  #define TIMx_IRQn TIM3_IRQn
-  #define HAVE_TIMER_32BIT 0
-#endif
-
-// Some chips have slightly different register names
-#if CONFIG_MACH_STM32G0B0
-  #define TIM3_IRQn TIM3_TIM4_IRQn
-#endif
-
-static inline uint32_t
-timer_get(void)
-{
-    return TIMx->CNT;
-}
-
-static inline void
-timer_set(uint32_t next)
-{
-    TIMx->CCR1 = next;
-    TIMx->SR = 0;
-}
-
-// Activate timer dispatch as soon as possible
-void
-timer_kick(void)
-{
-    timer_set(timer_get() + 50);
-}
-
-
-/****************************************************************
- * 16bit hardware timer to 32bit conversion
- ****************************************************************/
-
-// High bits of timer (top 17 bits)
-static uint32_t timer_high;
-
-// Return the current time (in absolute clock ticks).
-uint32_t __always_inline
-timer_read_time(void)
-{
-    if (HAVE_TIMER_32BIT)
-        return timer_get();
-    uint32_t th = readl(&timer_high);
-    uint32_t cur = timer_get();
-    // Combine timer_high (high 17 bits) and current time (low 16
-    // bits) using method that handles rollovers correctly.
-    return (th ^ cur) + (th & 0xffff);
-}
-
-// Update timer_high every 0x8000 clock ticks
-static uint_fast8_t
-timer_event(struct timer *t)
-{
-    timer_high += 0x8000;
-    t->waketime = timer_high + 0x8000;
-    return SF_RESCHEDULE;
-}
-static struct timer wrap_timer = {
-    .func = timer_event,
-    .waketime = 0x8000,
-};
-
-void
-timer_reset(void)
-{
-    if (!HAVE_TIMER_32BIT)
-        sched_add_timer(&wrap_timer);
-}
-DECL_SHUTDOWN(timer_reset);
-
-
-/****************************************************************
- * Setup and irqs
- ****************************************************************/
-
-// Hardware timer IRQ handler - dispatch software timers
-void __aligned(16)
-TIMx_IRQHandler(void)
-{
-    irq_disable();
-    uint32_t next = timer_dispatch_many();
-    timer_set(next);
-    irq_enable();
-}
-
-void
-timer_init(void)
-{
-    irqstatus_t flag = irq_save();
-    enable_pclock((uint32_t)TIMx);
-    TIMx->CNT = 0;
-    TIMx->DIER = TIM_DIER_CC1IE;
-    TIMx->CCER = TIM_CCER_CC1E;
-    armcm_enable_irq(TIMx_IRQHandler, TIMx_IRQn, 2);
-    timer_kick();
-    timer_reset();
-    TIMx->CR1 = TIM_CR1_CEN;
-    irq_restore(flag);
-}
-DECL_INIT(timer_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/stm32f1.c crealityShit/src/stm32/stm32f1.c
--- klipperStock/src/stm32/stm32f1.c	2024-01-14 23:02:00.097796058 -0600
+++ crealityShit/src/stm32/stm32f1.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,286 +0,0 @@
-// Code to setup clocks and gpio on stm32f1
-//
-// Copyright (C) 2019-2022  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_CLOCK_REF_FREQ
-#include "board/armcm_boot.h" // VectorTable
-#include "board/armcm_reset.h" // try_request_canboot
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // bootloader_request
-#include "internal.h" // enable_pclock
-#include "sched.h" // sched_main
-
-
-/****************************************************************
- * Clock setup
- ****************************************************************/
-
-#define FREQ_PERIPH (CONFIG_CLOCK_FREQ / 2)
-
-// Map a peripheral address to its enable bits
-struct cline
-lookup_clock_line(uint32_t periph_base)
-{
-    if (periph_base >= AHBPERIPH_BASE) {
-        uint32_t bit = 1 << ((periph_base - AHBPERIPH_BASE) / 0x400);
-        return (struct cline){.en=&RCC->AHBENR, .bit=bit};
-    } else if (periph_base >= APB2PERIPH_BASE) {
-        uint32_t bit = 1 << ((periph_base - APB2PERIPH_BASE) / 0x400);
-        return (struct cline){.en=&RCC->APB2ENR, .rst=&RCC->APB2RSTR, .bit=bit};
-    } else {
-        uint32_t bit = 1 << ((periph_base - APB1PERIPH_BASE) / 0x400);
-        return (struct cline){.en=&RCC->APB1ENR, .rst=&RCC->APB1RSTR, .bit=bit};
-    }
-}
-
-// Return the frequency of the given peripheral clock
-uint32_t
-get_pclock_frequency(uint32_t periph_base)
-{
-    return FREQ_PERIPH;
-}
-
-// Enable a GPIO peripheral clock
-void
-gpio_clock_enable(GPIO_TypeDef *regs)
-{
-    uint32_t rcc_pos = ((uint32_t)regs - APB2PERIPH_BASE) / 0x400;
-    RCC->APB2ENR |= 1 << rcc_pos;
-    RCC->APB2ENR;
-}
-
-// Main clock setup called at chip startup
-static void
-clock_setup(void)
-{
-    // Configure and enable PLL
-    uint32_t cfgr;
-    if (!CONFIG_STM32_CLOCK_REF_INTERNAL) {
-        // Configure 72Mhz PLL from external crystal (HSE)
-        RCC->CR |= RCC_CR_HSEON;
-        uint32_t div = CONFIG_CLOCK_FREQ / (CONFIG_CLOCK_REF_FREQ / 2);
-        cfgr = 1 << RCC_CFGR_PLLSRC_Pos;
-        if ((div & 1) && div <= 16)
-            cfgr |= RCC_CFGR_PLLXTPRE_HSE_DIV2;
-        else
-            div /= 2;
-        cfgr |= (div - 2) << RCC_CFGR_PLLMULL_Pos;
-    } else {
-        // Configure 72Mhz PLL from internal 8Mhz oscillator (HSI)
-        uint32_t div2 = (CONFIG_CLOCK_FREQ / 8000000) * 2;
-        cfgr = ((0 << RCC_CFGR_PLLSRC_Pos)
-                | ((div2 - 2) << RCC_CFGR_PLLMULL_Pos));
-    }
-    cfgr |= RCC_CFGR_PPRE1_DIV2 | RCC_CFGR_PPRE2_DIV2 | RCC_CFGR_ADCPRE_DIV8;
-    RCC->CFGR = cfgr;
-    RCC->CR |= RCC_CR_PLLON;
-
-    // Set flash latency
-    FLASH->ACR = (2 << FLASH_ACR_LATENCY_Pos) | FLASH_ACR_PRFTBE;
-
-    // Wait for PLL lock
-    while (!(RCC->CR & RCC_CR_PLLRDY))
-        ;
-
-    // Switch system clock to PLL
-    RCC->CFGR = cfgr | RCC_CFGR_SW_PLL;
-    while ((RCC->CFGR & RCC_CFGR_SWS_Msk) != RCC_CFGR_SWS_PLL)
-        ;
-}
-
-
-/****************************************************************
- * GPIO setup
- ****************************************************************/
-
-static void
-stm32f1_alternative_remap(uint32_t mapr_mask, uint32_t mapr_value)
-{
-    // The MAPR register is a mix of write only and r/w bits
-    // We have to save the written values in a global variable
-    static uint32_t mapr = 0;
-
-    mapr &= ~mapr_mask;
-    mapr |= mapr_value;
-    AFIO->MAPR = mapr;
-}
-
-#define STM_OSPEED 0x1 // ~10Mhz at 50pF
-
-// Set the mode and extended function of a pin
-void
-gpio_peripheral(uint32_t gpio, uint32_t mode, int pullup)
-{
-    GPIO_TypeDef *regs = digital_regs[GPIO2PORT(gpio)];
-
-    // Enable GPIO clock
-    gpio_clock_enable(regs);
-
-    // Configure GPIO
-    uint32_t pos = gpio % 16, shift = (pos % 8) * 4, msk = 0xf << shift, cfg;
-    if (mode == GPIO_INPUT) {
-        cfg = pullup ? 0x8 : 0x4;
-    } else if (mode == GPIO_OUTPUT) {
-        cfg = STM_OSPEED;
-    } else if (mode == (GPIO_OUTPUT | GPIO_OPEN_DRAIN)) {
-        cfg = 0x4 | STM_OSPEED;
-    } else if (mode == GPIO_ANALOG) {
-        cfg = 0x0;
-    } else {
-        if (mode & GPIO_OPEN_DRAIN)
-            // Alternate function with open-drain mode
-            cfg = 0xc | STM_OSPEED;
-        else if (pullup > 0)
-            // Alternate function input pins use GPIO_INPUT mode on the stm32f1
-            cfg = 0x8;
-        else
-            cfg = 0x8 | STM_OSPEED;
-    }
-    if (pos & 0x8)
-        regs->CRH = (regs->CRH & ~msk) | (cfg << shift);
-    else
-        regs->CRL = (regs->CRL & ~msk) | (cfg << shift);
-
-    if (pullup > 0)
-        regs->BSRR = 1 << pos;
-    else if (pullup < 0)
-        regs->BSRR = 1 << (pos + 16);
-
-    if (gpio == GPIO('A', 13) || gpio == GPIO('A', 14))
-        // Disable SWD to free PA13, PA14
-        stm32f1_alternative_remap(AFIO_MAPR_SWJ_CFG_Msk,
-                                  AFIO_MAPR_SWJ_CFG_DISABLE);
-
-    // STM32F1 remaps functions to pins in a very different
-    // way from other STM32s.
-    // Code below is emulating a few mappings to work like an STM32F4
-    uint32_t func = (mode >> 4) & 0xf;
-    if (func == 1) {
-        // TIM2
-        if (gpio == GPIO('A', 15) || gpio == GPIO('B', 3))
-            stm32f1_alternative_remap(AFIO_MAPR_TIM2_REMAP_Msk,
-                                      AFIO_MAPR_TIM2_REMAP_PARTIALREMAP1);
-        else if (gpio == GPIO('B', 10) || gpio == GPIO('B', 11))
-            stm32f1_alternative_remap(AFIO_MAPR_TIM2_REMAP_Msk,
-                                      AFIO_MAPR_TIM2_REMAP_PARTIALREMAP2);
-    } else if (func == 2) {
-        // TIM3 and TIM4
-        if (gpio == GPIO('B', 4) || gpio == GPIO('B', 5))
-            stm32f1_alternative_remap(AFIO_MAPR_TIM3_REMAP_Msk,
-                                      AFIO_MAPR_TIM3_REMAP_PARTIALREMAP);
-        else if (gpio == GPIO('C', 6) || gpio == GPIO('C', 7)
-                 || gpio == GPIO('C', 8) || gpio == GPIO('C', 9))
-            stm32f1_alternative_remap(AFIO_MAPR_TIM3_REMAP_Msk,
-                                      AFIO_MAPR_TIM3_REMAP_FULLREMAP);
-        else if (gpio == GPIO('D', 12) || gpio == GPIO('D', 13)
-                 || gpio == GPIO('D', 14) || gpio == GPIO('D', 15))
-            stm32f1_alternative_remap(AFIO_MAPR_TIM4_REMAP_Msk,
-                                      AFIO_MAPR_TIM4_REMAP);
-    } else if (func == 4) {
-        // I2C
-        if (gpio == GPIO('B', 8) || gpio == GPIO('B', 9))
-            stm32f1_alternative_remap(AFIO_MAPR_I2C1_REMAP_Msk,
-                                      AFIO_MAPR_I2C1_REMAP);
-    } else if (func == 5) {
-        // SPI
-        if (gpio == GPIO('B', 3) || gpio == GPIO('B', 4)
-            || gpio == GPIO('B', 5))
-            stm32f1_alternative_remap(AFIO_MAPR_SPI1_REMAP_Msk,
-                                      AFIO_MAPR_SPI1_REMAP);
-    } else if (func == 7) {
-        // USART
-        if (gpio == GPIO('B', 6) || gpio == GPIO('B', 7))
-            stm32f1_alternative_remap(AFIO_MAPR_USART1_REMAP_Msk,
-                                      AFIO_MAPR_USART1_REMAP);
-        else if (gpio == GPIO('D', 5) || gpio == GPIO('D', 6))
-            stm32f1_alternative_remap(AFIO_MAPR_USART2_REMAP_Msk,
-                                      AFIO_MAPR_USART2_REMAP);
-        else if (gpio == GPIO('D', 8) || gpio == GPIO('D', 9))
-            stm32f1_alternative_remap(AFIO_MAPR_USART3_REMAP_Msk,
-                                      AFIO_MAPR_USART3_REMAP_FULLREMAP);
-    } else if (func == 9) {
-        // CAN
-        if (gpio == GPIO('B', 8) || gpio == GPIO('B', 9))
-            stm32f1_alternative_remap(AFIO_MAPR_CAN_REMAP_Msk,
-                                      AFIO_MAPR_CAN_REMAP_REMAP2);
-        if (gpio == GPIO('D', 0) || gpio == GPIO('D', 1))
-            stm32f1_alternative_remap(AFIO_MAPR_CAN_REMAP_Msk,
-                                      AFIO_MAPR_CAN_REMAP_REMAP3);
-    }
-}
-
-
-/****************************************************************
- * Bootloader
- ****************************************************************/
-
-// Reboot into USB "HID" bootloader
-static void
-usb_hid_bootloader(void)
-{
-    irq_disable();
-    RCC->APB1ENR |= RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN;
-    PWR->CR |= PWR_CR_DBP;
-    BKP->DR4 = 0x424C; // HID Bootloader magic key
-    PWR->CR &=~ PWR_CR_DBP;
-    NVIC_SystemReset();
-}
-
-// Reboot into USB "stm32duino" bootloader
-static void
-usb_stm32duino_bootloader(void)
-{
-    irq_disable();
-    RCC->APB1ENR |= RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN;
-    PWR->CR |= PWR_CR_DBP;
-    BKP->DR10 = 0x01; // stm32duino bootloader magic key
-    PWR->CR &=~ PWR_CR_DBP;
-    NVIC_SystemReset();
-}
-
-// Handle reboot requests
-void
-bootloader_request(void)
-{
-    try_request_canboot();
-    if (CONFIG_STM32_FLASH_START_800)
-        usb_hid_bootloader();
-    else if (CONFIG_STM32_FLASH_START_2000)
-        usb_stm32duino_bootloader();
-}
-
-
-/****************************************************************
- * Startup
- ****************************************************************/
-
-// Main entry point - called from armcm_boot.c:ResetHandler()
-void
-armcm_main(void)
-{
-    // Run SystemInit() and then restore VTOR
-    SystemInit();
-    SCB->VTOR = (uint32_t)VectorTable;
-
-    // Reset peripheral clocks (for some bootloaders that don't)
-    RCC->AHBENR = 0x14;
-    RCC->APB1ENR = 0;
-    RCC->APB2ENR = 0;
-
-    // Setup clocks
-    clock_setup();
-
-    // Disable JTAG to free PA15, PB3, PB4
-    enable_pclock(AFIO_BASE);
-    if (CONFIG_STM32F103GD_DISABLE_SWD)
-        // GigaDevice clone can't enable PA13/PA14 at runtime - enable here
-        stm32f1_alternative_remap(AFIO_MAPR_SWJ_CFG_Msk,
-                                  AFIO_MAPR_SWJ_CFG_DISABLE);
-    else
-        stm32f1_alternative_remap(AFIO_MAPR_SWJ_CFG_Msk,
-                                  AFIO_MAPR_SWJ_CFG_JTAGDISABLE);
-
-    sched_main();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/stm32f4.c crealityShit/src/stm32/stm32f4.c
--- klipperStock/src/stm32/stm32f4.c	2024-01-14 23:02:00.097796058 -0600
+++ crealityShit/src/stm32/stm32f4.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,241 +0,0 @@
-// Code to setup clocks on stm32f2/stm32f4
-//
-// Copyright (C) 2019-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_CLOCK_REF_FREQ
-#include "board/armcm_boot.h" // VectorTable
-#include "board/armcm_reset.h" // try_request_canboot
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // bootloader_request
-#include "command.h" // DECL_CONSTANT_STR
-#include "internal.h" // enable_pclock
-#include "sched.h" // sched_main
-
-
-/****************************************************************
- * Clock setup
- ****************************************************************/
-
-#define FREQ_PERIPH_DIV (CONFIG_MACH_STM32F401 ? 2 : 4)
-#define FREQ_PERIPH (CONFIG_CLOCK_FREQ / FREQ_PERIPH_DIV)
-#define FREQ_USB 48000000
-
-// Map a peripheral address to its enable bits
-struct cline
-lookup_clock_line(uint32_t periph_base)
-{
-    if (periph_base >= AHB1PERIPH_BASE) {
-        uint32_t bit = 1 << ((periph_base - AHB1PERIPH_BASE) / 0x400);
-        return (struct cline){.en=&RCC->AHB1ENR, .rst=&RCC->AHB1RSTR, .bit=bit};
-    } else if (periph_base >= APB2PERIPH_BASE) {
-        uint32_t bit = 1 << ((periph_base - APB2PERIPH_BASE) / 0x400);
-        if (bit & 0x700)
-            // Skip ADC peripheral reset as they share a bit
-            return (struct cline){.en=&RCC->APB2ENR, .bit=bit};
-        return (struct cline){.en=&RCC->APB2ENR, .rst=&RCC->APB2RSTR, .bit=bit};
-    } else {
-        uint32_t bit = 1 << ((periph_base - APB1PERIPH_BASE) / 0x400);
-        return (struct cline){.en=&RCC->APB1ENR, .rst=&RCC->APB1RSTR, .bit=bit};
-    }
-}
-
-// Return the frequency of the given peripheral clock
-uint32_t
-get_pclock_frequency(uint32_t periph_base)
-{
-    return FREQ_PERIPH;
-}
-
-// Enable a GPIO peripheral clock
-void
-gpio_clock_enable(GPIO_TypeDef *regs)
-{
-    uint32_t rcc_pos = ((uint32_t)regs - AHB1PERIPH_BASE) / 0x400;
-    RCC->AHB1ENR |= 1 << rcc_pos;
-    RCC->AHB1ENR;
-}
-
-#if !CONFIG_STM32_CLOCK_REF_INTERNAL
-DECL_CONSTANT_STR("RESERVE_PINS_crystal", "PH0,PH1");
-#endif
-
-// Clock configuration
-static void
-enable_clock_stm32f20x(void)
-{
-#if CONFIG_MACH_STM32F207
-    uint32_t pll_base = 1000000, pll_freq = CONFIG_CLOCK_FREQ * 2, pllcfgr;
-    if (!CONFIG_STM32_CLOCK_REF_INTERNAL) {
-        // Configure 120Mhz PLL from external crystal (HSE)
-        uint32_t div = CONFIG_CLOCK_REF_FREQ / pll_base;
-        RCC->CR |= RCC_CR_HSEON;
-        pllcfgr = RCC_PLLCFGR_PLLSRC_HSE | (div << RCC_PLLCFGR_PLLM_Pos);
-    } else {
-        // Configure 120Mhz PLL from internal 16Mhz oscillator (HSI)
-        uint32_t div = 16000000 / pll_base;
-        pllcfgr = RCC_PLLCFGR_PLLSRC_HSI | (div << RCC_PLLCFGR_PLLM_Pos);
-    }
-    RCC->PLLCFGR = (pllcfgr | ((pll_freq/pll_base) << RCC_PLLCFGR_PLLN_Pos)
-                    | (0 << RCC_PLLCFGR_PLLP_Pos)
-                    | ((pll_freq/FREQ_USB) << RCC_PLLCFGR_PLLQ_Pos));
-    RCC->CR |= RCC_CR_PLLON;
-#endif
-}
-
-static void
-enable_clock_stm32f40x(void)
-{
-#if CONFIG_MACH_STM32F401 || CONFIG_MACH_STM32F4x5
-    uint32_t pll_base = (CONFIG_STM32_CLOCK_REF_25M) ? 1000000 : 2000000;
-    uint32_t pllp = (CONFIG_MACH_STM32F401) ? 4 : 2;
-    uint32_t pll_freq = CONFIG_CLOCK_FREQ * pllp, pllcfgr;
-    if (!CONFIG_STM32_CLOCK_REF_INTERNAL) {
-        // Configure 168Mhz PLL from external crystal (HSE)
-        uint32_t div = CONFIG_CLOCK_REF_FREQ / pll_base;
-        RCC->CR |= RCC_CR_HSEON;
-        pllcfgr = RCC_PLLCFGR_PLLSRC_HSE | (div << RCC_PLLCFGR_PLLM_Pos);
-    } else {
-        // Configure 168Mhz PLL from internal 16Mhz oscillator (HSI)
-        uint32_t div = 16000000 / pll_base;
-        pllcfgr = RCC_PLLCFGR_PLLSRC_HSI | (div << RCC_PLLCFGR_PLLM_Pos);
-    }
-    RCC->PLLCFGR = (pllcfgr | ((pll_freq/pll_base) << RCC_PLLCFGR_PLLN_Pos)
-                    | (((pllp >> 1) - 1) << RCC_PLLCFGR_PLLP_Pos)
-                    | ((pll_freq/FREQ_USB) << RCC_PLLCFGR_PLLQ_Pos));
-    RCC->CR |= RCC_CR_PLLON;
-#endif
-}
-
-static void
-enable_clock_stm32f446(void)
-{
-#if CONFIG_MACH_STM32F446
-    uint32_t pll_base = 2000000, pll_freq = CONFIG_CLOCK_FREQ * 2, pllcfgr;
-    if (!CONFIG_STM32_CLOCK_REF_INTERNAL) {
-        // Configure 180Mhz PLL from external crystal (HSE)
-        uint32_t div = CONFIG_CLOCK_REF_FREQ / pll_base;
-        RCC->CR |= RCC_CR_HSEON;
-        pllcfgr = RCC_PLLCFGR_PLLSRC_HSE | (div << RCC_PLLCFGR_PLLM_Pos);
-    } else {
-        // Configure 180Mhz PLL from internal 16Mhz oscillator (HSI)
-        uint32_t div = 16000000 / pll_base;
-        pllcfgr = RCC_PLLCFGR_PLLSRC_HSI | (div << RCC_PLLCFGR_PLLM_Pos);
-    }
-    RCC->PLLCFGR = (pllcfgr | ((pll_freq/pll_base) << RCC_PLLCFGR_PLLN_Pos)
-                    | (0 << RCC_PLLCFGR_PLLP_Pos)
-                    | ((pll_freq/FREQ_USB) << RCC_PLLCFGR_PLLQ_Pos)
-                    | (6 << RCC_PLLCFGR_PLLR_Pos));
-    RCC->CR |= RCC_CR_PLLON;
-
-    // Enable "over drive"
-    enable_pclock(PWR_BASE);
-    PWR->CR = (3 << PWR_CR_VOS_Pos) | PWR_CR_ODEN;
-    while (!(PWR->CSR & PWR_CSR_ODRDY))
-        ;
-    PWR->CR = (3 << PWR_CR_VOS_Pos) | PWR_CR_ODEN | PWR_CR_ODSWEN;
-    while (!(PWR->CSR & PWR_CSR_ODSWRDY))
-        ;
-
-    // Enable 48Mhz USB clock
-    if (CONFIG_USB) {
-        uint32_t ref = (CONFIG_STM32_CLOCK_REF_INTERNAL
-                        ? 16000000 : CONFIG_CLOCK_REF_FREQ);
-        uint32_t plls_base = 2000000, plls_freq = FREQ_USB * 4;
-        RCC->PLLSAICFGR = (
-            ((ref/plls_base) << RCC_PLLSAICFGR_PLLSAIM_Pos)
-            | ((plls_freq/plls_base) << RCC_PLLSAICFGR_PLLSAIN_Pos)
-            | (((plls_freq/FREQ_USB)/2 - 1) << RCC_PLLSAICFGR_PLLSAIP_Pos)
-            | ((plls_freq/FREQ_USB) << RCC_PLLSAICFGR_PLLSAIQ_Pos));
-        RCC->CR |= RCC_CR_PLLSAION;
-        while (!(RCC->CR & RCC_CR_PLLSAIRDY))
-            ;
-
-        RCC->DCKCFGR2 = RCC_DCKCFGR2_CK48MSEL;
-    }
-#endif
-}
-
-// Main clock setup called at chip startup
-static void
-clock_setup(void)
-{
-    // Configure and enable PLL
-    if (CONFIG_MACH_STM32F207)
-        enable_clock_stm32f20x();
-    else if (CONFIG_MACH_STM32F401 || CONFIG_MACH_STM32F4x5)
-        enable_clock_stm32f40x();
-    else
-        enable_clock_stm32f446();
-
-    // Set flash latency
-    FLASH->ACR = (FLASH_ACR_LATENCY_5WS | FLASH_ACR_ICEN | FLASH_ACR_DCEN
-                  | FLASH_ACR_PRFTEN);
-
-    // Wait for PLL lock
-    while (!(RCC->CR & RCC_CR_PLLRDY))
-        ;
-
-    // Switch system clock to PLL
-    if (FREQ_PERIPH_DIV == 2)
-        RCC->CFGR = RCC_CFGR_PPRE1_DIV2 | RCC_CFGR_PPRE2_DIV2 | RCC_CFGR_SW_PLL;
-    else
-        RCC->CFGR = RCC_CFGR_PPRE1_DIV4 | RCC_CFGR_PPRE2_DIV4 | RCC_CFGR_SW_PLL;
-    while ((RCC->CFGR & RCC_CFGR_SWS_Msk) != RCC_CFGR_SWS_PLL)
-        ;
-}
-
-
-/****************************************************************
- * Bootloader
- ****************************************************************/
-
-// Reboot into USB "HID" bootloader
-static void
-usb_hid_bootloader(void)
-{
-    irq_disable();
-    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
-    RCC->APB1ENR;
-    PWR->CR |= PWR_CR_DBP;
-    RTC->BKP4R = 0x424C; // HID Bootloader magic key
-    PWR->CR &= ~PWR_CR_DBP;
-    NVIC_SystemReset();
-}
-
-// Handle reboot requests
-void
-bootloader_request(void)
-{
-    try_request_canboot();
-    if (CONFIG_STM32_FLASH_START_4000)
-        usb_hid_bootloader();
-    dfu_reboot();
-}
-
-
-/****************************************************************
- * Startup
- ****************************************************************/
-
-// Main entry point - called from armcm_boot.c:ResetHandler()
-void
-armcm_main(void)
-{
-    dfu_reboot_check();
-
-    // Run SystemInit() and then restore VTOR
-    SystemInit();
-    SCB->VTOR = (uint32_t)VectorTable;
-
-    // Reset peripheral clocks (for some bootloaders that don't)
-    RCC->AHB1ENR = 0x38000;
-    RCC->AHB2ENR = 0;
-    RCC->APB1ENR = 0;
-    RCC->APB2ENR = 0;
-
-    clock_setup();
-
-    sched_main();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/stm32g0.c crealityShit/src/stm32/stm32g0.c
--- klipperStock/src/stm32/stm32g0.c	2024-01-14 23:02:00.097796058 -0600
+++ crealityShit/src/stm32/stm32g0.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,176 +0,0 @@
-// Code to setup clocks on stm32g0
-//
-// Copyright (C) 2019-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_CLOCK_REF_FREQ
-#include "board/armcm_boot.h" // armcm_main
-#include "board/armcm_reset.h" // try_request_canboot
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // bootloader_request
-#include "command.h" // DECL_CONSTANT_STR
-#include "internal.h" // enable_pclock
-#include "sched.h" // sched_main
-
-
-/****************************************************************
- * Clock setup
- ****************************************************************/
-
-#define FREQ_PERIPH 64000000
-#define FREQ_USB 48000000
-
-// Map a peripheral address to its enable bits
-struct cline
-lookup_clock_line(uint32_t periph_base)
-{
-    if (periph_base >= IOPORT_BASE) {
-        uint32_t bit = 1 << ((periph_base - IOPORT_BASE) / 0x400);
-        return (struct cline){.en=&RCC->IOPENR, .rst=&RCC->IOPRSTR, .bit=bit};
-    } else if (periph_base >= AHBPERIPH_BASE) {
-        uint32_t bit = 1 << ((periph_base - AHBPERIPH_BASE) / 0x400);
-        return (struct cline){.en=&RCC->AHBENR, .rst=&RCC->AHBRSTR, .bit=bit};
-    }
-#if defined(FDCAN1_BASE) || defined(FDCAN2_BASE)
-    if ((periph_base == FDCAN1_BASE) || (periph_base == FDCAN2_BASE))
-        return (struct cline){.en=&RCC->APBENR1,.rst=&RCC->APBRSTR1,.bit=1<<12};
-#endif
-    if (periph_base == USB_BASE)
-        return (struct cline){.en=&RCC->APBENR1,.rst=&RCC->APBRSTR1,.bit=1<<13};
-#ifdef CRS_BASE
-    if (periph_base == CRS_BASE)
-        return (struct cline){.en=&RCC->APBENR1,.rst=&RCC->APBRSTR1,.bit=1<<16};
-#endif
-    if (periph_base == I2C3_BASE)
-        return (struct cline){.en=&RCC->APBENR1,.rst=&RCC->APBRSTR1,.bit=1<<23};
-    if (periph_base == TIM1_BASE)
-        return (struct cline){.en=&RCC->APBENR2,.rst=&RCC->APBRSTR2,.bit=1<<11};
-    if (periph_base == SPI1_BASE)
-        return (struct cline){.en=&RCC->APBENR2,.rst=&RCC->APBRSTR2,.bit=1<<12};
-    if (periph_base == USART1_BASE)
-        return (struct cline){.en=&RCC->APBENR2,.rst=&RCC->APBRSTR2,.bit=1<<14};
-    if (periph_base == TIM14_BASE)
-        return (struct cline){.en=&RCC->APBENR2,.rst=&RCC->APBRSTR2,.bit=1<<15};
-    if (periph_base == TIM15_BASE)
-        return (struct cline){.en=&RCC->APBENR2,.rst=&RCC->APBRSTR2,.bit=1<<16};
-    if (periph_base == TIM16_BASE)
-        return (struct cline){.en=&RCC->APBENR2,.rst=&RCC->APBRSTR2,.bit=1<<17};
-    if (periph_base == TIM17_BASE)
-        return (struct cline){.en=&RCC->APBENR2,.rst=&RCC->APBRSTR2,.bit=1<<18};
-    if (periph_base == ADC1_BASE)
-        return (struct cline){.en=&RCC->APBENR2,.rst=&RCC->APBRSTR2,.bit=1<<20};
-    if (periph_base >= APBPERIPH_BASE
-        && periph_base < APBPERIPH_BASE + 32*0x400) {
-        uint32_t bit = 1 << ((periph_base - APBPERIPH_BASE) / 0x400);
-        return (struct cline){.en=&RCC->APBENR1, .rst=&RCC->APBRSTR1, .bit=bit};
-    }
-    // unknown peripheral. returning .bit=0 makes this a no-op
-    return (struct cline){.en=&RCC->APBENR1, .rst=NULL, .bit=0};
-}
-
-// Return the frequency of the given peripheral clock
-uint32_t
-get_pclock_frequency(uint32_t periph_base)
-{
-    return FREQ_PERIPH;
-}
-
-// Enable a GPIO peripheral clock
-void
-gpio_clock_enable(GPIO_TypeDef *regs)
-{
-    uint32_t rcc_pos = ((uint32_t)regs - IOPORT_BASE) / 0x400;
-    RCC->IOPENR |= 1 << rcc_pos;
-    RCC->IOPENR;
-}
-
-#if !CONFIG_STM32_CLOCK_REF_INTERNAL
-DECL_CONSTANT_STR("RESERVE_PINS_crystal", "PF0,PF1");
-#endif
-
-// Configure and enable the PLL as clock source
-static void
-clock_setup(void)
-{
-    uint32_t pll_base = 4000000, pll_freq = 192000000, pllcfgr;
-    if (!CONFIG_STM32_CLOCK_REF_INTERNAL) {
-        // Configure PLL from external crystal (HSE)
-        uint32_t div = CONFIG_CLOCK_REF_FREQ / pll_base;
-        RCC->CR |= RCC_CR_HSEON;
-        pllcfgr = RCC_PLLCFGR_PLLSRC_HSE | ((div - 1) << RCC_PLLCFGR_PLLM_Pos);
-    } else {
-        // Configure PLL from internal 16Mhz oscillator (HSI)
-        uint32_t div = 16000000 / pll_base;
-        pllcfgr = RCC_PLLCFGR_PLLSRC_HSI | ((div - 1) << RCC_PLLCFGR_PLLM_Pos);
-    }
-    pllcfgr |= (pll_freq/pll_base) << RCC_PLLCFGR_PLLN_Pos;
-    pllcfgr |= (pll_freq/CONFIG_CLOCK_FREQ - 1) << RCC_PLLCFGR_PLLR_Pos;
-    pllcfgr |= (pll_freq/FREQ_USB - 1) << RCC_PLLCFGR_PLLQ_Pos;
-    RCC->PLLCFGR = pllcfgr | RCC_PLLCFGR_PLLREN | RCC_PLLCFGR_PLLQEN;
-    RCC->CR |= RCC_CR_PLLON;
-
-    // Wait for PLL lock
-    while (!(RCC->CR & RCC_CR_PLLRDY))
-        ;
-
-    // Switch system clock to PLL
-    RCC->CFGR = (2 << RCC_CFGR_SW_Pos);
-    while ((RCC->CFGR & RCC_CFGR_SWS_Msk) != (2 << RCC_CFGR_SWS_Pos))
-        ;
-
-    // Use PLLQCLK for USB (setting USBSEL=2 works in practice)
-    RCC->CCIPR2 = 2 << RCC_CCIPR2_USBSEL_Pos;
-}
-
-
-/****************************************************************
- * Bootloader
- ****************************************************************/
-
-// Handle USB reboot requests
-void
-bootloader_request(void)
-{
-    try_request_canboot();
-    dfu_reboot();
-}
-
-
-/****************************************************************
- * Startup
- ****************************************************************/
-
-// Main entry point - called from armcm_boot.c:ResetHandler()
-void
-armcm_main(void)
-{
-    SCB->VTOR = (uint32_t)VectorTable;
-
-    // Reset clock registers (in case bootloader has changed them)
-    RCC->CR |= RCC_CR_HSION;
-    while (!(RCC->CR & RCC_CR_HSIRDY))
-        ;
-    RCC->CFGR = 0x00000000;
-    RCC->CR = RCC_CR_HSION;
-    while (RCC->CR & RCC_CR_PLLRDY)
-        ;
-    RCC->PLLCFGR = 0x00001000;
-    RCC->IOPENR = 0x00000000;
-    RCC->AHBENR = 0x00000100;
-    RCC->APBENR1 = 0x00000000;
-    RCC->APBENR2 = 0x00000000;
-
-    dfu_reboot_check();
-
-    // Set flash latency, cache and prefetch; use reset value as base
-    uint32_t acr = 0x00040600;
-    acr = (acr & ~FLASH_ACR_LATENCY) | (2<<FLASH_ACR_LATENCY_Pos);
-    acr |= FLASH_ACR_ICEN | FLASH_ACR_PRFTEN;
-    FLASH->ACR = acr;
-
-    // Configure main clock
-    clock_setup();
-
-    sched_main();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/stm32g4.c crealityShit/src/stm32/stm32g4.c
--- klipperStock/src/stm32/stm32g4.c	2024-01-14 23:02:00.101796106 -0600
+++ crealityShit/src/stm32/stm32g4.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,167 +0,0 @@
-// Code to setup clocks and gpio on stm32g4
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_CLOCK_REF_FREQ
-#include "board/armcm_boot.h" // VectorTable
-#include "board/irq.h" // irq_disable
-#include "command.h" // DECL_CONSTANT_STR
-#include "internal.h" // enable_pclock
-#include "sched.h" // sched_main
-
-#define FREQ_PERIPH_DIV 1
-#define FREQ_PERIPH (CONFIG_CLOCK_FREQ / FREQ_PERIPH_DIV)
-
-// Map a peripheral address to its enable bits
-struct cline
-lookup_clock_line(uint32_t periph_base)
-{
-    if (periph_base < APB2PERIPH_BASE) {
-        uint32_t pos = (periph_base - APB1PERIPH_BASE) / 0x400;
-        if (pos < 32) {
-            return (struct cline){.en = &RCC->APB1ENR1,
-                                  .rst = &RCC->APB1RSTR1,
-                                  .bit = 1 << pos};
-        } else {
-            return (struct cline){.en = &RCC->APB1ENR2,
-                                  .rst = &RCC->APB1RSTR2,
-                                  .bit = 1 << (pos - 32)};
-        }
-    } else if (periph_base < AHB1PERIPH_BASE) {
-        uint32_t pos = (periph_base - APB2PERIPH_BASE) / 0x400;
-        return (struct cline){.en = &RCC->APB2ENR,
-                              .rst = &RCC->APB2RSTR,
-                              .bit = 1 << pos};
-
-    } else if (periph_base < AHB2PERIPH_BASE) {
-        uint32_t pos = (periph_base - AHB1PERIPH_BASE) / 0x400;
-        return (struct cline){.en = &RCC->AHB1ENR,
-                              .rst = &RCC->AHB1RSTR,
-                              .bit = 1 << pos};
-
-    } else {
-        uint32_t pos = (periph_base - AHB2PERIPH_BASE) / 0x400;
-        return (struct cline){.en = &RCC->AHB2ENR,
-                              .rst = &RCC->AHB2RSTR,
-                              .bit = 1 << pos};
-    }
-}
-
-// Return the frequency of the given peripheral clock
-uint32_t
-get_pclock_frequency(uint32_t periph_base)
-{
-    return FREQ_PERIPH;
-}
-
-// Enable a GPIO peripheral clock
-void
-gpio_clock_enable(GPIO_TypeDef *regs)
-{
-    uint32_t rcc_pos = ((uint32_t)regs - GPIOA_BASE) / 0x400;
-    RCC->AHB2ENR |= 1 << rcc_pos;
-    RCC->AHB2ENR;
-}
-
-#if !CONFIG_STM32_CLOCK_REF_INTERNAL
-DECL_CONSTANT_STR("RESERVE_PINS_crystal", "PF0,PF1");
-#endif
-
-static void
-enable_clock_stm32g4(void)
-{
-    uint32_t pll_base = 4000000, pll_freq = CONFIG_CLOCK_FREQ * 2, pllcfgr;
-    if (!CONFIG_STM32_CLOCK_REF_INTERNAL) {
-        // Configure 150Mhz PLL from external crystal (HSE)
-        uint32_t div = CONFIG_CLOCK_REF_FREQ / pll_base - 1;
-        RCC->CR |= RCC_CR_HSEON;
-        while (!(RCC->CR & RCC_CR_HSERDY))
-            ;
-        pllcfgr = RCC_PLLCFGR_PLLSRC_HSE | (div << RCC_PLLCFGR_PLLM_Pos);
-    } else {
-        // Configure 150Mhz PLL from internal 16Mhz oscillator (HSI)
-        uint32_t div = 16000000 / pll_base - 1;
-        pllcfgr = RCC_PLLCFGR_PLLSRC_HSI | (div << RCC_PLLCFGR_PLLM_Pos);
-        RCC->CR |= RCC_CR_HSION;
-        while (!(RCC->CR & RCC_CR_HSIRDY))
-            ;
-    }
-    RCC->PLLCFGR = (pllcfgr | ((pll_freq/pll_base) << RCC_PLLCFGR_PLLN_Pos)
-                    | (0 << RCC_PLLCFGR_PLLR_Pos));
-    RCC->CR |= RCC_CR_PLLON;
-
-    // Enable 48Mhz USB clock using clock recovery
-    if (CONFIG_USBSERIAL) {
-        RCC->CRRCR |= RCC_CRRCR_HSI48ON;
-        while (!(RCC->CRRCR & RCC_CRRCR_HSI48RDY))
-            ;
-        enable_pclock(CRS_BASE);
-        CRS->CR |= CRS_CR_AUTOTRIMEN | CRS_CR_CEN;
-    }
-}
-
-// Main clock setup called at chip startup
-static void
-clock_setup(void)
-{
-    enable_clock_stm32g4();
-
-    // Set flash latency
-    uint32_t latency = ((CONFIG_CLOCK_FREQ>150000000) ? FLASH_ACR_LATENCY_5WS :
-                       ((CONFIG_CLOCK_FREQ>120000000) ? FLASH_ACR_LATENCY_4WS :
-                       ((CONFIG_CLOCK_FREQ>90000000) ? FLASH_ACR_LATENCY_3WS :
-                       ((CONFIG_CLOCK_FREQ>60000000) ? FLASH_ACR_LATENCY_2WS :
-                       ((CONFIG_CLOCK_FREQ>30000000) ? FLASH_ACR_LATENCY_1WS :
-                                                    FLASH_ACR_LATENCY_0WS)))));
-    FLASH->ACR = (latency | FLASH_ACR_ICEN | FLASH_ACR_DCEN
-                  | FLASH_ACR_PRFTEN | FLASH_ACR_DBG_SWEN);
-
-    enable_pclock(PWR_BASE);
-    PWR->CR3 |= PWR_CR3_APC; // allow gpio pullup/down
-
-    // Wait for PLL lock
-    while (!(RCC->CR & RCC_CR_PLLRDY))
-        ;
-
-    RCC->PLLCFGR |= RCC_PLLCFGR_PLLREN;
-
-    // Switch system clock to PLL
-    RCC->CFGR = RCC_CFGR_HPRE_DIV1 | RCC_CFGR_PPRE1_DIV1 | RCC_CFGR_PPRE2_DIV1
-                | RCC_CFGR_SW_PLL;
-    while ((RCC->CFGR & RCC_CFGR_SWS_Msk) != RCC_CFGR_SWS_PLL)
-        ;
-}
-
-
-/****************************************************************
- * Bootloader
- ****************************************************************/
-
-// Handle USB reboot requests
-void
-bootloader_request(void)
-{
-    dfu_reboot();
-}
-
-
-/****************************************************************
- * Startup
- ****************************************************************/
-
-// Main entry point - called from armcm_boot.c:ResetHandler()
-void
-armcm_main(void)
-{
-    dfu_reboot_check();
-
-    // Run SystemInit() and then restore VTOR
-    SystemInit();
-    SCB->VTOR = (uint32_t)VectorTable;
-
-    clock_setup();
-
-    sched_main();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/stm32h7_adc.c crealityShit/src/stm32/stm32h7_adc.c
--- klipperStock/src/stm32/stm32h7_adc.c	2024-01-14 23:02:00.097796058 -0600
+++ crealityShit/src/stm32/stm32h7_adc.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,399 +0,0 @@
-// ADC functions on STM32H7
-//
-// Copyright (C) 2020 Konstantin Vogel <konstantin.vogel@gmx.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/irq.h" // irq_save
-#include "board/misc.h" // timer_from_us
-#include "command.h" // shutdown
-#include "compiler.h" // ARRAY_SIZE
-#include "generic/armcm_timer.h" // udelay
-#include "gpio.h" // gpio_adc_setup
-#include "internal.h" // GPIO
-#include "sched.h" // sched_shutdown
-
-#if CONFIG_MACH_STM32H7
-  #define ADCIN_BANK_SIZE                     (20)
-  #define RCC_AHBENR_ADC                      (RCC->AHB1ENR)
-  #define RCC_AHBENR_ADCEN                    (RCC_AHB1ENR_ADC12EN)
-  #define ADC_CKMODE                          (0b11)
-  #define ADC_ATICKS                          (0b101)
-  #define ADC_RES                             (0b110)
-  #define ADC_TS                              (ADC3_COMMON)
-  #if CONFIG_MACH_STM32H723
-    #define PCSEL                               PCSEL_RES0
-  #endif
-
-  // Number of samples is 2^OVERSAMPLES_EXPONENT (exponent can be 0-10)
-  #define OVERSAMPLES_EXPONENT 3
-  #define OVERSAMPLES (1 << OVERSAMPLES_EXPONENT)
-
-  // LDORDY registers are missing from CMSIS (only available on revision V!)
-  #define ADC_ISR_LDORDY_Pos                  (12U)
-  #define ADC_ISR_LDORDY_Msk                  (0x1UL << ADC_ISR_LDORDY_Pos)
-  #define ADC_ISR_LDORDY                      ADC_ISR_LDORDY_Msk
-
-#elif CONFIG_MACH_STM32L4
-  #define ADCIN_BANK_SIZE                     (19)
-  #define RCC_AHBENR_ADC                      (RCC->AHB2ENR)
-  #define RCC_AHBENR_ADCEN                    (RCC_AHB2ENR_ADCEN)
-  #define ADC_CKMODE                          (0)
-  #define ADC_ATICKS                          (0b100)
-  #define ADC_RES                             (0b00)
-  #define ADC_TS                              (ADC12_COMMON)
-
-  #define OVERSAMPLES                         (0)
-
-#elif CONFIG_MACH_STM32G4
-  #define ADCIN_BANK_SIZE                     (19)
-  #define RCC_AHBENR_ADC                      (RCC->AHB2ENR)
-  #define RCC_AHBENR_ADCEN                    (RCC_AHB2ENR_ADC12EN)
-  #define ADC_CKMODE                          (0b11)
-  #define ADC_ATICKS                          (0b100)
-  #define ADC_RES                             (0b00)
-  #define ADC_TS                              (ADC12_COMMON)
-  #define ADC_CCR_TSEN                        (ADC_CCR_VSENSESEL)
-
-  #define OVERSAMPLES                         (0)
-#endif
-
-#define ADC_TEMPERATURE_PIN 0xfe
-DECL_ENUMERATION("pin", "ADC_TEMPERATURE", ADC_TEMPERATURE_PIN);
-
-DECL_CONSTANT("ADC_MAX", 4095);
-
-// GPIOs like A0_C are not covered!
-// This always gives the pin connected to the positive channel
-static const uint8_t adc_pins[] = {
-#if CONFIG_MACH_STM32H7
-    // ADC1
-    0, // PA0_C                ADC12_INP0
-    0, // PA1_C                ADC12_INP1
-    GPIO('F', 11), //           ADC1_INP2
-    GPIO('A', 6),  //          ADC12_INP3
-    GPIO('C', 4),  //          ADC12_INP4
-    GPIO('B', 1),  //          ADC12_INP5
-    GPIO('F', 12), //           ADC1_INP6
-    GPIO('A', 7),  //          ADC12_INP7
-    GPIO('C', 5),  //          ADC12_INP8
-    GPIO('B', 0),  //          ADC12_INP9
-    GPIO('C', 0),  //        ADC123_INP10
-    GPIO('C', 1),  //        ADC123_INP11
-    GPIO('C', 2),  //        ADC123_INP12
-    GPIO('C', 3),  //         ADC12_INP13
-    GPIO('A', 2),  //         ADC12_INP14
-    GPIO('A', 3),  //         ADC12_INP15
-    GPIO('A', 0),  //          ADC1_INP16
-    GPIO('A', 1),  //          ADC1_INP17
-    GPIO('A', 4),  //         ADC12_INP18
-    GPIO('A', 5),  //         ADC12_INP19
-    // ADC2
-    0, // PA0_C                ADC12_INP0
-    0, // PA1_C                ADC12_INP1
-    GPIO('F', 13), //           ADC2_INP2
-    GPIO('A', 6),  //          ADC12_INP3
-    GPIO('C', 4),  //          ADC12_INP4
-    GPIO('B', 1),  //          ADC12_INP5
-    GPIO('F', 14), //           ADC2_INP6
-    GPIO('A', 7),  //          ADC12_INP7
-    GPIO('C', 5),  //          ADC12_INP8
-    GPIO('B', 0),  //          ADC12_INP9
-    GPIO('C', 0),  //        ADC123_INP10
-    GPIO('C', 1),  //        ADC123_INP11
-    GPIO('C', 2),  //        ADC123_INP12
-    GPIO('C', 3),  //         ADC12_INP13
-    GPIO('A', 2),  //         ADC12_INP14
-    GPIO('A', 3),  //         ADC12_INP15
-    0,             //            dac_out1
-    0,             //            dac_out2
-    GPIO('A', 4),  //         ADC12_INP18
-    GPIO('A', 5),  //         ADC12_INP19
-    // ADC3
-    0, // PC2_C                 ADC3_INP0
-    0, // PC3_C                 ADC3_INP1
-    GPIO('F', 9) , //           ADC3_INP2
-    GPIO('F', 7),  //           ADC3_INP3
-    GPIO('F', 5),  //           ADC3_INP4
-    GPIO('F', 3),  //           ADC3_INP5
-    GPIO('F', 10), //           ADC3_INP6
-    GPIO('F', 8),  //           ADC3_INP7
-    GPIO('F', 6),  //           ADC3_INP8
-    GPIO('F', 4),  //           ADC3_INP9
-    GPIO('C', 0),  //        ADC123_INP10
-    GPIO('C', 1),  //        ADC123_INP11
-    GPIO('C', 2),  //        ADC123_INP12
-    GPIO('H', 2),  //          ADC3_INP13
-    GPIO('H', 3),  //          ADC3_INP14
-    GPIO('H', 4),  //          ADC3_INP15
-    GPIO('H', 5),  //          ADC3_INP16
-  #if CONFIG_MACH_STM32H723
-    ADC_TEMPERATURE_PIN,
-    0,
-  #else
-    0,             //              Vbat/4
-    ADC_TEMPERATURE_PIN,//         VSENSE
-  #endif
-    0,             //             VREFINT
-#elif CONFIG_MACH_STM32G4
-    0,                      // [0] vssa
-    GPIO('A', 0),           // [1]
-    GPIO('A', 1),           // [2]
-    GPIO('A', 2),           // [3]
-    GPIO('A', 3),           // [4]
-    GPIO('B', 14),          // [5]
-    GPIO('C', 0),           // [6]
-    GPIO('C', 1),           // [7]
-    GPIO('C', 2),           // [8]
-    GPIO('C', 3),           // [9]
-    GPIO('F', 0),           // [10]
-    GPIO('B', 12),          // [11]
-    GPIO('B', 1),           // [12]
-    0,                      // [13] opamp
-    GPIO('B', 11),          // [14]
-    GPIO('B', 0),           // [15]
-    ADC_TEMPERATURE_PIN,    // [16] vtemp
-    0,                      // [17] vbat/3
-    0,                      // [18] vref
-    0,                      // [0] vssa       ADC 2
-    GPIO('A', 0),           // [1]
-    GPIO('A', 1),           // [2]
-    GPIO('A', 6),           // [3]
-    GPIO('A', 7),           // [4]
-    GPIO('C', 4),           // [5]
-    GPIO('C', 0),           // [6]
-    GPIO('C', 1),           // [7]
-    GPIO('C', 2),           // [8]
-    GPIO('C', 3),           // [9]
-    GPIO('F', 1),           // [10]
-    GPIO('C', 5),           // [11]
-    GPIO('B', 2),           // [12]
-    GPIO('A', 5),           // [13]
-    GPIO('B', 11),          // [14]
-    GPIO('B', 15),          // [15]
-    0,                      // [16] opamp
-    GPIO('A', 4),           // [17]
-    0,                      // [18] opamp
-#else // stm32l4
-    0,                      // vref
-    GPIO('C', 0),           // ADC12_IN1 .. 16
-    GPIO('C', 1),
-    GPIO('C', 2),
-    GPIO('C', 3),
-    GPIO('A', 0),
-    GPIO('A', 1),
-    GPIO('A', 2),
-    GPIO('A', 3),
-    GPIO('A', 4),
-    GPIO('A', 5),
-    GPIO('A', 6),
-    GPIO('A', 7),
-    GPIO('C', 4),
-    GPIO('C', 5),
-    GPIO('B', 0),
-    GPIO('B', 1),
-    ADC_TEMPERATURE_PIN,    // temp
-    0,                      // vbat
-#endif
-};
-
-
-// ADC timing:
-// ADC clock=30Mhz, Tconv=6.5, Tsamp=64.5, total=2.3666us*OVERSAMPLES
-
-struct gpio_adc
-gpio_adc_setup(uint32_t pin)
-{
-    // Find pin in adc_pins table
-    int chan;
-    for (chan=0; ; chan++) {
-        if (chan >= ARRAY_SIZE(adc_pins))
-            shutdown("Not a valid ADC pin");
-        if (adc_pins[chan] == pin)
-            break;
-    }
-
-    // Determine which ADC block to use, enable peripheral clock
-    // (SYSCLK 480Mhz) /HPRE(2) /CKMODE divider(4) /additional divider(2)
-    // (ADC clock 30Mhz)
-    ADC_TypeDef *adc;
-#ifdef ADC3
-    if (chan >= 2 * ADCIN_BANK_SIZE){
-        adc = ADC3;
-        if (!is_enabled_pclock(ADC3_BASE)) {
-            enable_pclock(ADC3_BASE);
-        }
-        MODIFY_REG(ADC3_COMMON->CCR, ADC_CCR_CKMODE_Msk,
-            ADC_CKMODE << ADC_CCR_CKMODE_Pos);
-        chan -= 2 * ADCIN_BANK_SIZE;
-    } else
-#endif
-#ifdef ADC2
-    if (chan >= ADCIN_BANK_SIZE){
-        adc = ADC2;
-        RCC_AHBENR_ADC |= RCC_AHBENR_ADCEN;
-        MODIFY_REG(ADC12_COMMON->CCR, ADC_CCR_CKMODE_Msk,
-            ADC_CKMODE << ADC_CCR_CKMODE_Pos);
-        chan -= ADCIN_BANK_SIZE;
-    } else
-#endif
-    {
-        adc = ADC1;
-        RCC_AHBENR_ADC |= RCC_AHBENR_ADCEN;
-        MODIFY_REG(ADC12_COMMON->CCR, ADC_CCR_CKMODE_Msk,
-            ADC_CKMODE << ADC_CCR_CKMODE_Pos);
-    }
-
-    // Enable the ADC
-    if (!(adc->CR & ADC_CR_ADEN)) {
-        // STM32H723 ADC3 and ADC1/2 registers are slightly different
-        uint8_t is_stm32h723_adc3 = 0;
-#if CONFIG_MACH_STM32H723
-        if (adc == ADC3) {
-            is_stm32h723_adc3 = 1;
-        }
-#endif
-        // Pwr
-        // Exit deep power down
-        MODIFY_REG(adc->CR, ADC_CR_DEEPPWD_Msk, 0);
-        // Switch on voltage regulator
-        adc->CR |= ADC_CR_ADVREGEN;
-#ifdef ADC_ISR_LDORDY
-        if (is_stm32h723_adc3 == 0) {
-            while(!(adc->ISR & ADC_ISR_LDORDY))
-                ;
-        } else
-#endif
-        {
-            // stm32h723 ADC3 & stm32l4 lacks ldordy, delay to spec instead
-            uint32_t end = timer_read_time() + timer_from_us(20);
-            while (timer_is_before(timer_read_time(), end))
-                ;
-        }
-
-        // Set Boost mode for 25Mhz < ADC clock <= 50Mhz
-#ifdef ADC_CR_BOOST
-        MODIFY_REG(adc->CR, ADC_CR_BOOST_Msk, 0b11 << ADC_CR_BOOST_Pos);
-#endif
-
-        // Calibration
-        // Set calibration mode to Single ended (not differential)
-        MODIFY_REG(adc->CR, ADC_CR_ADCALDIF_Msk, 0);
-        // Enable linearity calibration
-#ifdef ADC_CR_ADCALLIN
-        MODIFY_REG(adc->CR, ADC_CR_ADCALLIN_Msk, ADC_CR_ADCALLIN);
-#endif
-        // Start the calibration
-        MODIFY_REG(adc->CR, ADC_CR_ADCAL_Msk, ADC_CR_ADCAL);
-        while(adc->CR & ADC_CR_ADCAL)
-            ;
-
-        // Enable ADC
-        // "Clear the ADRDY bit in the ADC_ISR register by writing ‘1’"
-        adc->ISR |= ADC_ISR_ADRDY;
-        adc->ISR; // Dummy read to make sure write is flushed
-        adc->CR |= ADC_CR_ADEN;
-        while(!(adc->ISR & ADC_ISR_ADRDY))
-           ;
-
-        // Set 64.5 ADC clock cycles sample time for every channel
-        // (Reference manual pg.940)
-        uint32_t aticks = ADC_ATICKS;
-        // Channel 0-9
-        adc->SMPR1 = (aticks        | (aticks << 3)  | (aticks << 6)
-                   | (aticks << 9)  | (aticks << 12) | (aticks << 15)
-                   | (aticks << 18) | (aticks << 21) | (aticks << 24)
-                   | (aticks << 27));
-        // Channel 10-19
-        adc->SMPR2 = (aticks        | (aticks << 3)  | (aticks << 6)
-                   | (aticks << 9)  | (aticks << 12) | (aticks << 15)
-                   | (aticks << 18) | (aticks << 21) | (aticks << 24)
-                   | (aticks << 27));
-        // Disable Continuous Mode
-        MODIFY_REG(adc->CFGR, ADC_CFGR_CONT_Msk, 0);
-        // Set to 12 bit
-        if (is_stm32h723_adc3) {
-#ifdef ADC3_CFGR_RES
-            MODIFY_REG(adc->CFGR, ADC3_CFGR_RES_Msk, 0 << ADC3_CFGR_RES_Pos);
-            MODIFY_REG(adc->CFGR, ADC3_CFGR_ALIGN_Msk, 0<<ADC3_CFGR_ALIGN_Pos);
-#endif
-        } else {
-            MODIFY_REG(adc->CFGR, ADC_CFGR_RES_Msk, ADC_RES<<ADC_CFGR_RES_Pos);
-        }
-#if CONFIG_MACH_STM32H7
-        // Set hardware oversampling
-        MODIFY_REG(adc->CFGR2, ADC_CFGR2_ROVSE_Msk, ADC_CFGR2_ROVSE);
-        if (is_stm32h723_adc3) {
-#ifdef ADC3_CFGR2_OVSR
-            MODIFY_REG(adc->CFGR2, ADC3_CFGR2_OVSR_Msk,
-                       (OVERSAMPLES_EXPONENT - 1) << ADC3_CFGR2_OVSR_Pos);
-#endif
-        } else {
-            MODIFY_REG(adc->CFGR2, ADC_CFGR2_OVSR_Msk,
-                       (OVERSAMPLES - 1) << ADC_CFGR2_OVSR_Pos);
-        }
-        MODIFY_REG(adc->CFGR2, ADC_CFGR2_OVSS_Msk,
-            OVERSAMPLES_EXPONENT << ADC_CFGR2_OVSS_Pos);
-#else // stm32l4
-        adc->CFGR |= ADC_CFGR_JQDIS | ADC_CFGR_OVRMOD;
-#endif
-    }
-
-    if (pin == ADC_TEMPERATURE_PIN) {
-        ADC_TS->CCR |= ADC_CCR_TSEN;
-    } else {
-        gpio_peripheral(pin, GPIO_ANALOG, 0);
-    }
-
-    // Preselect (connect) channel
-#ifdef ADC_PCSEL_PCSEL
-    adc->PCSEL |= (1 << chan);
-#endif
-    return (struct gpio_adc){ .adc = adc, .chan = chan };
-}
-
-// Try to sample a value. Returns zero if sample ready, otherwise
-// returns the number of clock ticks the caller should wait before
-// retrying this function.
-uint32_t
-gpio_adc_sample(struct gpio_adc g)
-{
-    ADC_TypeDef *adc = g.adc;
-    uint32_t cr = adc->CR;
-    if (cr & ADC_CR_ADSTART)
-        goto need_delay;
-    if (adc->ISR & ADC_ISR_EOC) {
-        if (adc->SQR1 == (g.chan << ADC_SQR1_SQ1_Pos))
-            return 0;
-        goto need_delay;
-    }
-    // Start sample
-    adc->SQR1 = (g.chan << ADC_SQR1_SQ1_Pos);
-    adc->CR = cr | ADC_CR_ADSTART;
-need_delay:
-    return timer_from_us(20);
-}
-
-// Read a value; use only after gpio_adc_sample() returns zero
-uint16_t
-gpio_adc_read(struct gpio_adc g)
-{
-    ADC_TypeDef *adc = g.adc;
-    return adc->DR;
-}
-
-// Cancel a sample that may have been started with gpio_adc_sample()
-void
-gpio_adc_cancel_sample(struct gpio_adc g)
-{
-    ADC_TypeDef *adc = g.adc;
-    irqstatus_t flag = irq_save();
-    if (adc->SQR1 == (g.chan << ADC_SQR1_SQ1_Pos)) {
-        uint32_t cr = adc->CR;
-        if (cr & ADC_CR_ADSTART)
-            adc->CR = (cr & ~ADC_CR_ADSTART) | ADC_CR_ADSTP;
-        if (adc->ISR & ADC_ISR_EOC)
-            gpio_adc_read(g);
-    }
-    irq_restore(flag);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/stm32h7.c crealityShit/src/stm32/stm32h7.c
--- klipperStock/src/stm32/stm32h7.c	2024-01-14 23:02:00.105796157 -0600
+++ crealityShit/src/stm32/stm32h7.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,241 +0,0 @@
-// Code to setup clocks on stm32h7
-//
-// Copyright (C) 2020 Konstantin Vogel <konstantin.vogel@gmx.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_CLOCK_REF_FREQ
-#include "board/armcm_boot.h" // VectorTable
-#include "board/armcm_reset.h" // try_request_canboot
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // bootloader_request
-#include "command.h" // DECL_CONSTANT_STR
-#include "internal.h" // get_pclock_frequency
-#include "sched.h" // sched_main
-
-
-/****************************************************************
- * Clock setup
- ****************************************************************/
-
-#define FREQ_PERIPH (CONFIG_CLOCK_FREQ / 4)
-
-// Map a peripheral address to its enable bits
-struct cline
-lookup_clock_line(uint32_t periph_base)
-{
-    if (periph_base >= D3_AHB1PERIPH_BASE) {
-        uint32_t bit = 1 << ((periph_base - D3_AHB1PERIPH_BASE) / 0x400);
-        return (struct cline){.en=&RCC->AHB4ENR, .rst=&RCC->AHB4RSTR, .bit=bit};
-    } else if (periph_base >= D3_APB1PERIPH_BASE) {
-        uint32_t bit = 1 << ((periph_base - D3_APB1PERIPH_BASE) / 0x400);
-        return (struct cline){.en=&RCC->APB4ENR, .rst=&RCC->APB4RSTR, .bit=bit};
-    } else if (periph_base >= D1_AHB1PERIPH_BASE) {
-        uint32_t bit = 1 << ((periph_base - D1_AHB1PERIPH_BASE) / 0x400);
-        return (struct cline){.en=&RCC->AHB3ENR, .rst=&RCC->AHB3RSTR, .bit=bit};
-    } else if (periph_base >= D1_APB1PERIPH_BASE) {
-        uint32_t bit = 1 << ((periph_base - D1_APB1PERIPH_BASE) / 0x400);
-        return (struct cline){.en=&RCC->APB3ENR, .rst=&RCC->APB3RSTR, .bit=bit};
-    } else if (periph_base >= D2_AHB2PERIPH_BASE) {
-        uint32_t bit = 1 << ((periph_base - D2_AHB2PERIPH_BASE) / 0x400);
-        return (struct cline){.en=&RCC->AHB2ENR, .rst=&RCC->AHB2RSTR, .bit=bit};
-    } else if (periph_base >= D2_AHB1PERIPH_BASE) {
-        uint32_t bit = 1 << ((periph_base - D2_AHB1PERIPH_BASE) / 0x400);
-        return (struct cline){.en=&RCC->AHB1ENR, .rst=&RCC->AHB1RSTR, .bit=bit};
-    } else if (periph_base >= D2_APB2PERIPH_BASE) {
-        uint32_t bit = 1 << ((periph_base - D2_APB2PERIPH_BASE) / 0x400);
-        return (struct cline){.en=&RCC->APB2ENR, .rst=&RCC->APB2RSTR, .bit=bit};
-    } else {
-        uint32_t offset = ((periph_base - D2_APB1PERIPH_BASE) / 0x400);
-        if (offset < 32) {
-            uint32_t bit = 1 << offset;
-            return (struct cline){
-                .en=&RCC->APB1LENR, .rst=&RCC->APB1LRSTR, .bit=bit};
-        } else {
-            uint32_t bit = 1 << (offset - 32);
-            return (struct cline){
-                .en=&RCC->APB1HENR, .rst=&RCC->APB1HRSTR, .bit=bit};
-        }
-    }
-}
-
-// Return the frequency of the given peripheral clock
-uint32_t
-get_pclock_frequency(uint32_t periph_base)
-{
-    return FREQ_PERIPH;
-}
-
-// Enable a GPIO peripheral clock
-void
-gpio_clock_enable(GPIO_TypeDef *regs)
-{
-    uint32_t pos = ((uint32_t)regs - D3_AHB1PERIPH_BASE) / 0x400;
-    RCC->AHB4ENR |= (1<<pos);
-    RCC->AHB4ENR;
-}
-
-#if !CONFIG_STM32_CLOCK_REF_INTERNAL
-DECL_CONSTANT_STR("RESERVE_PINS_crystal", "PH0,PH1");
-#endif
-
-// Main clock and power setup called at chip startup
-static void
-clock_setup(void)
-{
-#if !CONFIG_MACH_STM32H723
-    // Ensure USB OTG ULPI is not enabled
-    CLEAR_BIT(RCC->AHB1ENR, RCC_AHB1ENR_USB2OTGHSULPIEN);
-    CLEAR_BIT(RCC->AHB1LPENR, RCC_AHB1LPENR_USB2OTGHSULPILPEN);
-#endif
-    // Set this despite correct defaults.
-    // "The software has to program the supply configuration in PWR control
-    // register 3" (pg. 259)
-    // Only a single write is allowed (pg. 304)
-    PWR->CR3 = (PWR->CR3 | PWR_CR3_LDOEN) & ~(PWR_CR3_BYPASS | PWR_CR3_SCUEN);
-    while (!(PWR->CSR1 & PWR_CSR1_ACTVOSRDY))
-        ;
-    // (HSE 25mhz) /DIVM1(5) (pll_base 5Mhz) *DIVN1(192) (pll_freq 960Mhz)
-    // /DIVP1(2) (SYSCLK 480Mhz)
-    uint32_t pll_base = 5000000;
-    // Only even dividers (DIVP1) are allowed
-    uint32_t pll_freq = CONFIG_CLOCK_FREQ * 2;
-    if (!CONFIG_STM32_CLOCK_REF_INTERNAL) {
-        // Configure PLL from external crystal (HSE)
-        RCC->CR |= RCC_CR_HSEON;
-        while(!(RCC->CR & RCC_CR_HSERDY))
-            ;
-        MODIFY_REG(RCC->PLLCKSELR, RCC_PLLCKSELR_PLLSRC_Msk,
-                                   RCC_PLLCKSELR_PLLSRC_HSE);
-        MODIFY_REG(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM1_Msk,
-            (CONFIG_CLOCK_REF_FREQ/pll_base) << RCC_PLLCKSELR_DIVM1_Pos);
-    } else {
-        // Configure PLL from internal 64Mhz oscillator (HSI)
-        // HSI frequency of 64Mhz is integer divisible with 4Mhz
-        pll_base = 4000000;
-        MODIFY_REG(RCC->PLLCKSELR, RCC_PLLCKSELR_PLLSRC_Msk,
-                                   RCC_PLLCKSELR_PLLSRC_HSI);
-        MODIFY_REG(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM1_Msk,
-          (64000000/pll_base) << RCC_PLLCKSELR_DIVM1_Pos);
-    }
-    // Set input frequency range of PLL1 according to pll_base
-    // 3 = 8-16Mhz, 2 = 4-8Mhz
-    MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL1RGE_Msk, RCC_PLLCFGR_PLL1RGE_2);
-    // Disable unused PLL1 outputs
-    MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_DIVR1EN_Msk, 0);
-    // Enable PLL1Q and set to 100MHz for SPI 1,2,3
-    MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ1EN, RCC_PLLCFGR_DIVQ1EN);
-    MODIFY_REG(RCC->PLL1DIVR, RCC_PLL1DIVR_Q1,
-        (pll_freq / FREQ_PERIPH - 1) << RCC_PLL1DIVR_Q1_Pos);
-    // This is necessary, default is not 1!
-    MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_DIVP1EN_Msk, RCC_PLLCFGR_DIVP1EN);
-    // Set multiplier DIVN1 and post divider DIVP1
-    // 001 = /2, 010 = not allowed, 0011 = /4 ...
-    MODIFY_REG(RCC->PLL1DIVR, RCC_PLL1DIVR_N1_Msk,
-        (pll_freq/pll_base - 1) << RCC_PLL1DIVR_N1_Pos);
-    MODIFY_REG(RCC->PLL1DIVR, RCC_PLL1DIVR_P1_Msk,
-        (pll_freq/CONFIG_CLOCK_FREQ - 1) << RCC_PLL1DIVR_P1_Pos);
-
-    // Pwr
-    MODIFY_REG(PWR->D3CR, PWR_D3CR_VOS_Msk, PWR_D3CR_VOS);
-    while (!(PWR->D3CR & PWR_D3CR_VOSRDY))
-        ;
-
-    // Enable VOS0 (overdrive)
-    if (CONFIG_CLOCK_FREQ > 400000000) {
-        RCC->APB4ENR |= RCC_APB4ENR_SYSCFGEN;
-#if !CONFIG_MACH_STM32H723
-        SYSCFG->PWRCR |= SYSCFG_PWRCR_ODEN;
-#else
-        PWR->CR3 |= PWR_CR3_BYPASS;
-#endif
-        while (!(PWR->D3CR & PWR_D3CR_VOSRDY))
-            ;
-    }
-
-    SCB_EnableICache();
-    SCB_EnableDCache();
-
-    // Set flash latency according to clock frequency (pg.159)
-    uint32_t flash_acr_latency = (CONFIG_CLOCK_FREQ > 450000000) ?
-        FLASH_ACR_LATENCY_4WS : FLASH_ACR_LATENCY_2WS;
-    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY_Msk, flash_acr_latency);
-    MODIFY_REG(FLASH->ACR, FLASH_ACR_WRHIGHFREQ_Msk, FLASH_ACR_WRHIGHFREQ_1);
-    while (!(FLASH->ACR & flash_acr_latency))
-        ;
-
-    // Set HPRE, D1PPRE, D2PPRE, D2PPRE2, D3PPRE dividers
-    // 480MHz / 2 = 240MHz rcc_hclk3
-    MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE,    RCC_D1CFGR_HPRE_3);
-    // 240MHz / 2 = 120MHz rcc_pclk3
-    MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE,  RCC_D1CFGR_D1PPRE_DIV2);
-    // 240MHz / 2 = 120MHz rcc_pclk1
-    MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, RCC_D2CFGR_D2PPRE1_DIV2);
-    // 240MHz / 2 = 120MHz rcc_pclk2
-    MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, RCC_D2CFGR_D2PPRE2_DIV2);
-    // 240MHz / 2 = 120MHz rcc_pclk4
-    MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE,  RCC_D3CFGR_D3PPRE_DIV2);
-
-    // Switch on PLL1
-    RCC->CR |= RCC_CR_PLL1ON;
-    while (!(RCC->CR & RCC_CR_PLL1RDY))
-        ;
-
-    // Switch system clock source (SYSCLK) to PLL1
-    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW_Msk, RCC_CFGR_SW_PLL1);
-    while ((RCC->CFGR & RCC_CFGR_SWS_Msk) != RCC_CFGR_SWS_PLL1)
-        ;
-
-    // Set the source of FDCAN clock
-    MODIFY_REG(RCC->D2CCIP1R, RCC_D2CCIP1R_FDCANSEL, RCC_D2CCIP1R_FDCANSEL_0);
-
-    // Configure HSI48 clock for USB
-    if (CONFIG_USB) {
-        SET_BIT(RCC->CR, RCC_CR_HSI48ON);
-        while((RCC->CR & RCC_CR_HSI48RDY) == 0);
-        SET_BIT(RCC->APB1HENR, RCC_APB1HENR_CRSEN);
-        SET_BIT(RCC->APB1HRSTR, RCC_APB1HRSTR_CRSRST);
-        CLEAR_BIT(RCC->APB1HRSTR, RCC_APB1HRSTR_CRSRST);
-        CLEAR_BIT(CRS->CFGR, CRS_CFGR_SYNCSRC);
-        SET_BIT(CRS->CR, CRS_CR_CEN | CRS_CR_AUTOTRIMEN);
-        CLEAR_BIT(RCC->D2CCIP2R, RCC_D2CCIP2R_USBSEL);
-        SET_BIT(RCC->D2CCIP2R, RCC_D2CCIP2R_USBSEL);
-    }
-}
-
-
-/****************************************************************
- * Bootloader
- ****************************************************************/
-
-// Handle reboot requests
-void
-bootloader_request(void)
-{
-    try_request_canboot();
-    dfu_reboot();
-}
-
-
-/****************************************************************
- * Startup
- ****************************************************************/
-
-// Main entry point - called from armcm_boot.c:ResetHandler()
-void
-armcm_main(void)
-{
-    // Run SystemInit() and then restore VTOR
-    SystemInit();
-    RCC->D1CCIPR = 0x00000000;
-    RCC->D2CCIP1R = 0x00000000;
-    RCC->D2CCIP2R = 0x00000000;
-    RCC->D3CCIPR = 0x00000000;
-    SCB->VTOR = (uint32_t)VectorTable;
-
-    dfu_reboot_check();
-
-    clock_setup();
-
-    sched_main();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/stm32h7_spi.c crealityShit/src/stm32/stm32h7_spi.c
--- klipperStock/src/stm32/stm32h7_spi.c	2024-01-14 23:02:00.105796157 -0600
+++ crealityShit/src/stm32/stm32h7_spi.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,146 +0,0 @@
-// SPI functions on STM32H7
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "board/io.h" // readb, writeb
-#include "command.h" // shutdown
-#include "gpio.h" // spi_setup
-#include "internal.h" // gpio_peripheral
-#include "sched.h" // sched_shutdown
-
-struct spi_info {
-    SPI_TypeDef *spi;
-    uint8_t miso_pin, mosi_pin, sck_pin, function;
-};
-
-DECL_ENUMERATION("spi_bus", "spi2", __COUNTER__);
-DECL_CONSTANT_STR("BUS_PINS_spi2", "PB14,PB15,PB13");
-
-DECL_ENUMERATION("spi_bus", "spi1", __COUNTER__);
-DECL_CONSTANT_STR("BUS_PINS_spi1", "PA6,PA7,PA5");
-DECL_ENUMERATION("spi_bus", "spi1a", __COUNTER__);
-DECL_CONSTANT_STR("BUS_PINS_spi1a", "PB4,PB5,PB3");
-
-#if !CONFIG_MACH_STM32F1
-DECL_ENUMERATION("spi_bus", "spi2a", __COUNTER__);
-DECL_CONSTANT_STR("BUS_PINS_spi2a", "PC2,PC3,PB10");
-#endif
-
-#ifdef SPI3
-DECL_ENUMERATION("spi_bus", "spi3a", __COUNTER__);
-DECL_CONSTANT_STR("BUS_PINS_spi3a", "PC11,PC12,PC10");
-#endif
-
-#ifdef SPI4
-DECL_ENUMERATION("spi_bus", "spi4", __COUNTER__);
-DECL_CONSTANT_STR("BUS_PINS_spi4", "PE13,PE14,PE12");
-#endif
-
-#ifdef GPIOI
-DECL_ENUMERATION("spi_bus", "spi2b", __COUNTER__);
-DECL_CONSTANT_STR("BUS_PINS_spi2b", "PI2,PI3,PI1");
-#endif
-
-#ifdef SPI5
-DECL_ENUMERATION("spi_bus", "spi5", __COUNTER__);
-DECL_CONSTANT_STR("BUS_PINS_spi5", "PF8,PF9,PF7");
-DECL_ENUMERATION("spi_bus", "spi5a", __COUNTER__);
-DECL_CONSTANT_STR("BUS_PINS_spi5a", "PH7,PF11,PH6");
-#endif
-
-#ifdef SPI6
-DECL_ENUMERATION("spi_bus", "spi6", __COUNTER__);
-DECL_CONSTANT_STR("BUS_PINS_spi6", "PG12,PG14,PG13");
-#endif
-
-
-static const struct spi_info spi_bus[] = {
-    { SPI2, GPIO('B', 14), GPIO('B', 15), GPIO('B', 13), GPIO_FUNCTION(5) },
-    { SPI1, GPIO('A', 6), GPIO('A', 7), GPIO('A', 5), GPIO_FUNCTION(5) },
-    { SPI1, GPIO('B', 4), GPIO('B', 5), GPIO('B', 3), GPIO_FUNCTION(5) },
-#if !CONFIG_MACH_STM32F1
-    { SPI2, GPIO('C', 2), GPIO('C', 3), GPIO('B', 10), GPIO_FUNCTION(5) },
-#endif
-#ifdef SPI3
-    { SPI3, GPIO('C', 11), GPIO('C', 12), GPIO('C', 10), GPIO_FUNCTION(6) },
-#endif
-#ifdef SPI4
-    { SPI4, GPIO('E', 13), GPIO('E', 14), GPIO('E', 12), GPIO_FUNCTION(5) },
-#endif
-    { SPI2, GPIO('I', 2), GPIO('I', 3), GPIO('I', 1), GPIO_FUNCTION(5) },
-#ifdef SPI5
-    { SPI5, GPIO('F', 8), GPIO('F', 9), GPIO('F', 7), GPIO_FUNCTION(5) },
-    { SPI5, GPIO('H', 7), GPIO('F', 11), GPIO('H', 6), GPIO_FUNCTION(5) },
-#endif
-#ifdef SPI6
-    { SPI6, GPIO('G', 12), GPIO('G', 14), GPIO('G', 13), GPIO_FUNCTION(5)},
-#endif
-};
-
-struct spi_config
-spi_setup(uint32_t bus, uint8_t mode, uint32_t rate)
-{
-    if (bus >= ARRAY_SIZE(spi_bus))
-        shutdown("Invalid spi bus");
-
-    // Enable SPI
-    SPI_TypeDef *spi = spi_bus[bus].spi;
-    if (!is_enabled_pclock((uint32_t)spi)) {
-        enable_pclock((uint32_t)spi);
-        gpio_peripheral(spi_bus[bus].miso_pin, spi_bus[bus].function, 1);
-        gpio_peripheral(spi_bus[bus].mosi_pin, spi_bus[bus].function, 0);
-        gpio_peripheral(spi_bus[bus].sck_pin, spi_bus[bus].function, 0);
-    }
-
-    // Calculate CR1 register
-    uint32_t pclk = get_pclock_frequency((uint32_t)spi);
-    uint32_t div = 0;
-    while ((pclk >> (div + 1)) > rate && div < 7)
-        div++;
-
-    uint32_t cr1 = SPI_CR1_SPE;
-    spi->CFG1 |= (div << SPI_CFG1_MBR_Pos) | (7 << SPI_CFG1_DSIZE_Pos);
-    CLEAR_BIT(spi->CFG1, SPI_CFG1_CRCSIZE);
-    spi->CFG2 |= ((mode << SPI_CFG2_CPHA_Pos) | SPI_CFG2_MASTER | SPI_CFG2_SSM
-                   | SPI_CFG2_AFCNTR | SPI_CFG2_SSOE);
-    spi->CR1 |= SPI_CR1_SSI;
-
-    return (struct spi_config){ .spi = spi, .spi_cr1 = cr1 };
-}
-
-void
-spi_prepare(struct spi_config config)
-{
-}
-
-void
-spi_transfer(struct spi_config config, uint8_t receive_data,
-             uint8_t len, uint8_t *data)
-{
-    uint8_t rdata = 0;
-    SPI_TypeDef *spi = config.spi;
-
-    MODIFY_REG(spi->CR2, SPI_CR2_TSIZE, len);
-    // Enable SPI and start transfer, these MUST be set in this sequence
-    SET_BIT(spi->CR1, SPI_CR1_SPE);
-    SET_BIT(spi->CR1, SPI_CR1_CSTART);
-
-    while (len--) {
-        writeb((void *)&spi->TXDR, *data);
-        while((spi->SR & (SPI_SR_RXWNE | SPI_SR_RXPLVL)) == 0);
-        rdata = readb((void *)&spi->RXDR);
-
-        if (receive_data) {
-            *data = rdata;
-        }
-        data++;
-    }
-
-    while ((spi->SR & SPI_SR_EOT) == 0);
-
-    // Clear flags and disable SPI
-    SET_BIT(spi->IFCR, 0xFFFFFFFF);
-    CLEAR_BIT(spi->CR1, SPI_CR1_SPE);
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/stm32l4.c crealityShit/src/stm32/stm32l4.c
--- klipperStock/src/stm32/stm32l4.c	2024-01-14 23:02:00.109796205 -0600
+++ crealityShit/src/stm32/stm32l4.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,167 +0,0 @@
-// Code to setup clocks and gpio on stm32l4
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_CLOCK_REF_FREQ
-#include "board/armcm_boot.h" // VectorTable
-#include "board/irq.h" // irq_disable
-#include "command.h" // DECL_CONSTANT_STR
-#include "internal.h" // enable_pclock
-#include "sched.h" // sched_main
-
-#define FREQ_PERIPH_DIV 1
-#define FREQ_PERIPH (CONFIG_CLOCK_FREQ / FREQ_PERIPH_DIV)
-
-// Map a peripheral address to its enable bits
-struct cline
-lookup_clock_line(uint32_t periph_base)
-{
-    if (periph_base < APB2PERIPH_BASE) {
-        uint32_t pos = (periph_base - APB1PERIPH_BASE) / 0x400;
-        if (pos < 32) {
-            return (struct cline){.en = &RCC->APB1ENR1,
-                                  .rst = &RCC->APB1RSTR1,
-                                  .bit = 1 << pos};
-        } else {
-            return (struct cline){.en = &RCC->APB1ENR2,
-                                  .rst = &RCC->APB1RSTR2,
-                                  .bit = 1 << (pos - 32)};
-        }
-    } else if (periph_base < AHB1PERIPH_BASE) {
-        uint32_t pos = (periph_base - APB2PERIPH_BASE) / 0x400;
-        return (struct cline){.en = &RCC->APB2ENR,
-                              .rst = &RCC->APB2RSTR,
-                              .bit = 1 << pos};
-
-    } else if (periph_base < AHB2PERIPH_BASE) {
-        uint32_t pos = (periph_base - AHB1PERIPH_BASE) / 0x400;
-        return (struct cline){.en = &RCC->AHB1ENR,
-                              .rst = &RCC->AHB1RSTR,
-                              .bit = 1 << pos};
-
-    } else if (periph_base == ADC1_BASE) {
-        return (struct cline){.en = &RCC->AHB2ENR,
-                              .rst = &RCC->AHB2RSTR,
-                              .bit = RCC_AHB2ENR_ADCEN};
-    }
-    return (struct cline){.en = &RCC->AHB2ENR,
-                          .rst = &RCC->AHB2RSTR,
-                          .bit = 0};
-}
-
-// Return the frequency of the given peripheral clock
-uint32_t
-get_pclock_frequency(uint32_t periph_base)
-{
-    return FREQ_PERIPH;
-}
-
-// Enable a GPIO peripheral clock
-void
-gpio_clock_enable(GPIO_TypeDef *regs)
-{
-    uint32_t rcc_pos = ((uint32_t)regs - GPIOA_BASE) / 0x400;
-    RCC->AHB2ENR |= 1 << rcc_pos;
-    RCC->AHB2ENR;
-}
-
-#if !CONFIG_STM32_CLOCK_REF_INTERNAL
-DECL_CONSTANT_STR("RESERVE_PINS_crystal", "PC14,PC15");
-#endif
-
-static void
-enable_clock_stm32l4(void)
-{
-    uint32_t pll_base = 4000000, pll_freq = CONFIG_CLOCK_FREQ * 2, pllcfgr;
-    if (!CONFIG_STM32_CLOCK_REF_INTERNAL) {
-        // Configure 80Mhz PLL from external crystal (HSE)
-        uint32_t div = CONFIG_CLOCK_REF_FREQ / pll_base - 1;
-        RCC->CR |= RCC_CR_HSEON;
-        while (!(RCC->CR & RCC_CR_HSERDY))
-            ;
-        pllcfgr = RCC_PLLCFGR_PLLSRC_HSE | (div << RCC_PLLCFGR_PLLM_Pos);
-    } else {
-        // Configure 80Mhz PLL from internal 16Mhz oscillator (HSI)
-        uint32_t div = 16000000 / pll_base - 1;
-        pllcfgr = RCC_PLLCFGR_PLLSRC_HSI | (div << RCC_PLLCFGR_PLLM_Pos);
-        RCC->CR |= RCC_CR_HSION;
-        while (!(RCC->CR & RCC_CR_HSIRDY))
-            ;
-    }
-    RCC->PLLCFGR = (pllcfgr | ((pll_freq/pll_base) << RCC_PLLCFGR_PLLN_Pos)
-                    | (0 << RCC_PLLCFGR_PLLR_Pos));
-    RCC->CR |= RCC_CR_PLLON;
-
-    // Enable 48Mhz USB clock using clock recovery
-    if (CONFIG_USBSERIAL) {
-        RCC->CRRCR |= RCC_CRRCR_HSI48ON;
-        while (!(RCC->CRRCR & RCC_CRRCR_HSI48RDY))
-            ;
-        enable_pclock(CRS_BASE);
-        CRS->CR |= CRS_CR_AUTOTRIMEN | CRS_CR_CEN;
-        enable_pclock(PWR_BASE);
-        PWR->CR2 |= PWR_CR2_USV;
-    }
-}
-
-// Main clock setup called at chip startup
-static void
-clock_setup(void)
-{
-    enable_clock_stm32l4();
-
-    // Set flash latency
-    uint32_t latency = ((CONFIG_CLOCK_FREQ>64000000) ? FLASH_ACR_LATENCY_4WS :
-                       ((CONFIG_CLOCK_FREQ>48000000) ? FLASH_ACR_LATENCY_3WS :
-                       ((CONFIG_CLOCK_FREQ>32000000) ? FLASH_ACR_LATENCY_2WS :
-                       ((CONFIG_CLOCK_FREQ>16000000) ? FLASH_ACR_LATENCY_1WS :
-                                                    FLASH_ACR_LATENCY_0WS))));
-    FLASH->ACR = (latency | FLASH_ACR_ICEN | FLASH_ACR_DCEN
-                  | FLASH_ACR_PRFTEN);
-
-    // Wait for PLL lock
-    while (!(RCC->CR & RCC_CR_PLLRDY))
-        ;
-
-    RCC->PLLCFGR |= RCC_PLLCFGR_PLLREN;
-
-    // Switch system clock to PLL
-    RCC->CFGR = RCC_CFGR_HPRE_DIV1 | RCC_CFGR_PPRE1_DIV1 | RCC_CFGR_PPRE2_DIV1
-                | RCC_CFGR_SW_PLL;
-    while ((RCC->CFGR & RCC_CFGR_SWS_Msk) != RCC_CFGR_SWS_PLL)
-        ;
-}
-
-
-/****************************************************************
- * Bootloader
- ****************************************************************/
-
-// Handle USB reboot requests
-void
-bootloader_request(void)
-{
-    dfu_reboot();
-}
-
-
-/****************************************************************
- * Startup
- ****************************************************************/
-
-// Main entry point - called from armcm_boot.c:ResetHandler()
-void
-armcm_main(void)
-{
-    dfu_reboot_check();
-
-    // Run SystemInit() and then restore VTOR
-    SystemInit();
-    SCB->VTOR = (uint32_t)VectorTable;
-
-    clock_setup();
-
-    sched_main();
-}
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/usbfs.c crealityShit/src/stm32/usbfs.c
--- klipperStock/src/stm32/usbfs.c	2024-01-14 23:02:00.105796157 -0600
+++ crealityShit/src/stm32/usbfs.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,365 +0,0 @@
-// Hardware interface to "fullspeed USB controller"
-//
-// Copyright (C) 2018-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // NULL
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/armcm_timer.h" // udelay
-#include "board/gpio.h" // gpio_out_setup
-#include "board/io.h" // writeb
-#include "board/usb_cdc.h" // usb_notify_ep0
-#include "board/usb_cdc_ep.h" // USB_CDC_EP_BULK_IN
-#include "command.h" // DECL_CONSTANT_STR
-#include "internal.h" // GPIO
-#include "sched.h" // DECL_INIT
-
-#if CONFIG_MACH_STM32F103 || CONFIG_MACH_STM32G4
-  // Transfer memory is accessed with 32bits, but contains only 16bits of data
-  typedef volatile uint32_t epmword_t;
-  #define WSIZE 2
-  #define USBx_IRQn USB_LP_IRQn
-#elif CONFIG_MACH_STM32F0 || CONFIG_MACH_STM32L4
-  // Transfer memory is accessed with 16bits and contains 16bits of data
-  typedef volatile uint16_t epmword_t;
-  #define WSIZE 2
-  #define USBx_IRQn USB_IRQn
-#elif CONFIG_MACH_STM32G0
-  // Transfer memory is accessed with 32bits and contains 32bits of data
-  typedef volatile uint32_t epmword_t;
-  #define WSIZE 4
-  #define USBx_IRQn USB_IRQn
-#endif
-
-// The stm32g0 has slightly different register names
-#if CONFIG_MACH_STM32G0
-  #if CONFIG_MACH_STM32G0B1
-    #define USB_IRQn USB_UCPD1_2_IRQn
-  #endif
-  #define USB USB_DRD_FS
-  #define USB_PMAADDR USB_DRD_PMAADDR
-  #define USB_EPADDR_FIELD USB_CHEP_ADDR
-  #define USB_EP_CTR_RX USB_EP_VTRX
-  #define USB_EP_CTR_TX USB_EP_VTTX
-  #define USB_EPRX_STAT USB_EP_RX_STRX
-  #define USB_EPTX_STAT USB_EP_TX_STTX
-  #define USB_ISTR_EP_ID USB_ISTR_IDN
-  #define USB_CNTR_FRES USB_CNTR_USBRST
-#endif
-
-
-/****************************************************************
- * USB transfer memory
- ****************************************************************/
-
-// Layout of the USB transfer memory
-#define EPM ((epmword_t*)USB_PMAADDR)
-#define EPM_EP_DESC(ep) (&EPM[(ep) * (8 / WSIZE)])
-#define EPM_BUF_OFFSET 0x10
-#define EPM_EP_BUF_SIZE (64 / WSIZE + 1)
-#define EPM_EP_TX_BUF(ep) (&EPM[EPM_BUF_OFFSET + (ep)*2*EPM_EP_BUF_SIZE])
-#define EPM_EP_RX_BUF(ep) (&EPM[EPM_BUF_OFFSET + (1+(ep)*2)*EPM_EP_BUF_SIZE])
-
-// Configure the usb descriptor for an endpoint
-static void
-epm_ep_desc_setup(int ep, int rx_size)
-{
-    uint32_t addr_tx = (EPM_EP_TX_BUF(ep) - EPM) * WSIZE, count_tx = 0;
-    uint32_t addr_rx = (EPM_EP_RX_BUF(ep) - EPM) * WSIZE;
-    uint32_t count_rx = (rx_size <= 30 ? DIV_ROUND_UP(rx_size, 2) << 10
-                         : ((DIV_ROUND_UP(rx_size, 32) - 1) << 10) | 0x8000);
-    epmword_t *desc = EPM_EP_DESC(ep);
-    if (WSIZE == 2) {
-        desc[0] = addr_tx;
-        desc[1] = count_tx;
-        desc[2] = addr_rx;
-        desc[3] = count_rx;
-    } else {
-        desc[0] = addr_tx | (count_tx << 16);
-        desc[1] = addr_rx | (count_rx << 16);
-    }
-}
-
-// Return number of read bytes on an rx endpoint
-static uint32_t
-epm_get_ep_count_rx(int ep)
-{
-    epmword_t *desc = EPM_EP_DESC(ep);
-    if (WSIZE == 2)
-        return desc[3] & 0x3ff;
-    return (desc[1] >> 16) & 0x3ff;
-}
-
-// Set number of bytes ready to be transmitted on a tx endpoint
-static void
-epm_set_ep_count_tx(int ep, uint32_t count)
-{
-    epmword_t *desc = EPM_EP_DESC(ep);
-    if (WSIZE == 2) {
-        desc[1] = count;
-    } else {
-        uint32_t addr_tx = (EPM_EP_TX_BUF(ep) - EPM) * WSIZE;
-        desc[0] = addr_tx | (count << 16);
-    }
-}
-
-// Setup the transfer descriptors in dedicated usb memory
-static void
-btable_configure(void)
-{
-    epm_ep_desc_setup(0, USB_CDC_EP0_SIZE);
-    epm_ep_desc_setup(USB_CDC_EP_ACM, 0);
-    epm_ep_desc_setup(USB_CDC_EP_BULK_OUT, USB_CDC_EP_BULK_OUT_SIZE);
-    epm_ep_desc_setup(USB_CDC_EP_BULK_IN, 0);
-}
-
-// Read a packet stored in dedicated usb memory
-static uint32_t
-btable_read_packet(int ep, uint8_t *dest, int max_len)
-{
-    epmword_t *src = EPM_EP_RX_BUF(ep);
-    uint32_t count = epm_get_ep_count_rx(ep);
-    if (count > max_len)
-        count = max_len;
-    int i;
-    for (i=0; i<count/WSIZE; i++) {
-        uint32_t d = *src++;
-        *dest++ = d;
-        *dest++ = d >> 8;
-        if (WSIZE == 4) {
-            *dest++ = d >> 16;
-            *dest++ = d >> 24;
-        }
-    }
-    if (count & (WSIZE-1)) {
-        uint32_t d = *src;
-        *dest++ = d;
-        if ((count & (WSIZE-1)) > 1)
-            *dest++ = d >> 8;
-        if ((count & (WSIZE-1)) > 2)
-            *dest++ = d >> 16;
-    }
-    return count;
-}
-
-// Write a packet to dedicated usb memory
-static void
-btable_write_packet(int ep, const uint8_t *src, int count)
-{
-    epmword_t *dest = EPM_EP_TX_BUF(ep);
-    int i;
-    for (i=0; i<count/WSIZE; i++) {
-        uint8_t b1 = *src++, b2 = *src++, b3 = 0, b4 = 0;
-        if (WSIZE == 4) {
-            b3 = *src++;
-            b4 = *src++;
-        }
-        *dest++ = b1 | (b2 << 8) | (b3 << 16) | (b4 << 24);
-    }
-    if (count & (WSIZE-1)) {
-        uint32_t d = *src++;
-        if ((count & (WSIZE-1)) > 1)
-            d |= *src++ << 8;
-        if ((count & (WSIZE-1)) > 2)
-            d |= *src++ << 16;
-        *dest = d;
-    }
-    epm_set_ep_count_tx(ep, count);
-}
-
-
-/****************************************************************
- * USB endpoint register
- ****************************************************************/
-
-#define USB_EPR ((volatile uint32_t *)USB_BASE)
-
-#define EPR_RWBITS (USB_EPADDR_FIELD | USB_EP_KIND | USB_EP_TYPE_MASK)
-#define EPR_RWCBITS (USB_EP_CTR_RX | USB_EP_CTR_TX)
-
-static uint32_t
-set_stat_rx_bits(uint32_t epr, uint32_t bits)
-{
-    return ((epr & (EPR_RWBITS | USB_EPRX_STAT)) ^ bits) | EPR_RWCBITS;
-}
-
-static uint32_t
-set_stat_tx_bits(uint32_t epr, uint32_t bits)
-{
-    return ((epr & (EPR_RWBITS | USB_EPTX_STAT)) ^ bits) | EPR_RWCBITS;
-}
-
-static uint32_t
-set_stat_rxtx_bits(uint32_t epr, uint32_t bits)
-{
-    uint32_t mask = EPR_RWBITS | USB_EPRX_STAT | USB_EPTX_STAT;
-    return ((epr & mask) ^ bits) | EPR_RWCBITS;
-}
-
-
-/****************************************************************
- * USB interface
- ****************************************************************/
-
-int_fast8_t
-usb_read_bulk_out(void *data, uint_fast8_t max_len)
-{
-    uint32_t epr = USB_EPR[USB_CDC_EP_BULK_OUT];
-    if ((epr & USB_EPRX_STAT) == USB_EP_RX_VALID)
-        // No data ready
-        return -1;
-    uint32_t count = btable_read_packet(USB_CDC_EP_BULK_OUT, data, max_len);
-    USB_EPR[USB_CDC_EP_BULK_OUT] = set_stat_rx_bits(epr, USB_EP_RX_VALID);
-    return count;
-}
-
-int_fast8_t
-usb_send_bulk_in(void *data, uint_fast8_t len)
-{
-    uint32_t epr = USB_EPR[USB_CDC_EP_BULK_IN];
-    if ((epr & USB_EPTX_STAT) != USB_EP_TX_NAK)
-        // No buffer space available
-        return -1;
-    btable_write_packet(USB_CDC_EP_BULK_IN, data, len);
-    USB_EPR[USB_CDC_EP_BULK_IN] = set_stat_tx_bits(epr, USB_EP_TX_VALID);
-    return len;
-}
-
-int_fast8_t
-usb_read_ep0(void *data, uint_fast8_t max_len)
-{
-    uint32_t epr = USB_EPR[0];
-    if ((epr & USB_EPRX_STAT) != USB_EP_RX_NAK)
-        // No data ready
-        return -1;
-    uint32_t count = btable_read_packet(0, data, max_len);
-    USB_EPR[0] = set_stat_rxtx_bits(epr, USB_EP_RX_VALID | USB_EP_TX_NAK);
-    return count;
-}
-
-int_fast8_t
-usb_read_ep0_setup(void *data, uint_fast8_t max_len)
-{
-    return usb_read_ep0(data, max_len);
-}
-
-int_fast8_t
-usb_send_ep0(const void *data, uint_fast8_t len)
-{
-    uint32_t epr = USB_EPR[0];
-    if ((epr & USB_EPRX_STAT) != USB_EP_RX_VALID)
-        // Transfer interrupted
-        return -2;
-    if ((epr & USB_EPTX_STAT) != USB_EP_TX_NAK)
-        // No buffer space available
-        return -1;
-    btable_write_packet(0, data, len);
-    USB_EPR[0] = set_stat_tx_bits(epr, USB_EP_TX_VALID);
-    return len;
-}
-
-void
-usb_stall_ep0(void)
-{
-    USB_EPR[0] = set_stat_rxtx_bits(USB_EPR[0]
-                                    , USB_EP_RX_STALL | USB_EP_TX_STALL);
-}
-
-static uint8_t set_address;
-
-void
-usb_set_address(uint_fast8_t addr)
-{
-    writeb(&set_address, addr | USB_DADDR_EF);
-    usb_send_ep0(NULL, 0);
-}
-
-void
-usb_set_configure(void)
-{
-}
-
-
-/****************************************************************
- * Setup and interrupts
- ****************************************************************/
-
-// Configure interface after a USB reset event
-static void
-usb_reset(void)
-{
-    USB_EPR[0] = 0 | USB_EP_CONTROL | USB_EP_RX_VALID | USB_EP_TX_NAK;
-    USB_EPR[USB_CDC_EP_ACM] = (USB_CDC_EP_ACM | USB_EP_INTERRUPT
-                               | USB_EP_RX_NAK | USB_EP_TX_NAK);
-    USB_EPR[USB_CDC_EP_BULK_OUT] = (USB_CDC_EP_BULK_OUT | USB_EP_BULK
-                                    | USB_EP_RX_VALID | USB_EP_TX_NAK);
-    USB_EPR[USB_CDC_EP_BULK_IN] = (USB_CDC_EP_BULK_IN | USB_EP_BULK
-                                   | USB_EP_RX_NAK | USB_EP_TX_NAK);
-
-    USB->CNTR = USB_CNTR_CTRM | USB_CNTR_RESETM;
-    USB->DADDR = USB_DADDR_EF;
-}
-
-// Main irq handler
-void
-USB_IRQHandler(void)
-{
-    uint32_t istr = USB->ISTR;
-    if (istr & USB_ISTR_CTR) {
-        // Endpoint activity
-        uint32_t ep = istr & USB_ISTR_EP_ID;
-        uint32_t epr = USB_EPR[ep];
-        USB_EPR[ep] = epr & EPR_RWBITS;
-        if (ep == 0) {
-            usb_notify_ep0();
-            if (epr & USB_EP_CTR_TX && set_address) {
-                // Apply address after last "in" message transmitted
-                USB->DADDR = set_address;
-                set_address = 0;
-            }
-        } else if (ep == USB_CDC_EP_BULK_OUT) {
-            usb_notify_bulk_out();
-        } else if (ep == USB_CDC_EP_BULK_IN) {
-            usb_notify_bulk_in();
-        }
-    }
-    if (istr & USB_ISTR_RESET) {
-        // USB Reset
-        USB->ISTR = (uint16_t)~USB_ISTR_RESET;
-        usb_reset();
-    }
-}
-
-DECL_CONSTANT_STR("RESERVE_PINS_USB", "PA11,PA12");
-
-// Initialize the usb controller
-void
-usb_init(void)
-{
-    if (CONFIG_MACH_STM32F1) {
-        // Pull the D+ pin low briefly to signal a new connection
-        gpio_out_setup(GPIO('A', 12), 0);
-        udelay(5000);
-        gpio_in_setup(GPIO('A', 12), 0);
-    }
-
-    // Enable USB clock
-    enable_pclock(USB_BASE);
-
-    // Setup USB packet memory
-    btable_configure();
-
-    // Enable USB pullup
-#ifdef USB_BCDR_DPPU
-    USB->BCDR = USB_BCDR_DPPU;
-#endif
-
-    // Reset usb controller and enable interrupts
-    USB->CNTR = USB_CNTR_FRES;
-    USB->DADDR = 0;
-    USB->CNTR = USB_CNTR_RESETM;
-    USB->ISTR = 0;
-    armcm_enable_irq(USB_IRQHandler, USBx_IRQn, 1);
-}
-DECL_INIT(usb_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/usbotg.c crealityShit/src/stm32/usbotg.c
--- klipperStock/src/stm32/usbotg.c	2024-01-14 23:02:00.105796157 -0600
+++ crealityShit/src/stm32/usbotg.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,461 +0,0 @@
-// Hardware interface to "USB OTG (on the go) controller" on stm32
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // NULL
-#include "autoconf.h" // CONFIG_MACH_STM32F446
-#include "board/armcm_boot.h" // armcm_enable_irq
-#include "board/io.h" // writel
-#include "board/usb_cdc.h" // usb_notify_ep0
-#include "board/usb_cdc_ep.h" // USB_CDC_EP_BULK_IN
-#include "command.h" // DECL_CONSTANT_STR
-#include "internal.h" // GPIO
-#include "sched.h" // DECL_INIT
-
-#if CONFIG_STM32_USB_PB14_PB15
-  #define IS_OTG_HS 1
-  #define GPIO_D_NEG GPIO('B', 14)
-  #define GPIO_D_POS GPIO('B', 15)
-  #define GPIO_FUNC GPIO_FUNCTION(12)
-  DECL_CONSTANT_STR("RESERVE_PINS_USB1", "PB14,PB15");
-#else
-  #if CONFIG_MACH_STM32H723
-    #define IS_OTG_HS 1
-  #else
-    #define IS_OTG_HS 0
-  #endif
-  #define GPIO_D_NEG GPIO('A', 11)
-  #define GPIO_D_POS GPIO('A', 12)
-  #define GPIO_FUNC GPIO_FUNCTION(10)
-  DECL_CONSTANT_STR("RESERVE_PINS_USB", "PA11,PA12");
-#endif
-
-#if IS_OTG_HS
-  #define USB_PERIPH_BASE USB_OTG_HS_PERIPH_BASE
-  #define OTG_IRQn OTG_HS_IRQn
-  #define USBOTGEN RCC_AHB1ENR_USB1OTGHSEN
-#else
-  #define USB_PERIPH_BASE USB_OTG_FS_PERIPH_BASE
-  #define OTG_IRQn OTG_FS_IRQn
-  #define USBOTGEN RCC_AHB1ENR_USB2OTGHSEN
-#endif
-
-static void
-usb_irq_disable(void)
-{
-    NVIC_DisableIRQ(OTG_IRQn);
-}
-
-static void
-usb_irq_enable(void)
-{
-    NVIC_EnableIRQ(OTG_IRQn);
-}
-
-
-/****************************************************************
- * USB transfer memory
- ****************************************************************/
-
-#define OTG ((USB_OTG_GlobalTypeDef*)USB_PERIPH_BASE)
-#define OTGD ((USB_OTG_DeviceTypeDef*)(USB_PERIPH_BASE + USB_OTG_DEVICE_BASE))
-#define EPFIFO(EP) ((void*)(USB_PERIPH_BASE + USB_OTG_FIFO_BASE + ((EP) << 12)))
-#define EPIN(EP) ((USB_OTG_INEndpointTypeDef*)                          \
-                  (USB_PERIPH_BASE + USB_OTG_IN_ENDPOINT_BASE + ((EP) << 5)))
-#define EPOUT(EP) ((USB_OTG_OUTEndpointTypeDef*)                        \
-                   (USB_PERIPH_BASE + USB_OTG_OUT_ENDPOINT_BASE + ((EP) << 5)))
-
-// Setup the USB fifos
-static void
-fifo_configure(void)
-{
-    // Reserve memory for Rx fifo
-    uint32_t sz = ((4 * 1 + 6)
-                   + 4 * ((USB_CDC_EP_BULK_OUT_SIZE / 4) + 1)
-                   + (2 * 1));
-    OTG->GRXFSIZ = sz;
-
-    // Tx fifos
-    uint32_t fpos = sz, ep_size = 0x10;
-    OTG->DIEPTXF0_HNPTXFSIZ = ((fpos << USB_OTG_TX0FSA_Pos)
-                               | (ep_size << USB_OTG_TX0FD_Pos));
-    fpos += ep_size;
-
-    OTG->DIEPTXF[USB_CDC_EP_ACM - 1] = (
-        (fpos << USB_OTG_DIEPTXF_INEPTXSA_Pos)
-        | (ep_size << USB_OTG_DIEPTXF_INEPTXFD_Pos));
-    fpos += ep_size;
-
-    OTG->DIEPTXF[USB_CDC_EP_BULK_IN - 1] = (
-        (fpos << USB_OTG_DIEPTXF_INEPTXSA_Pos)
-        | (ep_size << USB_OTG_DIEPTXF_INEPTXFD_Pos));
-    fpos += ep_size;
-}
-
-// Write a packet to a tx fifo
-static int_fast8_t
-fifo_write_packet(uint32_t ep, const uint8_t *src, uint32_t len)
-{
-    void *fifo = EPFIFO(ep);
-    USB_OTG_INEndpointTypeDef *epi = EPIN(ep);
-    epi->DIEPINT = USB_OTG_DIEPINT_XFRC;
-    epi->DIEPTSIZ = len | (1 << USB_OTG_DIEPTSIZ_PKTCNT_Pos);
-    epi->DIEPCTL |= USB_OTG_DIEPCTL_EPENA | USB_OTG_DIEPCTL_CNAK;
-    int32_t count = len;
-    while (count >= 4) {
-        uint32_t data;
-        memcpy(&data, src, 4);
-        writel(fifo, data);
-        count -= 4;
-        src += 4;
-    }
-    if (count) {
-        uint32_t data = 0;
-        memcpy(&data, src, count);
-        writel(fifo, data);
-    }
-    return len;
-}
-
-// Read a packet from the rx queue
-static int_fast8_t
-fifo_read_packet(uint8_t *dest, uint_fast8_t max_len)
-{
-    // Transfer data
-    void *fifo = EPFIFO(0);
-    uint32_t grx = OTG->GRXSTSP;
-    uint32_t bcnt = (grx & USB_OTG_GRXSTSP_BCNT) >> USB_OTG_GRXSTSP_BCNT_Pos;
-    uint32_t xfer = bcnt > max_len ? max_len : bcnt, count = xfer;
-    while (count >= 4) {
-        uint32_t data = readl(fifo);
-        memcpy(dest, &data, 4);
-        count -= 4;
-        dest += 4;
-    }
-    if (count) {
-        uint32_t data = readl(fifo);
-        memcpy(dest, &data, count);
-    }
-    uint32_t extra = DIV_ROUND_UP(bcnt, 4) - DIV_ROUND_UP(xfer, 4);
-    while (extra--)
-        readl(fifo);
-    return xfer;
-}
-
-// Reenable packet reception if it got disabled by controller
-static void
-enable_rx_endpoint(uint32_t ep)
-{
-    USB_OTG_OUTEndpointTypeDef *epo = EPOUT(ep);
-    uint32_t ctl = epo->DOEPCTL;
-    if (!(ctl & USB_OTG_DOEPCTL_EPENA) || ctl & USB_OTG_DOEPCTL_NAKSTS) {
-        epo->DOEPTSIZ = 64 | (1 << USB_OTG_DOEPTSIZ_PKTCNT_Pos);
-        epo->DOEPCTL = ctl | USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_CNAK;
-    }
-}
-
-// Inspect the next packet on the rx queue
-static uint32_t
-peek_rx_queue(uint32_t ep)
-{
-    for (;;) {
-        uint32_t sts = OTG->GINTSTS;
-        if (!(sts & USB_OTG_GINTSTS_RXFLVL))
-            // No packet ready
-            return 0;
-        uint32_t grx = OTG->GRXSTSR, grx_ep = grx & USB_OTG_GRXSTSP_EPNUM_Msk;
-        uint32_t pktsts = ((grx & USB_OTG_GRXSTSP_PKTSTS_Msk)
-                           >> USB_OTG_GRXSTSP_PKTSTS_Pos);
-        if ((grx_ep == 0 || grx_ep == USB_CDC_EP_BULK_OUT)
-            && (pktsts == 2 || pktsts == 4 || pktsts == 6)) {
-            // A packet is ready
-            if (grx_ep != ep)
-                return 0;
-            return grx;
-        }
-        if ((grx_ep != 0 && grx_ep != USB_CDC_EP_BULK_OUT)
-            || (pktsts != 1 && pktsts != 3 && pktsts != 4)) {
-            // Rx queue has bogus value - just pop it
-            sts = OTG->GRXSTSP;
-            continue;
-        }
-        // Discard informational entries from queue
-        fifo_read_packet(NULL, 0);
-    }
-}
-
-
-/****************************************************************
- * USB interface
- ****************************************************************/
-
-int_fast8_t
-usb_read_bulk_out(void *data, uint_fast8_t max_len)
-{
-    usb_irq_disable();
-    uint32_t grx = peek_rx_queue(USB_CDC_EP_BULK_OUT);
-    if (!grx) {
-        // Wait for packet
-        OTG->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
-        usb_irq_enable();
-        return -1;
-    }
-    int_fast8_t ret = fifo_read_packet(data, max_len);
-    enable_rx_endpoint(USB_CDC_EP_BULK_OUT);
-    usb_irq_enable();
-    return ret;
-}
-
-int_fast8_t
-usb_send_bulk_in(void *data, uint_fast8_t len)
-{
-    usb_irq_disable();
-    uint32_t ctl = EPIN(USB_CDC_EP_BULK_IN)->DIEPCTL;
-    if (!(ctl & USB_OTG_DIEPCTL_USBAEP)) {
-        // Controller not enabled - discard data
-        usb_irq_enable();
-        return len;
-    }
-    if (ctl & USB_OTG_DIEPCTL_EPENA) {
-        // Wait for space to transmit
-        OTGD->DAINTMSK |= 1 << USB_CDC_EP_BULK_IN;
-        usb_irq_enable();
-        return -1;
-    }
-    int_fast8_t ret = fifo_write_packet(USB_CDC_EP_BULK_IN, data, len);
-    usb_irq_enable();
-    return ret;
-}
-
-int_fast8_t
-usb_read_ep0(void *data, uint_fast8_t max_len)
-{
-    usb_irq_disable();
-    uint32_t grx = peek_rx_queue(0);
-    if (!grx) {
-        // Wait for packet
-        OTG->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
-        usb_irq_enable();
-        return -1;
-    }
-    uint32_t pktsts = ((grx & USB_OTG_GRXSTSP_PKTSTS_Msk)
-                       >> USB_OTG_GRXSTSP_PKTSTS_Pos);
-    if (pktsts != 2) {
-        // Transfer interrupted
-        usb_irq_enable();
-        return -2;
-    }
-    int_fast8_t ret = fifo_read_packet(data, max_len);
-    enable_rx_endpoint(0);
-    usb_irq_enable();
-    return ret;
-}
-
-int_fast8_t
-usb_read_ep0_setup(void *data, uint_fast8_t max_len)
-{
-    static uint8_t setup_buf[8];
-    usb_irq_disable();
-    for (;;) {
-        uint32_t grx = peek_rx_queue(0);
-        if (!grx) {
-            // Wait for packet
-            OTG->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
-            usb_irq_enable();
-            return -1;
-        }
-        uint32_t pktsts = ((grx & USB_OTG_GRXSTSP_PKTSTS_Msk)
-                           >> USB_OTG_GRXSTSP_PKTSTS_Pos);
-        if (pktsts == 6)
-            // Store setup packet
-            fifo_read_packet(setup_buf, sizeof(setup_buf));
-        else
-            // Discard other packets
-            fifo_read_packet(NULL, 0);
-        if (pktsts == 4)
-            // Setup complete
-            break;
-    }
-    uint32_t ctl = EPIN(0)->DIEPCTL;
-    if (ctl & USB_OTG_DIEPCTL_EPENA) {
-        // Flush any pending tx packets
-        EPIN(0)->DIEPCTL = ctl | USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
-        while (EPIN(0)->DIEPCTL & USB_OTG_DIEPCTL_EPENA)
-            ;
-        OTG->GRSTCTL = USB_OTG_GRSTCTL_TXFFLSH;
-        while (OTG->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH)
-            ;
-    }
-    enable_rx_endpoint(0);
-    EPOUT(0)->DOEPINT = USB_OTG_DOEPINT_STUP;
-    usb_irq_enable();
-    // Return previously read setup packet
-    memcpy(data, setup_buf, max_len);
-    return max_len;
-}
-
-int_fast8_t
-usb_send_ep0(const void *data, uint_fast8_t len)
-{
-    usb_irq_disable();
-    uint32_t grx = peek_rx_queue(0);
-    if (grx) {
-        // Transfer interrupted
-        usb_irq_enable();
-        return -2;
-    }
-    if (EPIN(0)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) {
-        // Wait for space to transmit
-        OTG->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
-        OTGD->DAINTMSK |= 1 << 0;
-        usb_irq_enable();
-        return -1;
-    }
-    int_fast8_t ret = fifo_write_packet(0, data, len);
-    usb_irq_enable();
-    return ret;
-}
-
-void
-usb_stall_ep0(void)
-{
-    usb_irq_disable();
-    EPIN(0)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
-    usb_notify_ep0(); // XXX - wake from main usb_cdc.c code?
-    usb_irq_enable();
-}
-
-void
-usb_set_address(uint_fast8_t addr)
-{
-    OTGD->DCFG = ((OTGD->DCFG & ~USB_OTG_DCFG_DAD_Msk)
-                  | (addr << USB_OTG_DCFG_DAD_Pos));
-    usb_send_ep0(NULL, 0);
-    usb_notify_ep0();
-}
-
-void
-usb_set_configure(void)
-{
-    usb_irq_disable();
-    // Configure and enable USB_CDC_EP_ACM
-    USB_OTG_INEndpointTypeDef *epi = EPIN(USB_CDC_EP_ACM);
-    epi->DIEPTSIZ = (USB_CDC_EP_ACM_SIZE
-                     | (1 << USB_OTG_DIEPTSIZ_PKTCNT_Pos));
-    epi->DIEPCTL = (
-        USB_OTG_DIEPCTL_SNAK | USB_OTG_DIEPCTL_USBAEP
-        | (0x03 << USB_OTG_DIEPCTL_EPTYP_Pos) | USB_OTG_DIEPCTL_SD0PID_SEVNFRM
-        | (USB_CDC_EP_ACM << USB_OTG_DIEPCTL_TXFNUM_Pos)
-        | (USB_CDC_EP_ACM_SIZE << USB_OTG_DIEPCTL_MPSIZ_Pos));
-
-    // Configure and enable USB_CDC_EP_BULK_OUT
-    USB_OTG_OUTEndpointTypeDef *epo = EPOUT(USB_CDC_EP_BULK_OUT);
-    epo->DOEPTSIZ = 64 | (1 << USB_OTG_DOEPTSIZ_PKTCNT_Pos);
-    epo->DOEPCTL = (
-        USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_USBAEP | USB_OTG_DOEPCTL_EPENA
-        | (0x02 << USB_OTG_DOEPCTL_EPTYP_Pos) | USB_OTG_DOEPCTL_SD0PID_SEVNFRM
-        | (USB_CDC_EP_BULK_OUT_SIZE << USB_OTG_DOEPCTL_MPSIZ_Pos));
-
-    // Configure and flush USB_CDC_EP_BULK_IN
-    epi = EPIN(USB_CDC_EP_BULK_IN);
-    epi->DIEPTSIZ = (USB_CDC_EP_BULK_IN_SIZE
-                     | (1 << USB_OTG_DIEPTSIZ_PKTCNT_Pos));
-    epi->DIEPCTL = (
-        USB_OTG_DIEPCTL_SNAK | USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_USBAEP
-        | (0x02 << USB_OTG_DIEPCTL_EPTYP_Pos) | USB_OTG_DIEPCTL_SD0PID_SEVNFRM
-        | (USB_CDC_EP_BULK_IN << USB_OTG_DIEPCTL_TXFNUM_Pos)
-        | (USB_CDC_EP_BULK_IN_SIZE << USB_OTG_DIEPCTL_MPSIZ_Pos));
-    while (epi->DIEPCTL & USB_OTG_DIEPCTL_EPENA)
-        ;
-    OTG->GRSTCTL = ((USB_CDC_EP_BULK_IN << USB_OTG_GRSTCTL_TXFNUM_Pos)
-                    | USB_OTG_GRSTCTL_TXFFLSH);
-    while (OTG->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH)
-        ;
-    usb_irq_enable();
-}
-
-
-/****************************************************************
- * Setup and interrupts
- ****************************************************************/
-
-// Main irq handler
-void
-OTG_FS_IRQHandler(void)
-{
-    uint32_t sts = OTG->GINTSTS;
-    if (sts & USB_OTG_GINTSTS_RXFLVL) {
-        // Received data - disable irq and notify endpoint
-        OTG->GINTMSK &= ~USB_OTG_GINTMSK_RXFLVLM;
-        uint32_t grx = OTG->GRXSTSR, ep = grx & USB_OTG_GRXSTSP_EPNUM_Msk;
-        if (ep == 0)
-            usb_notify_ep0();
-        else
-            usb_notify_bulk_out();
-    }
-    if (sts & USB_OTG_GINTSTS_IEPINT) {
-        // Can transmit data - disable irq and notify endpoint
-        uint32_t daint = OTGD->DAINT;
-        OTGD->DAINTMSK &= ~daint;
-        if (daint & (1 << 0))
-            usb_notify_ep0();
-        if (daint & (1 << USB_CDC_EP_BULK_IN))
-            usb_notify_bulk_in();
-    }
-}
-
-// Initialize the usb controller
-void
-usb_init(void)
-{
-    // Enable USB clock
-#if CONFIG_MACH_STM32H7
-    if (READ_BIT(PWR->CR3, PWR_CR3_USB33RDY) != (PWR_CR3_USB33RDY)) {
-        SET_BIT(PWR->CR3, PWR_CR3_USB33DEN);
-    }
-    SET_BIT(RCC->AHB1ENR, USBOTGEN);
-#else
-    RCC->AHB2ENR |= RCC_AHB2ENR_OTGFSEN;
-#endif
-    while (!(OTG->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL))
-        ;
-
-    // Configure USB in full-speed device mode
-    OTG->GUSBCFG = (USB_OTG_GUSBCFG_FDMOD | USB_OTG_GUSBCFG_PHYSEL
-                    | (6 << USB_OTG_GUSBCFG_TRDT_Pos));
-    OTGD->DCFG |= (3 << USB_OTG_DCFG_DSPD_Pos);
-#if CONFIG_MACH_STM32F446 || CONFIG_MACH_STM32H7
-    OTG->GOTGCTL = USB_OTG_GOTGCTL_BVALOEN | USB_OTG_GOTGCTL_BVALOVAL;
-#else
-    OTG->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
-#endif
-
-    // Route pins
-    gpio_peripheral(GPIO_D_NEG, GPIO_FUNC, 0);
-    gpio_peripheral(GPIO_D_POS, GPIO_FUNC, 0);
-
-    // Setup USB packet memory
-    fifo_configure();
-
-    // Configure and enable ep0
-    uint32_t mpsize_ep0 = 2;
-    USB_OTG_INEndpointTypeDef *epi = EPIN(0);
-    USB_OTG_OUTEndpointTypeDef *epo = EPOUT(0);
-    epi->DIEPCTL = mpsize_ep0 | USB_OTG_DIEPCTL_SNAK;
-    epo->DOEPTSIZ = (64 | (1 << USB_OTG_DOEPTSIZ_STUPCNT_Pos)
-                     | (1 << USB_OTG_DOEPTSIZ_PKTCNT_Pos));
-    epo->DOEPCTL = mpsize_ep0 | USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_SNAK;
-
-    // Enable interrupts
-    OTGD->DIEPMSK = USB_OTG_DIEPMSK_XFRCM;
-    OTG->GINTMSK = USB_OTG_GINTMSK_RXFLVLM | USB_OTG_GINTMSK_IEPINT;
-    OTG->GAHBCFG = USB_OTG_GAHBCFG_GINT;
-    armcm_enable_irq(OTG_FS_IRQHandler, OTG_IRQn, 1);
-
-    // Enable USB
-    OTG->GCCFG |= USB_OTG_GCCFG_PWRDWN;
-    OTGD->DCTL = 0;
-}
-DECL_INIT(usb_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/stm32/watchdog.c crealityShit/src/stm32/watchdog.c
--- klipperStock/src/stm32/watchdog.c	2024-01-14 23:02:00.105796157 -0600
+++ crealityShit/src/stm32/watchdog.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,30 +0,0 @@
-// Watchdog handler on STM32
-//
-// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "autoconf.h" // CONFIG_MACH_STM32H7
-#include "internal.h" // IWDG
-#include "sched.h" // DECL_TASK
-
-#if CONFIG_MACH_STM32H7 // stm32h7 libraries only define IWDG1 and IWDG2
-#define IWDG IWDG1
-#endif
-
-void
-watchdog_reset(void)
-{
-    IWDG->KR = 0xAAAA;
-}
-DECL_TASK(watchdog_reset);
-
-void
-watchdog_init(void)
-{
-    IWDG->KR = 0x5555;
-    IWDG->PR = 0;
-    IWDG->RLR = 0x0FFF; // 410-512ms timeout (depending on stm32 chip)
-    IWDG->KR = 0xCCCC;
-}
-DECL_INIT(watchdog_init);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/thermocouple.c crealityShit/src/thermocouple.c
--- klipperStock/src/thermocouple.c	2024-01-14 23:02:00.169796942 -0600
+++ crealityShit/src/thermocouple.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,197 +0,0 @@
-// Basic support for common SPI controlled thermocouple chips
-//
-// Copyright (C) 2018  Petri Honkala <cruwaller@gmail.com>
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memcpy
-#include "board/irq.h" // irq_disable
-#include "basecmd.h" // oid_alloc
-#include "byteorder.h" // be32_to_cpu
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // DECL_TASK
-#include "spicmds.h" // spidev_transfer
-
-enum {
-    TS_CHIP_MAX31855, TS_CHIP_MAX31856, TS_CHIP_MAX31865, TS_CHIP_MAX6675
-};
-
-DECL_ENUMERATION("thermocouple_type", "MAX31855", TS_CHIP_MAX31855);
-DECL_ENUMERATION("thermocouple_type", "MAX31856", TS_CHIP_MAX31856);
-DECL_ENUMERATION("thermocouple_type", "MAX31865", TS_CHIP_MAX31865);
-DECL_ENUMERATION("thermocouple_type", "MAX6675", TS_CHIP_MAX6675);
-
-struct thermocouple_spi {
-    struct timer timer;
-    uint32_t rest_time;
-    uint32_t min_value;           // Min allowed ADC value
-    uint32_t max_value;           // Max allowed ADC value
-    struct spidev_s *spi;
-    uint8_t max_invalid, invalid_count;
-    uint8_t chip_type, flags;
-};
-
-enum {
-    TS_PENDING = 1,
-};
-
-static struct task_wake thermocouple_wake;
-
-static uint_fast8_t thermocouple_event(struct timer *timer) {
-    struct thermocouple_spi *spi = container_of(
-            timer, struct thermocouple_spi, timer);
-    // Trigger task to read and send results
-    sched_wake_task(&thermocouple_wake);
-    spi->flags |= TS_PENDING;
-    spi->timer.waketime += spi->rest_time;
-    return SF_RESCHEDULE;
-}
-
-void
-command_config_thermocouple(uint32_t *args)
-{
-    uint8_t chip_type = args[2];
-    if (chip_type > TS_CHIP_MAX6675)
-        shutdown("Invalid thermocouple chip type");
-    struct thermocouple_spi *spi = oid_alloc(
-        args[0], command_config_thermocouple, sizeof(*spi));
-    spi->timer.func = thermocouple_event;
-    spi->spi = spidev_oid_lookup(args[1]);
-    spi->chip_type = chip_type;
-}
-DECL_COMMAND(command_config_thermocouple,
-             "config_thermocouple oid=%c spi_oid=%c thermocouple_type=%c");
-
-void
-command_query_thermocouple(uint32_t *args)
-{
-    struct thermocouple_spi *spi = oid_lookup(
-        args[0], command_config_thermocouple);
-
-    sched_del_timer(&spi->timer);
-    spi->timer.waketime = args[1];
-    spi->rest_time = args[2];
-    if (! spi->rest_time)
-        return;
-    spi->min_value = args[3];
-    spi->max_value = args[4];
-    spi->max_invalid = args[5];
-    spi->invalid_count = 0;
-    sched_add_timer(&spi->timer);
-}
-DECL_COMMAND(command_query_thermocouple,
-             "query_thermocouple oid=%c clock=%u rest_ticks=%u"
-             " min_value=%u max_value=%u max_invalid_count=%c");
-
-static void
-thermocouple_respond(struct thermocouple_spi *spi, uint32_t next_begin_time
-                     , uint32_t value, uint8_t fault, uint8_t oid)
-{
-    sendf("thermocouple_result oid=%c next_clock=%u value=%u fault=%c",
-          oid, next_begin_time, value, fault);
-    /* check the result and stop if below or above allowed range */
-    if (fault || value < spi->min_value || value > spi->max_value) {
-        spi->invalid_count++;
-        if (spi->invalid_count < spi->max_invalid)
-            return;
-        try_shutdown("Thermocouple reader fault");
-    }
-    spi->invalid_count = 0;
-}
-
-static void
-thermocouple_handle_max31855(struct thermocouple_spi *spi
-                             , uint32_t next_begin_time, uint8_t oid)
-{
-    uint8_t msg[4] = { 0x00, 0x00, 0x00, 0x00 };
-    spidev_transfer(spi->spi, 1, sizeof(msg), msg);
-    uint32_t value;
-    memcpy(&value, msg, sizeof(value));
-    value = be32_to_cpu(value);
-    thermocouple_respond(spi, next_begin_time, value, value & 0x07, oid);
-}
-
-#define MAX31856_LTCBH_REG 0x0C
-#define MAX31856_SR_REG 0x0F
-
-static void
-thermocouple_handle_max31856(struct thermocouple_spi *spi
-                             , uint32_t next_begin_time, uint8_t oid)
-{
-    uint8_t msg[4] = { MAX31856_LTCBH_REG, 0x00, 0x00, 0x00 };
-    spidev_transfer(spi->spi, 1, sizeof(msg), msg);
-    uint32_t value;
-    memcpy(&value, msg, sizeof(value));
-    value = be32_to_cpu(value) & 0x00ffffff;
-    // Read faults
-    msg[0] = MAX31856_SR_REG;
-    msg[1] = 0x00;
-    spidev_transfer(spi->spi, 1, 2, msg);
-    thermocouple_respond(spi, next_begin_time, value, msg[1], oid);
-}
-
-#define MAX31865_RTDMSB_REG 0x01
-#define MAX31865_FAULTSTAT_REG 0x07
-
-static void
-thermocouple_handle_max31865(struct thermocouple_spi *spi
-                             , uint32_t next_begin_time, uint8_t oid)
-{
-    uint8_t msg[4] = { MAX31865_RTDMSB_REG, 0x00, 0x00, 0x00 };
-    spidev_transfer(spi->spi, 1, 3, msg);
-    uint32_t value;
-    memcpy(&value, msg, sizeof(value));
-    value = (be32_to_cpu(value) >> 8) & 0xffff;
-    // Read faults
-    msg[0] = MAX31865_FAULTSTAT_REG;
-    msg[1] = 0x00;
-    spidev_transfer(spi->spi, 1, 2, msg);
-    uint8_t fault = (msg[1] & ~0x03) | (value & 0x0001);
-    thermocouple_respond(spi, next_begin_time, value, fault, oid);
-}
-
-static void
-thermocouple_handle_max6675(struct thermocouple_spi *spi
-                            , uint32_t next_begin_time, uint8_t oid)
-{
-    uint8_t msg[2] = { 0x00, 0x00};
-    spidev_transfer(spi->spi, 1, sizeof(msg), msg);
-    uint16_t value;
-    memcpy(&value, msg, sizeof(msg));
-    value = be16_to_cpu(value);
-    thermocouple_respond(spi, next_begin_time, value, value & 0x06, oid);
-}
-
-// task to read thermocouple and send response
-void
-thermocouple_task(void)
-{
-    if (!sched_check_wake(&thermocouple_wake))
-        return;
-    uint8_t oid;
-    struct thermocouple_spi *spi;
-    foreach_oid(oid, spi, command_config_thermocouple) {
-        if (!(spi->flags & TS_PENDING))
-            continue;
-        irq_disable();
-        uint32_t next_begin_time = spi->timer.waketime;
-        spi->flags &= ~TS_PENDING;
-        irq_enable();
-        switch (spi->chip_type) {
-        case TS_CHIP_MAX31855:
-            thermocouple_handle_max31855(spi, next_begin_time, oid);
-            break;
-        case TS_CHIP_MAX31856:
-            thermocouple_handle_max31856(spi, next_begin_time, oid);
-            break;
-        case TS_CHIP_MAX31865:
-            thermocouple_handle_max31865(spi, next_begin_time, oid);
-            break;
-        case TS_CHIP_MAX6675:
-            thermocouple_handle_max6675(spi, next_begin_time, oid);
-            break;
-        }
-    }
-}
-DECL_TASK(thermocouple_task);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/tmcuart.c crealityShit/src/tmcuart.c
--- klipperStock/src/tmcuart.c	2024-01-14 23:02:00.169796942 -0600
+++ crealityShit/src/tmcuart.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,249 +0,0 @@
-// Commands for sending messages to a TMC2208 via its single wire UART
-//
-// Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include <string.h> // memcpy
-#include "board/gpio.h" // gpio_out_write
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_read_time
-#include "basecmd.h" // oid_alloc
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // DECL_SHUTDOWN
-
-struct tmcuart_s {
-    struct timer timer;
-    struct gpio_out tx_pin;
-    struct gpio_in rx_pin;
-    uint8_t flags;
-    uint8_t pos, read_count, write_count;
-    uint32_t cfg_bit_time, bit_time;
-    uint8_t data[10];
-};
-
-enum {
-    TU_LINE_HIGH = 1<<0, TU_ACTIVE = 1<<1, TU_READ_SYNC = 1<<2,
-    TU_REPORT = 1<<3, TU_PULLUP = 1<<4, TU_SINGLE_WIRE = 1<<5
-};
-
-static struct task_wake tmcuart_wake;
-
-// Restore uart line to normal "idle" mode
-static void
-tmcuart_reset_line(struct tmcuart_s *t)
-{
-    if (t->flags & TU_SINGLE_WIRE)
-        gpio_out_reset(t->tx_pin, 1);
-    else
-        gpio_out_write(t->tx_pin, 1);
-    t->flags = (t->flags & (TU_PULLUP | TU_SINGLE_WIRE)) | TU_LINE_HIGH;
-}
-
-// Helper function to end a transmission and schedule a response
-static uint_fast8_t
-tmcuart_finalize(struct tmcuart_s *t)
-{
-    tmcuart_reset_line(t);
-    t->flags |= TU_REPORT;
-    sched_wake_task(&tmcuart_wake);
-    return SF_DONE;
-}
-
-// Event handler for reading uart bits
-static uint_fast8_t
-tmcuart_read_event(struct timer *timer)
-{
-    struct tmcuart_s *t = container_of(timer, struct tmcuart_s, timer);
-    uint8_t v = gpio_in_read(t->rx_pin);
-    // Read and store bit
-    uint8_t pos = t->pos, mask = 1 << (pos & 0x07), data = t->data[pos >> 3];
-    if (v)
-        data |= mask;
-    else
-        data &= ~mask;
-    t->data[pos >> 3] = data;
-    pos++;
-    if (pos >= t->read_count)
-        return tmcuart_finalize(t);
-    t->pos = pos;
-    t->timer.waketime += t->bit_time;
-    return SF_RESCHEDULE;
-}
-
-// Event handler for detecting start of data reception
-static uint_fast8_t
-tmcuart_read_sync_event(struct timer *timer)
-{
-    struct tmcuart_s *t = container_of(timer, struct tmcuart_s, timer);
-    uint8_t v = gpio_in_read(t->rx_pin);
-    if (v) {
-        t->flags |= TU_READ_SYNC;
-    } else if (t->flags & TU_READ_SYNC) {
-        // Now synchronized - begin reading
-        t->pos = 0;
-        t->timer.func = tmcuart_read_event;
-        return tmcuart_read_event(timer);
-    }
-    if (t->pos++ >= 64) {
-        // Timeout
-        t->read_count = 0;
-        return tmcuart_finalize(t);
-    }
-    t->timer.waketime += t->bit_time;
-    return SF_RESCHEDULE;
-}
-
-// Event handler called at end of uart writing
-static uint_fast8_t
-tmcuart_send_finish_event(struct timer *timer)
-{
-    struct tmcuart_s *t = container_of(timer, struct tmcuart_s, timer);
-    if (!t->read_count)
-        // This is a tx only operation - success
-        return tmcuart_finalize(t);
-    // Prepare for message rx
-    if (t->flags & TU_SINGLE_WIRE)
-        gpio_in_reset(t->rx_pin, t->flags & TU_PULLUP);
-    t->pos = 0;
-    t->timer.func = tmcuart_read_sync_event;
-    t->timer.waketime += t->bit_time * 4;
-    return SF_RESCHEDULE;
-}
-
-// Event handler for sending uart bits
-static uint_fast8_t
-tmcuart_send_event(struct timer *timer)
-{
-    struct tmcuart_s *t = container_of(timer, struct tmcuart_s, timer);
-    // Toggle uart output
-    gpio_out_toggle_noirq(t->tx_pin);
-    t->flags ^= TU_LINE_HIGH;
-    // Determine next toggle time
-    uint8_t line_state = t->flags & TU_LINE_HIGH;
-    uint32_t bit_time = t->bit_time, next = bit_time;
-    uint8_t pos = t->pos;
-    for (;;) {
-        pos++;
-        if (pos >= t->write_count) {
-            // No more toggles necessary - schedule finish event
-            t->timer.func = tmcuart_send_finish_event;
-            t->timer.waketime += next;
-            return SF_RESCHEDULE;
-        }
-        uint8_t data = t->data[pos >> 3], bit = (data >> (pos & 0x07)) & 0x01;
-        if (bit != line_state)
-            break;
-        next += bit_time;
-    }
-    t->pos = pos;
-    t->timer.waketime += next;
-    return SF_RESCHEDULE;
-}
-
-// Event handler for sending sync nibble with enhanced baud detection
-static uint_fast8_t
-tmcuart_send_sync_event(struct timer *timer)
-{
-    struct tmcuart_s *t = container_of(timer, struct tmcuart_s, timer);
-    // Toggle uart output and note toggle time
-    gpio_out_toggle_noirq(t->tx_pin);
-    uint32_t cur = timer_read_time();
-    t->flags ^= TU_LINE_HIGH;
-    // Determine next wakeup time
-    t->pos++;
-    if (t->pos == 1) {
-        // First bit just sent - record scheduling offset for later use
-        uint32_t offset = cur - t->timer.waketime;
-        t->bit_time = offset;
-    } else if (t->pos >= 5) {
-        // Last bit of sync nibble just sent - calculate actual baud rate used
-        uint32_t offset = cur - t->timer.waketime, start_offset = t->bit_time;
-        int32_t diff = offset - start_offset;
-        t->bit_time = t->cfg_bit_time + DIV_ROUND_CLOSEST(diff, 4);
-        t->timer.func = tmcuart_send_event;
-        t->timer.waketime += diff + t->bit_time;
-        return SF_RESCHEDULE;
-    }
-    t->timer.waketime += t->cfg_bit_time;
-    return SF_RESCHEDULE;
-}
-
-void
-command_config_tmcuart(uint32_t *args)
-{
-    struct tmcuart_s *t = oid_alloc(args[0], command_config_tmcuart
-                                    , sizeof(*t));
-    uint8_t pull_up = args[2];
-    uint32_t rx_pin = args[1], tx_pin = args[3];
-    t->rx_pin = gpio_in_setup(rx_pin, !!pull_up);
-    t->tx_pin = gpio_out_setup(tx_pin, 1);
-    t->cfg_bit_time = args[4];
-    t->flags = (TU_LINE_HIGH | (pull_up ? TU_PULLUP : 0)
-                | (rx_pin == tx_pin ? TU_SINGLE_WIRE : 0));
-}
-DECL_COMMAND(command_config_tmcuart,
-             "config_tmcuart oid=%c rx_pin=%u pull_up=%c"
-             " tx_pin=%u bit_time=%u");
-
-// Parse and schedule a TMC UART transmission request
-void
-command_tmcuart_send(uint32_t *args)
-{
-    struct tmcuart_s *t = oid_lookup(args[0], command_config_tmcuart);
-    if (t->flags & TU_ACTIVE)
-        // Uart is busy - silently drop this request (host should retransmit)
-        return;
-    uint8_t write_len = args[1];
-    uint8_t *write = command_decode_ptr(args[2]);
-    uint8_t read_len = args[3];
-    if (write_len > sizeof(t->data) || read_len > sizeof(t->data))
-        shutdown("tmcuart data too large");
-    memcpy(t->data, write, write_len);
-    t->pos = 0;
-    t->flags = (t->flags & (TU_LINE_HIGH|TU_PULLUP|TU_SINGLE_WIRE)) | TU_ACTIVE;
-    t->write_count = write_len * 8;
-    t->read_count = read_len * 8;
-    if (write_len >= 1 && (t->data[0] & 0x3f) == 0x2a) {
-        t->timer.func = tmcuart_send_sync_event;
-    } else {
-        t->bit_time = t->cfg_bit_time;
-        t->timer.func = tmcuart_send_event;
-    }
-    irq_disable();
-    t->timer.waketime = timer_read_time() + timer_from_us(200);
-    sched_add_timer(&t->timer);
-    irq_enable();
-}
-DECL_COMMAND(command_tmcuart_send, "tmcuart_send oid=%c write=%*s read=%c");
-
-// Report completed response message back to host
-void
-tmcuart_task(void)
-{
-    if (!sched_check_wake(&tmcuart_wake))
-        return;
-    uint8_t oid;
-    struct tmcuart_s *t;
-    foreach_oid(oid, t, command_config_tmcuart) {
-        if (!(t->flags & TU_REPORT))
-            continue;
-        irq_disable();
-        t->flags &= ~TU_REPORT;
-        irq_enable();
-        sendf("tmcuart_response oid=%c read=%*s"
-              , oid, t->read_count / 8, t->data);
-    }
-}
-DECL_TASK(tmcuart_task);
-
-void
-tmcuart_shutdown(void)
-{
-    uint8_t i;
-    struct tmcuart_s *t;
-    foreach_oid(i, t, command_config_tmcuart) {
-        tmcuart_reset_line(t);
-    }
-}
-DECL_SHUTDOWN(tmcuart_shutdown);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/trsync.c crealityShit/src/trsync.c
--- klipperStock/src/trsync.c	2024-01-14 23:02:00.137796549 -0600
+++ crealityShit/src/trsync.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,200 +0,0 @@
-// Handling of synchronized "trigger" dispatch
-//
-// Copyright (C) 2016-2021  Kevin O'Connor <kevin@koconnor.net>
-//
-// This file may be distributed under the terms of the GNU GPLv3 license.
-
-#include "basecmd.h" // oid_alloc
-#include "board/gpio.h" // struct gpio
-#include "board/irq.h" // irq_disable
-#include "board/misc.h" // timer_read_time
-#include "command.h" // DECL_COMMAND
-#include "sched.h" // struct timer
-#include "trsync.h" // trsync_do_trigger
-
-struct trsync {
-    struct timer report_time, expire_time;
-    uint32_t report_ticks;
-    struct trsync_signal *signals;
-    uint8_t flags, trigger_reason, expire_reason;
-};
-
-enum { TSF_CAN_TRIGGER=1<<0, TSF_REPORT=1<<2 };
-
-static struct task_wake trsync_wake;
-
-// Activate a trigger (caller must disable IRQs)
-void
-trsync_do_trigger(struct trsync *ts, uint8_t reason)
-{
-    uint8_t flags = ts->flags;
-    if (!(flags & TSF_CAN_TRIGGER))
-        return;
-    ts->trigger_reason = reason;
-    ts->flags = (flags & ~TSF_CAN_TRIGGER) | TSF_REPORT;
-    // Dispatch signals
-    while (ts->signals) {
-        struct trsync_signal *tss = ts->signals;
-        trsync_callback_t func = tss->func;
-        ts->signals = tss->next;
-        tss->next = NULL;
-        tss->func = NULL;
-        func(tss, reason);
-    }
-    sched_wake_task(&trsync_wake);
-}
-
-// Timeout handler
-static uint_fast8_t
-trsync_expire_event(struct timer *t)
-{
-    struct trsync *ts = container_of(t, struct trsync, expire_time);
-    trsync_do_trigger(ts, ts->expire_reason);
-    return SF_DONE;
-}
-
-// Report handler
-static uint_fast8_t
-trsync_report_event(struct timer *t)
-{
-    struct trsync *ts = container_of(t, struct trsync, report_time);
-    ts->flags |= TSF_REPORT;
-    sched_wake_task(&trsync_wake);
-    ts->report_time.waketime += ts->report_ticks;
-    return SF_RESCHEDULE;
-}
-
-void
-command_config_trsync(uint32_t *args)
-{
-    struct trsync *ts = oid_alloc(args[0], command_config_trsync, sizeof(*ts));
-    ts->report_time.func = trsync_report_event;
-    ts->expire_time.func = trsync_expire_event;
-}
-DECL_COMMAND(command_config_trsync, "config_trsync oid=%c");
-
-// Return the 'struct trsync' for a given trsync oid
-struct trsync *
-trsync_oid_lookup(uint8_t oid)
-{
-    return oid_lookup(oid, command_config_trsync);
-}
-
-// Add a callback to invoke on a trigger
-void
-trsync_add_signal(struct trsync *ts, struct trsync_signal *tss
-                  , trsync_callback_t func)
-{
-    irqstatus_t flag = irq_save();
-    if (tss->func || !func)
-        shutdown("Can't add signal that is already active");
-    tss->func = func;
-    tss->next = ts->signals;
-    ts->signals = tss;
-    irq_restore(flag);
-}
-
-// Disable trigger and unregister any signal handlers (caller must disable IRQs)
-static void
-trsync_clear(struct trsync *ts)
-{
-    sched_del_timer(&ts->report_time);
-    sched_del_timer(&ts->expire_time);
-    struct trsync_signal *tss = ts->signals;
-    while (tss) {
-        struct trsync_signal *next = tss->next;
-        tss->func = NULL;
-        tss->next = NULL;
-        tss = next;
-    }
-    ts->signals = NULL;
-    ts->flags = ts->trigger_reason = ts->expire_reason = 0;
-}
-
-void
-command_trsync_start(uint32_t *args)
-{
-    struct trsync *ts = trsync_oid_lookup(args[0]);
-    irq_disable();
-    trsync_clear(ts);
-    ts->flags = TSF_CAN_TRIGGER;
-    ts->report_time.waketime = args[1];
-    ts->report_ticks = args[2];
-    if (ts->report_ticks)
-        sched_add_timer(&ts->report_time);
-    ts->expire_reason = args[3];
-    irq_enable();
-}
-DECL_COMMAND(command_trsync_start,
-             "trsync_start oid=%c report_clock=%u report_ticks=%u"
-             " expire_reason=%c");
-
-void
-command_trsync_set_timeout(uint32_t *args)
-{
-    struct trsync *ts = trsync_oid_lookup(args[0]);
-    irq_disable();
-    uint8_t flags = ts->flags;
-    if (flags & TSF_CAN_TRIGGER) {
-        sched_del_timer(&ts->expire_time);
-        ts->expire_time.waketime = args[1];
-        sched_add_timer(&ts->expire_time);
-    }
-    irq_enable();
-}
-DECL_COMMAND(command_trsync_set_timeout, "trsync_set_timeout oid=%c clock=%u");
-
-static void
-trsync_report(uint8_t oid, uint8_t flags, uint8_t reason, uint32_t clock)
-{
-    sendf("trsync_state oid=%c can_trigger=%c trigger_reason=%c clock=%u"
-          , oid, !!(flags & TSF_CAN_TRIGGER), reason, clock);
-}
-
-void
-command_trsync_trigger(uint32_t *args)
-{
-    uint8_t oid = args[0];
-    struct trsync *ts = trsync_oid_lookup(oid);
-    irq_disable();
-    trsync_do_trigger(ts, args[1]);
-    sched_del_timer(&ts->report_time);
-    sched_del_timer(&ts->expire_time);
-    ts->flags = 0;
-    uint8_t trigger_reason = ts->trigger_reason;
-    irq_enable();
-    trsync_report(oid, 0, trigger_reason, 0);
-}
-DECL_COMMAND(command_trsync_trigger, "trsync_trigger oid=%c reason=%c");
-
-void
-trsync_task(void)
-{
-    if (!sched_check_wake(&trsync_wake))
-        return;
-    uint8_t oid;
-    struct trsync *ts;
-    foreach_oid(oid, ts, command_config_trsync) {
-        if (!(ts->flags & TSF_REPORT))
-            continue;
-        uint32_t time = timer_read_time();
-        irq_disable();
-        uint8_t trigger_reason = ts->trigger_reason, flags = ts->flags;
-        ts->flags = flags & ~TSF_REPORT;
-        irq_enable();
-
-        trsync_report(oid, flags, trigger_reason, time);
-    }
-}
-DECL_TASK(trsync_task);
-
-void
-trsync_shutdown(void)
-{
-    uint8_t oid;
-    struct trsync *ts;
-    foreach_oid(oid, ts, command_config_trsync) {
-        trsync_clear(ts);
-    }
-}
-DECL_SHUTDOWN(trsync_shutdown);
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/src/trsync.h crealityShit/src/trsync.h
--- klipperStock/src/trsync.h	2024-01-14 23:02:00.169796942 -0600
+++ crealityShit/src/trsync.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,19 +0,0 @@
-#ifndef __TRSYNC_H
-#define __TRSYNC_H
-
-#include <stdint.h> // uint16_t
-
-struct trsync_signal;
-typedef void (*trsync_callback_t)(struct trsync_signal *tss, uint8_t reason);
-
-struct trsync_signal {
-    struct trsync_signal *next;
-    trsync_callback_t func;
-};
-
-struct trsync *trsync_oid_lookup(uint8_t oid);
-void trsync_do_trigger(struct trsync *ts, uint8_t reason);
-void trsync_add_signal(struct trsync *ts, struct trsync_signal *tss
-                       , trsync_callback_t func);
-
-#endif // trsync.h
diff -rNauw --exclude config --exclude fw --exclude .git --exclude .github --exclude test --exclude '*.pyc' --exclude '*.so' --exclude lib klipperStock/tool/host_crc16.c crealityShit/tool/host_crc16.c
--- klipperStock/tool/host_crc16.c	1969-12-31 18:00:00.000000000 -0600
+++ crealityShit/tool/host_crc16.c	2024-01-14 23:02:21.786061883 -0600
@@ -0,0 +1,116 @@
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+static const uint16_t crc16tab[256]= 
+{
+    0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,
+    0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,
+    0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,
+    0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,
+    0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,
+    0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d,
+    0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,
+    0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,
+    0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,
+    0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b,
+    0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,
+    0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,
+    0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,
+    0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49,
+    0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,
+    0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,
+    0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,
+    0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,
+    0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,
+    0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,
+    0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d,
+    0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,
+    0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,
+    0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,
+    0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,
+    0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,
+    0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,
+    0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,
+    0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9,
+    0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,
+    0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,
+    0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0
+};
+
+uint16_t crc16(const uint8_t *buf, uint32_t len, uint16_t crc) 
+{
+    uint32_t counter;
+    
+	for (counter = 0; counter < len; counter++)
+	{
+		crc = (crc << 8) ^ crc16tab[((crc >> 8) ^ *buf++) & 0x00FF];
+	}
+
+    return crc;
+}
+
+
+#define CRC16_BUFFER_LEN			64
+
+int32_t
+main(int argc, char* argv[])
+{
+	FILE *f = NULL;
+
+	uint32_t flen = 0;
+
+	uint32_t crc16Rtn = 0;
+
+	uint32_t tmpLen = 0;
+
+	uint8_t fbuff[CRC16_BUFFER_LEN] = {0};
+
+	//printf("argc = %d, argv[0] = %s, argv[1] = %s\r\n",argc, argv[0], argv[1]);	
+
+	if(argc != 2)
+	{
+		return -1;
+	}
+
+	f = fopen(argv[1],"rb+");
+
+	if(f == NULL)
+	{
+		printf("fopen failure.\r\n");
+
+		return -1;
+	}
+
+	fseek(f,0,SEEK_END);
+
+	flen = ftell(f);
+
+	//printf("flen = %d\r\n",flen);
+
+	fseek(f,0,SEEK_SET);
+
+	do
+	{
+		tmpLen = fread(fbuff, 1, CRC16_BUFFER_LEN,f);
+	
+		crc16Rtn = crc16(fbuff, tmpLen, crc16Rtn);
+
+	}while(tmpLen > 0);
+
+
+	fseek(f,0x20C,SEEK_SET);
+
+	fwrite(&crc16Rtn,1,2,f);
+	
+	fwrite(&flen,1,4,f);
+
+	fclose(f);
+
+	printf("  CRC16 is 0x%0x\r\n  Length is 0x%0x\r\n",crc16Rtn,flen);
+
+	return 0;
+}
+
